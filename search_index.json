[["index.html", "Méthodes quantitatives en sciences sociales : un grand bol dR Bienvenue", " Méthodes quantitatives en sciences sociales : un grand bol dR Philippe Apparicio et Jérémy Gelb Bienvenue Version : 07 mai 2022 Auteurs : Philippe Apparicio et Jérémy Gelb Remerciements : Ce manuel a été réalisé avec le soutien de la fabriqueREL. Fondée en 2019, la fabriqueREL est portée par divers établissements denseignement supérieur du Québec et agit en collaboration avec les services de soutien pédagogique et les bibliothèques. Son but est de faire des ressources éducatives libres (REL) le matériel privilégié en enseignement supérieur au Québec. Maquette de la page couverture : Graphe Logo (https://www.graphelogo.com/) Mise en page : Philippe Apparicio et Jérémy Gelb Révision linguistique : Denise Latreille © Philippe Apparicio et Jérémy Gelb Pour citer cet ouvrage : Apparicio P. et J. Gelb (2022). Méthodes quantitatives en sciences sociales : un grand bol dR. Institut national de la recherche scientifique. fabriqueREL. Licence CC BY-SA. "],["préface.html", "Préface", " Préface Ce livre vise à décrire une panoplie de méthodes quantitatives utilisées en sciences sociales avec le logiciel ouvert R. Il a dailleurs été écrit intégralement dans R avec rmarkdown. Le contenu est pensé pour être accessible à tous et toutes, même à ceux et celles nayant presque aucune base en statistique ou en programmation. Les personnes plus expérimentées y découvriront des sections sur des méthodes plus avancées comme les modèles à effets mixtes, les modèles multiniveaux, les modèles généralisés additifs ainsi que les méthodes factorielles et de classification. Ceux et celles souhaitant migrer progressivement dun autre logiciel statistique vers R trouveront dans cet ouvrage les éléments pour une transition en douceur. La philosophie de ce livre est de donner toutes les clefs de compréhension et de mise en uvre des méthodes abordées dans R. La présentation des méthodes est basée sur une approche compréhensive et intuitive plutôt que mathématique, sans pour autant que la rigueur statistique ne soit négligée. Servez-vous votre boisson chaude ou froide favorite et installez-vous dans votre meilleur fauteuil. Bonne lecture! "],["sect001.html", "Un manuel sous la forme dune ressource éducative libre", " Un manuel sous la forme dune ressource éducative libre Pourquoi un manuel de statistique en sciences sociales sous licence libre? Les logiciels libres sont aujourdhui très répandus. Comparativement aux logiciels propriétaires, laccès au code source permet à quiconque de lutiliser, de le modifier, de le dupliquer et de le partager. Le logiciel R, dans lequel sont mises en uvre les méthodes quantitatives décrites dans ce livre, est dailleurs à la fois un langage de programmation et un logiciel libre (sous la licence publique générale GNU GPL2). Par analogie aux logiciels libres, il existe aussi des ressources éducatives libres (REL) « dont la licence accorde les permissions désignées par les 5R (Retenir  Réutiliser  Réviser  Remixer  Redistribuer) et donc permet nécessairement la modification » (fabriqueREL). La licence de ce livre, CC BY-SA (figure 0.1), permet donc de : Retenir, cest-à-dire télécharger et dimprimer gratuitement le livre. Notez quil aurait été plutôt surprenant décrire un livre payant sur un logiciel libre et donc gratuit. Aussi, nous aurions été très embarrassés que des personnes étudiantes avec des ressources financières limitées doivent payer pour avoir accès au livre, sans pour autant savoir préalablement si le contenu est réellement adapté à leurs besoins. Réutiliser, cest-à-dire utiliser la totalité ou une section du livre sans limitation et sans compensation financière. Cela permet ainsi à dautres personnes enseignantes de lutiliser dans le cadre dactivités pédagogiques. Réviser, cest-à-dire modifier, adapter et traduire le contenu en fonction dun besoin pédagogique précis puisquaucun manuel nest parfait, tant sen faut! Rappelons que le livre a dailleurs été écrit intégralement dans R avec rmarkdown. Quiconque peut ainsi télécharger gratuitement le code source du livre sur github et le modifier à sa guise (voir lencadré intitulé Suggestions dadaptation du manuel). Remixer, cest-à-dire « de combiner la ressource avec dautres ressources dont la licence le permet aussi pour créer une nouvelle ressource intégrée » (fabriqueREL). Redistribuer, cest-à-dire distribuer en totalité ou partiellement le manuel ou une version révisée sur dautres canaux que le site Web du livre (par exemple, sur le site Moodle de votre université ou en faire une version imprimée). Figure 0.1: Licence Creative Commons du livre La licence de ce livre, CC BY-SA (figure 0.1), oblige donc à : Attribuer la paternité de lauteur dans vos versions dérivées, ainsi quune mention concernant les grandes modifications apportées, en utilisant la formulation suivante : Apparicio, Philippe et Jérémy Gelb. 2022. Méthodes quantitatives en sciences sociales : un grand bol dR. Institut national de la recherche scientifique. CC BY-SA (4.0). Utiliser la même licence ou une licence similaire à toutes versions dérivées. Suggestions dadaptation du manuel Notez que pour chaque méthode statistique abordée dans le livre sont disponibles une description détaillée et une mise en uvre dans R. Par conséquent, plusieurs adaptations du manuel sont possibles : Conserver uniquement les chapitres sur les méthodes statistiques ciblées dans votre cours. En faire une version imprimée et la distribuer aux personnes étudiantes. Modifier la description dune ou plusieurs méthodes en effectuant les mises à jour directement dans les chapitres. Insérer ses propres jeux de données dans les sections intitulées Mise en uvre dans R. Modifier les tableaux et figures. Ajouter une série dexercices. Rédiger un nouveau chapitre. Modifier des syntaxes R. Plusieurs packages R peuvent être utilisés pour mettre en uvre telle ou telle méthode statistique. Ces derniers évoluent aussi très vite et de nouveaux packages sont proposés fréquemment! Par conséquent, il peut être judicieux de modifier une syntaxe R du livre en fonction de ses habitudes de programmation dans R (utilisation dautres packages que ceux utilisés dans le manuel par exemple) ou de bien mettre à jour une syntaxe à la suite de la parution dun nouveau package plus performant ou intéressant. Toute autre adaptation qui permet de répondre au mieux à un besoin pédagogique. "],["sect002.html", "Un manuel conçu comme un projet collaboratif", " Un manuel conçu comme un projet collaboratif Il existe actuellement de nombreux livres sous licence ouverte écrits avec rmarkdown avec le package bookdown (Xie 2016), répertoriés sur le site de https://bookdown.org/. Sans surprise, R étant un logiciel libre dédié aux méthodes statistiques et à la science des données, plusieurs abordent les méthodes quantitatives, notamment : Beyond Multiple Linear Regression: Applied Generalized Linear Models and Multilevel Models in R (Roback et Legler 2021), CC BY-NC-SA. Introduction to Econometrics with R (Hanck et al. 2019), CC BY-NC-SA. Statistical Inference via Data Science: A ModernDive into R and the Tidyverse (Ismay et Kim 2019), CC BY-NC-SA. R Graphics Cookbook, 2nd edition (Chang 2018), CC BY. Par contre, la grande majorité de ces livres numériques rédigés avec bookdown sont en anglais. À notre connaissance, ce projet constitue le premier manuel numérique en français sur les méthodes quantitatives appliquées aux sciences sociales réalisé avec bookdown. La première version du livre étant lancée, il est grand temps de planifier les suivantes! Pour ce faire, nous considérons ce livre comme un projet collaboratif visant à mobiliser la communauté universitaire francophone qui enseigne les statistiques en sciences sociales avec R. Plusieurs raisons motivent cette vision collaborative : Rien nest parfait! Cette première version comprend sûrement des coquilles et certaines sections mériteraient dêtre améliorées. Les commentaires et suggestions visant à améliorer son contenu sont les bienvenus. La table des matières doit être impérativement extensible! De nombreuses méthodes statistiques très utilisées en sciences sociales ne sont pas abordées dans ce livre et mériteraient dêtre ajoutées dans une version ultérieure : certaines extensions des régressions linéaires (régressions Rigge et Lasso, Tobit, quantile, etc.), les modèles déquations simultanées, les analyses de données longitudinales (entre autres, modèles de survie, régression par panel), les modèles déquations structurelles et bien dautres! Par conséquent, si vous êtes intéressé(e)s, à ajouter un nouveau chapitre ou une partie du livre, nous vous invitons vivement à communiquer avec nous ou à diffuser sous une licence similaire votre version dérivée. Lobjectif étant de continuer à faire tourner la roue du libre et, idéalement, que les futures versions soient corédigées par une communauté dauteurs et dautrices spécialistes en méthodes quantitatives. References "],["sect003.html", "Comment lire ce livre?", " Comment lire ce livre? Si vous googlez lexpression « comment lire un livre? », vous trouverez une multitude de conseils et astuces. Pour ce livre, nous vous conseillons de le lire de gauche à droite et page par page! Plus sérieusement, le livre comprend plusieurs types de blocs de texte qui, nous lespèrons, en facilitent la lecture. Bloc packages. Habituellement localisé au début dun chapitre, il comprend la liste des packages R utilisés pour un chapitre. Bloc objectif. Il comprend une description des objectifs dun chapitre ou dune section. Bloc notes. Il comprend une information secondaire sur une notion, un élément, une idée abordée dans une section. Bloc pour aller plus loin. Il comprend des références ou des extensions dune méthode statistique abordée dans une section. Bloc astuce. Il décrit un élément qui vous facilitera le vie : une propriété statistique, un package, une fonction, une syntaxe R. Bloc attention. Il comprend une notion ou un élément important à bien maîtriser. "],["sect003B.html", "Comment utiliser les données du livre pour reproduire les exemples?", " Comment utiliser les données du livre pour reproduire les exemples? Ce livre propose des exemples détaillés et appliqués dans R pour chacune des méthodes abordées. Ces exemples se basent sur des jeux de données structurés et mis à disposition avec le livre. Ils sont disponibles sur le repo github dans le sous-dossier data, à ladresse https://github.com/LAEQ/livre_statistique_Phil_Jere/tree/master/data. Pour télécharger lintégralité des données, vous pouvez utiliser le lien suivant : https://downgit.github.io/#/home?url=https://github.com/LAEQ/livre_statistique_Phil_Jere/tree/master/data. Cela est rendu possible grâce à loutil DownGit. Une autre option est de télécharger le repo complet du livre directement sur github (https://github.com/LAEQ/livre_statistique_Phil_Jere) en cliquant sur le bouton Code, puis le bouton Download ZIP (figure 0.2). Les données se trouvent alors dans le sous-dossier nommé data. Figure 0.2: Téléchargement de lintégralité du livre "],["sect004.html", "Structure du livre", " Structure du livre Le livre est organisé autour de cinq grandes parties. Partie 1. La découverte de R. Dans cette première partie, nous discutons brièvement de lhistoire et de la philosophie de R. Nous voyons ensuite comment installer R et RStudio. Les bases du langage R (particulièrement les principaux objets que sont le vecteur, la matrice, la liste et le dataframe) ainsi que la manipulation des données avec R sont aussi largement abordés dans le chapitre 1. Partie 2. Analyses univariées et représentations graphiques. Cette seconde partie comprend deux chapitres. Dans le chapitre 2, nous décrivons dans un premier temps les différents types de données (primaires versus secondaires, transversales versus longitudinales, spatiales versus aspatiales, individuelles versus agrégées), les différents types de variables quantitatives (discrètes et continues) et qualitatives (nominales et ordinales) et les principales distributions de variables utilisées en sciences sociales (uniforme, Bernoulli, binomiale, géométrique, binomiale négative, poisson, poisson avec excès de zéros, gaussienne, gaussienne asymétrique, log-normale, Student, Cauchy, Chi-carré, exponentielle, Gamma, bêta, Weibull et Pareto). Dans un second temps, nous abordons les statistiques descriptives pour des variables quantitatives (paramètres de tendance centrale, paramètres de position, paramètres de dispersion, paramètres de forme), puis qualitatives (fréquences absolues, relatives et cumulées). Dans le chapitre 3, nous illustrons les incroyables capacités graphiques de R en mettant en uvre les principaux graphiques (histogramme, graphique de densité, nuage de points, graphique en lignes, boîtes à moustache, graphique en violon, graphique en barre, graphique circulaire), quelques graphiques particuliers (graphique en radar, diagramme daccord, nuage de mots, carte proportionnelle) et une initiation aux cartes choroplèthes. Partie 3. Analyses bivariées. Cette troisième partie comprend trois chapitres dans lesquelles sont présentées les principales méthodes exploratoires et confirmatoires bivariées permettant dévaluer la relation entre deux variables. Plus spécifiquement, nous présentons puis mettons en uvre dans R les méthodes permettant dexplorer les relations entre deux variables quantitatives (covariance, corrélation et régression linéaire simple) dans le chapitre 4, deux variables qualitatives (tableau de contingence et test du khi-deux) dans le chapitre 5 et une variable quantitative avec une variable qualitative avec deux modalités (tests de Student, de Welch et de Wilcoxon) ou avec plus de deux modalités (ANOVA et test de Kruskal-Wallis) dans le chapitre 6. Partie 4. Modèles de régression. Dans cette quatrième partie, sont présentées les principales méthodes de statistique inférentielle utilisées en sciences sociales : la régression linéaire multiple (chapitre 7), les régressions linéaires généralisées (chapitre 8), les régressions à effets mixtes (chapitre 9), les régressions multiniveaux (chapitre 10), (chapitre 11) et les modèles généralisés additifs (chapitre 11). Partie 5. Analyses exploratoires multivariées. Dans cette cinquième partie, sont abordées les méthodes de statistique exploratoire et descriptive permettant de décrire des tableaux de données comprenant plusieurs variables. Nous décrivons dabord les méthodes de réduction de données : les méthodes factorielles dans le chapitre 12 (analyses de composantes principales, analyses factorielles de correspondances, analyses factorielles de correspondances multiples) et les méthodes de classification non supervisées dans le chapitre 13 (classification ascendante hiérarchique, k-moyennes, k-médianes, k-médoïdes et leurs extensions en logique floue comme les c-moyennes et c-médianes). "],["sect005.html", "Pourquoi faut-il programmer en sciences sociales?", " Pourquoi faut-il programmer en sciences sociales? Vous contrasterez rapidement que R est un véritable langage de programmation. Lapprentissage de ce language de programmation est-il pour autant pertinent pour les étudiants et étudiantes en sciences sociales? Il est vrai que la programmation nest pas une compétence qui vient demblée à lesprit lorsque lon sintéresse à la recherche aux sciences sociales. Pourtant, elle est de plus en plus importante, et ce, pour plusieurs raisons : Une part toujours plus grande des phénomènes sociaux se produisent ou peuvent sobserver au travers denvironnements numériques. Être capable dexploiter efficacement ces outils permet dextraire des données riches sur des phénomènes complexes, tel quen témoignent des études récentes sur la propagation de la désinformation sur les réseaux sociaux (Allcott et Gentzkow 2017), la migration des personnes (Spyratos et al. 2019), la propagation et les risques de contamination de la COVID-19 (Boulos et Geraghty 2020). Le plus souvent, les interfaces (API par exemple) permettant daccéder à ces données nécessitent des habiletés en programmation. La quantité de données numériques ouvertes et accessibles en ligne croit chaque année sur des sujets très divers. La plupart des villes et des gouvernements ont maintenant leur portail de données ouvertes auxquelles sajoutent les données produites par des projets collaboratifs comme OpenStreetMap ou NoisePlanet. Récupérer ces données et les structurer pour les utiliser à des fins de recherche nécessitent le plus souvent des compétences en programmation. Les méthodes quantitatives connaissent également un développement très important. Les logiciels propriétaires peinent à suivre la cadence de ce développement, contrairement aux logiciels à code source ouvert (comme R) qui permettent davoir accès aux dernières méthodes. Il est souvent long et coûteux de développer une interface graphique pour un logiciel, ce qui explique que la plupart de ces programmes en sont dépourvus et nécessitent alors de savoir programmer pour les utiliser. Savoir programmer donne une liberté considérable en recherche. Cette compétence permet notamment de ne plus être limité(e) aux fonctionnalités proposées par des logiciels spécifiques. Il devient possible dinnover tant en matière de structuration, dexploration et danalyse des données que de représentation des résultats en écrivant ses propres fonctions. Cette flexibilité contribue directement à la production dune recherche de meilleure qualité et plus diversifiée. Programmer permet également dautomatiser des tâches qui autrement seraient extrêmement répétitives comme : déplacer et renommer une centaine de fichiers; retirer les lignes inutiles dans un ensemble de fichiers et les compiler dans une seule base de données; vérifier parmi des milliers dadresses lesquelles sont valides; récupérer chaque jour les messages postés sur un forum. Autant de tâches faciles à automatiser si lon sait programmer. Dans un logiciel avec une interface graphique, il est compliqué de conserver un historique des opérations effectuées. Programmer permet au contraire de garder une trace de lensemble des actions effectuées au cours dun projet de recherche. En effet, le code utilisé reste disponible et permet de reproduire (ou dadapter) la méthode et les résultats obtenus, ce qui est essentiel dans le monde de la recherche. À cela sajoute le fait que chaque ligne de code que vous écrivez vient sajouter à un capital de code que vous possédez, car elles pourront être réutilisées dans dautres projets! References "],["sect006.html", "Remerciements", " Remerciements De nombreuses personnes ont contribué à lélaboration de ce manuel. Ce projet a bénéficié du soutien pédagogique et financier de la fabriqueREL (ressources éducatives libres). Les différentes rencontres avec le comité de suivi nous ont permis de comprendre lunivers des ressources éducatives libres (REL) et notamment leurs fameux 5R (Retenir  Réutiliser  Réviser  Remixer  Redistribuer), de mieux définir le besoin pédagogique visé par ce manuel, didentifier des outils et des ressources pédagogiques pertinents pour son élaboration. Ainsi, nous remercions chaleureusement les membres de suivi de la fabriqueREL pour leur support inconditionnel : Myriam Beaudet, bibliothécaire à lUniversité de Sherbrooke. Marianne Dubé, conseillère pédagogique à lUniversité de Sherbrooke et coordonnatrice de la fabriqueREL. Myrian Grondin, bibliothécaire à lInstitut national de la recherche scientifique (INRS). Claude Potvin, conseiller en formation à lUniversité Laval. Serge Allary, vice-recteur adjoint aux études de lUniversité de Sherbrooke. Nous tenons aussi à remercier sincèrement les étudiants et étudiantes du cours Méthodes quantitatives appliquées aux études urbaines (EUR8219) du programme de maîtrise en études urbaines de lINRS. Leurs commentaires et suggestions nous ont permis daméliorer grandement les versions préliminaires de ce manuel qui ont été utilisées dans le cadre de ce cours. Nous remercions les membres du comité de révision pour leurs commentaires et suggestions très constructifs. Ce comité est composé de trois étudiantes et deux professeurs de lINRS : Victoria Gay-Gauvin, étudiante à la maîtrise en études urbaines. Salomé Vallette, étudiante au doctorat en études urbaines. Diana Pena Ruiz, étudiante au doctorat en études des populations. Benoît Laplante, professeur enseignant aux programmes de maîtrise et de doctorat en études des populations. Xavier Leloup, professeur enseignant au programme de doctorat en études urbaines. Finalement, nous remercions Denise Latreille, réviseure linguistique et chargée de cours à lUniversité Sherbrooke, pour la révision du manuel. "],["sect007.html", "Dédicace toute spéciale à Cargo et Ambrée", " Dédicace toute spéciale à Cargo et Ambrée Fait cocasse, lécriture de ce livre a démarré lorsque Philippe Apparicio était famille daccueil dun chiot de la Fondation Mira, un organisme à but non lucratif qui forme des chiens-guides et dassistance pour accroître lautonomie et linclusion sociale des personnes vivant avec un handicap visuel ou moteur, ainsi que des jeunes présentant un trouble du spectre de lautisme (TSA). En fin de rédaction du livre, ce fût au tour de Jérémy Gelb dêtre famille daccueil dun autre chiot Mira. Nous remercions chaleureusement la Fondation Mira pour nous avoir donné loccasion de vivre cette expérience incroyable. Ce livre est donc dédié au beau Cargo et à la belle Ambrée qui nous ont tant supportés dans lécriture du livre. Il ny a rien de plus relaxant que décrire un livre de statistique avec un chiot qui dort à ses pieds! Figure 0.3: Cargo et Ambrée, chiots de la Fondation Mira "],["auteurs.html", "À propos des auteurs", " À propos des auteurs Philippe Apparicio (http://www.inrs.ca/philippe-apparicio) est professeur titulaire au Centre Urbanisation Culture Société de lInstitut national de la recherche scientifique (INRS, http://www.inrs.ca/). Il enseigne au programme de maîtrise en études urbaines (https://inrs.ca/les-etudes/programmes-d-etudes/etudier-en-sciences-sociales/) les cours Méthodes quantitatives appliquées aux études urbaines et Analyses spatiales appliquées aux études urbaines. Il a aussi créé et enseigné, il y a plusieurs années, le cours Systèmes dinformation géographique appliqués aux études urbaines. Durant les dernières années, il a offert plusieurs formations aux Écoles dété du Centre interuniversitaire québécois de statistiques sociales (CIQSS, https://www.ciqss.org/). Il est le directeur du laboratoire déquité environnementale (http://laeq.ucs.inrs.ca). Géographe de formation, ses intérêts de recherche actuels incluent la justice et léquité environnementale, la pollution atmosphérique, le bruit et le vélo en ville. Il a publié une centaine darticles scientifiques dans différents domaines des études urbaines et de la géographie. Jérémy Gelb a obtenu un doctorat en études urbaines à lINRS en 2022, sous la supervision de Philippe Apparicio. Il est membre du laboratoire déquité environnementale (http://laeq.ucs.inrs.ca). Son sujet de thèse porte sur lexposition des cyclistes aux pollutions atmosphériques et sonores en milieu urbain. Il utilise quotidiennement des systèmes dinformation géographique (SIG) et est tombé dans la marmite de lopen source avec le triptyque QGIS, R et Python au début de sa maîtrise. Il a récemment développé deux packages R : geocmeans et spNetwork, permettant respectivement deffectuer des analyses de classification floue non supervisée pondérée spatialement et des estimations de densité par kernel sur réseau. Philippe et Jérémy travaillent étroitement ensemble depuis plusieurs années. Avec dautres collègues, ils ont copublié plusieurs articles (Apparicio, Gelb et al. 2021; Apparicio, Maignan et Gelb 2021; Gelb et Apparicio 2021a; Gelb et Apparicio 2021b; Apparicio et Gelb 2020; Buregeya, Apparicio et Gelb 2020; Gelb et Apparicio 2020; Apparicio, Gelb et Mathieu 2019; Delaunay et al. 2019; Gelb et Apparicio 2019; Apparicio et al. 2018; Apparicio et al. 2017; Apparicio, Carrier et al. 2016). Tous deux sintéressent à lexposition des cyclistes à la pollution atmosphérique et sonore dans plusieurs villes à travers le monde : Philippe ayant une préférence pour les collectes dans les villes des Suds (notamment indiennes, africaines et latino-américaines) et Jérémy dans les villes des Nords (européennes et nord-américaines). Figure 0.4: Philippe Apparicio et Jérémy Gelb lors dune collecte de données à vélo à Delhi References "],["chap01.html", "Chapitre 1 Prise en main de R", " Chapitre 1 Prise en main de R Dans ce chapitre, nous revenons brièvement sur lhistoire de R et la philosophie qui entoure le logiciel. Nous donnons quelques conseils pour son installation et la mise en place dun environnement de développement. Nous présentons les principaux objets qui sous-tendent le travail effectué avec R (DataFrame, vecteur, matrice, etc.) et comment les manipuler avec des exemples appliqués. Si vous maîtrisez déjà R, nullement besoin de lire ce chapitre! Dans ce chapitre, nous utilisons principalement les packages suivants : Pour importer des fichiers externes : foreign pour entre autres les fichiers dbase et ceux des logiciels SPSS et Stata. sas7bdat pour les fichiers du logiciel SAS. xlsx pour les fichiers Excel. Pour manipuler des chaînes de caractères et des dates : stringr pour les chaînes de caractères. lubridate pour les dates. Pour manipuler des données : dplyr du tidyverse propose une grammaire pour manipuler et structurer des données. "],["sect011.html", "1.1 Histoire et philosophie de R", " 1.1 Histoire et philosophie de R R est à la fois un langage de programmation et un logiciel libre (sous la licence publique générale GNU) dédié à lanalyse statistique et soutenu par une fondation : R Foundation for Statistical Computing. Il est principalement écrit en C et en Fortran, deux langages de programmation de « bas niveau », proches du langage machine. À linverse, R est un langage de « haut niveau », car plus proche du langage humain. R a été créé par Ross Ihaka et Robert Gentleman à lUniversité dAuckland en Nouvelle-Zélande. Si vous avez un jour loccasion de passer dans le coin, une plaque est affichée dans le département de statistique de luniversité; ça mérite le détour (figure 1.1). Une version expérimentale a été publiée en 1996, mais la première version stable ne date que de 2000. Il sagit donc dun logiciel relativement récent si nous le comparons à ses concurrents SPSS (1968), SAS (1976) et Stata (1984). Figure 1.1: Lieu de pèlerinage de R R a cependant réussi à simposer tant dans le milieu de la recherche que dans le secteur privé. Pour sen convaincre, il suffit de lire lexcellent article concernant la popularité des logiciels danalyse de données tiré du site r4stats.com (figure 1.2). Figure 1.2: Nombre darticles trouvés sur Google Scholar (source : Robert A. Muenchen) Les nombreux atouts de R justifient largement sa popularité sans cesse croissante : R est un logiciel à code source ouvert (open source) et ainsi accessible à tous gratuitement. Le développement du langage R est centralisé, mais la communauté peut créer et partager facilement des packages. Les nouvelles méthodes sont ainsi rapidement implémentées comparativement aux logiciels propriétaires. R est un logiciel multiplateforme, fonctionnant sur Linux, Unix, Windows et Mac. Comparativement à ses concurrents, R dispose dexcellentes solutions pour manipuler des données et réaliser des graphiques. R dispose de nombreuses interfaces lui permettant de communiquer, notamment avec des systèmes de bases de données SQL et non SQL (MySQL, PostgresSQL, MongoDB, etc.), avec des systèmes de big data (Spark, Hadoop), avec des systèmes dinformation géographique (QGIS, ArcGIS) et même avec des services en ligne comme Microsoft Azure ou Amazon AWS. R est un langage de programmation à part entière, ce qui lui donne plus de flexibilité que ses concurrents commerciaux (SPSS, SAS, STATA). Avec R, vous pouvez accomplir de nombreuses tâches : monter un site web, créer un robot collectant des données en ligne, combiner des fichiers PDF, composer des diapositives pour une présentation ou même éditer un livre (comme celui-ci), mais aussi, et surtout, réaliser des analyses statistiques. Un des principaux attraits de R est la quantité astronomique de packages actuellement disponibles. Un package est un ensemble de nouvelles fonctionnalités développées par des personnes utilisatrices de R et mises à disposition de lensemble de la communauté. Par exemple, le package ggplot2 est dédié à la réalisation de graphiques; les packages data.table et dplyr permettent de manipuler des tableaux de données; le package car offre de nombreux outils pour faciliter lanalyse de modèles de régressions, etc. Ce partage de packages rend accessible à tous des méthodes danalyses complexes et récentes et favorise grandement la reproductibilité de la recherche. Cependant, ce fonctionnement implique quelques désavantages : Il existe généralement plusieurs packages pour effectuer le même type danalyse, ce qui peut devenir une source de confusion. Certains packages cessent dêtre mis à jour au fil des années, ce qui nécessite de trouver des solutions de rechange (et ainsi apprendre la syntaxe de nouveaux packages). Il est impératif de sassurer de la fiabilité des packages que vous souhaitez utiliser, car nimporte qui peut proposer un package. Il nous semble important de relativiser demblée la portée du dernier point. Il est rarement nécessaire de lire et danalyser le code source dun package pour sassurer de sa fiabilité. Nous ne sommes pas des spécialistes de tous les sujets et il peut être extrêmement ardu de comprendre la logique dun code écrit par une autre personne. Nous vous recommandons donc de privilégier lutilisation de packages qui : ont fait lobjet dune publication dans une revue à comité de lecture ou qui ont déjà été cités dans des études ayant fait lobjet dune publication revue par les pairs; font partie de projets comme ROpensci prônant la vérification par les pairs ou subventionnés par des organisations comme R Consortium; sont disponibles sur lun des deux principaux répertoires de packages R, soit CRAN et Bioconductor. Toujours pour nuancer notre propos, il convient de distinguer package de package! Certains dentre eux sont des ensembles très complexes de fonctions permettant de réaliser des analyses poussées alors que dautres sont des projets plus modestes dont lobjectif principal est de simplifier le travail des personnes utilisant R. Ces derniers ressemblent à de petites boîtes à outils et font généralement moins lobjet dune vérification intensive. Pour conclure cette section, lillustration partagée sur Twitter par Darren L Dahly résume avec humour la force du logiciel R et de sa communauté (figure 1.3) : R apparaît clairement comme une communauté hétéroclite, mais diversifiée et adaptable. Figure 1.3: Métaphore sur les langages et programmes danalyse statistique Dans ce livre, nous détaillons les packages utilisés dans chaque section avec un encadré spécifique, accompagné de licône présentée à la figure 1.4. Figure 1.4: Icône des encadrés dédiés aux packages "],["sect012.html", "1.2 Environnement de travail", " 1.2 Environnement de travail Dans cette section, nous vous proposons une visite de lenvironnement de travail classique R. 1.2.1 Installation de R La première étape pour travailler avec R est bien sûr de linstaller. Pour cela, il suffit de visiter le site web de CRAN et de télécharger la dernière version de R en fonction de votre système dexploitation : Windows, Linux ou Mac. Une fois installé, si vous démarrez R immédiatement, vous aurez accès à une console, plutôt rudimentaire, attendant sagement vos instructions (figure 1.5). Figure 1.5: Console de base de R Notez que vous pouvez aussi télécharger des versions plus anciennes de R en allant sur ce lien. Cela peut être intéressant lorsque vous voulez reproduire des résultats dune autre étude ou que certains packages ne sont plus disponibles dans les nouvelles versions. 1.2.2 Environnement RStudio Rares sont les adeptes de R qui préfèrent travailler directement avec la console classique. Nous vous recommandons vivement dutiliser RStudio, un environnement de développement (IDE) dédié à R offrant une intégration très intéressante dune console, dun éditeur de texte, dune fenêtre de visualisation des données et dune autre pour les graphiques, dun accès à la documentation, etc. En dautres termes, si R est un vélo minimaliste, RStudio permet dy rajouter des freins, des vitesses, un porte-bagages, des garde-boues et une selle confortable. Vous pouvez télécharger et installer RStudio sur Windows, Linux et Mac. La version de base est gratuite, mais lentreprise qui développe ce logiciel propose aussi des versions commerciales du logiciel qui assurent essentiellement une assistance technique. Il existe dautres environnements de développement pour travailler avec R (VisualStudio, Jupyter, Tinn-R, Radiant, RIDE, etc.), mais RStudio offre à ce jour la meilleure option en termes de facilité dinstallation, de prise en main et de fonctionnalités proposées (voir linterface de RStudio à la figure 1.6). Figure 1.6: Environnement de base de RStudio Avant daller plus loin, notez que : La console actuellement ouverte dans RStudio vous informe de la version de R que vous utilisez. Vous pouvez en effet avoir plusieurs versions de R installées sur votre ordinateur et passer de lune à lautre avec RStudio. Pour cela, naviguez dans longlet Tools/Global Options et dans le volet General, puis sélectionnez la version de R que vous souhaitez utiliser. Laspect de RStudio peut être modifié en navigant dans longlet Tools/Global Options et dans le volet Appearance. Nous avons une préférence pour le mode sombre avec le style pastel on dark, mais libre à vous de choisir le style qui vous convient. Figure 1.7: RStudio avec le style pastel on dark Une fois ces détails réglés, vous pouvez ouvrir votre première feuille de code en allant dans longlet File/New File/R Script. Votre environnement est maintenant découpé en quatre fenêtres (figure 1.8) : Léditeur de code, vous permettant décrire le script que vous voulez exécuter et de garder une trace de votre travail. Ce script peut être enregistré sur votre ordinateur avec lextension .R, mais ce nest quun simple fichier texte. La console vous permettant dexécuter votre code R et de voir les résultats safficher au fur et à mesure. La fenêtre denvironnement vous montrant les objets, les fonctions et les jeux de données actuellement disponibles dans votre session (chargés dans la mémoire vive). La fenêtre de laide, des graphiques et de lexplorateur de fichiers. Vous pouvez accéder ici à la documentation de R et des packages que vous utilisez, aux sorties graphiques que vous produisez et aux dossiers de votre environnement de travail. Figure 1.8: Fenêtres de RStudio Prenons un bref exemple : tapez la syntaxe suivante dans léditeur de code (fenêtre 1 à la figure 1.8) : ma_somme &lt;- 4+4 Sélectionnez ensuite cette syntaxe (mettre en surbrillance avec la souris) et utilisez le raccourci Ctrl+Entrée ou cliquez sur le bouton Run (avec la flèche verte) pour envoyer cette syntaxe à la console qui lexécutera immédiatement. Notez que rien ne se passe tant que le code nest pas envoyé à la console. Il sagit donc de deux étapes distinctes : écrire son code, puis lenvoyer à la console. Constatez également quun objet ma_somme est apparu dans votre environnement et que sa valeur est bien 8. Votre console se « souvient » de cette valeur : elle est actuellement stockée dans votre mémoire vive sous le nom de ma_somme (figure 1.9). Figure 1.9: Exécuter du code dans RStudio Pour conclure cette section, nous vous invitons à enregistrer votre première syntaxe R (File/Save As) dans un fichier .R que vous pouvez appeler mon_premier_script.R par exemple. Fermez ensuite RStudio, redémarrez-le et ouvrez (File/Open File) votre fichier mon_premier_script.R. Vous pouvez constater que votre code est toujours présent, mais que votre environnement est vide tant que vous nexécutez pas votre syntaxe. En effet, lorsque vous fermez RStudio, lenvironnement est vidé pour libérer de la mémoire vive. Cela peut poser problème lorsque certains codes sont très longs à exécuter, nous verrons donc plus tard comment enregistrer lenvironnement en cours pour le recharger par la suite. 1.2.3 Installation et chargement un package Dans la section sur la Philosophie de R, nous avons souligné la place centrale jouée par les packages. Notez que les termes paquet et plus rarement librairie sont parfois utilisés en français. Voyons ensemble comment installer un package, par exemple celui intitulé lubridate, qui nous permettra plus tard de manipuler des données temporelles. 1.2.3.1 Installation dun package depuis CRAN Pour installer un package, il est nécessaire dêtre connecté à Internet puisque R va accéder au répertoire de packages CRAN pour télécharger le package et linstaller sur votre machine. Cette opération est réalisée avec la fonction install.packages. install.packages(&quot;lubridate&quot;) Notez quune fois que le package est installé, il demeure disponible localement sur votre ordinateur, à moins de le désinstaller explicitement avec la fonction remove.packages. 1.2.3.2 Installation dun package depuis GitHub CRAN est le répertoire officiel des packages de R. Vous pouvez cependant télécharger des packages provenant dautres sources. Très souvent, les packages sont disponibles sur le site web GitHub et nous pouvons même y trouver des versions en développement avec des fonctionnalités encore non intégrées dans la version sur CRAN. Reprenons le cas de lubridate, mais sur GitHub (il est disponible ici). Pour linstaller, nous devons dabord installer un autre package appelé remotes (depuis CRAN). install.packages(&quot;remotes&quot;) Maintenant que nous disposons de remotes, nous pouvons utiliser la fonction dinstallation remotes::install_github pour directement télécharger lubridate depuis GitHub. remotes::install_github(&quot;tidyverse/lubridate&quot;) 1.2.3.3 Chargement dun package Maintenant que lubridate est installé, nous pouvons le charger dans notre session actuelle de R et accéder aux fonctions quil propose. Pour cela, il suffit dutiliser la fonction library. Conventionnellement, lappel des packages se fait au tout début du script que vous rédigez. Rien ne vous empêche de le faire au fur et à mesure de votre code, mais ce dernier perd alors en lisibilité. Notez que pour chaque nouvelle session (redémarrage de R), il faut recharger les packages dont vous avez besoin avec la fonction library. library(lubridate) Si vous obtenez un message derreur du type : Error in library(monPackage) : aucun package nommé monPackage nest trouvé Cela signifie que le package que vous tentez de charger nest pas encore installé sur votre ordinateur. Dans ce cas, réessayer de linstaller avec la fonction install.packages. Si le problème persiste, vérifiez que vous navez pas fait une faute de frappe dans le nom du package. Vous pouvez également redémarrer RStudio et réessayer dinstaller ce package. 1.2.4 Aide disponible Lorsque vous installez des packages dans R, vous téléchargez aussi leur documentation. Tous les packages de CRAN disposent dune documentation, ce qui nest pas forcément vrai pour ceux sur GitHub. Dans RStudio, vous pouvez accéder à la documentation des packages dans longlet Packages (figure 1.10). Vous pouvez utiliser la barre de recherche pour retrouver rapidement un package installé. Si vous cliquez sur le nom du package, vous accédez directement à sa documentation dans cette fenêtre. Figure 1.10: Description des packages Vous pouvez également accéder à ces informations en utilisant la syntaxe suivante dans votre console : help(package = &#39;lubridate&#39;) Souvent, vous aurez besoin daccéder à la documentation dune fonction spécifique dun package. Affichons la documentation de la fonction now de lubridate : help(now, package = &#39;lubridate&#39;) ou plus simplement : ?lubridate::now Vous pouvez aussi utiliser le raccourci suivant. ?now Si vous ne vous souvenez plus à quel package la fonction appartient, lancez une recherche en utilisant un double point dinterrogation : ??now Vous découvrirez ainsi que la fonction now nexiste pas que dans lubridate, ce qui souligne limportance de bien connaître les packages que nous installons et que nous chargeons dans notre session ! Maintenant que nous avons fait le tour de lenvironnement de travail, nous pouvons passer aux choses sérieuses, soit les bases du langage R. "],["sect013.html", "1.3 Bases du langage R", " 1.3 Bases du langage R R est un langage de programmation. Il vous permet de communiquer avec votre ordinateur pour lui donner des tâches à accomplir. Dans cette section, nous abordons les bases du langage. Ce type de section introductive à R est présente dans tous les manuels sur R; elle est donc incontournable. À la première lecture, elle vous semblera probablement aride, et ce, dautant plus que nous ne réalisons pas danalyse à proprement parler. Gardez en tête que lanalyse de données requiert au préalable une phase de structuration de ces dernières, opération qui nécessite la maîtrise des notions abordées dans cette section. Nous vous recommandons une première lecture de ce chapitre pour comprendre les manipulations que vous pouvez effectuer avec R, avant de poursuivre avec de la lecture des chapitres suivants dédiés aux analyses statistiques. Vous pourrez revenir consulter cette section au besoin. Notez aussi que la maîtrise des différents objets et des différentes opérations de base de R ne sacquiert quen pratiquant. Vous gagnerez cette expertise au fil de vos prochains codes R, période durant laquelle vous pourrez consulter ce chapitre tel un guide de référence des objets et des notions fondamentales de R. 1.3.1 Hello World! Une introduction à un langage de programmation se doit de commencer par le rite de passage Hello World. Il sagit dune forme de tradition consistant à montrer aux néophites comment afficher le message Hello World à lécran avec le langage en question. print(&quot;Hello World&quot;) ## [1] &quot;Hello World&quot; Bravo! Vous venez officiellement de faire votre premier pas dans R! 1.3.2 Objets et expressions Dans R, nous passons notre temps à manipuler des objets à laide dexpressions. Prenons un exemple concret : si vous tapez la syntaxe 4 + 3, vous manipulez deux objets (4 et 3) avec une expression indiquant que vous souhaitez obtenir la somme des deux objets. 4 + 3 ## [1] 7 Cette expression est correcte, R comprend vos indications et effectue le calcul. Il est possible denregistrer le résultat dune expression et de le conserver dans un nouvel objet. On appelle cette opération : « déclarer une variable ». ma_somme &lt;- 4 + 3 Concrètement, nous venons de demander à R denregistrer le résultat de 4 + 3 dans un espace spécifique de notre mémoire vive. Si vous regardez dans votre fenêtre Environment, vous verrez en effet quun objet appelé ma_somme est actuellement en mémoire et a pour valeur 7. Notez ici que le nom des variables ne peut être composé que de lettres, de chiffres, de points (.) et de tirets bas (_) et doit commencer par une lettre. R est sensible à la casse; en dautres termes, les variables Ma_somme, ma_sommE, ma_SOMME, et MA_SOMME renvoient toutes à un objet différent. Attention donc aux fautes de frappe. Si vous déclarez une variable en utilisant le nom dune variable existante, la première est écrasée par la seconde : age &lt;- 35 age ## [1] 35 age &lt;- 45 age ## [1] 45 Portez alors attention aux noms de variables que vous utilisez et réutilisez. Réutilisons notre objet ma_somme dans une nouvelle expression : ma_somme2 &lt;- ma_somme + ma_somme Avec cette nouvelle expression, nous indiquons à R que nous souhaitons déclarer une nouvelle variable appelée ma_somme2, et que cette variable aura pour valeur ma_somme + ma_somme, soit 7 + 7. Sans surprise, ma_somme2 a pour valeur 14. Notez que la mémoire vive (lenvironnement) est vidée lorsque vous fermez R. Autrement dit, R perd complètement la mémoire lorsque vous le fermez. Vous pouvez bien sûr recréer vos objets en relançant les mêmes syntaxes. Cest pourquoi vous devez conserver vos feuilles de codes et ne pas seulement travailler dans la console. La console ne garde aucune trace de votre travail. Pensez donc à bien enregistrer votre code! Nous verrons dans une prochaine section comment sauvegarder des objets et les recharger dans une session ultérieure de R (section 1.6). Ce type dopération est pertinent quand le temps de calcul nécessaire à la production de certains objets est très long. 1.3.3 Fonctions et arguments Dans R, nous manipulons le plus souvent nos objets avec des fonctions. Une fonction est elle-même un objet, mais qui a la particularité de pouvoir effectuer des opérations sur dautres objets. Par exemple, déclarons lobjet taille avec une valeur de 175,897 : taille &lt;- 175.897 Nous utilisons la fonction round, dont lobjectif est darrondir un nombre avec décimales pour obtenir un nombre entier. round(taille) ## [1] 176 Pour effectuer leurs opérations, les fonctions ont généralement besoin darguments. Ici, taille est un argument passé à la fonction round. Si nous regardons la documentation de round avec help(round) (figure 1.11), nous constatons que cette fonction prend en réalité deux arguments : x et digits. Le premier est le nombre que nous souhaitons arrondir et le second est le nombre de décimales à conserver. Nous pouvons lire dans la documentation que la valeur par défaut de digits est 0, ce qui explique que round(taille) a produit le résultat de 176. Figure 1.11: Arguments de la fonction round Réutilisons maintenant la fonction round, mais en gardant une décimale : round(taille, digits = 1) ## [1] 175.9 Il est aussi possible que certaines fonctions ne requièrent pas dargument. Par exemple, la fonction now indique la date précise (avec lheure) et na besoin daucun argument pour le faire : now() ## [1] &quot;2022-05-07 10:48:46 EDT&quot; Par contre, si nous essayons de lancer la fonction round sans argument, nous obtenons une erreur : round() Erreur : 0 argument passé à round qui en exige 1 ou 2 Le message est très clair, round a besoin dau moins un argument pour fonctionner. Si, au lieu dun nombre, nous avions donné du texte à la fonction round, nous aurions aussi obtenu une erreur : round(&quot;Hello World&quot;) Erreur dans round(Hello World) : argument non numérique pour une fonction mathématique À nouveau le message est très explicite : nous avons passé un argument non numérique à une fonction mathématique. Lisez toujours vos messages derreurs : ils permettent de repérer les coquilles et de corriger votre code! Nous terminons cette section avec une fonction essentielle, print, qui permet dafficher la valeur dune variable. print(ma_somme) ## [1] 7 1.3.4 Principaux types de données Depuis le début de ce chapitre, nous avons déclaré plusieurs variables et essentiellement des données numériques. Dans R, il existe trois principaux types de données de base : Les données numériques qui peuvent être des nombres entiers (appelés integers) ou des nombres décimaux (appelés floats ou doubles), par exemple 15 et 15.3. Les données de type texte qui sont des chaînes de caractères (appelées strings) et déclarées entre guillemets \"abcdefg\". Les données booléennes (booleans) qui peuvent navoir que deux valeurs : vrai (TRUE) ou faux (FALSE). Déclarons une variable pour chacun de ces types : age &lt;- 35 taille &lt;- 175.5 adresse &lt;- &#39;4225 rue de la gauchetiere&#39; proprietaire &lt;- TRUE Simples ou doubles quotes? Pour déclarer des données de type texte, il est possible dutiliser des quotes simples ' (apostrophe) ou des quotes doubles \" (guillemets), cela ne fait aucune différence pour R. Cependant, si la chaîne de caractères que vous créez contient une apostrophe, il est nécessaire dutiliser des quotes doubles et inversement si votre chaîne de caractère contient des guillemets. phrase1 &lt;- &quot;J&#39;adore le langage R!&quot; phrase2 &lt;- &#39;Je cite : &quot;il est le meilleur langage de statistique&quot;.&#39; Si la chaîne de caractère contient des guillemets et des apostrophes, il est nécessaire dutiliser la barre oblique inversée \\ pour indiquer à R que ces apostrophes ou ces guillemets ne doivent pas être considérés comme la fin de la chaîne de caractère. phrase3 &lt;- &quot;Je cite : \\&quot;j&#39;en rêve la nuit\\&quot;.&quot; cat(phrase3) ## Je cite : &quot;j&#39;en rêve la nuit&quot;. Les barres obliques inversées ne font pas partie de la chaîne de caractère, ils sont là pour échapper les guillemets qui doivent rester dans la chaîne de caractère. Si une chaîne de caractère doit contenir une barre oblique inversée, alors il faut léchapper également en utilisant une deuxième barre oblique inversée. phrase4 &lt;- &quot;Une phrase avec une barre oblique inversée : \\\\&quot; cat(phrase4) ## Une phrase avec une barre oblique inversée : \\ Faites attention à la coloration syntaxique de RStudio! Elle peut vous aider à repérer facilement une chaîne de caractère qui aurait été interrompue par un guillemet ou une apostrophe mal placés. Si vous avez un doute sur le type de données stockées dans une variable, vous pouvez utiliser la fonction typeof. Par exemple, cela permet de repérer si des données qui sont censées être numériques sont en fait stockées sous forme de texte comme dans lexemple ci-dessous. typeof(age) ## [1] &quot;double&quot; typeof(taille) ## [1] &quot;double&quot; # Ici tailletxt est définie comme une chaîne de caractère car la valeur est # définie entre des guillemets. tailletxt &lt;- &quot;175.5&quot; typeof(tailletxt) ## [1] &quot;character&quot; Notez également quil existe des types pour représenter labsence de données : pour représenter un objet vide, nous utilisons lobjet NULL, pour représenter une donnée manquante, nous utilisons lobjet NA, pour représenter un texte vide, nous utilisons une chaîne de caractère de longueur 0, soit \"\". age2 &lt;- NULL taille2 &lt;- NA adresse2 &lt;- &#39;&#39; 1.3.5 Opérateurs Nous avons vu que les fonctions permettent de manipuler des objets. Nous pouvons également effectuer un grand nombre dopérations avec les opérateurs. 1.3.5.1 Opérateurs mathématiques Les opérateurs mathématiques (tableau 1.1) permettent deffectuer des calculs avec des données de type numérique. Tableau 1.1: Opérateurs mathématiques Opérateur Description Syntaxe Résultat + Addition 4 + 4 8,0 - Soustraction 4 - 3 1,0 * Multiplication 4 * 3 12,0 / Division 12 / 4 3,0 ^ Exponentiel 4 ^ 3 64,0 ** Exponentiel 4 ** 3 64,0 %% Reste de division 15,5 %% 2 1,5 %/% Division entière 15,5 %/% 2 7,0 1.3.5.2 Opérateurs relationnels Les opérateurs relationnels (tableau 1.2) permettent de vérifier des conditions dans R. Ils renvoient un booléen, TRUE si la condition est vérifiée et FALSE si ce nest pas le cas. Tableau 1.2: Opérateurs relationnels Opérateur Description Syntaxe Résultat == Égalité 4 == 4 TRUE != Différence 4 != 4 FALSE &gt; Est supérieur 5 &gt; 4 TRUE &lt; Est inférieur 5 &lt; 4 FALSE &gt;= Est supérieur ou égal 5 &gt;= 4 TRUE &lt;= Est inférieur ou égal 5 &lt;= 4 FALSE 1.3.5.3 Opérateurs logiques Les opérateurs logiques (tableau 1.3) permettent de combiner plusieurs conditions : Lopérateur ET (&amp;) permet de vérifier que deux conditions (lune ET lautre) sont TRUE. Si lune des deux est FALSE, il renvoie FALSE. Lopérateur OU (|) permet de vérifier que lune des deux conditions est TRUE (lune OU lautre). Si les deux sont FALSE, alors il renvoie FALSE. Lopérateur NOT (!) permet dinverser une condition. Ainsi, NOT TRUE donne FALSE et NOT FALSE donne TRUE. Tableau 1.3: Opérateurs logiques Opérateur Description Syntaxe Résultat &amp; ET TRUE &amp; FALSE FALSE | OU TRUE | FALSE TRUE ! NOT ! TRUE FALSE Prenons le temps pour un rapide exemple : A &lt;- 4 B &lt;- 10 C &lt;- -5 # Produit TRUE car A est bien plus petit que B et C est bien plus petit que A A &lt; B &amp; C &lt; A ## [1] TRUE # Produit FALSE car si A est bien plus petit que B, # B est en revanche plus grand que c A &lt; B &amp; B &lt; C ## [1] FALSE # Produit TRUE car la seconde condition est inversée A &lt; B &amp; ! B &lt; C ## [1] TRUE # Produit TRUE car au moins une des deux conditions est juste A &lt; B | B &lt; C ## [1] TRUE Notez que lopérateur ET est prioritaire sur lopérateur OU et que les parenthèses sont prioritaires sur tous les opérateurs : # Produit TRUE car nous commençons par tester A &lt; B puis B &lt; C ce qui donne FALSE # On obtient ensuite # FALSE | A &gt; C # Enfin, A est bien supérieur à C, donc l&#39;une des deux conditions est vraie A &lt; B &amp; B &lt; C | A &gt; C ## [1] TRUE Notez quen arrière-plan, les opérateurs sont en réalité des fonctions déguisées. Il est donc possible de définir de nouveaux comportements pour les opérateurs. Il est par exemple possible dadditionner ou de comparer des objets spéciaux comme des dates, des géométries, des graphes, etc. 1.3.6 Structures de données Jusquà présent, nous avons utilisé des objets ne comprenant quune seule valeur. Or, des analyses statistiques nécessitent de travailler avec des volumes de données bien plus grands. Pour stocker des valeurs, nous travaillons avec différentes structures de données : les vecteurs, les matrices, les tableaux de données et les listes. 1.3.6.1 Vecteurs Les vecteurs sont la brique élémentaire de R. Ils permettent de stocker une série de valeurs du même type dans une seule variable. Pour déclarer un vecteur, nous utilisons la fonction c() : ages &lt;- c(35,45,72,56,62) tailles &lt;- c(175.5,180.3,168.2,172.8,167.6) adresses &lt;- c(&#39;4225 rue de la gauchetiere&#39;, &#39;4223 rue de la gauchetiere&#39;, &#39;4221 rue de la gauchetiere&#39;, &#39;4219 rue de la gauchetiere&#39;, &#39;4217 rue de la gauchetiere&#39;) proprietaires &lt;- c(TRUE,TRUE,FALSE,TRUE,TRUE) Nous venons ainsi de déclarer quatre nouvelles variables étant chacune un vecteur de longueur cinq (comprenant chacun cinq valeurs). Ces vecteurs représentent, par exemple, les réponses de plusieurs personnes à un questionnaire. Il existe dans R une subtilité à lorigine de nombreux malentendus : la distinction entre un vecteur de type texte et un vecteur de type facteur. Dans lexemple précédent, le vecteur adresses est un vecteur de type texte. Chaque nouvelle valeur ajoutée dans le vecteur peut être nimporte quelle nouvelle adresse. Déclarons un nouveau vecteur qui contient cette fois-ci la couleur des yeux de personnes ayant répondu au questionnaire. couleurs_yeux &lt;- c(&#39;marron&#39;,&#39;marron&#39;,&#39;bleu&#39;,&#39;bleu&#39;,&#39;marron&#39;,&#39;vert&#39;) Contrairement aux adresses, il y a un nombre limité de couleurs que nous pouvons mettre dans ce vecteur. Il est donc intéressant de fixer les valeurs possibles du vecteur pour éviter den ajouter de nouvelles par erreur. Pour cela, nous devons convertir ce vecteur texte en vecteur de type facteur, ci-après nommé simplement facteur, avec la fonction as.factor. couleurs_yeux_facteur &lt;- as.factor(couleurs_yeux) Notez quà présent, nous pouvons ajouter une nouvelle couleur dans le premier vecteur, mais pas dans le second. couleurs_yeux[7] &lt;- &quot;rouge&quot; couleurs_yeux_facteur[7] &lt;- &quot;rouge&quot; ## Warning in `[&lt;-.factor`(`*tmp*`, 7, value = &quot;rouge&quot;): invalid factor level, NA ## generated Le message derreur nous informe que nous avons tenté dintroduire une valeur invalide dans le facteur. Les facteurs peuvent sembler restrictifs et, très régulièrement, nous préférons travailler avec de simples vecteurs de type texte plutôt que des facteurs. Cependant, de nombreuses fonctions danalyse nécessitent dutiliser des facteurs, car ils assurent une certaine cohérence dans les données. Il est donc essentiel de savoir passer du texte au facteur avec la fonction as.factor. À linverse, il est parfois nécessaire de revenir à une variable de type texte avec la fonction as.character. Notez que des vecteurs numériques peuvent aussi être convertis en facteurs : tailles_facteur &lt;- as.factor(tailles) Cependant, si vous souhaitez reconvertir ce facteur en format numérique, il faudra passer dans un premier temps par le format texte : as.numeric(tailles_facteur) ## [1] 4 5 2 3 1 Comme vous pouvez le voir, convertir un facteur en valeur numérique renvoie des nombres entiers. Ceci est dû au fait que les valeurs dans un facteur sont recodées sous forme de nombres entiers, chaque nombre correspondant à une des valeurs originales (appelées niveaux). Si nous convertissons un facteur en valeurs numériques, nous obtenons donc ces nombres entiers. as.numeric(as.character(tailles_facteur)) ## [1] 175.5 180.3 168.2 172.8 167.6 Morale de lhistoire : ne confondez pas les données de type texte et de type facteur. Dans le doute, vous pouvez demander à R quel est le type dun vecteur avec la fonction class. class(tailles) ## [1] &quot;numeric&quot; class(tailles_facteur) ## [1] &quot;factor&quot; class(couleurs_yeux) ## [1] &quot;character&quot; class(couleurs_yeux_facteur) ## [1] &quot;factor&quot; Quasiment toutes les fonctions utilisent des vecteurs. Par exemple, nous pouvons calculer la moyenne du vecteur ages en utilisant la fonction mean présente de base dans R. mean(ages) ## [1] 54 Cela démontre bien que le vecteur est la brique élémentaire de R! Toutes les variables que nous avons déclarées dans les sections précédentes sont aussi des vecteurs, mais de longueur 1. 1.3.6.2 Matrices Il est possible de combiner des vecteurs pour former des matrices. Une matrice est un tableau en deux dimensions (colonnes et lignes) et est généralement utilisée pour représenter certaines structures de données comme des images (pixels), effectuer du calcul matriciel ou plus simplement présenter des matrices de corrélations. Vous aurez rarement à travailler directement avec des matrices, mais il est bon de savoir ce quelles sont. Créons deux matrices à partir de nos précédents vecteurs. matrice1 &lt;- cbind(ages,tailles) # Afficher la matrice 1 print(matrice1) ## ages tailles ## [1,] 35 175.5 ## [2,] 45 180.3 ## [3,] 72 168.2 ## [4,] 56 172.8 ## [5,] 62 167.6 # Afficher les dimensions de la matrice 1 (1er chiffre : lignes; 2e chiffre : colonnes) print(dim(matrice1)) ## [1] 5 2 matrice2 &lt;- rbind(ages, tailles) # Afficher la matrice 2 print(matrice2) ## [,1] [,2] [,3] [,4] [,5] ## ages 35.0 45.0 72.0 56.0 62.0 ## tailles 175.5 180.3 168.2 172.8 167.6 # Afficher les dimensions de la matrice 2 print(dim(matrice2)) ## [1] 2 5 Comme vous pouvez le constater, la fonction cbind permet de concaténer des vecteurs comme sils étaient les colonnes dune matrice, alors que rbind les combine comme sils étaient les lignes dune matrice. La figure 1.12 présente graphiquement le passage du vecteur à la matrice. Figure 1.12: Du vecteur à la matrice Notez que vous pouvez transposer une matrice avec la fonction t. Si nous essayons maintenant de comparer la matrice 1 à la matrice 2 nous allons avoir une erreur, car elles nont pas les mêmes dimensions. matrice1 == matrice2 Erreur dans matrice1 == matrice2 : tableaux de tailles inadéquates En revanche, nous pouvons transposer la matrice 1 et refaire cette comparaison : t(matrice1) == matrice2 ## [,1] [,2] [,3] [,4] [,5] ## ages TRUE TRUE TRUE TRUE TRUE ## tailles TRUE TRUE TRUE TRUE TRUE Le résultat souligne bien que nous avons les mêmes valeurs dans les deux matrices. Il est aussi possible de construire des matrices directement avec la fonction matrix, ce que nous montrons dans la prochaine section. 1.3.6.3 Arrays Sil est rare de travailler avec des matrices, il est encore plus rare de manipuler des arrays. Un array est une matrice spéciale qui peut avoir plus que deux dimensions. Un cas simple serait un array en trois dimensions : lignes, colonnes, profondeur, que nous pourrions représenter comme un cube, ou une série de matrices de mêmes dimensions et empilées. Au-delà de trois dimensions, il devient difficile de les représenter mentalement. Cette structure de données peut être utilisée pour représenter les différentes bandes spectrales dune image satellitaire. Les lignes et les colonnes délimiteraient les pixels de limage et la profondeur délimiterait les différentes bandes composant limage (figure 1.12). Figure 1.13: Un array avec trois dimensions Créons un array en combinant trois matrices avec la fonction array. Chacune de ces matrices est composée respectivement de 1, de 2 et de 3 et a une dimension de 5 x 5. Larray final a donc une dimension de 5 x 5 x 3. mat1 &lt;- matrix(1, nrow = 5, ncol = 5) mat2 &lt;- matrix(2, nrow = 5, ncol = 5) mat3 &lt;- matrix(3, nrow = 5, ncol = 5) mon_array &lt;- array(c(mat1, mat2, mat3), dim = c(5,5,3)) print(mon_array) ## , , 1 ## ## [,1] [,2] [,3] [,4] [,5] ## [1,] 1 1 1 1 1 ## [2,] 1 1 1 1 1 ## [3,] 1 1 1 1 1 ## [4,] 1 1 1 1 1 ## [5,] 1 1 1 1 1 ## ## , , 2 ## ## [,1] [,2] [,3] [,4] [,5] ## [1,] 2 2 2 2 2 ## [2,] 2 2 2 2 2 ## [3,] 2 2 2 2 2 ## [4,] 2 2 2 2 2 ## [5,] 2 2 2 2 2 ## ## , , 3 ## ## [,1] [,2] [,3] [,4] [,5] ## [1,] 3 3 3 3 3 ## [2,] 3 3 3 3 3 ## [3,] 3 3 3 3 3 ## [4,] 3 3 3 3 3 ## [5,] 3 3 3 3 3 1.3.6.4 DataFrames Sil est rare de manipuler des matrices et des arrays, le DataFrame (tableau de données en français) est la structure de données la plus souvent utilisée. Dans cette structure, chaque ligne du tableau représente un individu et chaque colonne représente une caractéristique de cet individu. Ces colonnes ont des noms qui permettent facilement daccéder à leurs valeurs. Créons un DataFrame (tableau 1.4) à partir de nos quatre vecteurs et de la fonction data.frame. df &lt;- data.frame( &quot;age&quot; = ages, &quot;taille&quot; = tailles, &quot;adresse&quot; = adresses, &quot;proprietaire&quot; = proprietaires ) Tableau 1.4: Premier DataFrame age taille adresse proprietaire 35 175,5 4225 rue de la gauchetiere TRUE 45 180,3 4223 rue de la gauchetiere TRUE 72 168,2 4221 rue de la gauchetiere FALSE 56 172,8 4219 rue de la gauchetiere TRUE 62 167,6 4217 rue de la gauchetiere TRUE Dans RStudio, vous pouvez visualiser votre tableau de données avec la fonction View(df). Comme vous pouvez le constater, chaque vecteur est devenu une colonne de votre tableau de données df. La figure 1.14 résume ce passage dune simple donnée à un DataFrame en passant par un vecteur. Figure 1.14: De la donnée au DataFrame Plusieurs fonctions de base de R fournissent des informations importantes sur un DataFrame : names renvoie les noms des colonnes du DataFrame; nrow renvoie le nombre de lignes; ncol renvoie le nombre de colonnes. names(df) ## [1] &quot;age&quot; &quot;taille&quot; &quot;adresse&quot; &quot;proprietaire&quot; nrow(df) ## [1] 5 ncol(df) ## [1] 4 Vous pouvez accéder à chaque colonne de df en utilisant le symbole $ ou [[\"nom_de_la_colonne\"]]. Recalculons ainsi la moyenne des âges : mean(df$age) ## [1] 54 mean(df[[&quot;age&quot;]]) ## [1] 54 1.3.6.5 Listes La dernière structure de données à connaître est la liste. Elle ressemble à un vecteur, au sens où elle permet de stocker un ensemble dobjets les uns à la suite des autres. Cependant, une liste peut contenir nimporte quel type dobjets. Vous pouvez ainsi construire des listes de matrices, des listes darrays, des listes mixant des vecteurs, des graphiques, des DataFrames, des listes de listes Créons ensemble une liste qui va contenir des vecteurs et des matrices à laide de la fonction list. ma_liste &lt;- list(c(1,2,3,4), matrix(1, ncol = 3, nrow = 5), matrix(5, ncol = 3, nrow = 7), &#39;A&#39; ) Il est possible daccéder aux éléments de la liste par leur position dans cette dernière en utilisant les doubles crochets [[ ]] : print(ma_liste[[1]]) ## [1] 1 2 3 4 print(ma_liste[[4]]) ## [1] &quot;A&quot; Il est aussi possible de donner des noms aux éléments de la liste et dutiliser le symbole $ pour y accéder. Créons une nouvelle liste de vecteurs et donnons-leur des noms avec la fonction names. liste2 &lt;- list(c(35,45,72,56,62), c(175.5,180.3,168.2,172.8,167.6), c(TRUE,TRUE,FALSE,TRUE,TRUE) ) names(liste2) &lt;- c(&quot;age&quot;,&#39;taille&#39;,&#39;proprietaire&#39;) print(liste2$age) ## [1] 35 45 72 56 62 Si vous avez bien suivi, vous devriez avoir compris quun DataFrame nest en fait rien dautre quune liste de vecteurs avec des noms! Bravo! Vous venez de faire le tour des bases du langage R. Vous allez apprendre désormais à manipuler des données dans des DataFrames! "],["sect014.html", "1.4 Manipulation de données", " 1.4 Manipulation de données Dans cette section, vous apprendrez à charger et à manipuler des DataFrames en vue deffectuer des opérations classiques de gestion de données. 1.4.1 Chargement dun DataFrame depuis un fichier Il est rarement nécessaire de créer vos DataFrames manuellement. Le plus souvent, vous disposerez de fichiers contenant vos données et utiliserez des fonctions pour les importer dans R sous forme dun DataFrame. Les formats à importer les plus répandus sont : .csv, soit un fichier texte dont chaque ligne représente une ligne du tableau de données et dont les colonnes sont séparées par un délimiteur (généralement une virgule ou un point-virgule); .dbf, ou fichier dBase, souvent associés à des fichiers dinformation géographique au format ShapeFile; .xls et .xlsx, soit des fichiers générés par Excel; .json, soit un fichier texte utilisant la norme décriture propre au langage JavaScript. Plus rarement, il se peut que vous ayez à charger des fichiers provenant de logiciels propriétaires : .sas7bdat (SAS); .sav (SPSS); .dta (STATA). Pour lire la plupart de ces fichiers, nous utilisons le package foreign dédié à limportation dune multitude de formats. Nous commençons donc par linstaller (install.packages(\"foreign\")). Ensuite, nous chargeons cinq fois le même jeu de données enregistré dans des formats différents (csv, dbf, dta, sas7bdat et xlsx) et nous mesurons le temps nécessaire pour importer chacun de ces fichiers avec la fonction Sys.time. 1.4.1.1 Lecture dun fichier csv Pour le format csv, il nest pas nécessaire dutiliser un package puisque R dispose dune fonction de base pour lire ce format. t1 &lt;- Sys.time() df1 &lt;- read.csv(&quot;data/priseenmain/SR_MTL_2016.csv&quot;, header = TRUE, sep = &quot;,&quot;, dec = &quot;.&quot;, stringsAsFactors = FALSE) t2 &lt;- Sys.time() d1 &lt;- as.numeric(difftime(t2,t1,units=&quot;secs&quot;)) cat(&quot;le DataFrame df1 a &quot;,nrow(df1),&#39; observations&#39;, &#39;et &#39;,ncol(df1),&quot;colonnes\\n&quot;) ## le DataFrame df1 a 951 observations et 48 colonnes Rien de bien compliqué! Notez tout de même que : Lorsque vous chargez un fichier csv, vous devez connaître le délimiteur (ou séparateur), soit le caractère utilisé pour délimiter les colonnes. Dans le cas présent, il sagit dune virgule (spécifiez avec largument sep = \",\"), mais il pourrait tout aussi bien être un point virgule (sep = \";\"), une tabulation (sep = \" \"), etc. Vous devez également spécifier le caractère utilisé comme séparateur de décimales. Le plus souvent, ce sera le point (dec = \".\"), mais certains logiciels avec des paramètres régionaux de langue française (notamment Excel) exportent des fichiers csv avec des virgules comme séparateur de décimales (utilisez alors dec = \",\"). Largument header indique si la première ligne (lentête) du fichier comprend ou non les noms des colonnes du jeu de données (avec les valeurs TRUE ou FALSE). Il arrive que certains fichiers csv soient fournis sans entête et que le nom et la description des colonnes soient fournis dans un autre fichier. Largument stringsAsFactors permet dindiquer à R que les colonnes comportant du texte doivent être chargées comme des vecteurs de type texte et non de type facteur. 1.4.1.2 Lecture dun fichier dbase Pour lire un fichier dbase (.dbf), nous utilisons la fonction read.dbf du package foreign installé précédemment : library(foreign) t1 &lt;- Sys.time() df2 &lt;- read.dbf(&quot;data/priseenmain/SR_MTL_2016.dbf&quot;) t2 &lt;- Sys.time() d2 &lt;- as.numeric(difftime(t2,t1,units=&quot;secs&quot;)) cat(&quot;le DataFrame df2 a &quot;,nrow(df2),&quot; observations&quot;, &quot;et &quot;,ncol(df2),&quot; colonnes\\n&quot;) ## le DataFrame df2 a 951 observations et 48 colonnes Comme vous pouvez le constater, nous obtenons les mêmes résultats quavec le fichier csv. 1.4.1.3 Lecture dun fichier dta (Stata) Si vous travaillez avec des collègues utilisant le logiciel Stata, il se peut que ces derniers vous partagent des fichiers dta. Toujours en utilisant le package foreign, vous serez en mesure de les charger directement dans R. t1 &lt;- Sys.time() df3 &lt;- read.dta(&quot;data/priseenmain/SR_MTL_2016.dta&quot;) t2 &lt;- Sys.time() d3 &lt;- as.numeric(difftime(t2,t1,units=&quot;secs&quot;)) cat(&quot;le DataFrame df3 a &quot;,nrow(df3),&quot; observations &quot;, &quot;et &quot;,ncol(df3),&quot;colonnes\\n&quot;, sep = &quot;&quot;) ## le DataFrame df3 a 951 observations et 48colonnes 1.4.1.4 Lecture dun fichier sav (SPSS) Pour importer un fichier sav provenant du logiciel statistique SPSS, utilisez la fonction read.spss du package foreign. t1 &lt;- Sys.time() df4 &lt;- as.data.frame(read.spss(&quot;data/priseenmain/SR_MTL_2016.sav&quot;)) t2 &lt;- Sys.time() d4 &lt;- as.numeric(difftime(t2,t1,units=&quot;secs&quot;)) cat(&quot;le DataFrame df4 a &quot;,nrow(df4),&quot; observations &quot;, &quot;et &quot;,ncol(df4),&quot;colonnes\\n&quot;, sep = &quot;&quot;) ## le DataFrame df4 a 951 observations et 48colonnes 1.4.1.5 Lecture dun fichier sas7bdat (SAS) Pour importer un fichier sas7bdat provenant du logiciel statistique SAS, utilisez la fonction read.sas7bdat du package sas7bdat. Installez préalablement le package (install.packages(\"sas7bdat\")) et chargez-le (library(sas7bdat)). library(sas7bdat) t1 &lt;- Sys.time() df5 &lt;- read.sas7bdat(&quot;data/priseenmain/SR_MTL_2016.sas7bdat&quot;) t2 &lt;- Sys.time() d5 &lt;- as.numeric(difftime(t2,t1,units=&quot;secs&quot;)) cat(&quot;le DataFrame df5 a &quot;,nrow(df5),&quot; observations &quot;, &quot;et &quot;,ncol(df5),&quot; colonnes\\n&quot;, sep =&quot;&quot;) ## le DataFrame df5 a 951 observations et 48 colonnes 1.4.1.6 Lecture dun fichier xlsx (Excel) Lire un fichier Excel dans R nest pas toujours une tâche facile. Généralement, nous recommandons dexporter le fichier en question au format csv dans un premier temps, puis de le lire avec la fonction read.csv dans un second temps (section 1.4.1.1). Il est néanmoins possible de lire directement un fichier xlsx avec le package xlsx. Ce dernier requiert que le logiciel JAVA soit installé sur votre ordinateur (Windows, Mac ou Linux). Si vous utilisez la version 64 bit de R, vous devrez télécharger et installer la version 64 bit de JAVA. Une fois que ce logiciel tiers est installé, il ne vous restera plus quà installer (install.packages(\"xlsx\")) et charger (library(xlsx)) le package xlsx. Sous windows, il est possible que vous deviez également installer manuellement le package rJava et indiquer à R où se trouve JAVA sur votre ordinateur. La procédure est détaillée ici. library(xlsx) t1 &lt;- Sys.time() df6 &lt;- read.xlsx(file=&quot;data/priseenmain/SR_MTL_2016.xlsx&quot;, sheetIndex = 1, as.data.frame = TRUE) t2 &lt;- Sys.time() d6 &lt;- as.numeric(difftime(t2,t1,units=&quot;secs&quot;)) cat(&quot;le DataFrame df6 a &quot;,nrow(df6),&quot; observations &quot;, &quot;et &quot;,ncol(df6),&quot; colonnes\\n&quot;, sep = &quot;&quot;) ## le DataFrame df6 a 951 observations et 48 colonnes Il est possible daccélérer significativement la vitesse de lecture dun fichier xlsx en utilisant la fonction read.xlsx2. Il faut cependant indiquer à cette dernière le type de données de chaque colonne. Dans le cas présent, les cinq premières colonnes contiennent des données de type texte (character), alors que les 43 autres sont des données numériques (numeric). Nous utilisons la fonction rep afin de ne pas avoir à écrire plusieurs fois character et numeric. library(xlsx) t1 &lt;- Sys.time() df7 &lt;- read.xlsx2(file=&quot;data/priseenmain/SR_MTL_2016.xlsx&quot;, sheetIndex = 1, as.data.frame = TRUE, colClasses = c(rep(&quot;character&quot;,5),rep(&quot;numeric&quot;,43)) ) t2 &lt;- Sys.time() d7 &lt;- as.numeric(difftime(t2,t1,units=&quot;secs&quot;)) cat(&quot;le DataFrame df6 a &quot;,nrow(df7),&quot; observations &quot;, &quot;et &quot;,ncol(df7),&quot;colonnes\\n&quot;, sep = &quot;&quot;) ## le DataFrame df6 a 951 observations et 48colonnes Si nous comparons les temps dexécution (tableau 1.5), nous constatons que la lecture des fichiers xlsx peut être extrêmement longue si nous ne spécifions pas le type des colonnes, ce qui peut devenir problématique pour des fichiers volumineux. Notez également que la lecture dun fichier csv devient de plus en plus laborieuse à mesure que sa taille augmente. Si vous devez un jour charger des fichiers csv de plusieurs gigaoctets, nous vous recommandons vivement dutiliser la fonction fread du package data.table qui est beaucoup plus rapide. Tableau 1.5: Temps nécessaire pour lire les données en fonction du type de fichiers Durée (secondes) Fonction 0,25 read.csv 0,05 read.dbf 0,02 read.spss 0,02 read.dta 0,87 read.sas7bdat 20,06 read.xlsx 0,57 read.xlsx2 1.4.2 Manipulation dun DataFrame Une fois le DataFrame chargé, voyons comment il est possible de le manipuler. 1.4.2.1 Petit mot sur le tidyverse tidyverse est un ensemble de packages conçus pour faciliter la structuration et la manipulation des données dans R. Avant daller plus loin, il est important daborder brièvement un débat actuel dans la Communauté R. Entre 2010 et 2020, lutilisation du tidyverse sest peu à peu répandue. Développé et maintenu par Hadley Wickham, tidyverse introduit une philosophie et une grammaire spécifiques qui diffèrent du langage R traditionnel. Une partie de la communauté a pour ainsi dire complètement embrassé le tidyverse et de nombreux packages, en dehors du tidyverse, ont adopté sa grammaire et sa philosophie. À linverse, une autre partie de la communauté est contre cette évolution (voir larticle du blogue suivant). Les arguments pour et contre tidyverse sont résumés dans le tableau suivant. Tableau 1.6: Avantages et inconvénients du tidyverse Avantage du tidyverse Problème posé par le tidyverse Simplicité décriture et dapprentissage Nouvelle syntaxe à apprendre Ajout de lopérateur %&gt;% permettant denchaîner les traitements Perte de lisibilité avec lopérateur -&gt; La meilleure librairie pour réaliser des graphiques : ggplot2 Remplacement de certaines fonctions de base par dautres provenant du tidyverse lors de son chargement, pouvant créer des erreurs. Crée un écosystème cohérent Ajout dune dépendance dans le code Package en développement et de plus en plus utilisé Philosophie dévolution agressive, aucune assurance de rétrocompatibilité Le dernier point est probablement le plus problématique. Dans sa volonté dévoluer au mieux et sans restriction, le package tidyverse noffre aucune garantie de rétrocompatibilité. En dautre termes, des changements importants peuvent être introduits dune version à lautre rendant potentiellement obsolète votre ancien code. Nous navons pas dopinion tranchée sur le sujet : tidyverse est un outil très intéressant dans de nombreux cas; nous évitons simplement de lutiliser systématiquement et préférons charger directement des sous-packages (comme dplyr ou ggplot2) du tidyverse. Notez que le package data.table offre une alternative au tidyverse dans la manipulation de données. Au prix dune syntaxe généralement un peu plus complexe, le package data.table offre une vitesse de calcul bien supérieure au tidyverse et assure une bonne rétrocompatibilité. 1.4.2.2 Gestion des colonnes dun DataFrame Repartons du DataFrame que nous avions chargé précédemment en important un fichier csv. df &lt;- read.csv(file=&quot;data/priseenmain/SR_MTL_2016.csv&quot;, header = TRUE, sep = &quot;,&quot;, dec = &quot;.&quot;, stringsAsFactors = FALSE) 1.4.2.2.1 Sélection dune colonne Rappelons quil est possible daccéder aux colonnes dans ce DataFrame en utilisant le symbole dollar $ma_colonne ou les doubles crochets [[\"ma_colonne\"]]. # Calcul de la superficie totale de l&#39;Île de Montréal sum(df$KM2) ## [1] 4680.543 sum(df[[&quot;KM2&quot;]]) ## [1] 4680.543 1.4.2.2.2 Sélection de plusieurs colonnes Il est possible de sélectionner plusieurs colonnes dun DataFrame et de filtrer ainsi les colonnes inutiles. Pour cela, nous pouvons utiliser un vecteur contenant soit les positions des colonnes (1 pour la première colonne, 2 pour la seconde et ainsi de suite), soit les noms des colonnes. # Conserver les 5 premières colonnes df2 &lt;- df[1:5] # Conserver les colonnes 1, 5, 10 et 15 df3 &lt;- df[c(1,5,10,15)] # Cela peut aussi être utilisé pour changer l&#39;ordre des champs df3 &lt;- df[c(10,15,1,5)] # Conserver les colonnes 1 à 5, 7 à 12, 17 et 22 df4 &lt;- df[c(1:5,7:12,17,22)] # Conserver les colonnes avec leurs noms df5 &lt;- df[c(&quot;SRIDU&quot;,&quot;KM2&quot;,&quot;Pop2016&quot;,&quot;MaisonIndi&quot;,&quot;LoyerMed&quot;)] 1.4.2.2.3 Suppression de colonnes Il est parfois plus intéressant et rapide de supprimer directement des colonnes plutôt que de recréer un nouveau DataFrame. Pour ce faire, nous attribuons la valeur NULL à ces colonnes. # Supprimer le colonnes 2, 3 et 5 df3[c(2,3,5)] &lt;- list(NULL) # Supprimer une colonne avec son nom df4$OID &lt;- NULL # Supprimer plusieurs colonnes par leur nom df5[c(&quot;SRIDU&quot;,&quot;LoyerMed&quot;)] &lt;- list(NULL) Notez que si vous supprimez une colonne, vous ne pouvez pas revenir en arrière. Il faudra recharger votre jeu de données ou éventuellement relancer les calculs qui avaient produit cette colonne. 1.4.2.2.4 Modification du nom des colonnes Il est possible de changer le nom dune colonne. Cette opération est importante pour faciliter la lecture du DataFrame ou encore sassurer que lexportation du DataFrame dans un format particulier (tel que .dbf qui ne supporte que les noms de colonnes avec moins de 10 caractères) ne posera pas de problème. # Voici les noms des colonnes names(df5) ## [1] &quot;KM2&quot; &quot;Pop2016&quot; &quot;MaisonIndi&quot; # Renommer toutes les colonnes names(df5) &lt;- c(&#39;superficie_km2&#39;,&#39;population_2016&#39;, &#39;maison_individuelle_prt&#39;) names(df5) ## [1] &quot;superficie_km2&quot; &quot;population_2016&quot; ## [3] &quot;maison_individuelle_prt&quot; # Renommer avec dplyr library(dplyr) df4 &lt;- rename(df4, &quot;population_2016&quot; = &quot;Pop2016&quot;, &quot;prs_moins_14ans_prt&quot; = &quot;A014&quot;, &quot;prs_15_64_ans_prt&quot; = &quot;A1564&quot;, &quot;prs_65plus_ans_prt&quot; = &quot;A65plus&quot; ) 1.4.2.3 Calcul de nouvelles variables Il est possible dutiliser les colonnes de type numérique pour calculer de nouvelles colonnes en utilisant les opérateurs mathématiques vus dans la section 1.3.5. Prenons un exemple concret : calculons la densité de population par secteur de recensement dans notre DataFrame, puis affichons un résumé de cette nouvelle variable. # Calcul de la densité df$pop_density_2016 &lt;- df$Pop2016 / df$KM2 # Statistiques descriptives summary(df$pop_density_2016) ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 17.45 1946.96 3700.50 5465.03 7918.39 48811.79 Nous pouvons aussi calculer le ratio entre le nombre de maisons et le nombre dappartements. # Calcul du ratio df$total_maison &lt;- (df$MaisonIndi + df$MaisJumule + df$MaisRangee + df$AutreMais) df$total_apt &lt;- (df$AppDuplex + df$App5Moins + df$App5Plus) df$ratio_maison_apt &lt;- df$total_maison / df$total_apt Retenez ici que R applique le calcul à chaque ligne de votre jeu de données et stocke le résultat dans une nouvelle colonne. Cette opération est du calcul vectoriel : toute la colonne est calculée en une seule fois. R est dailleurs optimisé pour le calcul vectoriel. 1.4.2.4 Fonctions mathématiques R propose un ensemble de fonctions de base pour effectuer du calcul. Voici une liste non exhaustive des principales fonctions : abs calcule la valeur absolue de chaque valeur dun vecteur; sqrt calcule la racine carrée de chaque valeur dun vecteur; log calcule le logarithme de chaque valeur dun vecteur; exp calcule lexponentielle de chaque valeur dun vecteur; factorial calcule la factorielle de chaque valeur dun vecteur; round arrondit la valeur dun vecteur; ceiling, floor arrondit à lunité supérieure ou inférieure de chaque valeur dun vecteur; sin, asin, cos, acos, tan, atan sont des fonctions de trigonométrie; cumsum calcule la somme cumulative des valeurs dun vecteur. Ces fonctions sont des fonctions vectorielles puisquelles sappliquent à tous les éléments dun vecteur. Si votre vecteur en entrée comprend cinq valeurs, le vecteur en sortie comprendra aussi cinq valeurs. À linverse, les fonctions suivantes sappliquent directement à lensemble dun vecteur et ne vont renvoyer quune seule valeur : sum calcule la somme des valeurs dun vecteur; prod calcule le produit des valeurs dun vecteur; min, max renvoient les valeurs maximale et minimale dun vecteur; mean, median renvoient la moyenne et la médiane dun vecteur; quantile renvoie les percentiles dun vecteur. 1.4.2.5 Fonctions pour manipuler des chaînes de caractères Outre les données numériques, vous aurez à travailler avec des données de type texte (string). Le tidyverse avec le package stringr offre des fonctions très intéressantes pour manipuler ce type de données. Pour un aperçu de toutes les fonctions offertes par stringr, référez-vous à sa Cheat Sheet. Commençons avec un DataFrame assez simple comprenant des adresses et des noms de personnes. library(stringr) df &lt;- data.frame( noms = c(&quot;Jérémy Toutanplace&quot;,&quot;constant Tinople&quot;,&quot;dino Resto&quot;,&quot;Luce tancil&quot;), adresses = c(&#39;15 rue Levy&#39;, &#39;413 Blvd Saint-Laurent&#39;, &#39;3606 rue Duké&#39;, &#39;2457 route St Marys&#39;) ) 1.4.2.5.1 Majuscules et minuscules Pour harmoniser ce DataFrame, nous mettons, dans un premier temps, des majuscules à la première lettre des prénoms et des noms des individus avec la fonction str_to_title. df$noms_corr &lt;- str_to_title(df$noms) print(df$noms_corr) ## [1] &quot;Jérémy Toutanplace&quot; &quot;Constant Tinople&quot; &quot;Dino Resto&quot; ## [4] &quot;Luce Tancil&quot; Nous pourrions également tout mettre en minuscules ou tout en majuscules. df$noms_min &lt;- tolower(df$noms) df$noms_maj &lt;- toupper(df$noms) print(df$noms_min) ## [1] &quot;jérémy toutanplace&quot; &quot;constant tinople&quot; &quot;dino resto&quot; ## [4] &quot;luce tancil&quot; print(df$noms_maj) ## [1] &quot;JÉRÉMY TOUTANPLACE&quot; &quot;CONSTANT TINOPLE&quot; &quot;DINO RESTO&quot; ## [4] &quot;LUCE TANCIL&quot; 1.4.2.5.2 Remplacement du texte Les adresses comprennent des caractères accentués. Ce type de caractères cause régulièrement des problèmes dencodage. Nous pourrions alors décider de les remplacer par des caractères simples avec la fonction str_replace_all. df$adresses_1 &lt;- str_replace_all(df$adresses,&#39;é&#39;,&#39;e&#39;) print(df$adresses_1) ## [1] &quot;15 rue Levy&quot; &quot;413 Blvd Saint-Laurent&quot; &quot;3606 rue Duke&quot; ## [4] &quot;2457 route St Marys&quot; La même fonction peut être utilisée pour remplacer les St par Saint et les Blvd par Boulevard. df$adresses_2 &lt;- str_replace_all(df$adresses_1,&#39; St &#39;,&#39; Saint &#39;) df$adresses_3 &lt;- str_replace_all(df$adresses_2,&#39; Blvd &#39;,&#39; Boulevard &#39;) print(df$adresses_3) ## [1] &quot;15 rue Levy&quot; &quot;413 Boulevard Saint-Laurent&quot; ## [3] &quot;3606 rue Duke&quot; &quot;2457 route Saint Marys&quot; 1.4.2.5.3 Découpage du texte Il est parfois nécessaire de découper du texte pour en extraire des éléments. Nous devons alors choisir un caractère de découpage. Dans notre exemple, nous pourrions vouloir extraire les numéros civiques des adresses en sélectionnant le premier espace comme caractère de découpage, et en utilisant la fonction str_split_fixed. df$num_civique &lt;- str_split_fixed(df$adresses_3, &#39; &#39;,n=2)[,1] print(df$num_civique) ## [1] &quot;15&quot; &quot;413&quot; &quot;3606&quot; &quot;2457&quot; Pour être exact, sachez que pour notre exemple, la fonction str_split_fixed renvoie deux colonnes de texte : une avec le texte avant le premier espace, soit le numéro civique, et une avec le reste du texte. Le nombre de colonnes est contrôlé par largument n. Si n = 1, la fonction ne fait aucun découpage; avec n = 2 la fonction découpe en deux parties le texte avec la première occurrence du délimiteur et ainsi de suite. En ajoutant [,1] à la fin, nous indiquons que nous souhaitons garder seulement la première des deux colonnes. Il est également possible dextraire des parties de texte et de ne garder par exemple que les N premiers caractères ou les N derniers caractères : # Ne garder que les 5 premiers caractères substr(df$adresses_3,start = 1, stop = 5) ## [1] &quot;15 ru&quot; &quot;413 B&quot; &quot;3606 &quot; &quot;2457 &quot; # Ne garder que les 5 derniers caractères n_caract &lt;- nchar(df$adresses_3) substr(df$adresses_3, start = n_caract-4, stop = n_caract) ## [1] &quot; Levy&quot; &quot;urent&quot; &quot; Duke&quot; &quot;Marys&quot; Notez que les paramètres start et stop de la fonction substr peuvent accepter un vecteur de valeurs. Il est ainsi possible dappliquer une sélection de texte différente à chaque chaîne de caractères dans notre vecteur en entrée. Nous pourrions par exemple vouloir récupérer tout le texte avant le second espace pour garder uniquement le numéro civique et le type de rue. # Étape 1 : récupérer les positions des espaces pour chaque adresses positions &lt;- str_locate_all(df$adresses_3, &quot; &quot;) # Étape 2 : récupérer les positions des seconds espaces sec_positions &lt;- sapply(positions, function(i){ i[2,1] }) # Étape 3 : appliquer le découpage substr(df$adresses_3, start = 1, stop = sec_positions-1) ## [1] &quot;15 rue&quot; &quot;413 Boulevard&quot; &quot;3606 rue&quot; &quot;2457 route&quot; 1.4.2.5.4 Concaténation du texte À linverse du découpage, il est parfois nécessaire de concaténer des éléments de texte, ce quil est possible de réaliser avec la fonction paste. df$texte_complet &lt;- paste(df$noms_corr, df$adresses_3, sep = &quot; : &quot;) print(df$texte_complet) ## [1] &quot;Jérémy Toutanplace : 15 rue Levy&quot; ## [2] &quot;Constant Tinople : 413 Boulevard Saint-Laurent&quot; ## [3] &quot;Dino Resto : 3606 rue Duke&quot; ## [4] &quot;Luce Tancil : 2457 route Saint Marys&quot; Le paramètre sep permet dindiquer le ou les caractères à intercaler entre les éléments à concaténer. Notez quil est possible de concaténer plus que deux éléments. df$ville &lt;- c(&#39;Montreal&#39;,&#39;Montreal&#39;,&#39;Montreal&#39;,&#39;Montreal&#39;) paste(df$noms_corr, df$adresses_3, df$ville, sep = &quot;, &quot;) ## [1] &quot;Jérémy Toutanplace, 15 rue Levy, Montreal&quot; ## [2] &quot;Constant Tinople, 413 Boulevard Saint-Laurent, Montreal&quot; ## [3] &quot;Dino Resto, 3606 rue Duke, Montreal&quot; ## [4] &quot;Luce Tancil, 2457 route Saint Marys, Montreal&quot; Si vous souhaitez concaténer des éléments de texte sans séparateur, la fonction paste0 peut être plus simple à utiliser. paste0(&quot;Please conca&quot;, &quot;tenate me!&quot;) ## [1] &quot;Please concatenate me!&quot; 1.4.2.6 Manipulation des colonnes de type date Nous avons vu que les principaux types de données dans R sont le numérique, le texte, le booléen et le facteur. Il existe dautres types introduits par différents packages. Nous abordons ici les types date et heure (date and time). Pour les manipuler, nous privilégions lutilisation du package lubridate du tidyverse. Pour illustrer le tout, nous lutilisons avec un jeu de données ouvertes de la Ville de Montréal représentant les collisions routières impliquant au moins un cycliste survenues après le 1er janvier 2017. accidents_df &lt;- read.csv(file=&quot;data/priseenmain/accidents.csv&quot;, sep = &quot;,&quot;) names(accidents_df) ## [1] &quot;HEURE_ACCDN&quot; &quot;DT_ACCDN&quot; &quot;NB_VICTIMES_TOTAL&quot; Nous disposons de trois colonnes représentant respectivement lheure, la date et le nombre de victimes impliquées dans la collision. 1.4.2.6.1 Du texte à la date Actuellement, les colonnes HEURE_ACCDN et DT_ACCDN sont au format texte. Nous pouvons afficher quelques lignes du jeu de données avec la fonction head pour visualiser comment elles ont été saisies. head(accidents_df, n = 5) ## HEURE_ACCDN DT_ACCDN NB_VICTIMES_TOTAL ## 1 16:00:00-16:59:00 2017/11/02 0 ## 2 06:00:00-06:59:00 2017/01/16 1 ## 3 18:00:00-18:59:00 2017/04/18 0 ## 4 11:00:00-11:59:00 2017/05/28 1 ## 5 15:00:00-15:59:00 2017/05/28 1 Un peu de ménage simpose : les heures sont indiquées comme des périodes dune heure. Nous utilisons la fonction str_split_fixed du package stringr pour ne garder que la première partie de lheure (avant le tiret). Ensuite, Nous concaténons lheure et la date avec la fonction paste, puis nous convertissons ce résultat en un objet date-time. library(lubridate) # Étape 1 : découper la colonne Heure_ACCDN accidents_df$heure &lt;- str_split_fixed(accidents_df$HEURE_ACCDN, &quot;-&quot;, n=2)[,1] # Étape 2 : concaténer l&#39;heure et la date accidents_df$date_heure &lt;- paste(accidents_df$DT_ACCDN, accidents_df$heure, sep = &#39; &#39;) # Étape 3 : convertir au format datetime accidents_df$datetime &lt;- as_datetime(accidents_df$date_heure, format = &quot;%Y/%m/%d %H:%M:%S&quot;) Pour effectuer la conversion, nous avons utilisé la fonction as_datetime du package lubridate. Elle prend comme paramètre un vecteur de texte et une indication du format de ce vecteur de texte. Il existe de nombreuses façons de spécifier une date et une heure et largument format permet dindiquer celle à utiliser. Dans cet exemple, la date est structurée comme suit : année/mois/jour heure:minute:seconde, ce qui se traduit par le format %Y/%m/%d %H:%M:%S. %Y signifie une année indiquée avec quatre caractères : 2017; %m signifie un mois, indiqué avec deux caractères : 01, 02, 03,  12; %d signifie un jour, indiqué avec deux caractères : 01, 02, 03,  31; %H signifie une heure, au format 24 heures avec deux caractères : 00, 02,  23; %M signifie des minutes indiquées avec deux caractères : 00, 02,  59; %S signifie des secondes, indiquées avec deux caractères : 00, 02,  59. Notez que les caractères séparant les années, jours, heures, etc. sont aussi à indiquer dans le format. Dans notre exemple, nous utilisons la barre oblique (/) pour séparer les éléments de la date et le deux points (:) pour lheure, et une espace pour séparer la date et lheure. Il existe dautres nomenclatures pour spécifier un format datetime : par exemple, des mois renseignés par leur nom, lindication AM-PM, etc. Vous pouvez vous référer à la documentation de la fonction strptime (help(strptime)) pour explorer les différentes nomenclatures et choisir celle qui vous convient. Bien évidemment, il est nécessaire que toutes les dates de votre colonne soient renseignées dans le même format, pour éviter que la fonction ne retourne la valeur NA lorsquelle ne peut lire le format. Après toutes ces opérations, rejetons un oeil à notre DataFrame. head(accidents_df, n = 5) ## HEURE_ACCDN DT_ACCDN NB_VICTIMES_TOTAL heure date_heure ## 1 16:00:00-16:59:00 2017/11/02 0 16:00:00 2017/11/02 16:00:00 ## 2 06:00:00-06:59:00 2017/01/16 1 06:00:00 2017/01/16 06:00:00 ## 3 18:00:00-18:59:00 2017/04/18 0 18:00:00 2017/04/18 18:00:00 ## 4 11:00:00-11:59:00 2017/05/28 1 11:00:00 2017/05/28 11:00:00 ## 5 15:00:00-15:59:00 2017/05/28 1 15:00:00 2017/05/28 15:00:00 ## datetime ## 1 2017-11-02 16:00:00 ## 2 2017-01-16 06:00:00 ## 3 2017-04-18 18:00:00 ## 4 2017-05-28 11:00:00 ## 5 2017-05-28 15:00:00 1.4.2.6.2 Extraction des informations dune date À partir de la nouvelle colonne datetime, nous sommes en mesure dextraire des informations intéressantes comme : le nom du jour de la semaine avec la fonction weekdays accidents_df$jour &lt;- weekdays(accidents_df$datetime) la période de la journée avec les fonctions am et pm accidents_df$AM &lt;- am(accidents_df$datetime) accidents_df$PM &lt;- pm(accidents_df$datetime) head(accidents_df[c(&quot;jour&quot;, &quot;AM&quot;, &quot;PM&quot;)], n=5) ## jour AM PM ## 1 jeudi FALSE TRUE ## 2 lundi TRUE FALSE ## 3 mardi FALSE TRUE ## 4 dimanche TRUE FALSE ## 5 dimanche FALSE TRUE Il est aussi possible daccéder aux sous-éléments dun datetime comme lannée, le mois, le jour, lheure, la minute et la seconde avec les fonctions year(), month(),day(), hour(), minute() et second(). 1.4.2.6.3 Calcul dune durée entre deux datetime Une autre utilisation intéressante du format datetime est de calculer des différences de temps. Par exemple, nous pourrions utiliser le nombre de minutes écoulées depuis 7 h comme une variable dans une analyse visant à déterminer le moment critique des collisions routières durant lheure de pointe du matin. Pour cela, nous devons créer un datetime de référence en concaténant la date de chaque observation, et le temps 07:00:00, qui est notre point de départ. accidents_df$date_heure_07 &lt;- paste(accidents_df$DT_ACCDN, &#39;07:00:00&#39;, sep = &#39; &#39;) accidents_df$ref_datetime &lt;- as_datetime(accidents_df$date_heure_07, format = &quot;%Y/%m/%d %H:%M:%S&quot;) Il ne nous reste plus quà calculer la différence de temps entre la colonne datetime et notre temps de référence ref_datetime. accidents_df$diff_time &lt;- difftime(accidents_df$datetime, accidents_df$ref_datetime, units = &#39;min&#39;) Notez quici la colonne diff_time est dun type spécial : une différence temporelle (difftime). Il faut encore la convertir au format numérique pour lutiliser avec la fonction as.numeric. Par curiosité, réalisons rapidement un histogramme avec la fonction hist pour analyser rapidement cette variable décart de temps! accidents_df$diff_time_num &lt;- as.numeric(accidents_df$diff_time) hist(accidents_df$diff_time_num, breaks = 50) Figure 1.15: Répartition temporelle des accidents à vélo Nous observons clairement deux pics, un premier entre 0 et 100 (entre 7 h et 8 h 30 environ) et un second plus important entre 550 et 650 (entre 16 h et 17 h 30 environ), ce qui correspond sans surprise aux heures de pointe (figure 1.15). Il est intéressant de noter que plus daccidents se produisent à lheure de pointe du soir quà celle du matin. 1.4.2.6.4 Fuseau horaire Lorsque nous travaillons avec des données provenant de différents endroits dans le monde ou que nous devons tenir compte des heures dété et dhiver, il convient de tenir compte du fuseau horaire. Pour créer une date avec un fuseau horaire, il est possible dutiliser le paramètre tz dans la fonction as_datetime et dutiliser lidentifiant du fuseau approprié. Dans notre cas, les données daccident ont été collectées à Montréal, qui a un décalage de -5 heures par rapport au temps de référence UTC (+1 heure en été). Le code spécifique de ce fuseau horaire est EDT; il est facile de trouver ces codes avec le site web timeanddate.com. accidents_df$datetime &lt;- as_datetime(accidents_df$date_heure, format = &quot;%Y/%m/%d %H:%M:%S&quot;, tz = &quot;EDT&quot;) 1.4.2.7 Recodage des variables Recoder une variable signifie changer ses valeurs selon une condition afin dobtenir une nouvelle variable. Si nous reprenons le jeu de données précédent sur les accidents à vélo, nous pourrions vouloir créer une nouvelle colonne nous indiquant si la collision a eu lieu en heures de pointe ou non. Nous obtiendrions ainsi une nouvelle variable avec seulement deux catégories plutôt que la variable numérique originale. Nous pourrions aussi définir quatre catégories avec lheure de pointe du matin, lheure de pointe du soir, le reste de la journée et la nuit. 1.4.2.7.1 Cas binaire avec ifelse Si nous ne souhaitons créer que deux catégories, le plus simple est dutiliser la fonction ifelse. Cette fonction évalue une condition (section 1.3.5) pour chaque ligne dun DataFrame et produit un nouveau vecteur. Créons donc une variable binaire indiquant si une collision a eu lieu durant les heures de pointe ou hors heures de pointe. Nous devons alors évaluer les conditions suivantes : Est-ce que laccident a eu lieu entre 7 h (0) ET 9 h (120), OU entre 16 h 30 (570) ET 18 h 30 (690)? table(is.na(accidents_df$diff_time_num)) ## ## FALSE TRUE ## 2414 40 Notons dans un premier temps que nous avons 40 observations sans valeur pour la colonne diff_time_num. Il sagit dobservations pour lesquelles nous ne disposions pas de dates au départ. Cond1 &lt;- accidents_df$diff_time_num &gt;= 0 &amp; accidents_df$diff_time_num &lt;= 120 Cond2 &lt;- accidents_df$diff_time_num &gt;= 570 &amp; accidents_df$diff_time_num &lt;= 690 accidents_df$moment_bin &lt;- ifelse(Cond1 | Cond2, &quot;en heures de pointe&quot;, &quot;hors heures de pointe&quot;) Comme vous pouvez le constater, la fonction ifelse nécessite trois arguments : une condition, pouvant être TRUE ou FALSE; la valeur à renvoyer si la condition est FALSE; la valeur à renvoyer si la condition est TRUE. Avec la fonction table, nous pouvons rapidement visualiser les effectifs des deux catégories ainsi créées : table(accidents_df$moment_bin) ## ## en heures de pointe hors heures de pointe ## 841 1573 # Vérifier si nous avons toujours seulement 40 NA table(is.na(accidents_df$moment_bin)) ## ## FALSE TRUE ## 2414 40 Les heures de pointe représentent quatre heures de la journée, ce qui nous laisse neuf heures hors heures de pointe entre 7 h et 20 h. # Ratio de collisions routières en heures de pointe (841 / 2414) / (4 / 13) ## [1] 1.132249 # Ratio de collisions routières hors heure de pointe (1573 / 2414) / (9 / 13) ## [1] 0.9412225 En rapportant les collisions aux durées des deux périodes, nous observons une nette surreprésentation des collisions impliquant un vélo pendant les heures de pointe denviron 13 % comparativement à la période hors des heures de pointe. 1.4.2.7.2 Cas multiple avec la case_when Lorsque nous souhaitons créer plus que deux catégories, il est possible soit denchaîner plusieurs fonctions ifelse (ce qui produit un code plus long et moins lisible), soit dutiliser la fonction case_when du package dplyr du tidyverse. Reprenons notre exemple et créons quatre catégories : en heures de pointe du matin; en heures de pointe du soir; le reste de la journée (entre 7 h et 20 h); la nuit (entre 21 h et 7 h). library(dplyr) accidents_df$moment_multi &lt;- case_when( accidents_df$diff_time_num &gt;= 0 &amp; accidents_df$diff_time_num &lt;= 120 ~ &quot;pointe matin&quot;, accidents_df$diff_time_num &gt;= 570 &amp; accidents_df$diff_time_num &lt;= 690 ~ &quot;pointe soir&quot;, accidents_df$diff_time_num &gt; 690 &amp; accidents_df$diff_time_num &lt; 780 ~ &quot;journee&quot;, accidents_df$diff_time_num &gt; 120 &amp; accidents_df$diff_time_num &lt; 570 ~ &quot;journee&quot;, accidents_df$diff_time_num &lt; 0 | accidents_df$diff_time_num &gt;= 780 ~ &quot;nuit&quot; ) table(accidents_df$moment_multi) ## ## journee nuit pointe matin pointe soir ## 1155 418 404 437 # Vérifions encore les NA table(is.na(accidents_df$moment_multi)) ## ## FALSE TRUE ## 2414 40 La syntaxe de cette fonction est un peu particulière. Elle accepte un nombre illimité (ou presque) darguments. Chaque argument est composé dune condition et dune valeur à renvoyer si la condition est vraie; ces deux éléments étant reliés par le symbole ~. Notez que toutes les évaluations sont effectuées dans lordre des arguments. En dautres termes, la fonction teste dabord la première condition et assigne ses valeurs, puis recommence pour les prochaines conditions. Ainsi, si une observation (ligne du tableau de données) obtient TRUE à plusieurs conditions, elle obtient au final la valeur de la dernière condition validée. Dans lexemple précédent, si la première condition est accidents_df$diff_time_num &gt;= 0 | accidents_df$diff_time_num &lt;= 120, alors nous obtenons pour seule valeur en résultat \"pointe matin\" puisque chaque observation a une valeur supérieure à 0 et que nous avons remplacé lopérateur &amp; (ET) par lopérateur | (OU). 1.4.2.8 Sous-sélection dun DataFrame Dans cette section, nous voyons comment extraire des sous-parties dun DataFrame. Il est possible de sous-sélectionner des lignes et des colonnes en se basant sur des conditions ou leur index. Pour cela, nous utilisons un jeu de données fourni avec R : le jeu de données iris décrivant des fleurs du même nom. data(&quot;iris&quot;) # Nombre de lignes et de colonnes dim(iris) ## [1] 150 5 1.4.2.8.1 Sous-sélection des lignes Sous-sélectionner des lignes par index est relativement simple. Admettons que nous souhaitons sélectionner les lignes 1 à 5, 10 à 25, 37 et 58. sub_iris &lt;- iris[c(1:5, 10:25, 37, 58),] nrow(sub_iris) ## [1] 23 Sous-sélectionner des lignes avec une condition peut être effectué soit avec une syntaxe similaire, soit en utilisant la fonction subset. Sélectionnons toutes les fleurs de lespèce Virginica. iris_virginica1 &lt;- iris[iris$Species == &quot;virginica&quot;,] iris_virginica2 &lt;- subset(iris, iris$Species == &quot;virginica&quot;) # Vérifions que les deux DataFrames ont le même nombre de lignes nrow(iris_virginica1) == nrow(iris_virginica2) ## [1] TRUE Vous pouvez utiliser, dans les deux cas, tous les opérateurs vus dans les sections 1.3.5.2 et 1.3.5.3. Lenjeu est darriver à créer un vecteur booléen final permettant didentifier les observations à conserver. 1.4.2.8.2 Sous-sélection des colonnes Nous avons déjà vu comment sélectionner des colonnes en utilisant leur nom ou leur index dans la section 1.4.2.2.1. Ajoutons ici un cas particulier où nous souhaitons sélectionner des colonnes selon une condition. Par exemple, nous pourrions vouloir conserver que les colonnes comprenant le mot Length. Pour cela, nous utilisons la fonction grepl, permettant de déterminer si des caractères sont présents dans une chaîne de caractères. nom_cols &lt;- names(iris) print(nom_cols) ## [1] &quot;Sepal.Length&quot; &quot;Sepal.Width&quot; &quot;Petal.Length&quot; &quot;Petal.Width&quot; &quot;Species&quot; test_nom &lt;- grepl(&quot;Length&quot;,nom_cols, fixed = TRUE) ok_nom &lt;- nom_cols[test_nom] iris_2 &lt;- iris[ok_nom] print(names(iris_2)) ## [1] &quot;Sepal.Length&quot; &quot;Petal.Length&quot; Il est possible dobtenir ce résultat en une seule ligne de code, mais elle est un peu moins lisible. iris2 &lt;- iris[names(iris)[grepl(&quot;Length&quot;,names(iris), fixed = TRUE)]] 1.4.2.8.3 Sélection des colonnes et des lignes Nous avons vu quavec les crochets [], nous pouvons extraire les colonnes et les lignes dun DataFrame. Il est possible de combiner les deux opérations simultanément. Pour ce faire, il faut indiquer en premier les index ou la condition permettant de sélectionner une ligne, puis les index ou la condition pour sélectionner les colonnes : [index_lignes , index_colonnes]. Sélectionnons cinq premières lignes et les trois premières colonnes du jeu de données iris : iris_5x3 &lt;- iris[c(1,2,3,4,5),c(1,2,3)] print(iris_5x3) ## Sepal.Length Sepal.Width Petal.Length ## 1 5.1 3.5 1.4 ## 2 4.9 3.0 1.4 ## 3 4.7 3.2 1.3 ## 4 4.6 3.1 1.5 ## 5 5.0 3.6 1.4 Combinons nos deux exemples précédents pour sélectionner uniquement les lignes avec des fleurs de lespèce virginica, et les colonnes avec le mot Length. iris_virginica3 &lt;- iris[iris$Species == &quot;virginica&quot;, names(iris)[grepl(&quot;Length&quot;,names(iris), fixed = TRUE)]] head(iris_virginica3, n=5) ## Sepal.Length Petal.Length ## 101 6.3 6.0 ## 102 5.8 5.1 ## 103 7.1 5.9 ## 104 6.3 5.6 ## 105 6.5 5.8 1.4.2.9 Fusion de DataFrames Terminons cette section avec la fusion de DataFrames. Nous distinguons deux méthodes répondant à des besoins différents : par ajout ou par jointure. 1.4.2.9.1 Fusion de DataFrames par ajout Ajouter deux DataFrames peut se faire en fonction de leurs colonnes ou en fonction de leurs lignes. Dans ces deux cas, nous utilisons respectivement les fonctions cbind et rbind. La figure 1.16 résume graphiquement le fonctionnement des deux fonctions. Figure 1.16: Fusion de DataFrames Pour que cbind fonctionne, il faut que les deux DataFrames aient le même nombre de lignes. Pour rbind, les deux DataFrames doivent avoir le même nombre de colonnes. Prenons à nouveau comme exemple le jeu de données iris. Nous commençons par le séparer en trois sous-jeux de données comprenant chacun une espèce diris. Puis, nous fusionnons deux dentre eux avec la fonction rbind. iris1 &lt;- subset(iris, iris$Species == &quot;virginica&quot;) iris2 &lt;- subset(iris, iris$Species == &quot;versicolor&quot;) iris3 &lt;- subset(iris, iris$Species == &quot;setosa&quot;) iris_comb &lt;- rbind(iris2,iris3) Nous pourrions aussi extraire dans les deux DataFrames les colonnes comprenant le mot Length et le mot Width, puis les fusionner. iris_l &lt;- iris[names(iris)[grepl(&quot;Length&quot;,names(iris), fixed = TRUE)]] iris_w &lt;- iris[names(iris)[grepl(&quot;Width&quot;,names(iris), fixed = TRUE)]] iris_comb &lt;- cbind(iris_l,iris_w) names(iris_comb) ## [1] &quot;Sepal.Length&quot; &quot;Petal.Length&quot; &quot;Sepal.Width&quot; &quot;Petal.Width&quot; 1.4.2.9.2 Jointure de DataFrames Une jointure est une opération un peu plus complexe quun simple ajout. Lidée est dassocier des informations de plusieurs DataFrames en utilisant une colonne (appelée une clef) présente dans les deux jeux de données. Nous distinguons plusieurs types de jointure : les jointures internes permettant de combiner les éléments communs entre deux DataFrames A et B; la jointure complète permettant de combiner les éléments présents dans A ou B; la jointure à gauche, permettant de ne conserver que les éléments présents dans A même sils nont pas de correspondance dans B. Ces trois jointures sont présentées à la figure 1.17; pour ces trois cas, la colonne commune se nomme id. Figure 1.17: Jointure de DataFrames Vous retiendrez que les deux dernières jointures peuvent produire des valeurs manquantes. Pour réaliser ces opérations, nous utilisons la fonction merge. Prenons un exemple simple à partir dun petit jeu de données. auteurs &lt;- data.frame( name = c(&quot;Tukey&quot;, &quot;Venables&quot;, &quot;Tierney&quot;, &quot;Ripley&quot;, &quot;McNeil&quot;, &quot;Apparicio&quot;), nationality = c(&quot;US&quot;, &quot;Australia&quot;, &quot;US&quot;, &quot;UK&quot;, &quot;Australia&quot;, &quot;Canada&quot;), retired = c(&quot;yes&quot;, rep(&quot;no&quot;, 5))) livres &lt;- data.frame( aut = c(&quot;Tukey&quot;, &quot;Venables&quot;, &quot;Tierney&quot;, &quot;Ripley&quot;, &quot;Ripley&quot;, &quot;McNeil&quot;,&quot;Wickham&quot;), title = c(&quot;Exploratory Data Analysis&quot;, &quot;Modern Applied Statistics ...&quot;, &quot;LISP-STAT&quot;, &quot;Spatial Statistics&quot;, &quot;Stochastic Simulation&quot;, &quot;Interactive Data Analysis&quot;, &quot;R for Data Science&quot;)) Nous avons donc deux DataFrames, le premier décrivant des auteurs et le second des livres. Effectuons une première jointure interne afin de savoir pour chaque livre la nationnalité de son auteur et si ce dernier est à la retraite. df1 &lt;- merge(livres, auteurs, #les deux DataFrames by.x = &quot;aut&quot;, by.y = &#39;name&#39;, #les noms des colonnes de jointures all.x = FALSE, all.y = FALSE) print(df1) ## aut title nationality retired ## 1 McNeil Interactive Data Analysis Australia no ## 2 Ripley Spatial Statistics UK no ## 3 Ripley Stochastic Simulation UK no ## 4 Tierney LISP-STAT US no ## 5 Tukey Exploratory Data Analysis US yes ## 6 Venables Modern Applied Statistics ... Australia no Cette jointure est interne, car les deux paramètres all.x et all.y ont pour valeur FALSE. Ainsi, nous indiquons à la fonction que nous ne souhaitons ni garder tous les éléments du premier DataFrame ni tous les éléments du second, mais uniquement les éléments présents dans les deux. Vous noterez ainsi que le livre R for Data Science nest pas présent dans le jeu de données final, car son auteur Wickham ne fait pas partie du DataFrame auteurs. De même, lauteur Apparicio napparaît pas dans la jointure, car aucun livre dans le DataFrame books na été écrit par cet auteur. Pour conserver tous les livres, nous pouvons effectuer une jointure à gauche en renseignant all.x = TRUE. Nous forçons ainsi la fonction à garder tous les livres et à mettre des valeurs vides aux informations manquantes des auteurs. df2 &lt;- merge(livres, auteurs, #les deux DataFrames by.x = &quot;aut&quot;, by.y = &#39;name&#39;, #les noms des colonnes de jointures all.x = TRUE, all.y = FALSE) print(df2) ## aut title nationality retired ## 1 McNeil Interactive Data Analysis Australia no ## 2 Ripley Spatial Statistics UK no ## 3 Ripley Stochastic Simulation UK no ## 4 Tierney LISP-STAT US no ## 5 Tukey Exploratory Data Analysis US yes ## 6 Venables Modern Applied Statistics ... Australia no ## 7 Wickham R for Data Science &lt;NA&gt; &lt;NA&gt; Pour garder tous les livres et tous les auteurs, nous pouvons faire une jointure complète en indiquant all.x = TRUE et all.y = TRUE. df3 &lt;- merge(livres, auteurs, #les deux DataFrames by.x = &quot;aut&quot;, by.y = &#39;name&#39;, #les noms des colonnes de jointures all.x = TRUE, all.y = TRUE) print(df3) ## aut title nationality retired ## 1 Apparicio &lt;NA&gt; Canada no ## 2 McNeil Interactive Data Analysis Australia no ## 3 Ripley Spatial Statistics UK no ## 4 Ripley Stochastic Simulation UK no ## 5 Tierney LISP-STAT US no ## 6 Tukey Exploratory Data Analysis US yes ## 7 Venables Modern Applied Statistics ... Australia no ## 8 Wickham R for Data Science &lt;NA&gt; &lt;NA&gt; "],["sect016.html", "1.5 Code R bien structuré", " 1.5 Code R bien structuré Terminons ici avec quelques conseils sur la rédaction dun code R. Bien rédiger son code est essentiel pour trois raisons : Pouvoir relire et réutiliser son code dans le futur. Permettre à dautres personnes de bien lire et de réutiliser votre code. Minimiser les risques derreurs. Ne négligez pas limportance dun code bien rédigé et bien documenté, vous vous éviterez ainsi des migraines lorsque vous devrez exhumer du code écrit il y a plusieurs mois. Voici quelques lignes directrices peu contraignantes, mais qui devraient vous être utiles : Privilégier la clarté à la concision : il vaut mieux parfois scinder une ligne de code en plusieurs sous-étapes afin de faciliter la lecture de lopération réalisée. Par exemple, si nous reprenons une ligne de code dune section précédente où nous sélectionnions lensemble des colonnes du jeu de données iris comprenant le mot Length : iris_l &lt;- iris[names(iris)[grepl(&quot;Length&quot;,names(iris), fixed = TRUE)]] Nous pouvons simplifier la lecture de ce code en détaillant les différentes étapes comme suit : noms_cols &lt;- names(iris) sel_noms &lt;- noms_cols[grepl(&quot;Length&quot;,noms_cols, fixed = TRUE)] iris_l &lt;- iris[sel_noms] Documenter et commenter son code le plus possible : il est possible dajouter du texte dans un code R qui ne sera pas exécuté, ce que nous appelons des commentaires. Typiquement, une ligne commençant par un # nest pas interprétée par le logiciel. Utilisez des commentaires le plus souvent possible pour décrire les actions que vous souhaitez effectuer avec votre code. Il sera ainsi plus facile de le relire, de naviguer dedans, mais également de repérer déventuelles erreurs. Si nous reprenons lexemple précédent : # Récupération du nom des colonnes dans le DataFrame iris noms_cols &lt;- names(iris) # Sélection des colonnes avec les caractères &quot;Length&quot; sel_noms &lt;- noms_cols[grepl(&quot;Length&quot;,noms_cols, fixed = TRUE)] # Extraction des colonnes sélectionnées dans un nouveau DataFrame iris_l &lt;- iris[sel_noms] Éviter le code à rallonge : typiquement, essayez de vous limiter à des lignes de code dune longueur maximale de 80 caractères. Au-delà de ce seuil, il est judicieux de découper votre code en plusieurs lignes. Adopter une convention décriture : une convention décriture est un ensemble de règles strictes définissant comment un code doit être rédigé. À titre dexemple, il est parfois recommandé dutiliser le lowerCamelCase, le UpperCamelCase, ou encore de séparer les mots par des tirets bas upper_camel_case. Un mélange de ces différentes conventions peut être utilisé pour distinguer les variables, les fonctions et les classes. Il peut être difficile de réellement arrêter une telle convention, car les différents packages dans R utilisent des conventions différentes. Dans vos propres codes, il est surtout important davoir une certaine cohérence et ne pas changer de convention. Indenter le code : lindentation du code permet de le rendre beaucoup plus lisible. Indenter son code signifie dinsérer, au début de chaque ligne de code, un certain nombre despaces permettant dindiquer à quel niveau de profondeur nous nous situons. Typiquement, lorsque des accolades ou des parenthèses sont ouvertes dans une fonction, une boucle ou une condition, nous rajoutons deux ou quatre espaces en début de ligne. Prenons un exemple très concret : admettons que nous écrivons une fonction affichant un résumé statistique à chaque colonne dun jeu de données si cette colonne est de type numérique. Lindentation dans cette fonction joue un rôle crucial dans sa lisibilité. Sans indentation et sans respecter la règle des 80 caractères, nous obtenons ceci : summary_all_num_cols &lt;- function(dataset){for(col in names(dataset)){if(class(dataset[[col]] == &quot;numeric&quot;)){print(summary(dataset[[col]]))}}} Avec de lindentation et des commentaires, la syntaxe est beaucoup plus lisible puisquelle permet de repérer facilement trois niveaux/paliers dans le code : # Définition d&#39;une fonction summary_all_num_cols &lt;- function(dataset){ # Itération sur chaque colonne de la fonction for(col in names(dataset)){ # A chaque itération, testons si la colonne est de type numérique if(class(dataset[[col]] == &quot;numeric&quot;)){ # Si oui, nous affichons un résumé statistique pour cette colonne print(summary(dataset[[col]])) } # Ici nous sortons de la condition (niveau 3) } # Ici nous sortons de la boucle (niveau 2) }# Ici nous sortons de la fonction (niveau 1) Adopter une structure globale pour vos scripts : un code R peut être comparé à une recette de cuisine. Si tous les éléments sont dans le désordre et sans structure globale, la recette risque dêtre très difficile à suivre. Cette structure risque de changer quelque peu en fonction de la recette ou de lauteur(e), mais les principaux éléments restent les mêmes. Dans un code R, nous pouvons distinguer plusieurs éléments récurrents que nous vous recommandons dorganiser de la façon suivante : Charger les différents packages utilisés par le script. Cela permet dès le début du code de savoir quelles sont les fonctions et méthodes qui seront employées dans le script. Cela limite aussi les risques doublier des packages qui seraient chargés plus loin dans le code. Définir les fonctions dont vous aurez besoin en plus de celles présentes dans les packages. Idem, placer nos fonctions en début de code évite doublier de les charger ou de les chercher quand nous en avons besoin. Définir le répertoire de travail avec la fonction setwd et charger les données nécessaires. Effectuer au besoin les opérations de manipulation sur les données. Effectuer les analyses nécessaires en scindant si possible les différentes étapes. Notez également que létape de définition des fonctions complémentaires peut être effectuée dans une feuille de code séparée, et lensemble de ces fonctions chargées à laide de la fonction source. De même, si la manipulation des données est conséquente, il est recommandé de leffectuer avec un code à part, denregistrer les données structurées, puis de les charger directement au début de votre code dédié à lanalyse. Exploiter les commentaires délimitant les sections dans RStudio : il est possible décrire des commentaires dune certaine façon pour que lIDE les détecte comme des délimiteurs de sections. Lintérêt principal est que nous pouvons ensuite facilement naviguer entre ces sections en utilisant RStudio comme montré à la figure 1.18, mais aussi masquer des sections afin de faciliter la lecture du reste du code. Pour délimiter une section, il suffit dajouter une ligne de commentaire comprenant quatre fois les caractères -, = ou # à la suite : # Voici ma section 1 ---------------------------------- # Voici ma section 2 ================================== # Voici ma section 3 ################################## # Autre exemple pour mieux marquer la rupture dans un code : #%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% #### Titre de ma section 4 #### #%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Figure 1.18: Navigation dans des sections de codes avec RStudio Adopter une structure globale pour vos projets : au-delà du script, il est nécessaire de bien structurer vos projets, le plus important étant dutiliser une structure commune à chaque projet pour vous faciliter le travail. Nous proposons à la figure 1.19 un exemple de structure assez générale pouvant être utilisée dans la plupart des cas. Elle sépare notamment les données originales des données structurées, ainsi que les fonctions complémentaires et la structuration des données du principal bloc danalyse. Figure 1.19: Structure de dossier recommandée pour un projet avec R Ne négligez jamais limportance dun code bien écrit et documenté ! "],["sect017.html", "1.6 Enregistrement des résultats", " 1.6 Enregistrement des résultats Comme nous lavons indiqué précédemment, lensemble des objets actuellement chargés dans votre session R sont perdus si vous la fermez. Cela peut être problématique si certains résultats nécessitent de longs temps de calcul ou si vous avez besoin de partager les objets obtenus avec dautres personnes, mais pas le code pour les obtenir. Il est possible de retrouver les résultats dune session précédente si ceux-ci ont été enregistrés sur votre disque dur puisque laction denregistrer permet de faire passer vos objets présents dans votre mémoire vive dans des fichiers stockés sur votre disque dur. Vous pouvez pour cela utiliser la fonction save.image ou save. save.image enregistre une copie exacte de votre session actuelle avec tous les objets présents dans votre environnement dans un fichier RData. La fonction save permet dêtre plus sélectif et de ne garder que certains objets spécifiques. Voici la syntaxe pour enregistrer toute votre session : save.image(file = &#39;chemin/vers/mon/fichier/session.RData&#39;, compress = TRUE) Vous pouvez aussi utiliser le bouton denregistrement dans longlet Environnement dans RStudio (figure 1.20). Figure 1.20: Bouton enregistrer la session Il est recommandé de compresser ces fichiers (compress = TRUE) pour minimiser leur taille. Pour nenregistrer que certains objets (ici iris et noms_cols), vous pouvez adapter cette syntaxe : save(iris, noms_cols, file = &#39;chemin/vers/mon/fichier/mes_objet.RData&#39;, compress = TRUE) Pour récupérer ces objets dans une autre session, il suffit dutiliser la fonction load : load(file = &#39;chemin/vers/mon/fichier/mes_objet.RData&#39;) ou dutiliser le bouton ouvrir de longlet Environnement dans RStudio (figure 1.21). Figure 1.21: Bouton charger un fichier RDA "],["sect018.html", "1.7 Session de travail", " 1.7 Session de travail Comme vous avez pu le constater dans les sections 1.6 et 1.4.1, il est nécessaire de connaître les chemins vers les fichiers que vous souhaitez utiliser dans votre code R. Si tous ces fichiers sont organisés dans un même dossier (ce que nous vous recommandons à la figure 1.19), il est possible de définir un répertoire de travail avec la fonction setwd. Il est recommandé deffectuer cette étape au début de votre code R, après le chargement des packages. Ainsi, vous naurez pas besoin de réécrire à chaque fois le chemin complet pour accéder à vos fichiers. # Chemin complet mes_donnes &lt;- read.csv(&quot;C:/projets/articles/2022/mon_projet/data/mes_donnes.csv&quot;) # Utilisation de setwd setwd(&quot;C:/projets/articles/2022/mon_projet&quot;) mes_donnes &lt;- read.csv(&quot;data/mes_donnes.csv&quot;) La fonction getwd permet dafficher le répertoire de travail utilisé actuellement par R. Si vous utilisez RStudio, il est possible dutiliser une petite astuce pour définir comme répertoire de travail le dossier dans lequel se trouve le fichier de code R que vous utilisez actuellement : setwd(dirname(rstudioapi::getActiveDocumentContext()$path)) Admettons que votre code R se trouve dans un sous dossier appelé CodeR de votre répertoire de travail, vous pouvez remonter dun niveau dans votre arborescence en utilisant la syntaxe suivante : setwd(paste0(dirname(rstudioapi::getActiveDocumentContext()$path), &quot;/..&quot;)) Le double point (..) indique que nous souhaitons remonter dans le dossier parent du dossier dans lequel nous se trouvons acutellement. Il existe deux solutions de rechange à lutilisation de setwd que certains jugent un peu démodé. La première est le package here permettant de spécifier plus facilement des chemins relatifs et de définir un top-level directory pour votre projet. La seconde est lutilisation de la fonctionnalité projects de RStudio. "],["sect019.html", "1.8 Conclusion et ressources pertinentes", " 1.8 Conclusion et ressources pertinentes Voilà qui conclut ce chapitre sur les bases du langage R. Vous avez maintenant les connaissances nécessaires pour commencer à travailler. Nhésitez pas à revenir sur les différentes sous-sections au besoin! Quelques ressources pertinentes qui pourraient vous être utiles sont aussi reportées au tableau 1.7. Tableau 1.7: Ressources pertinente pour en apprendre plus sur R Ressource Description Rbloggers Un recueil de nombreux blogues sur R : parfait pour être tenu au courant des nouveautés et faire des découvertes. CRAN packages by date Les derniers packages publiés sur CRAN : cela permet de garder un oeil sur les nouvelles fonctionnalités de ses packages préférés. Introduction à R et au TidyVerse Une excellente ressource en français pour en apprendre plus sur le tidyverse. Numyard Une chaîne YouTube pour revoir les bases de R en vidéo. Cheasheets Des feuilles de triche résumant les fonctionnalités de nombreux packages. "],["sect0110.html", "1.9 Quiz de révision du chapitre", " 1.9 Quiz de révision du chapitre Avec quelle fonction peut-on sélectionner son répertoire de travail? Relisez au besoin la section 1.7. get.wd set.wd setWd setwd Installer RStudio est suffisant pour pouvoir utiliser R. Relisez au besoin le début de la section 1.2. Vrai Faux Un package doit être réinstallé à chaque fois que lon souhaite lutiliser. Relisez au besoin la section 1.2.3. Vrai Faux La brique de données élémentaire dans R est : Relisez au besoin la section 1.3.6. Le vecteur Le DataFrame La liste La matrice Un vecteur peut contenir : Relisez au besoin la section 1.3.6. uniquement des valeurs numériques uniquement des valeurs textuelles uniquement des valeurs booléennes des valeurs de types différents La jointure et la concaténation de DataFrames désignent exactement la même opération. Relisez au besoin la section 1.4.2.9. Vrai Faux Comparativement à une jointure complète, une jointure interne génère un DataFrame avec : Relisez le deuxième encadré à la section 1.4.2.9.2. nécessairement moins dobservations nécessairement plus dobservations au moins autant dobservations autant ou moins dobservations le même nombre dobservation Verifier Votre score "],["chap02.html", "Chapitre 2 Statistiques descriptives univariées", " Chapitre 2 Statistiques descriptives univariées Comprendre la notion de variable et de ses différents types est essentiel en statistiques. En effet, en fonction du type de variable à létude, les méthodes de statistique exploratoire ou inférentielle sont différentes. Nous distinguons ainsi cinq types de variables : nominale, ordinale, discrète, continue et semi-quantitative. Aussi, nous abordons un concept central de la statistique : les distributions. Finalement, dans ce chapitre, nous présentons les différentes statistiques descriptives univariées qui peuvent sappliquer à ces types de variables. Dans ce chapitre, nous utilisons principalement les packages suivants : Pour créer des graphiques : ggplot2, le seul, lunique! ggpubr pour combiner des graphiques et réaliser des diagrammes quantiles-quantiles. Pour créer des distributions : fitdistrplus pour générer différentes distributions. actuar pour la fonction de densité de Pareto. gamlss.dist pour des distributions de Poisson. Pour les statistiques descriptives : stats et moments pour les statistiques descriptives. nortest pour le test de Kolmogorov-Smirnov. DescTools pour les tests de Lilliefors, Shapiro-Wilk, Anderson-Darling et Jarque-Bera. Autres packages : Hmisc et Weighted.Desc.Stat pour les statistiques descriptives pondérées. foreign pour importer des fichiers externes. "],["sect021.html", "2.1 Notion et types de variable", " 2.1 Notion et types de variable 2.1.1 Notion de variable Dun point de vue empirique, une variable est une propriété, une caractéristique dune unité statistique, dune observation. Il convient alors de bien saisir à quelle unité danalyse (ou unité dobservation) sappliquent les valeurs dune variable : des personnes, des ménages, des municipalités, des entreprises, etc. Par exemple, pour des individus, lâge, le genre ou encore le revenu sont autant de caractéristiques qui peuvent être mesurées à partir de variables. Autrement dit, une variable permet de mesurer un phénomène (dans un intervalle de valeurs, cest-à-dire de manière quantitative) ou de le qualifier (avec plusieurs catégories, cest-à-dire de manière qualitative). Dun point de vue plus théorique, une variable permet dopérationnaliser un concept en sciences sociales (Gilles et Maranda 1994, 30), soit une « idée générale et abstraite que se fait lesprit humain dun objet de pensée concret ou abstrait, et qui lui permet de rattacher à ce même objet les diverses perceptions quil en a, et den organiser les connaissances » (Larousse). En effet, la construction dun modèle théorique suppose dopérationnaliser différents concepts et détablir les relations quils partagent entre eux. Or, lopérationnalisation dun concept nécessite soit de mesurer (dans un intervalle de valeurs, cest-à-dire de manière quantitative), soit de qualifier (avec plusieurs catégories, cest-à-dire de manière qualitative) un phénomène. Maîtriser la définition des variables que vous utilisez : un enjeu crucial! Ne pas maîtriser la définition dune variable revient à ne pas bien saisir la caractéristique ou encore le concept sous-jacent quelle tente de mesurer. Si vous exploitez des données secondaires  par exemple, issues dun recensement de population ou dune enquête longitudinale ou transversale , il faut impérativement lire les définitions des variables que vous souhaitez utiliser. Ne pas le faire risque daboutir à : Une mauvaise opérationnalisation de votre modèle théorique, même si votre analyse est bien menée statistiquement parlant. Autrement dit, vous risquez de ne pas sélectionner les bonnes variables : prenons un exemple concret. Vous avez construit un modèle théorique dans lequel vous souhaitez inclure un concept sur la langue des personnes. Dans le recensement canadien de 2016, plusieurs variables relatives à la langue sont disponibles : connaissance des langues officielles, langue parlée à la maison, langue maternelle, première langue officielle parlée, connaissance des langues non officielles et langue de travail (https://www12.statcan.gc.ca/census-recensement/2016/ref/guides/003/98-500-x2016003-fra.cfm). La sélection de lune de ces variables doit être faite de manière rigoureuse, cest-à-dire en lien avec votre cadre théorique et suite à une bonne compréhension des définitions des variables. Dans une étude sur le marché du travail, nous sélectionnerions probablement la variable sur la connaissance des langues officielles du Canada, afin dévaluer son effet sur lemployabilité, toutes choses étant égales par ailleurs. Dans une autre étude portant sur la réussite ou la performance scolaire, il est probable que nous utiliserions la langue maternelle. Une mauvaise interprétation et discussion de vos résultats en lien avec votre cadre théorique. Une mauvaise identification des pistes de recherche. Finalement, la définition dune variable peut évoluer à travers plusieurs recensements de population : la société évolue, les variables aussi! Par conséquent, si vous comptez utiliser plusieurs années de recensement dans une même étude, assurez-vous que les définitions des variables sont similaires dun jeu de données à lautre et quelles mesurent ainsi la même chose. Comprendre les variables utilisées dans un article scientifique : un exercice indispensable dans lélaboration dune revue de littérature Une lecture rigoureuse dun article scientifique suppose, entre autres, de bien comprendre les concepts et les variables mobilisés. Il convient alors de lire attentivement la section méthodologique (pas uniquement la section des résultats ou pire, celle du résumé), sans quoi vous risquez daboutir à une revue de littérature approximative. Ayez aussi un regard critique sur les variables utilisées en lien avec le cadre théorique. Certains concepts sont très difficiles à traduire en variables; leurs opérationnalisations (mesures) peuvent ainsi faire lobjet de vifs débats au sein de la communauté scientifique. Très succinctement, cest notamment le cas du concept de capital social. Dune part, les définitions et ancrages sont bien différents selon Bourdieu (sociologue, ancrage au niveau des individus) et Putman (politologue, ancrage au niveau des collectivités); dautre part, aucun consensus ne semble clairement se dégager quant à la définition de variables permettant de mesurer le capital social efficacement (de manière quantitative). Variable de substitution (proxy variable en anglais) Nous faisons la moins pire des recherches! En effet, les données disponibles sont parfois imparfaites pour répondre avec précision à une question de recherche; nous pouvons toujours les exploiter, tout en signalant honnêtement leurs faiblesses et limites, et ce, tant pour les données que pour les variables utilisées. Des bases de données peuvent être en effet imparfaites. Par exemple, en criminologie, lorsquune étude est basée sur lexploitation de données policières, la limite du chiffre noir est souvent signalée : les données policières comprennent uniquement les crimes et délits découverts par la police et occultent ainsi les crimes non découverts; ils ne peuvent ainsi refléter la criminalité réelle sur un territoire donné. Des variables peuvent aussi être imparfaites. Dans un jeu de données, il est fréquent quune variable ne soit pas disponible ou quelle nait tout simplement pas été mesurée. Nous cherchons alors une variable de substitution (proxy) pour la remplacer. Prenons un exemple concret portant sur lexposition des cyclistes à la pollution atmosphérique ou au bruit environnemental. Lun des principaux facteurs dexposition à ces pollutions est le trafic routier : plus ce dernier est élevé, plus les cyclistes risquent de rouler dans un environnement bruyant et pollué. Toutefois, il est rare de disposer de mesures du trafic en temps réel qui nécessitent des comptages de véhicules pendant le trajet des cyclistes (par exemple, à partir de vidéos captées par une caméra fixée sur le guidon). Pour pallier labsence de mesures directes, plusieurs auteur(e)s utilisent des variables de substitution de la densité du trafic, comme la typologie des types daxes (primaire, secondaire, tertiaire, rue locale, etc.), supposant ainsi quun axe primaire supporte un volume de véhicules supérieur à un axe secondaire. 2.1.2 Types de variables Nous distinguons habituellement les variables qualitatives (nominale ou ordinale) des variables quantitatives (discrète ou continue). Tel quillustré à la figure 2.1, plusieurs mécanismes différents visent à qualifier, à classer, à compter ou à mesurer afin de caractériser les unités statistiques (observations) dune population ou dun échantillon. Figure 2.1: Types de variables 2.1.2.1 Variables qualitatives Une variable nominale permet de qualifier des observations (individus) à partir de plusieurs catégories dénommées modalités. Par exemple, la variable couleur des yeux pourrait comprendre les modalités bleu, marron, vert, noir tandis que le type de famille compendrait les modalités couple marié, couple en union libre et famille monoparentale. Une variable ordinale permet de classer des observations à partir de plusieurs modalités hiérarchisées. Lexemple le plus connu est certainement léchelle de Likert, très utilisée dans les sondages évaluant le degré daccord dune personne à une affirmation avec les modalités suivantes : tout à fait daccord, daccord, ni en désaccord ni daccord, pas daccord et pas du tout daccord. Une multitude de variantes sont toutefois possibles pour classer la fréquence dun phénomène (très souvent, souvent, parfois, rarement, jamais), limportance accordée à un phénomène (pas du tout important, peu important, plus ou moins important, important, très important) ou la proximité perçue dun lieu (très éloigné, loin, plus ou moins proche, proche, très proche). En fonction du nombre de modalités quelle comprend, une variable qualitative (nominale ou ordinale) est soit dichtomique (binaire) (deux modalités), soit polytomique (plus de deux modalités). Par exemple, dans le recensement canadien, le sexe est une variable binaire (avec les modalités sexe masculin, sexe féminin), tandis que le genre est une variable polytomique (avec les modalités genre masculin, genre féminin et diverses identités de genre). Les variables nominales et ordinales sont habituellement encodées avec des valeurs numériques entières (par exemple, 1 pour couple marié, 2 pour couple en union libre et 3 pour famille monoparentale). Toutefois, aucune opération arithmétique (moyenne ou écart-type par exemple) nest possible sur ces valeurs. Dans R, nous utilisons un facteur pour attribuer un intitulé à chacune des valeurs numériques de la variable qualitative : df$Famille &lt;- factor(df$Famille, c(1,2,3), labels = c(\"couple marié\",\"couple en union libre\", \"famille monoparentale\")) Nous calculons toutefois les fréquences des différentes modalités pour une variable nominale ou ordinale. Il est aussi possible de calculer la médiane sur une variable ordinale. 2.1.2.2 Variables quantitatives Une variable discrète permet de compter un phénomène dans un ensemble fini de valeurs, comme le nombre daccidents impliquant un ou une cycliste à une intersection sur une période de cinq ans ou encore le nombre de vélos en libre service disponibles à une station. Il existe ainsi une variable binaire sous-jacente : la présence ou non dun accident à lintersection ou la disponibilité dun vélo ou non à la station pour laquelle nous opérons un comptage. Habituellement, une variable discrète ne peut prendre que des valeurs entières (sans décimale), comme le nombre de personnes fréquentant un parc. Une variable continue permet de mesurer un phénomène avec un nombre infini de valeurs réelles (avec décimales) dans un intervalle donné. Par exemple, une variable relative à la distance de dépassement dun ou dune cycliste par un véhicule motorisé pourrait varier de 0 à 5 mètres (\\(X \\in \\left[0,5\\right]\\)); toutefois, cette distance peut être de 0,759421 ou de 4,785612 mètres. Le nombre de décimales de la valeur réelle dépend de la précision et de la fiabilité de la mesure. Pour un capteur de distance de dépassement, le nombre de décimales dépend de la précision du lidar ou du sonar de lappareil; aussi, lutilisation de trois décimales  soit une précision au millimètre  est largement suffisante pour mesurer la distance de dépassement. De plus, une variable continue est soit une variable dintervalle, soit une variable de rapport. Les variables dintervalle ont une échelle relative, cest-à-dire que les intervalles entre les valeurs de la variable ne sont pas constants; elles nont pas de vrai zéro. Autrement dit, ce type de variable a une échelle relative avec un zéro arbitraire. Ces valeurs peuvent être manipulées uniquement par addition et soustraction et non par multiplication et division. La variable dintervalle la plus connue est certainement celle de la température. Sil fait 10 degrés Celsius à Montréal et 30 °C à Mumbai (soit 50 et 86 degrés en Fahrenheit), nous pouvons affirmer quil y a 20 °C ou 36 °F décart entre les deux villes, mais ne pouvons pas affirmer quil fait trois fois plus chaud à Mumbai. Presque toutes les mesures statistiques sur une variable dintervalle peuvent être calculées, exceptés le coefficient de variation et la moyenne géométrique puisquil ny a pas de vrai zéro ni dintervalles constants entre les valeurs. À linverse, les variables de rapport ont une échelle absolue, cest-à-dire que les intervalles entre les valeurs sont constants et elles ont un vrai zéro. Elles peuvent ainsi être manipulées par addition, soustraction, multiplication et division. Par exemple, le prix dun produit exprimé dans une unité monétaire ou la distance exprimée dans le système métrique sont des variables de rapport. Un vélo dont le prix affiché est de 1000 $ est bien deux fois plus cher quun autre à 500 $, une piste cyclable hors rue à 25 mètres du tronçon routier le plus proche est bien quatre fois plus proche quune autre à 100 mètres. Une variable semi-quantitative, appelée aussi variable quantitative ordonnée, est une variable discrète ou continue dont les valeurs ont été regroupées en classes hiérarchisées. Par exemple, lâge est une variable continue pouvant être transformée avec les groupes dâge ordonnés suivants : moins 25 ans, 25 à 44 ans, 45 à 64 ans et 65 ans et plus. References "],["sect022.html", "2.2 Types de données", " 2.2 Types de données Différents types de données sont utilisés en sciences sociales. Lobjectif ici nest pas de les décrire en détail, mais plutôt de donner quelques courtes définitions. En fonction de votre question de recherche et des bases des données disponibles, il sagit de sélectionner le ou les types de données les plus appropriés à votre étude. 2.2.1 Données secondaires versus données primaires Les données secondaires sont des données qui existent déjà au début de votre projet de recherche : nul besoin de les collecter, il suffit de les exploiter! Une multitude de données de recensements ou denquêtes de Statistique Canada sont disponibles et largement exploitées en sciences sociales (par exemple, lenquête nationale auprès des ménages  ENM, lenquête sur la dynamique du marché du travail et du revenu  EDTR, lenquête longitudinale auprès des immigrants  ELIC, etc.). Au Canada, les personnes qui font de la recherche, qui étudient ou qui enseignent ont accès aux microdonnées des enquêtes de Statistique Canada dans les centres de données de recherche (CDR). Vous pouvez consulter le moteur de recherche du Réseau canadien des Centres de données de recherche (https://crdcn.org/fr/donn%C3%A9es) afin dexplorer les différentes enquêtes disponibles. Au Québec, laccès à ces enquêtes est possible dans les différentes antennes du Centre interuniversitaire québécois de statistiques sociales de Statistique Canada (https://www.ciqss.org/). Par opposition, les données primaires nexistent pas quand vous démarrez votre projet : vous devez les collecter spécifiquement pour votre étude! Par exemple, une chercheure souhaitant analyser lexposition des cyclistes au bruit et à la pollution dans une ville donnée doit réaliser une collecte de données avec idéalement plusieurs personnes participantes (équipées de différents capteurs), et ce, sur plusieurs jours. Une collecte de données primaires peut aussi être réalisée avec une enquête par sondage. Brièvement, réaliser une collecte de données primaires nécessite différentes phases complexes comme la définition de la méthode de collecte et de la population à létude, lestimation de la taille de léchantillon, la validation des outils de collecte avec une phase de test, la réalisation de la collecte, la structuration, la gestion et lexploitation de données collectées. Finalement, dans le milieu académique, une collecte de données primaires auprès dindividus doit être approuvée par le comité déthique de la recherche de luniversité à laquelle est affiliée la personne responsable du projet de recherche. 2.2.2 Données transversales versus données longitudinales Les données transversales sont des mesures pour une période relativement courte. Lexemple classique est un jeu de données constitué des variables extraites dun recensement de population pour une année donnée (comme celui de 2016 de Statistique Canada). Les données longitudinales, appelées aussi données par panel, sont des mesures répétées pour plusieurs observations au cours du temps (N observations pour T dates). Par exemple, des observations pourraient être des pays, les dates pourraient être différentes années (de 1990 à 2019) pour lesquelles différentes variables seraient disponibles (population totale, taux durbanisation, produit intérieur brut par habitant, émissions de gaz à effet de serre par habitant, etc.). 2.2.3 Données spatiales versus données aspatiales Les observations des données spatiales sont des unités spatiales géoréférencées. Elles peuvent être par exemple : des points (x,y) ou (lat-long) représentant des entreprises avec plusieurs variables (adresse, date de création, nombre demployés, secteurs dactivité, etc.); les lignes représentant des tronçons de rues pour lesquels plusieurs variables sont disponibles (type de rue, longueur en mètres, nombre de voies, débit journalier moyen annuel, etc.); des polygones délimitant des régions ou des arrondissements pour lesquels une multitude de variables sociodémographiques et socioéconomiques sont disponibles; les pixels des bandes spectrales dune image satellite. À linverse, aucune information spatiale nest disponible pour des données aspatiales. 2.2.4 Données individuelles versus données agrégées Comme son nom lindique, pour des données individuelles, chaque observation correspond à un individu. Les microdonnées de recensements ou denquêtes, par exemple, sont des données individuelles pour lesquelles toute une série de variables sont disponibles. Une étude analysant les caractéristiques de chaque arbre dun quartier nécessite aussi des données individuelles : linformation doit être disponible pour chaque arbre. Pour les microdonnées des recensements canadiens, « chaque enregistrement au niveau de la personne comprend des identifiants (comme les identifiants du ménage et de la famille), des variables géographiques et des variables directes et dérivées tirées du questionnaire » (Statistique Canada). Comme signalé plus haut, ces microdonnées de recensements ou denquêtes sont uniquement accessibles dans les centres de données de recherche (CDR). Les données individuelles peuvent être agrégées à un niveau supérieur. Prenons le cas de microdonnées dun recensement. Les informations disponibles pour chaque individu sont agrégées par territoire géographique (province, région économique, division de recensement, subdivision de recensement, région et agglomération de recensement, secteurs de recensement, aires de diffusion, etc.) en fonction du lieu de résidence des individus. Des sommaires statistiques  basés sur la moyenne, la médiane, la somme ou la proportion de chacune des variables mesurées au niveau individuel (âge, sexe, situation familiale, revenu, etc.)  sont alors construits pour ces différents découpages géographiques (Statistique Canada). Lagrégation nest pas nécessairement géographique. En éducation, il est fréquent de travailler avec des données concernant les élèves, mais agrégées au niveau des écoles. La figure 2.2 donne un exemple simple dagrégation de données individuelles. Figure 2.2: Exemple dagrégation de données individuelles Erreur écologique et erreur atomiste: attention aux interprétations abusives. Il convient dêtre prudent dans lanalyse des données agrégées. Très fréquente en géographie, lerreur écologique (ecological fallacy en anglais) est une mauvaise interprétation des résultats. Elle consiste à attribuer des constats obtenus à partir de données agrégées pour un territoire aux individus qui forment la population de ce territoire. À linverse, attribuer des résultats à partir de données individuelles à des territoires est une erreur atomiste. Prenons un exemple concret tiré dune étude récente sur la localisation des écoles primaires et le bruit aérien dans la région métropolitaine de Toronto (Audrin, Apparicio et Séguin 2021). Un des objectifs de cette étude est de vérifier si les écoles primaires (ns = 1420) avec des niveaux de bruit aérien élevés présentent des niveaux de réussite scolaire plus faibles. Les résultats de leur étude démontrent que les enfants scolarisés dans les écoles primaires exposées à des niveaux élevés de bruit aérien sont issus de milieux plus défavorisés et ont plus souvent une langue maternelle autre que la langue denseignement. Aussi, les écoles avec des niveaux de bruit aérien élevés présentent des niveaux de réussite scolaire plus faibles. Toutefois, étant donné que les variables sur la réussite scolaire sont mesurées au niveau de lécole (soit les pourcentages délèves ayant atteint ou dépassé la norme provinciale en lecture, en écriture et en mathématique, respectivement pour la 3e année et la 6e année) et non au niveau individuel, nous ne pouvons pas conclure que le bruit aérien à un impact significatif sur la réussite scolaire des élèves : « Nous avons pu démontrer que les écoles primaires localisées dans la zone NEF 25 présentent des taux de réussite plus faibles. Rappelons toutefois quune association obtenue avec des données agrégées ne peut pas nous permettre de conclure à une influence directe au niveau individuel, car lagrégation des données entraîne une perte dinformation. Cette erreur dinterprétation dite erreur écologique (ecological fallacy) tend à laisser penser que les associations entre les groupes sappliquent à chaque individu (Robinson, 1950). Nos résultats gagneraient à être corroborés à partir danalyses reposant sur des données individuelles ». Pour le cas de lagrégation géographique, il convient alors de bien comprendre la hiérarchie des régions géographiques délimitées par lorganisme ou lagence ayant la responsabilité de produire, de gérer et de diffuser les données des recensements et des enquêtes, puis de sélectionner le découpage géographique qui répond le mieux à votre question de recherche. Pour le recensement de 2016 de Statistique Canada vous pouvez consulter : la hiérarchie des régions géographiques normalisées pour la diffusion (https://www12.statcan.gc.ca/census-recensement/2016/ref/dict/figures/f1_1-fra.cfm) le glossaire illustré (https://www150.statcan.gc.ca/n1/pub/92-195-x/92-195-x2016001-fra.htm) des régions géographiques les différents profils du recensement de 2016 à télécharger pour les différentes régions géographiques (https://www12.statcan.gc.ca/census-recensement/2016/dp-pd/prof/details/download-telecharger/comp/page_dl-tc.cfm?Lang=F). Bien entendu, les différents types de données abordés ci-dessus ne sont pas exclusifs. Par exemple, des données pour des régions administratives extraites de plusieurs recensements sont en fait des données secondaires, spatiales, agrégées et longitudinales. Une collecte de données sur la pollution atmosphérique et sonore réalisée à vélo (avec différents capteurs et un GPS) sont des données spatiales primaires. References "],["sect023.html", "2.3 Statistique descriptive et statistique inférentielle", " 2.3 Statistique descriptive et statistique inférentielle 2.3.1 Population, échantillon et inférence Les notions de population et déchantillon sont essentielles en statistique puisquelles sont le socle de linférence statistique. Un échantillon est un sous-ensemble représentatif dune population donnée. Prenons un exemple concret : une chercheure veut comprendre la mobilité des personnes étudiant dans une université. Bien entendu, elle ne peut interroger toutes les personnes étudiantes de son université. Elle devra donc sassurer dobtenir un échantillon de taille suffisante et représentatif de la population étudiante. Une fois les données collectées (avec un sondage par exemple), elle pourra utiliser des techniques inférentielles pour analyser la mobilité des personnes interrogées. Si son échantillon est représentatif, les résultats obtenus pourront être inférés  cest-à-dire généralisés, extrapolés  à lensemble de la population. Les méthodes déchantillonnage Nous nabordons pas ici les méthodes déchantillonnage. Sachez toutefois quil existe plusieurs méthodes probabilistes pour constituer un échantillon, notamment de manière aléatoire, systématique, stratifiée, par grappes. Consultez par exemple cette publication de Statistique Canada (https://www150.statcan.gc.ca/n1/edu/power-pouvoir/ch13/prob/5214899-fra.htm). Autre exemple, une autre chercheure souhaite comprendre les facteurs influençant le sentiment de sécurité des cyclistes dans un quartier. De nouveau, elle ne peut pas enquêter sur lensemble des cyclistes du quartier et devra constituer un échantillon représentatif. Par la suite, la mise en uvre de techniques inférentielles lui permettra didentifier les caractéristiques individuelles (âge, sexe, habiletés à vélo, etc.) et de lenvironnement urbain (types de voies empruntés, niveaux de trafic, de pollution, de bruit, etc.) ayant des effets significatifs sur le sentiment de sécurité. Si léchantillon est représentatif, les résultats pourront être généralisés à lensemble des cyclistes du quartier. 2.3.2 Deux grandes familles de méthodes statistiques Nous distinguons habituellement deux grandes familles de méthodes statistiques : la statistique descriptive et exploratoire et la statistiques inférentielle et confirmatoire. Il existe de nombreuses définitions de ces deux branches de la statistique, celles proposées de Lebart et al. (1995) étant parmi les plus abouties : « La statistique descriptive et exploratoire : elle permet, par des résumés et des graphiques plus ou moins élaborés, de décrire des ensembles de données statistiques, détablir des relations entre les variables sans faire jouer de rôle privilégié à une variable particulière. Les conclusions ne portent dans cette phase de travail que sur les données étudiées, sans être inférées à une population plus large. Lanalyse exploratoire sappuie essentiellement sur des notions élémentaires telles que des indicateurs de moyenne et de dispersion, sur des représentations graphiques. [] La statistique inférentielle et confirmatoire : elle permet de valider ou dinfirmer, à partir de tests statistiques ou de modèles probabilistes, des hypothèses formulées a priori (ou après une phase exploratoire), et dextrapoler, cest-à-dire détendre certaines propriétés dun échantillon à une population plus large. Les conclusions obtenues à partir des données vont au-delà de ces données. La statistique confirmatoire fait surtout appel aux méthodes dites explicatives et prévisionnelles, destinées, comme leurs noms lindiquent, à expliquer puis à prévoir, suivant des règles de décision, une variable privilégiée à laide dune ou plusieurs variables explicatives (régressions multiples et logistiques, analyse de variance, analyse discriminante, segmentation, etc.) » (Lebart, Morineau et Piron 1995, 209). References "],["sect024.html", "2.4 Notion de distribution", " 2.4 Notion de distribution Dans cette section, nous abordons un concept central de la statistique : les distributions. Prenez le temps de lire cette section à tête reposée et assurez-vous de bien comprendre chaque idée avant de passer à la suivante. Nhésitez pas à y revenir plusieurs fois si nécessaire, car la compréhension de ces concepts est essentielle pour utiliser adéquatement les méthodes que nous abordons dans ce livre. 2.4.1 Définition générale En probabilité, nous nous intéressons aux résultats dexpériences. Du point de vue de la théorie des probabilités, lancer un dé, mesurer la pollution atmosphérique, compter le nombre de collisions à une intersection, et demander à une personne dévaluer son sentiment de sécurité sur une échelle de 1 à 10 sont autant dexpériences pouvant produire des résultats. Une distribution est un modèle mathématique permettant dassocier pour chaque résultat possible dune expérience la probabilité dobtenir ce résultat. Dun point de vue pratique, si nous disposons de la distribution régissant lexpérience : « mesurer la concentration dozone à Montréal à 13 h en été », nous pouvons calculer la probabilité de mesurer une valeur inférieure à 15 g/m3. Loi de probabilité et distribution Lutilisation que nous faisons ici du terme « distribution » est un anglicisme (éhonté diront certaines personnes). En effet, en français, la définition précédente est plus proche du terme « loi de probabilité ». Cependant, la quasi-totalité de la documentation sur R est en anglais et, dans la pratique, ces deux termes ont tendance à se confondre. Nous avons donc fait le choix de poursuivre avec ce terme dans le reste du livre. Une distribution est toujours définie dans un intervalle en dehors duquel elle nest définie; les valeurs dans cet intervalle sont appelées lespace déchantillonnage. Il sagit donc des valeurs possibles que peut produire lexpérience. La somme des probabilités de lensemble des valeurs de lespace déchantillonnage est 1 (100 %). Intuitivement, cela signifie que si nous réalisons lexpérience, nous obtenons nécessairement un résultat, et que la somme des probabilités est répartie entre tous les résultats possibles de lexpérience. En langage mathématique, nous disons que lintégrale de la fonction de densité dune distribution est 1 dans son intervalle de définition. Prenons un exemple concret avec lexpérience suivante : tirer à pile ou face avec une pièce de monnaie non truquée. Si lon souhaite décrire la probabilité dobtenir pile ou face, nous pouvons utiliser une distribution qui aura comme espace déchantillonnage [pile; face] et ces deux valeurs auront chacune comme probabilité 0,5. Il est facile détendre cet exemple au cas dun dé à six faces. La distribution de probabilité décrivant lexpérience « lancer le dé » a pour espace déchantillonnage [1,2,3,4,5,6], chacune de ces valeurs étant associée à la probabilité de 1/6. Chacune des deux expériences précédentes est régie par une distribution appartenant à la famille des distributions discrètes. Elles servent à représenter des expériences dont le nombre de valeurs possibles est fini. Par opposition, la seconde famille de distributions regroupe les distributions continues, décrivant des expériences dont le nombre de résultats possibles est en principe infini. Par exemple, mesurer la taille dune personne adulte sélectionnée au hasard peut produire en principe un nombre infini de valeurs. Les distributions sont utiles pour décrire les résultats potentiels dune expérience. Reprenons notre exemple du dé. Nous savons que chaque face a une chance sur six dêtre tirée au hasard. Nous pouvons représenter cette distribution avec un graphique (figure 2.3). Figure 2.3: Distribution théorique dun lancer de dé Nous avons donc sous les yeux un modèle statistique décrivant le comportement attendu dun dé, soit sa distribution théorique. Cependant, si nous effectuons dix fois lexpérience (nous collectons donc un échantillon), nous obtiendrons une distribution différente de cette distribution théorique (figure 2.4). Figure 2.4: Distribution empirique dun lancer de dé (n=10) Il sagit de la distribution empirique. Chaque échantillon aura sa propre distribution empirique. Cependant, comme le prédit la loi des grands nombres : si une expérience est répétée un grand nombre de fois, la probabilité empirique dun résultat se rapproche de la probabilité théorique à mesure que le nombre de répétitions augmente. Du point de vue de la théorie des probabilités, chaque échantillon correspond à un ensemble de tirages aléatoires effectués à partir de la distribution théorique du phénomène étudié. Pour nous en convaincre, collectons trois échantillons de lancer de dé de respectivement 30, 100 et 1000 observations (figure 2.5). Comme le montre la figure 2.4, nous connaissons la distribution théorique qui régit cette expérience. Figure 2.5: Distribution empirique dun lancer de dé Nous constatons bien quau fur et à mesure que la taille de léchantillon augmente, nous tendons vers la distribution théorique. Cette relation a été étudiée pour la première fois au XVIIIe siècle par le mathématicien Daniel Bernoulli, qui a montré que la probabilité que la moyenne dune distribution empirique soit éloignée de la moyenne de la distribution théorique dont elle est tirée diminuait lorsque nous augmentons le nombre des tirages et donc la taille de léchantillon. Un autre mathématicien, Siméon-Denis Poisson, a fait connaître cette relation sous le nom de « loi des grands nombres ». Les distributions théoriques sont utilisées pour modéliser des phénomènes réels et sont à la base de presque tous les tests statistiques dinférence fréquentiste ou bayésienne. En pratique, la question que nous nous posons le plus souvent est : quelle distribution théorique peut le mieux décrire le phénomène empirique à létude? Pour répondre à cette question, deux approches sont possibles : Considérant la littérature existante sur le sujet, les connaissances accumulées et la nature de la variable étudiée, sélectionner des distributions théoriques pouvant vraisemblablement correspondre au phénomène mesuré. Comparer visuellement ou à laide de tests statistiques la distribution empirique de la variable et diverses distributions théoriques pour trouver la plus adaptée. Idéalement, le choix dune distribution théorique devrait reposer sur ces deux méthodes combinées. 2.4.2 Anatomie dune distribution Une distribution (ou loi de probabilité) est une fonction. Il est possible de la représenter à laide dune formule mathématique (appelée fonction de masse pour les distributions discrètes et fonction de densité pour les distributions continues) associant chaque résultat possible de lexpérience régie par la distribution à la probabilité dobserver ce résultat. Prenons un premier exemple concret avec la distribution théorique associée au lancer de pièce de monnaie : la distribution de Bernoulli. Sa formule est la suivante : \\[\\begin{equation} f(x ; p)=\\left\\{\\begin{array}{ll} q=1-p &amp; \\text { si } x=0 \\\\ p &amp; \\text { si } x=1 \\end{array}\\right. \\tag{2.1} \\end{equation}\\] avec p la probabilité dobtenir \\(x = 1\\) (pile), et \\(1  p\\) la probabilité davoir \\(x = 0\\) (face). La distribution de Bernoulli ne dépend que dun paramètre : p. Avec différentes valeurs de p, nous pouvons obtenir différentes formes pour la distribution de Bernoulli. Si p = 1/2, la distribution de Bernoulli décrit parfaitement lexpérience : obtenir pile à un lancer de pièce de monnaie. Si p = 1/6, elle décrit alors lexpérience : obtenir 4 (tout comme nimporte quelle valeur de 1 à 6) à un lancer de dé. Pour un exemple plus appliqué, la distribution de Bernoulli est utilisée en analyse spatiale pour étudier la concentration daccidents de la route ou de crimes en milieu urbain. À chaque endroit du territoire, il est possible de calculer la probabilité quun tel évènement ait lieu ou non en modélisant les données observées au moyen de la loi de Bernoulli. La distribution continue la plus simple à décrire est certainement la distribution uniforme. Il sagit dune distribution un peu spéciale puisquelle attribue la même probabilité à toutes ses valeurs dans son espace déchantillonnage. Elle est définie sur lintervalle \\([-\\infty; +\\infty]\\) et a la fonction de densité suivante : \\[\\begin{equation} f(x ; \\mathrm{a} ; \\mathrm{b})=\\left\\{\\begin{array}{cc} \\frac{1}{a-b} &amp; \\text { si } a \\geq x \\geq b \\\\ 0 &amp; \\text { sinon } \\end{array}\\right. \\tag{2.2} \\end{equation}\\] La fonction de densité de la distribution uniforme a donc deux paramètres, a et b, représentant respectivement les valeurs maximale et minimale au-delà desquelles les valeurs ont une probabilité 0 dêtre obtenues. Pour avoir une meilleure intuition de ce que décrit une fonction de densité, il est intéressant de la représenter avec un graphique (figure 2.6). Notez que sur ce graphique, laxe des ordonnées nindique pas précisément la probabilité associée à chaque valeur, car celle-ci est infinitésimale. Il sert uniquement à représenter la valeur de la fonction de densité de la distribution pour chaque valeur de x. Figure 2.6: Distributions uniformes continues Nous observons clairement que toutes les valeurs de x entre a et b ont la même probabilité pour chacune de trois distributions uniformes présentées dans le graphique. Plus létendue est grande (\\(a-b\\)), plus lespace déchantillonnage est grand et plus la probabilité totale est répartie dans cet espace. Cette distribution est donc idéale pour décrire un phénomène pour lequel chaque valeur a autant de chance de se produire quune autre. Prenons pour exemple un cas fictif avec un jeu de hasard qui vous proposerait la situation suivante : en tirant sur la manette dune machine à sous, un nombre est tiré aléatoirement entre -60 et +50. Si le nombre est négatif, vous perdez de largent et inversement si le nombre est positif. Nous pouvons représenter cette situation avec une distribution uniforme continue et lutiliser pour calculer quelques informations essentielles : Selon cette distribution, quelle est la probabilité de gagner de largent lors dun tirage (x &gt; 0)? Quelle est la probabilité de perdre de largent (x &lt; 0)? Si je perds moins de 30 $ au premier tirage, quelle est la probabilité que jai de récupérer au moins ma mise au second tirage (x &gt; 30)? Il est assez facile de calculer ces probabilités en utilisant la fonction punif dans R. Concrètement, cela permet de calculer lintégrale de la fonction de masse sur un intervalle donné. # Probabilité d&#39;obtenir une valeur supérieure ou égale à 0 punif(0,min = -60, max = 50) ## [1] 0.5454545 # Probabilité d&#39;obtenir une valeur inférieure à 0 punif(0,min = -60, max = 50, lower.tail = F) ## [1] 0.4545455 # Probabilité d&#39;obtenir une valeur supérieure à 30 punif(30, min = -60, max = 50,lower.tail = F) ## [1] 0.1818182 Les paramètres permettent donc dajuster la fonction de masse ou de densité dune distribution afin de lui permettre de prendre des formes différentes. Certains paramètres changent la localisation de la distribution (la déplacer vers la droite ou la gauche de laxe des X), dautres changent son degré de dispersion (distribution pointue ou aplatie) ou encore sa forme (symétrie). Les différents paramètres dune distribution correspondent donc à sa carte didentité et donnent une idée précise sur sa nature. Fonction de répartition, de survie et dintensité Si les fonctions de densité ou de masse dune distribution sont le plus souvent utilisée pour décrire une distribution, dautres types de fonctions peuvent également être employées et disposent de propriétés intéressantes. La fonction de répartition : il sagit dune fonction décrivant le cumul de probabilités dune distribution. Cette fonction a un minimum de zéro qui est obtenu pour la plus petite valeur de lespace déchantillonnage de la distribution, et un maximum dun pour la plus grande valeur de ce même espace. Formellement, la fonction de répartition (\\(F\\)) est lintégrale de la fonction de densité (\\(f\\)). \\[F(x) = \\int_{-\\infty}^{x}f(u)du\\] 2. La fonction de survie : soit linverse additif de la fonction de répartition (\\(R\\)) \\[R(x) = 1-F(x)\\] 3. La fonction de dintensité, soit le quotient de la fonction de densité et de la fonction de survie (\\(D\\)). \\[D(x) = \\frac{f(x)}{D(x)}\\] Ces fonctions jouent notamment un rôle central dans la modélisation des phénomènes qui régissent la survenue des événements, par exemple la mort, les accidents de la route ou les bris déquipement. 2.4.3 Principales distributions Il existe un très grand nombre de distributions théoriques et parmi elles, de nombreuses sont en fait des cas spéciaux dautres distributions. Pour un petit aperçu du « bestiaire », vous pouvez faire un saut à la page Univariate Distribution Relationships, qui liste près de 80 distributions. Nous nous concentrons ici sur une sélection de dix-huit distributions très répandues en sciences sociales. La figure 2.7 présente graphiquement leurs fonctions de masse et de densité présentées dans cette section. Notez que ces graphiques correspondent tous à une forme possible de chaque distribution. En modifiant leurs paramètres, il est possible de produire une figure très différente. Les distributions discrètes sont représentées avec des graphiques en barre, et les distributions continues avec des graphiques de densité. Figure 2.7: Dix-huit distributions essentielles, figure inspirée de Sean (2018) 2.4.3.1 Distribution uniforme discrète Nous avons déjà abordé cette distribution dans les exemples précédents. Elle permet de décrire un phénomène dont tous les résultats possibles ont exactement la même probabilité de se produire. Lexemple classique est bien sûr un lancer de dé. 2.4.3.2 Distribution de Bernoulli La distribution de Bernoulli permet de décrire une expérience pour laquelle deux résultats sont possibles. Son espace déchantillonnage est donc \\([0; 1]\\). Sa fonction de masse est la suivante : \\[\\begin{equation} f(x ; p)=\\left\\{\\begin{array}{ll} q=1-p &amp; \\text { si } x=0 \\\\ p &amp; \\text { si } x=1 \\end{array}\\right. \\tag{2.3} \\end{equation}\\] avec p la probabilité dobtenir \\(x = 1\\) (réussite) et donc \\(1  p\\) la probabilité davoir \\(x = 0\\) (échec). La distribution de Bernoulli ne dépend que dun paramètre : p, contrôlant la probabilité de réussite de lexpérience. Notez que si \\(p = 1/2\\), alors la distribution de Bernoulli est également une distribution uniforme. Un exemple dapplication de la distribution de Bernoulli en études urbaines est la modélisation de la survie dun ou dune cycliste (1 pour survie, 0 pour décès) lors dune collision avec un véhicule motorisé, selon une vitesse donnée. 2.4.3.3 Distribution binomiale La distribution binomiale est utilisée pour caractériser la somme de variables aléatoires (expériences) suivant chacune une distribution de Bernoulli. Un exemple simple est laccumulation des lancers dune pièce de monnaie. Si nous comptons le nombre de fois où nous obtenons pile, cette expérience est décrite par une distribution binomiale. Son espace déchantillonnage est donc \\([0; +\\infty[\\) (limité aux nombres entiers). Sa fonction de masse est la suivante : \\[\\begin{equation} f(x ; n )=\\binom{n}{x}p^x(1-p)^{n-x} \\tag{2.4} \\end{equation}\\] avec x le nombre de tirages réussis sur n essais avec une probabilité p de réussite à chaque tirage (figure 2.8). Pour reprendre lexemple précédent concernant les accidents de la route, une distribution binomiale permettrait de représenter la distribution du nombre de cyclistes ayant survécu sur dix personnes à vélo impliquées dans un accident avec une voiture à une intersection. Figure 2.8: Distribution binomiale 2.4.3.4 Distribution géométrique La distribution géométrique permet de représenter le nombre de tirages quil faut faire avec une distribution de Bernoulli avant dobtenir une réussite. Par exemple, avec un lancer de dé, lidée serait de compter le nombre de lancers nécessaires avant de tomber sur un 6. Son espace déchantillonnage est donc \\([1; +\\infty[\\) (limité aux nombres entiers). Sa distribution de masse est la suivante : \\[\\begin{equation} f(x; p)= (1-p)^xp \\tag{2.5} \\end{equation}\\] avec x le nombre de tentatives avant dobtenir une réussite, \\(f(x)\\) la probabilité que le premier succès narrive quaprès x tentatives et p la probabilité de réussite à chaque tentative (figure 2.9). Cette distribution est notamment utilisée en marketing pour modéliser le nombre dappels nécessaires avant de réussir une vente. Figure 2.9: Distribution géométrique 2.4.3.5 Distribution binomiale négative La distribution binomiale négative est proche de la distribution géométrique. Elle permet de représenter le nombre de tentatives nécessaires afin dobtenir un nombre n de réussites \\([1; +\\infty[\\) (limité aux nombres entiers positifs). Sa formule est la suivante : \\[\\begin{equation} f(x; n; p)=\\left(\\begin{array}{c} x+n-1 \\\\ n \\end{array}\\right) p^{n}(1-p)^{x} \\tag{2.6} \\end{equation}\\] avec x le nombre de tentatives avant dobtenir n réussites et p la probabilité dobtenir une réussite à chaque tentative (figure 2.10). Cette distribution pourrait être utilisée pour modéliser le nombre de questionnaires x à envoyer pour une enquête pour obtenir au moins n réponses, sachant que la probabilité dune réponse est p. Figure 2.10: Distribution binomiale négative 2.4.3.6 Distribution de Poisson La distribution de Poisson est utilisée pour modéliser des comptages. Son espace déchantillonnage est donc \\([0; +\\infty[\\) (limité aux nombres entiers positifs). Par exemple, il est possible de compter à une intersection le nombre de collisions entre des automobilistes et des cyclistes sur une période donnée. Cet exemple devrait vous faire penser à la distribution binomiale vue plus haut. En effet, il est possible de noter chaque rencontre entre une voiture et un ou une cycliste et de considérer que leur collision est une « réussite » (0 : pas daccidents, 1 : accident). Cependant, ce type de données est fastidieux à collecter comparativement au simple comptage des accidents. La distribution de Poisson a une fonction de densité avec un seul paramètre généralement noté \\(\\lambda\\) (lambda) et est décrite par la formule suivante : \\[\\begin{equation} f(x; \\lambda)=\\frac{\\lambda^{x}}{x !} e^{-\\lambda} \\tag{2.7} \\end{equation}\\] avec x le nombre de cas, f(x) la probabilité dobtenir x sachant \\(\\lambda\\). \\(\\lambda\\) peut être vu comme le taux moyen doccurrences (nombre dévènements divisé par la durée totale de lexpérience). Il permet à la fois de caractériser le centre et la dispersion de la distribution. Notez également que plus le paramètre \\(\\lambda\\) augmente, plus la distribution de Poisson tend vers une distribution normale. Figure 2.11: Distribution de Poisson 2.4.3.7 Distribution de Poisson avec excès de zéros Il arrive régulièrement quune variable de comptage mesurée produise un très grand nombre de zéros. Prenons pour exemple le nombre de seringues de drogue injectable par tronçon de rue ramassées sur une période dun mois. À léchelle de toute une ville, un très grand nombre de tronçons nauront tout simplement aucune seringue et dans ce contexte, la distribution classique de Poisson nest pas adaptée. Nous lui préfèrons alors une autre distribution : la distribution de Poisson avec excès de zéros (ou distribution de Pólya) qui inclut un paramètre contrôlant la forte présence de zéros. Sa fonction de densité est la suivante : \\[\\begin{equation} f(x; \\lambda; p)=(1-p)\\frac{\\lambda^{x}}{x !} e^{-\\lambda} \\tag{2.8} \\end{equation}\\] Plus exactement, la distribution de Poisson avec excès de zéro (zero-inflated en anglais) est une combinaison de deux processus générant des zéros. En effet, un zéro peut être produit par la distribution de Poisson proprement dite (aussi appelé vrai zéro) ou alors par le processus générant les zéros excédentaires dans le jeu de données, capturé par la probabilité p (faux zéro). p est donc le paramètre contrôlant la probabilité dobtenir un zéro, indépendamment du phénomène étudié. Figure 2.12: Distribution de Poisson avec excès de zéros 2.4.3.8 Distribution gaussienne Plus communément appelée la distribution normale, la distribution gaussienne est utilisée pour représenter des variables continues centrées sur leur moyenne. Son espace déchantillonnage est \\(]-\\infty; +\\infty[\\). Cette distribution joue un rôle central en statistique. Selon la formule consacrée, cette distribution résulte de la superposition dun très grand nombre de petits effets fortuits indépendants. Cest ce quexprime formellement le théorème central limite qui montre que la somme dun grand nombre de variables aléatoires tend généralement vers une distribution normale. Autrement dit, lorsque nous répétons une même expérience et que nous conservons les résultats de ces expériences, la distribution du résultat de ces expériences tend vers la normalité. Cela sexplique par le fait quen moyenne, chaque répétition de lexpérience produit le même résultat, mais quun ensemble de petits facteurs aléatoires viennent ajouter de la variabilité dans les données collectées. Prenons un exemple concret : si nous plantons une centaine darbres simultanément dans un parc avec un degré densoleillement identique et que nous leur apportons les mêmes soins pendant dix ans, la distribution de leurs tailles suivra une distribution normale. Un ensemble de facteurs aléatoires (composition du sol, exposition au vent, aléas génétiques, passage de nuages, etc.) auront affecté différemment chaque arbre, ajoutant ainsi un peu de hasard dans leur taille finale. Cette dernière est cependant davantage affectée par des paramètres majeurs (comme lespèce, lensoleillement, larrosage, etc.), et est donc centrée autour dune moyenne. La fonction de densité de la distribution normale est la suivante : \\[\\begin{equation} f(x ; \\mu ; \\sigma)=\\frac{1}{\\sigma \\sqrt{2 \\pi}} e^{-\\frac{1}{2}\\left(\\frac{x-\\mu}{\\sigma}\\right)^{2}} \\tag{2.9} \\end{equation}\\] avec x une valeur dont nous souhaitons connaître la probabilité, f(x) sa probabilité, \\(\\mu\\) (mu) la moyenne de la distribution normale (paramètre de localisation) et \\(\\sigma\\) (sigma) son écart-type (paramètre de dispersion). Cette fonction suit une courbe normale ayant une forme de cloche. Notez que : 68,2 % de la masse de la distribution normale est comprise dans lintervalle \\([\\mu- \\sigmax \\mu+ \\sigma]\\) 95,4 % dans lintervalle \\([\\mu- 2\\sigmax \\mu+ 2\\sigma]\\) 99,7 % dans lintervalle \\([\\mu- 3\\sigmax \\mu+ 3\\sigma]\\) Autrement dit, dans le cas dune distribution normale, il est très invraisemblable dobserver des données situées à plus de trois écarts types de la moyenne. Ces différentes égalités sont vraies quelles ques soient les valeurs de la moyenne et de lécart-type. Notez ici que lorsque \\(\\mu = 0\\) et \\(\\sigma = 1\\), nous obtenons la loi normale générale (ou centrée réduite) (section 2.5.5.2). Figure 2.13: Distribution gaussienne 2.4.3.9 Distribution gaussienne asymétrique La distribution normale asymétrique (skew-normal) est une extension de la distribution gaussienne permettant de lever la contrainte de symétrie de la simple distribution gaussienne. Son espace déchantillonnage est donc \\(]-\\infty; +\\infty[\\). Sa fonction de densité est la suivante : \\[\\begin{equation} f(x;\\xi;\\omega;\\alpha) = \\frac{2}{\\omega \\sqrt{2 \\pi}} e^{-\\frac{(x-\\xi)^{2}}{2 \\omega^{2}}} \\int_{-\\infty}^{\\alpha\\left(\\frac{x-\\xi}{\\omega}\\right)} \\frac{1}{\\sqrt{2 \\pi}} e^{-\\frac{t^{2}}{2}} d t \\tag{2.10} \\end{equation}\\] avec \\(\\xi\\) (xi) le paramètre de localisation, \\(\\omega\\) (omega) le paramètre de dispersion (ou déchelle) et \\(\\alpha\\) (alpha) le paramètre de forme (contrôlant le degré de symétrie). Si \\(\\alpha = 0\\), alors la distribution normale asymétrique est une distribution normale ordinaire. Ce type de distribution est très utile lorsque nous souhaitons modéliser une variable pour laquelle nous savons que des valeurs plus extrêmes sobserveront dun côté ou de lautre de la distribution. Les revenus totaux annuels des personnes ou des ménages sont de très bons exemples puisquils sont distribués généralement avec une asymétrie positive : bien quune moyenne existe, il y a généralement plus de personnes ou de ménages avec des revenus très faibles que de personnes ou de ménages avec des revenus très élevés. Figure 2.14: Distribution gaussienne asymétrique 2.4.3.10 Distribution log-normale Au même titre que la distribution normale asymétrique, la distribution log-normale est une version asymétrique de la distribution normale. Son espace déchantillonnage est \\(]0; +\\infty[\\). Cela signifie que cette distribution ne peut décrire que des données continues et positives. Sa fonction de densité est la suivante : \\[\\begin{equation} f(x ; \\mu ; \\sigma)=\\frac{1}{x \\sigma \\sqrt{2 \\pi}} e^{-\\left(\\frac{(\\ln x-\\mu)^{2}}{2 \\sigma^{2}}\\right)} \\tag{2.11} \\end{equation}\\] À la différence la distribution skew-normal, la distribution log-normale ne peut avoir quune asymétrie positive (étirée vers la droite). Elle est cependant intéressante puisquelle ne compte que deux paramètres (\\(\\mu\\) et \\(\\sigma\\)), ce qui la rend plus facile à ajuster. À nouveau, une distribution log-normale peut être utilisée pour décrire les revenus totaux annuels des individus ou des ménages ou les revenus demploi. Elle est aussi utilisée en économie sur les marchés financiers pour représenter les cours des actions et des biens (ces derniers ne pouvant pas être inférieurs à 0). Figure 2.15: Distribution log-gaussienne Plus spécifiquement, la distribution log-normale est une transformation de la distribution normale. Comme son nom lindique, elle permet de décrire le logarithme dune variable aléatoire suivant une distribution normale. 2.4.3.11 Distribution de Student La distribution de Student joue un rôle important en statistique. Elle est par exemple utilisée lors du test t pour calculer le degré de significativité du test. Comme la distribution gaussienne, la distribution de Student a une forme de cloche, est centrée sur sa moyenne et définie sur \\(]-\\infty; +\\infty[\\). Elle se distingue de la distribution normale principalement par le rôle que joue son troisième paramètre, \\(\\nu\\) : le nombre de degrés de liberté, contrôlant le poids des queues de la distribution. Une petite valeur de \\(\\nu\\) signifie que la distribution a des « queues plus lourdes » (heavy tails en anglais). Entendez par-là que les valeurs extrêmes ont une plus grande probabilité doccurrence : \\[\\begin{equation} p(x ; \\nu ; \\hat{\\mu} ; \\hat{\\sigma})=\\frac{\\Gamma\\left(\\frac{\\nu+1}{2}\\right)}{\\Gamma\\left(\\frac{\\nu}{2}\\right) \\sqrt{\\pi \\nu} \\hat{\\sigma}}\\left(1+\\frac{1}{\\nu}\\left(\\frac{x-\\hat{\\mu}}{\\hat{\\sigma}}\\right)^{2}\\right)^{-\\frac{\\nu+1}{2}} \\tag{2.12} \\end{equation}\\] avec \\(\\mu\\) le paramètre de localisation, \\(\\sigma\\) le paramètre de dispersion (qui nest cependant pas un écart-type comme pour la distribution normale) et \\(\\nu\\) le nombre de degrés de liberté. Plus \\(\\nu\\) est grand, plus la distribution de Student tend vers une distribution normale. Ici, la lettre grecque \\(\\Gamma\\) représente la fonction mathématique gamma (à ne pas confondre avec la distribution Gamma). Un exemple dapplication en études urbaines est lexposition au bruit environnemental de cyclistes. Cette distribution sapprocherait certainement dune distribution normale, mais les cyclistes croisent régulièrement des secteurs peu bruyants (parcs, rues résidentielles, etc.) et des secteurs très bruyants (artères majeures, zones industrielles, etc.), plus souvent que ce que prévoit une distribution normale, justifiant le choix dune distribution de Student. Figure 2.16: Distribution de Student 2.4.3.12 Distribution de Cauchy La distribution de Cauchy est également une distribution symétrique définie sur lintervalle \\(]-\\infty; +\\infty[\\). Elle a comme particularité dêtre plus aplatie que la distribution de Student (davoir des queues potentiellement plus lourdes). Elle est notamment utilisée pour modéliser des phénomènes extrêmes comme les précipitations maximales annuelles, les niveaux dinondations maximaux annuels ou les seuils critiques de perte pour les portefeuilles financiers. Il est également intéressant de noter que le quotient de deux variables indépendantes normalement distribuées suit une distribution de Cauchy. Sa fonction de densité est la suivante : \\[\\begin{equation} \\frac{1}{\\pi \\gamma}\\left[\\frac{\\gamma^{2}}{\\left(x-x_{0}\\right)^{2}+\\gamma^{2}}\\right] \\tag{2.13} \\end{equation}\\] Elle dépend donc de deux paramètres : \\(x_0\\), le paramètre de localisation indiquant le pic de la distribution et \\(\\gamma\\), un paramètre de dispersion. Figure 2.17: Distribution de Cauchy 2.4.3.13 Distribution du khi-deux La distribution du khi-deux est utilisée dans de nombreux tests statistiques. Par exemple, le test du khi-deux de Pearson est utilisé pour comparer les écarts au carré entre des fréquences attendues et observées de deux variables qualitatives. La distribution du khi-deux décrit plus généralement la somme des carrés dun nombre k de variables indépendantes normalement distribuées. Il est assez rare de modéliser un phénomène à laide dune distribution du khi-deux, mais son omniprésence dans les tests statistiques justifie quelle soit mentionnée ici. Cette distribution est définie sur lintervalle \\([0; +\\infty[\\) et a pour fonction de densité : \\[\\begin{equation} f(x;k) = \\frac{1}{2^{k / 2} \\Gamma(k / 2)} x^{k / 2-1} e^{-x / 2} \\tag{2.14} \\end{equation}\\] La distribution du khi-deux na quun paramètre k, représentant donc le nombre de variables mises au carré et dont nous faisons la somme pour obtenir la distribution du khi-deux. Figure 2.18: Distribution du khi-deux 2.4.3.14 Distribution exponentielle La distribution exponentielle est une version continue de la distribution géométrique. Pour cette dernière, nous nous intéressons au nombre de tentatives nécessaires pour obtenir un résultat positif, soit une dimension discrète. Pour la distribution exponentielle, cette dimension discrète est remplacée par une dimension continue. Lexemple le plus intuitif est sûrement le cas du temps. Dans ce cas, la distribution exponentielle sert à modéliser le temps dattente nécessaire pour quun évènement se produise. Il peut aussi sagir dune force que nous appliquons jusquà ce quun matériau cède. Cette distribution est donc définie sur lintervalle [0; +\\(\\infty\\)[ et a pour fonction de densité : \\[\\begin{equation} f(x;\\lambda) = \\lambda e^{-\\lambda x} \\tag{2.15} \\end{equation}\\] Figure 2.19: Distribution exponentielle La distribution exponentielle est conceptuellement proche de la distribution de Poisson. La distribution de Poisson régit le nombre des événements qui surviennent au cours dun laps de temps donné. La distribution exponentielle peur servir à modéliser le temps qui sécoule entre deux événements. 2.4.3.15 Distribution Gamma La distribution Gamma peut être vue comme la généralisation dun grand nombre de distributions. Ainsi, la distribution exponentielle et du khi-deux peuvent être vues comme des cas particuliers de la distribution Gamma. Cette distribution est définie sur lintervalle ]0; +\\(\\infty\\)[ (notez que le 0 est exclu) et sa fonction de densité est la suivante : \\[\\begin{equation} f(x ; \\alpha; \\beta)=\\frac{\\beta^{\\alpha} x^{\\alpha-1} e^{-\\beta x}}{\\Gamma(\\alpha)} \\tag{2.16} \\end{equation}\\] Elle comprend donc deux paramètres : \\(\\alpha\\) et \\(\\beta\\). Le premier est le paramètre de forme et le second un paramètre déchelle (à linverse dun paramètre de dispersion, plus sa valeur est petite, plus la distribution est dispersée). Notez que cette distribution ne dispose pas dun paramètre de localisation. Du fait de sa flexibilité, cette distribution est largement utilisée, que ce soit dans la modélisation des temps dattente avant un évènement, de la taille des réclamations dassurance, des quantités de précipitations, etc. Figure 2.20: Distribution Gamma 2.4.3.16 Distribution bêta La distribution bêta est définie sur lintervalle [0; 1], elle est donc énormément utilisée pour modéliser des variables étant des proportions ou des probabilités. La distribution bêta a été élaborée pour modéliser la superposition dun très grand nombre de petits effets fortuits qui ne sont pas indépendants et notamment pour étudier leffet de la réalisation dun événement aléatoire sur la probabilité des tirages subséquents. Elle a aussi une utilité pratique en statistique, car elle peut être combinée avec dautres distributions (distribution bêta-binomiale, bêta-negative-binomiale, etc.). Un autre usage plus rare mais intéressant est la modélisation de la fraction du temps représentée par une tâche dans le temps nécessaire à la réalisation de deux tâches de façon séquentielle. Cela est dû au fait que la distribution dune distribution Gamma g1 divisée par la somme de g1 et dune autre distribution Gamma g2 suit une distribution bêta. Un exemple concret est, par exemple, la fraction du temps effectué à pied dans un déplacement multimodal. La distribution de bêta a la fonction de densité suivante : \\[\\begin{equation} f(x;\\alpha;\\beta) = \\frac{1}{\\mathrm{B}(\\alpha, \\beta)} x^{\\alpha-1}(1-x)^{\\beta-1} \\tag{2.17} \\end{equation}\\] Elle a donc deux paramètres \\(\\alpha\\) et \\(\\beta\\) contrôlant tous les deux la forme de la distribution. Cette caractéristique lui permet davoir une très grande flexibilité et même dadopter des formes bimodales. \\(B\\) correspond à la fonction mathématique Beta : ne pas la confondre avec la distribution Beta et le paramètre Beta (\\(\\beta\\)) de cette même distribution. Figure 2.21: Distribution bêta 2.4.3.17 Distribution de Weibull La distribution de Weibull est directement liée à la distribution exponentielle, cette dernière étant en fait un cas particulier de distribution Weibull. Elle sert donc souvent à modéliser une quantité x (souvent le temps) à accumuler pour quun évènement se produise. La distribution de Weibull est définie sur lintervalle [0; +\\(\\infty\\)[ et a la fonction de densité suivante : \\[\\begin{equation} f(x;\\lambda) = \\frac{k}{\\lambda} (\\frac{x}{\\lambda})^{k-1} e^{-(\\frac{x}{\\lambda})^k} \\tag{2.18} \\end{equation}\\] \\(\\lambda\\) est le paramètre de dispersion (analogue à celui dune distribution exponentielle classique) et k le paramètre de forme. Pour bien comprendre le rôle de k, prenons un exemple : la propagation dun champignon dun arbre à son voisin. Si \\(k&lt;1\\), le risque instantané que lévènement modélisé se produise diminue avec le temps (en dautres termes, plus le temps passe, plus petite devient la probabilité dêtre contaminé). Si \\(k=1\\), alors le risque instantané que lévènement se produise reste identique dans le temps (la loi de Weibull se résume alors à une loi exponentielle). Si \\(k &gt; 1\\), alors le risque instantané que lévènement se produise augmente avec le temps (la probabilité pour un arbre dêtre contaminé sil ne la pas déjà été  pas seulement le risque cumulé  augmente en fonction du temps). La distribution de Weibull est très utilisée en analyse de survie, en météorologie, en ingénierie des matériaux et dans la théorie des valeurs extrêmes. Figure 2.22: Distribution de Weibull 2.4.3.18 Distribution Pareto Cette distribution a été élaborée par Vilfredo Pareto pour donner une forme mathématique à ce qui porte aujourdhui le nom de principe de Pareto et que nous exprimons souvent de manière imagée  dans une société donnée, 20 % des individus possèdent 80 % de la richesse , mais qui est plus justement exprimée en écrivant que, de manière générale, dans toute société, la plus grande partie du capital est détenue par une petite fraction de la population. Elle est définie sur lintervalle \\([x_m; +\\infty[\\) avec la fonction de densité suivante : \\[\\begin{equation} f(x;x_m;k) = (\\frac{x_m}{x})^k \\tag{2.19} \\end{equation}\\] Elle comprend donc deux paramètres, \\(x_m\\) étant un paramètre de localisation (décalant la distribution vers la droite ou vers la gauche) et \\(k\\) un paramètre de forme. Plus \\(k\\) augmente, plus la probabilité prédite par la distribution décroît rapidement. Figure 2.23: Distribution de Pareto Au-delà de la question de la répartition de la richesse, la distribution de Pareto peut également être utilisée pour décrire la répartition de la taille des villes (Reed 2002), la popularité des hommes sur Tinder ou la taille des fichiers échangés sur Internet (Reed et Jorgensen 2004). Pour ces trois exemples, nous avons les situations suivantes : de nombreuses petites villes, profils peu attractifs, petits fichiers échangés et à linverse très peu de grandes villes, profils très attractifs, gros fichiers échangés. La loi de Pareto est liée à la loi exponentielle. Si une variable aléatoire suit une loi de Pareto, le logarithme du quotient de cette variable et de son paramètre de localisation est une variable aléatoire qui suit une loi exponentielle. 2.4.3.19 Cas particuliers Sachez également quil existe des distributions « plus exotiques » que nous nabordons pas ici, mais auxquelles vous pourriez être confrontés un jour : Les distributions sphériques, servant à décrire des données dont le 0 est équivalent à la valeur maximale. Par exemple, des angles puisque 0 et 360 degrés sont identiques. Les distributions composées (mixture distributions), permettant de modéliser des phénomènes issus de la superposition de plusieurs distributions. Par exemple, la distribution de la taille de lensemble des êtres humains est en réalité une superposition de deux distributions gaussiennes, une pour chaque sexe, puisque ces deux distributions nont pas la même moyenne ni le même écart-type. Les distributions multivariées permettant de décrire des phénomènes multidimensionnels. Par exemple, la réussite des élèves en français et en mathématique pourrait être modélisée par une distribution gaussienne bivariée plutôt que deux distributions distinctes. Ce choix serait pertinent si nous présumons que ces deux variables sont corrélées plutôt quindépendantes. Les distributions censurées décrivant des variables pour lesquelles les données sont issues dun tirage « censuré ». En dautres termes, la variable étudiée varie sur une certaine étendue, mais du fait du processus de tirage (collecte des données), les valeurs au-delà de certaines limites sont censurées. Un bon exemple est la mesure de la pollution sonore avec un capteur incapable de détecter des niveaux sonores en dessous de 55 décibels. Il arrive parfois en ville que les niveaux sonores descendent plus bas que ce seuil, mais les données collectées ne le montrent pas. Dans ce contexte, il est important dutiliser des versions censurées des distributions présentées précédemment. Les observations au-delà de la limite sont conservées dans lanalyse, mais nous ne disposons que dune information partielle à leur égard (elles sont au-delà de la limite). Les distributions tronquées, souvent confondues avec les distributions censurées, décrivent des situations où des données au-delà dune certaine limite sont impossibles à collecter et retirées simplement de lanalyse. 2.4.4 Conclusion sur les distributions Voilà qui conclut cette exploration des principales distributions à connaître. Lidée nest bien sûr pas de toutes les retenir par cur (et encore moins les formules mathématiques), mais plutôt de se rappeler dans quels contextes elles peuvent être utiles. Vous aurez certainement besoin de le relire cette section avant daborder le chapitre 8 portant sur les modèles linéaires généralisés (GLM). Wikipédia dispose dinformations très détaillées sur chaque distribution si vous avez besoin dinformations complémentaires. Pour un tour dhorizon plus exhaustif des distributions, vous pouvez aussi faire un tour sur les projets ProbOnto et the ultimate probability distribution explorer. References "],["sect025.html", "2.5 Statistiques descriptives sur des variables quantitatives", " 2.5 Statistiques descriptives sur des variables quantitatives 2.5.1 Paramètres de tendance centrale Trois mesures de tendance centrale permettent de résumer rapidement une variable quantitative : la moyenne arithmétique est simplement la somme des données dune variable divisée par le nombre dobservations (n), soit \\(\\frac{\\sum_{i=1}^n x_i}{n}\\) notée \\(\\mu\\) (prononcé mu) pour des données pour une population et \\(\\bar{x}\\) (prononcé x barre) pour un échantillon. la médiane est la valeur qui coupe la distribution dune variable dune population ou dun échantillon en deux parties égales. Autrement dit, 50 % des valeurs des observations lui sont supérieures et 50 % lui sont inférieures. le mode est la valeur la plus fréquente parmi un ensemble dobservations pour une variable. Il sapplique ainsi à des variables discrètes (avec un nombre fini de valeurs discrètes dans un intervalle donné) et non à des variables continues (avec un nombre infini de valeurs réelles dans un intervalle donné). Prenons deux variables : lune discrète relative au nombre daccidents par intersection (avec \\(X \\in \\left[0,20\\right]\\)) et lautre continue relative à la distance de dépassement (en mètres) dun personne à vélo par un personne conduisant un véhicule motorisé (avec \\(X \\in \\left[0,5\\right]\\)). Pour la première, le mode  la valeur la plus fréquente  est certainement 0. Pour la seconde, identifier le mode nest pas pertinent puisquil peut y avoir un nombre infini de valeurs entre 0 et 5 mètres. Il convient de ne pas confondre moyenne et médiane! Dans le tableau 2.1, nous avons reporté les valeurs moyennes et médianes des revenus des ménages pour les municipalités de lîle de Montréal en 2015. Par exemple, les 8685 ménages résidant à Wesmount disposaient en moyenne dun revenu de 295 099 $; la moitié de ces 8685 ménages avaient un revenu inférieur à 100 153 $ et lautre moitié un revenu supérieur à cette valeur (médiane). Cela démontre clairement que la moyenne peut être grandement affectée par des valeurs extrêmes (faibles ou fortes). Autrement dit, plus lécart entre les valeurs de la moyenne et la médiane est important, plus les données de la variable sont inégalement réparties. À Westmount, soit la municipalité la plus nantie de lîle de Montréal, les valeurs extrêmes sont des ménages avec des revenus très élevés tirant fortement la moyenne vers le haut. À linverse, le faible écart entre les valeurs moyenne et médiane dans la municipalité de Montréal-Est (58 594 $ versus 50 318 $) souligne que les revenus des ménages sont plus également répartis. Cela explique que pour comparer les revenus totaux ou demploi entre différents groupes (selon le sexe, le groupe dâge, le niveau déducation, la municipalité ou région métropolitaine, etc.), nous privilégions habituellement lutilisation des revenus médians. Tableau 2.1: Revenus moyens et médians des ménages en dollars, municipalités de lîle de Montréal, 2015 Municipalité Nombre de ménages Revenu moyen Revenu médian Baie-DUrfé 1 330 171 390 118 784 Beaconsfield 6 660 187 173 123 392 Côte-Saint-Luc 13 490 94 570 58 935 Dollard-Des Ormeaux 17 210 102 104 78 981 Dorval 8 390 89 952 64 689 Hampstead 2 470 250 497 122 496 Kirkland 6 685 144 676 115 381 Montréal 779 805 69 047 50 227 Montréal-Est 1 730 58 594 50 318 Montréal-Ouest 1 850 159 374 115 029 Mont-Royal 7 370 205 309 109 540 Pointe-Claire 12 380 100 294 80 242 Sainte-Anne-de-Bellevue 1 960 102 969 67 200 Senneville 345 203 790 116 224 Westmount 8 685 295 099 100 153 2.5.2 Paramètres de position Les paramètres de position permettent de diviser une distribution en n parties égales. Les quartiles qui divisent une distribution en quatre parties (25 %) : Q1 (25 %), soit le quartile inférieur ou premier quartile; Q2 (50 %), soit la médiane; Q3 (75 %), soit le quartile supérieur ou troisième quartile. Les quintiles qui divisent une distribution en cinq parties égales (20 %). Les déciles (de D1 à D9) qui divisent une distribution en dix parties égales (10 %). Les centiles (de C1 à C99) qui divisent une distribution en cent parties égales (1 %). En cartographie, les quartiles et les quintiles sont souvent utilisés pour discrétiser une variable quantitative (continue ou discrète) en quatre ou cinq classes et plus rarement, en dix classes (déciles). Avec les quartiles, les bornes des classes qui comprennent chacune 25 % des unités spatiales sont définies comme suit : [Min à Q1], [Q1 à Q2], [Q2 à Q3] et [Q3 à Max]. La méthode de discrétisation selon les quartiles ou quintiles permet de repérer, en un coup dil, à quelle tranche de 25 % ou de 20 % des données appartient chacune des unités spatiales. Cette méthode de discrétisation est aussi utile pour comparer plusieurs cartes et vérifier si deux phénomènes sont ou non colocalisés (Pumain et Béguin 1994). En guise dexemple, les pourcentages de personnes à faible revenu et de locataires par secteur de recensement ont clairement des distributions spatiales très semblables dans la région métropolitaine de Montréal en 2016 (figure 2.24). Figure 2.24: Exemples de cartographie avec une discrétisation selon les quantiles Une lecture attentive des valeurs des centiles permet de repérer la présence de valeurs extrêmes, voire aberrantes, dans un jeu de données. Il nest donc pas rare de les voir reportées dans un tableau de statistiques descriptives dun article scientifique, et ce, afin de décrire succinctement les variables à létude. Par exemple, dans une étude récente comparant les niveaux dexposition au bruit des cyclistes dans trois villes (Apparicio et Gelb 2020), les auteurs reportent à la fois les valeurs moyennes et celles de plusieurs centiles. Globalement, la lecture des valeurs moyennes permet de constater que, sur la base des données collectées, les cyclistes sont plus exposés au bruit à Paris quà Montréal et Copenhague (73,4 dB(A) contre 70,7 et 68,4, tableau 2.2). Compte tenu de léchelle logarithmique du bruit, la différence de 5 dB(A) entre les valeurs moyennes du bruit de Copenhague et de Paris peut être considérée comme une multiplication de lénergie sonore par plus de 3. Pour Paris, lanalyse des quartiles montre que durant 25 % du temps des trajets à vélo (plus de 63 heures de collecte), les participantes et participants ont été exposés à des niveaux de bruit soit inférieurs à 69,1 dB(A) (premier quartile), soit supérieurs à 74 dB(A) (troisième quartile). Quant à lanalyse des centiles, elle permet de constater que durant 5 % et 10 % du temps, les participantes et participants étaient exposés à des niveaux de bruit très élevés, dépassant 75 dB(A) (C90 = 76 et C90 = 77,2). Tableau 2.2: Stastistiques descriptives de lexposition au bruit des cyclistes par minute dans trois villes (dB(A), Laeq 1min) Statistiques Copenhague Montréal Paris N 6 212,0 4 723,0 3 793,0 Moyenne de bruit 68,4 70,7 73,4 Centiles 1 57,5 59,2 62,3 5 59,1 61,1 65,0 10 60,3 62,3 66,5 25 (premier quartile) 62,7 64,5 69,1 50 (médiane) 66,0 67,7 71,6 75 (troisième quartile) 69,2 71,0 74,0 90 71,9 73,7 76,0 95 73,3 75,2 77,2 99 76,5 78,9 81,0 2.5.3 Paramètres de dispersion Cinq principales mesures de dispersion permettent dévaluer la variabilité des valeurs dune variable quantitative : létendue, lécart interquartile, la variance, lécart-type et le coefficient de variation. Notez demblée que cette dernière mesure ne sapplique pas à des variables dintervalle (section 2.1.2.2). Létendue est la différence entre les valeurs minimale et maximale dune variable, soit lintervalle des valeurs dans lequel elle a été mesurée. Il convient danalyser avec prudence cette mesure puisquelle inclut dans son calcul des valeurs potentiellement extrêmes, voire aberrantes (faibles ou fortes). Lintervalle ou écart interquartile est la différence entre les troisième et premier quartiles (Q3  Q1). Il représente ainsi une mesure de la dispersion des valeurs de 50 % des observations centrales de la distribution. Plus la valeur de lécart interquartile est élevée, plus la dispersion des 50 % des observations centrales est forte. Contrairement à létendue, cette mesure élimine linfluence des valeurs extrêmes puisquelle ne tient pas compte des 25 % des observations les plus faibles [Min à Q1] et des 25 % des observations les plus fortes [Q3 à Max]. Graphiquement, lintervalle interquartile est représenté à laide dune boîte à moustaches (boxplot en anglais) : plus lintervalle interquartile est grand, plus la boîte est allongée (figure 2.25) Figure 2.25: Graphique en violon, boîte à moustaches et intervalle interquartile La variance est la somme des déviations à la moyenne au carré (numérateur) divisée par le nombre dobservations pour une population (\\(\\sigma^2\\)) ou divisée par le nombre dobservations moins une (\\(s^2\\)) pour un échantillon (équation (2.20)). Puisque les déviations à la moyenne sont mises au carré, la valeur de la variance (tout comme celle de lécart-type) est toujours positive. Plus sa valeur est élevée, plus les observations sont dispersées autour de la moyenne. La variance représente ainsi lécart au carré moyen des observations à la moyenne. \\[\\begin{equation} \\sigma^2=\\frac{\\sum_{i=1}^n (x_{i}-\\mu)^2}{n} \\text{ ou } s^2=\\frac{\\sum_{i=1}^n (x_{i}-\\bar{x})^2}{n-1} \\tag{2.20} \\end{equation}\\] Lécart-type est la racine carrée de la variance (équation (2.21)). Rappelez-vous que la variance est calculée à partir des déviations à la moyenne mises au carré. Étant donné que lécart-type est la racine carrée de la variance, il est donc évalué dans la même unité que la variable, contrairement à la variance. Bien entendu, comme pour la variance, plus la valeur de lécart-type est élevée, plus la distribution des observations autour de la moyenne est dispersée. \\[\\begin{equation} \\sigma=\\sqrt{\\sigma^2}=\\sqrt{\\frac{\\sum_{i=1}^n (x_{i}-\\mu)^2}{n}} \\text{ ou } s=\\sqrt{s^2}=\\sqrt{\\frac{\\sum_{i=1}^n (x_{i}-\\bar{x})^2}{n-1}} \\tag{2.21} \\end{equation}\\] Les formules des variances et des écarts-types pour une population et un échantillon sont très similaires : seul le dénominateur change avec \\(n\\) versus \\(n-1\\) observations. Par conséquent, plus le nombre dobservations de votre jeu de données est important, plus lécart entre ces deux mesures de dispersion pour une population et un échantillon est minime. Comme dans la plupart des logiciels de statistique, les fonctions de base var et sd de R calculent la variance et lécart-type pour un échantillon (\\(n-1\\) au dénominateur). Si vous souhaitez les calculer pour une population, adaptez la syntaxe ci-dessous dans laquelle df$var1 représente la variable intitulée var1 présente dans un DataFrame nommé df. var.p &lt;- mean((df$var1 - mean(df$var1))^2) sd.p &lt;- sqrt(mean((df$var1 - mean(df$var1))^2)) Le coefficient de variation (CV) est le rapport entre lécart-type et la moyenne, représentant ainsi une standardisation de lécart-type ou, en dautres termes, une mesure de dispersion relative (équation (2.22)). Lécart-type étant exprimé dans lunité de mesure de la variable, il ne peut pas être utilisé pour comparer les dispersions de variables exprimées des unités de mesure différentes (par exemple, en pourcentage, en kilomètres, en dollars, etc.). Pour y remédier, nous utilisons le coefficient de variation : une variable est plus dispersée quune autre si la valeur de son CV est plus élevée. Certaines personnes préfèrent multiplier la valeur du CV par 100 : lécart-type est alors exprimé en pourcentage de la moyenne. \\[\\begin{equation} CV=\\frac{\\sigma}{\\mu} \\text{ ou } CV=\\frac{s^2}{\\bar{x}} \\tag{2.22} \\end{equation}\\] Illustrons comment calculer les cinq mesures de dispersion précédemment décrites à partir de valeurs fictives pour huit observations (colonne intitulée \\(x_i\\) au tableau 2.3). Les différentes statistiques reportées dans ce tableau sont calculées comme suit : La moyenne est la somme divisée par le nombre dobservations, soit \\(\\mbox{248/8}=\\mbox{31}\\). Létendue est la différence entre les valeurs maximale et minimale, soit \\(\\mbox{40}-\\mbox{22}=\\mbox{30}\\). Les quartiles coupent la distribution en quatre parties égales. Avec huit observations triées par ordre croissant, le premier quartile est égal à la valeur de la deuxième observation (soit 25), la médiane à celle de la quatrième (30), le troisième quartile à celle de la sixième (35). Lécart interquartile est la différence entre Q3 et Q1, soit \\(\\mbox{35}-\\mbox{25}=\\mbox{10}\\). La seconde colonne du tableau est lécart à la moyenne (\\(x_i-\\bar{x}\\)), soit \\(\\mbox{22} - \\mbox{31} = -\\mbox{9}\\) pour lobservation 1; la somme de ces écarts est toujours égale à 0. La troisième colonne est cette déviation mise au carré (\\((x_i-\\bar{x})^2\\)), soit \\(-\\mbox{9}^2 = \\mbox{81}\\), toujours pour lobservation 1. La somme de ces déviations à la moyenne au carré (268) représente le numérateur de la variance (équation (2.20)). En divisant cette somme par le nombre dobservations, nous obtenons la variance pour une population (\\(\\mbox{268}/\\mbox{8}=\\mbox{33,5}\\)) tandis que la variance dun échantillon est égale à \\(\\mbox{268}/(\\mbox{8}-\\mbox{1})=\\mbox{38,29}\\). Lécart-type est la racine carrée de la variance (équation (2.21)), soit \\(\\sigma=\\sqrt{\\mbox{33,5}}=\\mbox{5,79}\\) et \\(s=\\sqrt{\\mbox{38,29}}=\\mbox{6,19}\\). Finalement, les valeurs des coefficients de variation (équation (2.22)) sont de \\(\\mbox{5,79}/\\mbox{31}=\\mbox{0,19}\\) pour une population et \\(\\mbox{6,19}/\\mbox{31}=\\mbox{0,20}\\) pour un échantillon. Tableau 2.3: Calcul des mesures de dispersion sur des données fictives Observation \\(x_i\\) \\(x_i-\\bar{x}\\) \\((x_i-\\bar{x})^2\\) 1 22,00 -9 81,0 2 25,00 -6 36,0 3 27,00 -4 16,0 4 30,00 -1 1,0 5 32,00 1 1,0 6 35,00 4 16,0 7 37,00 6 36,0 8 40,00 9 81,0 Statistique N 8,00 Somme 248,00 0 268,0 Moyenne (\\(\\bar{x}\\) ou \\(\\mu\\)) 31,00 0 33,5 Étendue 18,00 Premier quartile 25,00 Troisième quartile 35,00 Intervalle interquartile 10,00 Variance (population, \\(\\sigma^2\\)) 33,50 Écart-type (population, \\(\\sigma\\)) 5,79 Variance (échantillon, \\(s^2\\)) 38,29 Écart-type (échantillon, \\(s\\)) 6,19 Coefficient de variation (\\(\\sigma / \\mu\\)) 0,19 Coefficient de variation (\\(s / \\bar{x}\\)) 0,20 Le tableau 2.4 vise à démontrer, à partir de trois variables, comment certaines mesures de dispersion sont sensibles à lunité de mesure et/ou aux valeurs extrêmes. Concernant lunité de mesure, nous avons créé deux variables A et B, où B étant simplement A multipliée par 10. Pour A, les valeurs de la moyenne, de létendue et de lintervalle interquartile sont respectivement 31, 18 et 10. Sans surprise, celles de B sont multipliées par 10 (310, 180, 100). La variance étant la moyenne des déviations à la moyenne au carré, elle est égale à 33,50 pour A et donc à \\(\\mbox{33,50}\\times10^2=\\mbox{3350}\\) pour B; lécart-type de B est égal à celui de A multiplié par 10. Cela démontre que létendue, lintervalle interquartile, la variance et lécart-type sont des mesures de dispersion dépendantes de lunité de mesure. Par contre, étant donné que le coefficient de variation (CV) est le rapport de lécart-type avec la moyenne, il a la même valeur pour A et B, ce qui démontre que le CV est bien une mesure de dispersion relative permettant de comparer des variables exprimées dans des unités de mesure différentes. Concernant la sensibilité aux valeurs extrêmes, nous avons créé la variable C pour laquelle seule la huitième observation a une valeur différente (40 pour A et 105 pour B). Cette valeur de 105 pourrait être soit une valeur extrême positive mesurée, soit une valeur aberrante (par exemple, si lunité de mesure était un pourcentage variant de 0 à 100 %). Cette valeur a un impact important sur la moyenne (31 contre 39,12) et létendue (18 contre 83) et corollairement sur la variance (33,50 contre 641,86), lécart-type (5,79 contre 25,33) et le coefficient de variation (0,19 contre 0,65). Par contre, comme lintervalle interquartile est calculé sur 50 % des observations centrales (\\(\\mbox{Q3}-\\mbox{Q1}\\)), il nest pas affecté par cette valeur extrême. Tableau 2.4: Illustration de la sensibilité des mesures de dispersion à lunité de mesure et aux valeurs extrêmes Observation A B C 1 22,00 220,00 22,00 2 25,00 250,00 25,00 3 27,00 270,00 27,00 4 30,00 300,00 30,00 5 32,00 320,00 32,00 6 35,00 350,00 35,00 7 37,00 370,00 37,00 8 40,00 400,00 105,00 Statistique Moyenne (\\(\\mu\\)) 31,00 310,00 39,12 Étendue 18,00 180,00 83,00 Intervalle interquartile 10,00 100,00 10,00 Variance (population, \\(\\sigma^2\\)) 33,50 3 350,00 641,86 Écart-type (population, \\(\\sigma\\)) 5,79 57,88 25,33 Coefficient de variation (\\(\\sigma / \\mu\\)) 0,19 0,19 0,65 Tableau 2.5: Résumé de la sensibilité de la moyenne et des mesures de dispersion Statistique Unité de mesure Valeurs extrêmes Moyenne X X Étendue X X Intervalle interquartile X Variance X X Écart-type X X Coefficient de variation X 2.5.4 Paramètres de forme 2.5.4.1 Vérification de la normalité dune variable quantitative De nombreuses méthodes statistiques qui sont abordées dans les chapitres suivants  entre autres, la corrélation de Pearson, les test t et lanalyse de variance, les régressions simple et multiple  requièrent que la variable quantitative suive une distribution normale (nommée aussi distribution gaussienne). Dans cette sous-section, nous décrivons trois démarches pour vérifier si la distribution dune variable est normale : les coefficients dasymétrie et daplatissement (skewness et kurtosis en anglais), les graphiques (histogramme avec courbe normale et diagramme quantile-quantile), les tests de normalité (tests de Shapiro-Wilk, de Kolmogorov-Smirnov, de Lilliefors, dAnderson-Darling et de Jarque-Bera). Il est vivement recommandé de réaliser les trois démarches! Une distribution est normale quand elle est symétrique et mésokurtique (figure 2.26). Figure 2.26: Formes dune distribution et coefficients dasymétrie et daplatissement 2.5.4.1.1 Vérification de la normalité avec les coefficients dasymétrie et daplatissement Une distribution est dite symétrique quand la moyenne arithmétique est au centre de la distribution, cest-à-dire que les observations sont bien réparties de part et dautre de la moyenne qui est alors égale à la médiane et au mode (nous utilisons uniquement le mode pour une variable discrète et non pour une variable continue). Pour évaluer lasymétrie, nous utilisons habituellement le coefficient dasymétrie (skewness en anglais). Sachez toutefois quil existe trois façons (formules) pour le calculer (Joanes et Gill 1998) : \\(g_1\\) est la formule classique (équation (2.23)), disponible dans R avec la fonction skewness du package moments), \\(G_1\\) est une version ajustée (équation (2.24)), utilisée dans les logiciels SAS et SPSS notamment) et \\(b_1\\) est une autre version ajustée (équation (2.25)), utilisée par les logiciels MINITAB et BMDP). Nous verrons quavec les packages DescTools ou e1071, il est possible de calculer ces trois méthodes. Aussi, pour des grands échantillons (\\(n&gt;100\\)), il y a très peu de différences entre les résultats produits par ces trois formules (Joanes et Gill 1998). Quelle que soit la formule utilisée, le coefficient dasymétrie sinterprète comme suit (figure 2.27) : Quand la valeur du skewness est négative, la distribution est asymétrique négative. La distribution est alors tirée à gauche par des valeurs extrêmes faibles, mais peu nombreuses. Nous employons souvent lexpression la queue de distribution est étirée vers la gauche. La moyenne est alors inférieure à la médiane. Quand la valeur du skewness est égale à 0, la distribution est symétrique (la médiane est égale à la moyenne). Pour une variable discrète, les valeurs du mode, de la moyenne et de la médiane sont égales. Quand la valeur du skewness est positive, la distribution est symétrique positive. La distribution est alors tirée à droite par des valeurs extrêmes fortes, mais peu nombreuses. La queue de distribution est alors étirée vers la droite et la moyenne est supérieure à la médiane. En sciences sociales, les variables de revenu (totaux ou demploi, des individus ou des ménages) ont souvent des distributions asymétriques positives : la moyenne est affectée par quelques observations avec des valeurs de revenu très élevées et est ainsi supérieure à la médiane. En études urbaines, la densité de la population pour des unités géographiques dune métropole donnée (secteur de recensement par exemple) a aussi souvent une distribution asymétrique positive : quelques secteurs de recensement au centre de la métropole sont caractérisés par des valeurs de densité très élevées qui tirent la distribution vers la droite. \\[\\begin{equation} g_1=\\frac{ \\frac{1}{n} \\sum_{i=1}^n(x_i-\\bar{x})^3} { \\left[\\frac{1}{n}\\sum_{i=1}^n(x_i-\\bar{x})^2\\right] ^\\frac{3}{2}} \\tag{2.23} \\end{equation}\\] \\[\\begin{equation} G_1= \\frac{\\sqrt{n(n-1)}}{n-2} g_1 \\tag{2.24} \\end{equation}\\] \\[\\begin{equation} b_1= \\left( \\frac{n-1}{n} \\right) ^\\frac{3}{2} g_1 \\tag{2.25} \\end{equation}\\] Figure 2.27: Asymétrie dune distribution Pour évaluer laplatissement dune distribution, nous utilisons le coefficient daplatissement (kurtosis en anglais). Là encore, il existe trois formules pour le calculer (équation (2.26), (2.27), (2.28)) qui renvoient des valeurs très semblables pour de grands échantillons (Joanes et Gill 1998). Cette mesure sinterprète comme suit (figure 2.27) : Quand la valeur du kurtosis est négative, la distribution est platikurtique. La distribution est dite plate, cest-à-dire que la valeur de lécart-type est importante (comparativement à une distribution normale), signalant une grande dispersion des valeurs de part et dautre la moyenne. Quand la valeur du kurtosis est égale à 0, la distribution est mésokurtique, ce qui est typique dune distribution normale. Quand la valeur du kurtosis est positive, la distribution est leptokurtique, signalant que lécart-type (la dispersion des valeurs) est plutôt faible. Autrement dit, la dispersion des valeurs autour de la moyenne est faible. \\[\\begin{equation} g_2=\\frac{\\frac{1}{n}\\sum_{i=1}^n(x_i-\\bar{x})^4} {\\left( \\frac{1}{n}\\sum_{i=1}^n(x_i-\\bar{x})^2\\right)^2}-3 \\tag{2.26} \\end{equation}\\] \\[\\begin{equation} G_2 = \\frac{n-1}{(n-2)(n-3)} \\{(n+1) g_2 + 6\\} \\tag{2.27} \\end{equation}\\] \\[\\begin{equation} b_2 = (g_2 + 3) (1 - 1/n)^2 - 3 \\tag{2.28} \\end{equation}\\] Figure 2.28: Applatissement dune distribution Regardez attentivement les équations (2.26), (2.27), (2.28); vous remarquez que pour \\(g_2\\) et \\(b_2\\), il y a une soustraction de 3 et une addition 6 pour \\(G_2\\). Nous parlons alors de kurtosis normalisé (excess kurtosis en anglais). Pour une distribution normale, il prend la valeur de 0, comparativement à la valeur de 3 pour un kurtosis non normalisé. Par conséquent, avant de calculer le kurtosis, il convient de sassurer que la fonction que vous utilisez implémente une méthode de calcul normalisée (donnant une valeur de 0 pour une distribution normale). Par exemple, la fonction Kurt du package DescTools calcule les trois formules normalisées tandis que la fonction kurtosis du package moments renvoie un kurtosis non normalisé. library(DescTools) library(moments) # Générer une variable normalement distribuée avec 1000 observations Normale &lt;- rnorm(1500,0,1) round(DescTools::Kurt(Normale),3) ## [1] 0.024 round(moments::kurtosis(Normale),3) ## [1] 3.028 2.5.4.1.2 Vérification de la normalité avec des graphiques Les graphiques sont un excellent moyen de vérifier visuellement si une distribution est normale ou pas. Bien entendu, les histogrammes, que nous avons déjà largement utilisés, sont un incontournable. À titre de rappel, ils permettent de représenter la forme de la distribution des données (figure 2.29). Un autre type de graphique intéressant est le diagramme quantile-quantile (Q-Q plot en anglais), qui permet de comparer la distribution dune variable avec une distribution gaussienne (normale). Trois éléments composent ce graphique comme quillustré à la figure 2.30 : les points, représentant les observations de la variable; la distribution gaussienne (normale), représentée par une ligne; lintervalle de confiance à 95 % de la distribution normale (en marron sur la figure). Quand la variable est normalement distribuée, les points sont situés le long de la ligne. Plus les points localisés en dehors de lintervalle de confiance (bande marron) sont nombreux, plus la variable est alors anormalement distribuée. Figure 2.29: Histogrammes et courbe normale Figure 2.30: Diagrammes quantile-quantile 2.5.4.1.3 Vérification de la normalité avec des tests de normalité Cinq principaux tests dhypothèse permettent de vérifier la normalité dune variable : les tests de Kolmogorov-Smirnov (KS), de Lilliefors (LF), de Shapiro-Wilk (SW), dAnderson-Darling et de Jarque-Bera (JB). Sachez toutefois quil y en a dautres non discutés ici (tests de dAgostinoPearson, de Cramervon Mises, de Ryan-Joiner, de ShapiroFrancia, etc.). Pour les formules et une description détaillée de ces tests, vous pouvez consulter Razali et al. (2011) ou Yap et Sim (2011). Quel test choisir? Plusieurs auteur(e)s ont comparé ces différents tests à partir de plusieurs échantillons, et ce, en faisant varier la forme de la distribution et le nombre dobservations (Razali et Wah 2011; Yap et Sim 2011). Selon Razali et al. (2011), le meilleur test semble être celui de Shapiro-Wilk, puis ceux dAnderson-Darling, de Lilliefors et de Kolmogorov-Smirnov. Yap et Sim (2011) concluent aussi que le Shapiro-Wilk semble être le plus performant. Quoi quil en soit, ces cinq tests postulent que la variable suit une distribution gaussienne (hypothèse nulle, H0). Cela signifie que si la valeur de p associée à la valeur de chacun des tests est inférieure ou égale au seuil alpha choisi (habituellement \\(\\alpha=\\mbox{0,05}\\)), la distribution est anormale. À linverse, si \\(p&gt;\\mbox{0,05}\\), la distribution est normale. Tableau 2.6: Différents tests dhypothèse pour la normalité Test Propriétés et interprétation Fonction R Kolmogorov-Smirnov Plus sa valeur est proche de zéro, plus la distribution est normale. Lavantage de ce test est quil peut être utilisé pour vérifier si une variable suit la distribution de nimporte quelle loi (autre que la loi normale). ks.test du package stats Lilliefors Ce test est une adaptation du test de Kolmogorov-Smirnov. Plus sa valeur est proche de zéro, plus la distribution est normale. lillie.test du package nortest Shapiro-Wilk Si la valeur de la statistique de Shapiro-Wilk est proche de 1, alors la distribution est normale; anormale quand elle est inférieure à 1. shapiro.test du package stats Anderson-Darling Ce test est une modification du test de Cramer-von Mises (CVM). Il peut être aussi utilisé pour tester dautres distributions (uniforme, log-normale, exponentielle, Weibull, distribution de pareto généralisée, logistique, etc.). ad.test du package stats Jarque-Bera Basé sur un test du type multiplicateur de Lagrange, ce test utilise dans son calcul les valeurs du Skewness et du Kurtosis. Plus sa valeur sapproche de 0, plus la distribution est normale. Ce test est surtout utilisé pour vérifier si les résidus dun modèle de régression linéaire sont normalement distribués; nous y reviendrons dans le chapitre sur la régression multiple. Il sécrit \\(JB=\\frac{1}{6} \\left({g_1}^2+\\frac{{g_1}^2}{4} \\right)\\) avec \\(g_1\\) et \\(g_2\\) qui sont respectivement les valeurs du skewness et du kurtosis de la variable (voir les équations (2.23) et (2.26)). JarqueBeraTest du package DescTools Dans le tableau 2.7 sont reportées les valeurs des différents tests pour les cinq types de distribution générés à la figure 2.29. Sans surprise, pour lensemble des tests, la valeur de p est inférieure à 0,05 pour la distribution normale. Tableau 2.7: Tests de normalité pour différentes distributions Normale Asymétrie négative Asymétrie positive Leptokurtique Platikurtique Skewness 0,066 1,662 -1,340 -0,166 0,066 Kurtosis -0,110 5,122 2,313 7,946 -1,061 Kolmogorov-Smirnov (KS) 0,031 0,114 0,099 0,086 0,059 Lilliefors (LF) 0,031 0,114 0,099 0,086 0,059 Shapiro-Wilk (SW) 0,998 0,884 0,898 0,911 0,969 Anderson-Darling (AD) 0,298 11,594 11,595 8,659 3,785 Jarque-Bera (JB) 0,598 1 082,424 331,593 2 870,430 19,128 KS (valeur p) 0,718 0,000 0,000 0,001 0,062 LF (valeur p) 0,282 0,000 0,000 0,000 0,000 SW (valeur p) 0,705 0,000 0,000 0,000 0,000 AD (valeur p) 0,586 0,000 0,000 0,000 0,000 JB (valeur p) 0,742 0,000 0,000 0,000 0,000 La plupart des auteurs sentendent sur le fait que ces tests sont très restrictifs : plus la taille de votre échantillon est importante, plus les tests risquent de vous signaler que vos distributions sont anormales (à la lecture des valeurs de p). Certains conseillent même de ne pas les utiliser quand \\(n&gt;200\\) et de vous fier uniquement aux graphiques (histogramme et diagramme Q-Q)! Bref, vérifier la normalité dune variable nest pas une tâche si simple. De nouveau, nous vous conseillons vivement de : Construire les graphiques pour analyser visuellement la forme de la distribution (histogramme avec courbe normale et diagramme Q-Q). Calculer le skewness et le kurtosis. Calculer plusieurs tests (minimalement Shapiro-Wilk et Kolmogorov-Smirnov). Accorder une importance particulière aux graphiques lorsque vous traitez de grands échantillons (\\(n&gt;200\\)). 2.5.4.2 Tests pour dautres formes de distribution Comme nous lavons vu, la distribution normale nest que lune des multiples distributions existantes. Dans de nombreuses situations, elle ne sera pas adaptée pour décrire vos variables. La démarche à adopter pour trouver une distribution adaptée est la suivante : Définissez la nature de votre variable : identifier si elle est discrète ou continue et lintervalle dans lequel elle est définie. Une variable dont les valeurs sont positives ou négatives ne peut pas être décrite avec une distribution Gamma par exemple (à moins de la décaler). Explorez votre variable : affichez son histogramme et son graphique de densité pour avoir une vue générale de sa morphologie. Présélectionnez un ensemble de distributions candidates en tenant compte des observations précédentes. Vous pouvez également vous reporter à la littérature existante sur votre sujet détude pour inclure dautres distributions. Soyez flexible! Une variable strictement positive pourrait tout de même avoir une forme normale. De même, une variable décrivant des comptages suffisamment grands pourrait être mieux décrite par une distribution normale quune distribution de Poisson. Tentez dajuster chacune des distributions retenues à vos données et comparez les qualités dajustements pour retenir la plus adaptée. Pour ajuster une distribution à un jeu de données, il faut trouver les valeurs des paramètres de cette distribution qui lui permettent dadopter une forme la plus proche possible des données. Nous appelons cette opération ajuster un modèle, puisque la distribution théorique est utilisée pour modéliser les données. Lajustement des paramètres est un problème doptimisation que plusieurs algorithmes sont capables de résoudre (gradient descent, Newton-Raphson method, Fisher scoring, etc.). Dans R, le package fitdistrplus permet dajuster pratiquement nimporte quelle distribution à des données en offrant plusieurs stratégies doptimisation grâce à la fonction fitdist. Il suffit de disposer dune fonction représentant la distribution de densité ou de masse de la distribution en question, généralement noté dnomdeladistribution (dnorm, dgamma, dpoisson, etc.) dans R. Notez que certains packages comme VGAM ou gamlss.dist ajoutent un grand nombre de fonctions de densité et de masse à celles déjà disponibles de base dans R. Pour comparer lajustement de plusieurs distributions théoriques à des données, trois approches doivent être combinées : Observer graphiquement lajustement de la courbe théorique à lhistogramme des données. Cela permet déliminer au premier coup dil les distributions qui ne correspondent pas. Comparer les loglikelihood. Le loglikelihood est un score dajustement des distributions aux données. Pour faire simple, plus le loglikelihood est grand, plus la distribution théorique est proche des données. Référez-vous à lencadré suivant pour une description plus en profondeur du loglikelihood. Utiliser le test de Kolmogorov-Smirnov pour déterminer si une distribution particulière est mieux ajustée pour les données. Quest-ce-que le loglikelihood? Le loglikelihood est une mesure de lajustement dun modèle à des données. Il est utilisé à peu près partout en statistique. Comprendre sa signification est donc un exercice important pour développer une meilleure intuition du fonctionnement général de nombreuses méthodes. Si les concepts de fonction de densité et de fonction de masse vous semblent encore flous, reportez-vous à la section 2.4 sur les distributions dans un premier temps. Admettons que nous disposons dune variable continue v que nous tentons de modéliser avec une distribution d (il peut sagir de nimporte quelle distribution). d a une fonction de densité avec laquelle il est possible de calculer, pour chacune des valeurs de v, la probabilité dêtre observée selon le modèle d. Prenons un exemple concret dans R. Admettons que nous avons une variable comprenant 10 valeurs (oui, cest un petit échantillon, mais cest pour faire un exemple simple). v &lt;- c(5,8,7,8,10,4,7,6,9,7) moyenne &lt;- mean(v) ecart_type &lt;- sd(v) En calculant la moyenne et lécart-type de la variable, nous obtenons les paramètres dune distribution normale que nous pouvons utiliser pour représenter les données observées. En utilisant la fonction dnorm (la fonction de densité de la distribution normale), nous pouvons calculer la probabilité dobserver chacune des valeurs de v selon cette distribution normale. probas &lt;- dnorm(v, moyenne, ecart_type) df &lt;- data.frame(valeur = v, proba = probas) print(df) ## valeur proba ## 1 5 0.11203710 ## 2 8 0.19624888 ## 3 7 0.22228296 ## 4 8 0.19624888 ## 5 10 0.06009897 ## 6 4 0.04985613 ## 7 7 0.22228296 ## 8 6 0.18439864 ## 9 9 0.12689976 ## 10 7 0.22228296 Nous observons ainsi que les valeurs 7 et 8 sont très probables selon le modèle alors que les valeurs 4 et 10 sont très improbables. Le likelihood est simplement le produit de toutes ces probabilités. Il sagit donc de la probabilité conjointe davoir observé toutes les valeurs de v sous lhypothèse que d est la distribution produisant ces valeurs. Si d décrit efficacement v, alors le likelihood est plus grand que si d ne décrit pas efficacement v. Il sagit dune forme de raisonnement par labsurde : après avoir observé v, nous calculons la probabilité davoir observé v (likelihood) si notre modèle d était vrai. Si cette probabilité est très basse, alors cest que notre modèle est mauvais puisquon a bien observé v. likelihood_norm &lt;- prod(probas) print(likelihood_norm) ## [1] 3.322759e-09 Cependant, multiplier un grand nombre de valeurs inférieures à zéro tend à produire des chiffres infiniment petits et donc à complexifier grandement le calcul. Nous préférons donc utiliser le loglikelihood : lidée étant transformer les probabilités obtenues avec la fonction log puis dadditionner leurs résultats, puisque \\(log(xy) = log(x)+log(y)\\). loglikelihood_norm &lt;- sum(log(probas)) print(loglikelihood_norm) ## [1] -19.52247 Comparons ce loglikelihood à celui dun second modèle dans lequel nous utilisons toujours la distribution normale, mais avec une moyenne différente (faussée en ajoutant +3) : probas2 &lt;- dnorm(v, moyenne+3, ecart_type) loglikelihood_norm2 &lt;- sum(log(probas2)) print(loglikelihood_norm2) ## [1] -33.53631 Ce second loglikehood est plus faible, indiquant clairement que le premier modèle est plus adapté aux données. Passons à la pratique avec deux exemples. 2.5.4.2.1 Temps de retard des bus de la ville de Toronto Analysons les temps de retard pris par les bus de la ville de Toronto lorsquun évènement perturbe la circulation. Ce jeu de données est disponible sur le site des données ouvertes de la Ville de Toronto. Compte tenu de la grande quantité dobservations, nous avons fait le choix de nous concentrer sur les évènements ayant eu lieu durant le mois de janvier 2019. Puisque la variable étudiée est une durée exprimée en minutes, elle est strictement positive (supérieure à 0), car un bus avec zéro minute de retard est à lheure! Nous considérons également quun bus ayant plus de 150 minutes de retard (2 heures 30) nest tout simplement pas passé (personne ne risque dattendre 2 heures 30 pour prendre son bus). Commençons par charger les données et observer leur distribution empirique. library(ggplot2) # charger le jeu de données data_trt_bus &lt;- read.csv(&#39;data/univariee/bus-delay-2019_janv.csv&#39;, sep =&#39;;&#39;) # retirer les observations aberrantes data_trt_bus &lt;- subset(data_trt_bus, data_trt_bus$Min.Delay &gt; 0 &amp; data_trt_bus$Min.Delay &lt; 150) # représenter la distribution empirique du jeu de données ggplot(data = data_trt_bus) + geom_histogram(aes(x=Min.Delay, y = ..density..), bins = 40)+ geom_density(aes(x=Min.Delay), color = &#39;blue&#39;, bw = 2, size = 0.8)+ labs(x = &#39;temps de retard (en minutes)&#39;, y = &#39;&#39;) Figure 2.31: Distribution empirique des temps de retard des bus à Toronto en janvier 2019 Compte tenu de la forme de la distribution empirique et de sa nature, quatre distributions sont envisageables : La distribution Gamma, strictement positive et asymétrique, est aussi une généralisation de la distribution exponentielle utilisée pour modéliser des temps dattente. Pour des raisons similaires, nous pouvons aussi retenir la distribution de Weibull et la distribution log-normale. Nous écartons ici la distribution normale asymétrique puisque le jeu de données na clairement pas une forme normale au départ. La distribution de Pareto, strictement positive et permettant de représenter ici le fait que la plupart des retards durent moins de 10 minutes, mais que quelques retards sont également beaucoup plus longs. Commençons par ajuster les quatre distributions avec la fonction fitdist du package fitdistrplus et représentons-les graphiquement pour éliminer les moins bons candidats. Nous utilisons également le package actuar pour la fonction de densité de Pareto (dpareto). library(fitdistrplus) library(actuar) library(ggpubr) # ajustement des modèles model_gamma &lt;- fitdist(data_trt_bus$Min.Delay, distr = &quot;gamma&quot;) model_weibull &lt;- fitdist(data_trt_bus$Min.Delay, distr = &quot;weibull&quot;) model_lognorm &lt;- fitdist(data_trt_bus$Min.Delay, distr = &quot;lnorm&quot;) model_pareto &lt;- fitdist(data_trt_bus$Min.Delay, distr = &quot;pareto&quot;, start = list(shape = 1, scale = 1), method = &quot;mse&quot;) # différentes méthodes d&#39;optimisations # réalisation des graphiques plot1 &lt;- ggplot(data = data_trt_bus) + geom_histogram(aes(x=Min.Delay, y = ..density..), bins = 40)+ stat_function(fun = dgamma, color = &#39;red&#39;, size = 0.8, args = as.list(model_gamma$estimate))+ labs(x = &#39;temps de retard (en minutes)&#39;, y = &#39;&#39;, subtitle = &quot;Modèle Gamma&quot;) plot2 &lt;- ggplot(data = data_trt_bus) + geom_histogram(aes(x=Min.Delay, y = ..density..), bins = 40)+ stat_function(fun = dweibull, color = &#39;red&#39;, size = 0.8, args = as.list(model_weibull$estimate))+ labs(x = &#39;temps de retard (en minutes)&#39;, y = &#39;&#39;, subtitle = &quot;Modèle Weibull&quot;) plot3 &lt;- ggplot(data = data_trt_bus) + geom_histogram(aes(x=Min.Delay, y = ..density..), bins = 40)+ stat_function(fun = dlnorm, color = &#39;red&#39;, size = 0.8, args = as.list(model_lognorm$estimate))+ labs(x = &#39;temps de retard (en minutes)&#39;, y = &#39;&#39;, subtitle = &quot;Modèle log-normal&quot;) plot4 &lt;- ggplot(data = data_trt_bus) + geom_histogram(aes(x=Min.Delay, y = ..density..), bins = 40)+ stat_function(fun = dpareto, color = &#39;red&#39;, size = 0.8, args = as.list(model_pareto$estimate))+ labs(x = &#39;temps de retard (en minutes)&#39;, y = &#39;&#39;, subtitle = &quot;Modèle Pareto&quot;) ggarrange(plotlist = list(plot1, plot2, plot3, plot4), ncol = 2, nrow = 2) Figure 2.32: Comparaison des distributions ajustées aux données de retard des bus Visuellement, nous constatons que la distribution de Pareto est un mauvais choix. Pour les trois autres distributions, la comparaison des valeurs de loglikelihood simpose (tableau 2.8). df &lt;- data.frame(model = c(&quot;Gamma&quot;,&quot;Weibull&quot;, &quot;log-normal&quot;), loglikelihood = c(model_gamma$loglik, model_weibull$loglik, model_lognorm$loglik)) show_table(df, col.names = c(&quot;Distribution&quot;,&quot;LogLikelihood&quot;), caption = &#39;Comparaison des LogLikelihood des trois distributions&#39;, align= c(&quot;l&quot;, &quot;r&quot;) ) Tableau 2.8: Comparaison des LogLikelihood des trois distributions Distribution LogLikelihood Gamma -23 062,56 Weibull -23 195,54 log-normal -23 375,74 Le plus grand logLikelihood est obtenu par la distribution Gamma qui sajuste donc le mieux à nos données. Pour finir, nous pouvons tester formellement, avec le test de Kolmogorov-Smirnov, si les données proviennent bien de cette distribution Gamma. params &lt;- as.list(model_gamma$estimate) ks.test(data_trt_bus$Min.Delay, y = pgamma, shape = params$shape, rate = params$rate) ## ## One-sample Kolmogorov-Smirnov test ## ## data: data_trt_bus$Min.Delay ## D = 0.099912, p-value &lt; 2.2e-16 ## alternative hypothesis: two-sided Comme la valeur de p est inférieure à 0,05, nous ne pouvons pas accepter lhypothèse que notre jeu de données suit effectivement un loi de Gamma. Considérant le nombre dobservations et le fait que de nombreux temps dattente sont identiques (ce à quoi le test est très sensible), ce résultat nest pas surprenant. La distribution Gamma reste cependant la distribution qui représente le mieux nos données. Nous pouvons estimer grâce, à cette distribution, la probabilité quun bus ait un retard de plus de 10 minutes de la façon suivante : pgamma(10, shape = params$shape, rate = params$rate, lower.tail = F) ## [1] 0.5409424 ce qui correspond à 54 % de chance. Pour moins de 10 minutes : pgamma(10, shape = params$shape, rate = params$rate, lower.tail = T) ## [1] 0.4590576 soit 46 %. Un dernier exemple avec la probabilité quun retard dépasse 45 minutes : pgamma(45, shape = params$shape, rate = params$rate, lower.tail = F) ## [1] 0.01348194 Soit seulement 1,3 %. Par conséquent, si un matin à Toronto votre bus a plus de 45 minutes de retard, bravo, vous êtes tombé sur une des très rares occasions où un tel retard se produit! 2.5.4.2.2 Accidents de vélo à Montréal Le second jeu de données représente le nombre daccidents de la route impliquant un vélo sur les intersections dans les quartiers centraux de Montréal (2.33). Le jeu de données complet est disponible sur le site des données ouvertes de la Ville de Montréal. Puisque ces données correspondent à des comptages, la première distribution à envisager est la distribution de Poisson. Cependant, puisque nous aurons également un grand nombre dintersections sans accident, il serait judicieux de tester la distribution de Poisson avec excès de zéro. library(ggplot2) # charger le jeu de données data_accidents &lt;- read.csv(&#39;data/univariee/accidents_mtl.csv&#39;, sep =&#39;,&#39;) counts &lt;- data.frame(table(data_accidents$nb_accident)) names(counts) &lt;- c(&quot;nb_accident&quot;,&#39;frequence&#39;) counts$nb_accident &lt;- as.numeric(as.character(counts$nb_accident)) counts$prop &lt;- counts$frequence / sum(counts$frequence) # représenter la distribution empirique du jeu de donnée ggplot(data = counts) + geom_bar(aes(x=nb_accident, weight = frequence), width = 0.5)+ labs(x = &quot;nombre d&#39;accidents&quot;, y = &#39;fréquence&#39;) Figure 2.33: Distribution empirique du nombre daccidents par intersection impliquant un ou une cycliste à Montréal en 2017 dans les quartiers centraux Nous avons effectivement de nombreux zéros, alors essayons dajuster nos deux distributions à ce jeu de données. Dans la figure 2.34, les barres grises représentent la distribution empirique du jeu de données et les barres rouges, les distributions théoriques ajustées. Nous utilisons ici le package gamlss.dist pour avoir la fonction de masse dune distribution de Poisson avec excès de zéros. library(gamlss.dist) #ajuster le modèle de poisson model_poisson &lt;- fitdist(data_accidents$nb_accident, distr = &quot;pois&quot;) #ajuster le modèle de poisson avec excès de zéros model_poissonzi &lt;- fitdist(data_accidents$nb_accident, &quot;ZIP&quot;, start = list(mu = 4, sigma = 0.15), # valeurs pour faciliter la convergence optim.method = &quot;L-BFGS-B&quot;, # méthode d&#39;optimisation recommandée dans la documentation lower = c(0.00001, 0.00001), # valeurs minimales des deux paramètres upper = c(Inf, 1)# valeurs maximales des deux paramètres ) dfpoisson &lt;- data.frame(x=c(0:10), y=dpois(0:10, model_poisson$estimate) ) plot1 &lt;- ggplot() + geom_bar(aes(x=nb_accident, weight = prop), width = 0.6, data = counts)+ geom_bar(aes(x=x, weight = y), width = 0.15, data = dfpoisson, fill = &quot;red&quot;)+ scale_x_continuous(limits = c(-0.5,7), breaks = c(0:7))+ labs(subtitle = &quot;Modèle de Poisson&quot;, x = &quot;nombre d&#39;accidents&quot;, y = &quot;&quot;) dfpoissonzi &lt;- data.frame(x=c(0:10), y=dZIP(0:10, model_poissonzi$estimate[[1]], model_poissonzi$estimate[[2]]) ) plot2 &lt;- ggplot() + geom_bar(aes(x=nb_accident, weight = prop), width = 0.6, data = counts)+ geom_bar(aes(x=x, weight = y), width = 0.15, data = dfpoissonzi, fill = &quot;red&quot;)+ scale_x_continuous(limits = c(-0.5,7), breaks = c(0:7))+ labs(subtitle = &quot;Modèle de Poisson avec excès de zéro&quot;, x = &quot;nombre d&#39;accident&quot;, y = &quot;&quot;) ggarrange(plotlist = list(plot1,plot2), ncol = 2) Figure 2.34: Ajustement des distributions de Poisson et Poisson avec excès de zéros Visuellement, comme nous pouvons lobserver à la figure 2.34, le modèle avec excès de zéro semble simposer. Nous pouvons vérifier cette impression avec la comparaison des loglikelihood. print(model_poisson$loglik) ## [1] -989.83 print(model_poissonzi$loglik) ## [1] -931.8778 #afficher les paramètres ajustés model_poisson$estimate ## lambda ## 0.1991963 model_poissonzi$estimate ## mu sigma ## 0.6690301 0.7022605 Nous avons donc la confirmation que le modèle de Poisson avec excès de zéros est mieux ajusté. Nous apprenons donc que 70 % (sigma = 0,70) des intersections sont en fait exclues du phénomène étudié (probablement parce que très peu de cyclistes les utilisent ou parce quelles sont très peu accidentogènes) et que pour les autres, le taux daccidents par année en 2017 était de 0,67 (mu = 0,669, mu signifiant \\(\\lambda\\) pour le package gamlss). À nouveau, nous pouvons effectuer un test formel avec le fonction ks.test. params &lt;- as.list(model_poissonzi$estimate) ks.test(data_accidents$nb_accident, y = pZIP, mu = params$mu, sigma = params$sigma) ## ## One-sample Kolmogorov-Smirnov test ## ## data: data_accidents$nb_accident ## D = 0.85476, p-value &lt; 2.2e-16 ## alternative hypothesis: two-sided Encore une fois, nous devons rejeter lhypothèse selon laquelle le test suit une distribution de Poisson avec excès de zéros. Ces deux exemples montrent à quel point ce test est restrictif. 2.5.5 Transformation des variables 2.5.5.1 Transformations visant à atteindre la normalité Comme énoncé au début de cette section, plusieurs méthodes statistiques nécessitent que la variable quantitative soit normalement distribuée. Cest notamment le cas de lanalyse de variance et des tests t (abordés dans les chapitres suivants) qui fournissent des résultats plus robustes lorsque la variable est normalement distribuée. Plusieurs transformations sont possibles, les plus courantes étant la racine carrée, le logarithme et linverse de la variable. Selon plusieurs auteur(e)s (notamment, les statisticiennes Barbara G. Tabacknick et Linda S. Fidell (2007, 89)), en fonction du type (positive ou négative) et du degré dasymétrie, les transformations suivantes sont possibles afin daméliorer la normalité de la variable : Asymétrie positive modérée : la racine carrée de la variable X avec la fonction sqrt(df$x). Asymétrie positive importante : le logarithme de la variable avec log10(df$x). Asymétrie positive sévère : linverse de la variable avec 1/(df$x). Pour une valeur égale ou inférieure à 0, nous ne pouvons pas calculer une racine carrée ou un logarithme. Par conséquent, il convient de décaler simplement la distribution vers la droite afin de sassurer quil ny ait plus de valeurs négatives ou égales à 0 : sqrt(df$x - min(df$x+1))pour une asymétrie positive avec des valeurs négatives ou égales à 0 log(df$x - min(df$x+1))pour une asymétrie positive avec des valeurs négatives ou égales à 0 Par exemple, si la valeur minimale de la variable est égale à -10, la valeur minimale de variable décalée sera ainsi de 11. Asymétrie négative modérée : sqrt(max(df$x+1) - df$x) Asymétrie négative importante : log(max(df$x+1) - df$x) Asymétrie négative sévère : 1/(max(df$x+1) - df$x) Transformation des variables pour atteindre la normalité : ce nest pas toujours la panacée! La transformation des données fait et fera encore longtemps débat à la fois parmi les statisticien(ne)s, et les personnes utilisatrices débutantes ou avancées des méthodes quantitatives. Field et al. (2012, 193) résument le tout avec humour : « to transform or not transform, that is the question ». Avantages de la transformation Lobtention de résultats plus robustes. Dans une régression linéaire multiple, la transformation de la variable dépendante peut remédier au non-respect des hypothèses de base liées à la régression (linéarité et homoscédasticité des erreurs, absence de valeurs aberrantes, etc.). Inconvénients de la transformation Une variable transformée est plus difficile à interpréter puisque cela change lunité de mesure de la variable. Prenons un exemple concret : vous souhaitez comparer les moyennes de revenu de deux groupes A et B. Vous obtenez une différence de 15 000 $, soit une valeur facile à interpréter. Par contre, si la variable a été préalablement transformée en logarithme, il est possible que vous obteniez une différence de 9, ce qui est beaucoup moins parlant. Aussi, en transformant la variable en log, vous ne comparez plus les moyennes arithmétiques des deux groupes, mais plutôt leurs moyennes géométriques (Field, Miles et Field 2012, 193). Pourquoi perdre la forme initiale de la distribution du phénomène à expliquer? Il est possible, pour de nombreuses méthodes de choisir la distribution que nous souhaitons utiliser, il nest donc pas nécessaire de toujours se limiter à la distribution normale. Par exemple, dans les modèles de régression généralisés (GLM), nous pourrions indiquer que la variable indépendante suit une distribution de Student plutôt que de vouloir à tout prix la rendre normale. De même, certains tests non paramétriques permettent danalyser des variables ne suivant pas une distribution normale. Démarche à suivre avant et après la transformation La transformation est-elle nécessaire? Ne transformez jamais une variable sans avoir analysé rigoureusement sa forme (histogramme avec courbe normale, skewness et kurtosis, tests de normalité). Dautres options à la transformation dune variable dépendante (VD) sont-elles envisageables? Identifiez la forme de la distribution de la VD et utilisez au besoin un modèle GLM adapté à cette distribution. Autrement dit, ne transformez pas automatiquement votre VD simplement pour lintroduire dans une régression linéaire multiple. La transformation a-t-elle un apport significatif? Premièrement, vérifiez si la transformation utilisée (logarithme, racine carrée, inverse, etc.) améliore la normalité de la variable. Ce nest pas toujours le cas, parfois cest pire! Prenez soin de comparer les histogrammes, les valeurs de skewness, de kurtosis et des différents tests de normalité avant et après la transformation. Deuxièmement, comparez les résultats de vos analyses statistiques sans et avec transformation, et ce, dans une démarche coût-avantage. Vos résultats sont-ils bien plus robustes? Par exemple, un R2 qui passe de 0,597 à 0,602 (avant et après la transformation des variables) avec des associations significatives similaires, mais qui sont plus difficiles à interpréter (du fait des transformations), nest pas forcément un gain significatif. La modélisation en sciences sociales ne vise pas à prédire la trajectoire dun satellite ou latterrissage dun engin sur Mars! La précision à la quatrième décimale nest pas une condition! Par conséquent, un modèle un peu moins robuste, mais plus facile à interpréter est parfois préférable. 2.5.5.2 Autres types de transformations Les trois transformations les plus couramment utilisées sont : La côte \\(z\\) (z score en anglais) qui consiste à soustraire à chaque valeur sa moyenne (soit un centrage), puis à la diviser par son écart-type (soit une réduction) (équation (2.29)). Par conséquent, nous parlons aussi de variable centrée réduite qui a comme propriétés intéressantes une moyenne égale à 0 et un écart-type égal à 1 (la variance est aussi égale à 1 puisque 12 = 1). Nous verrons que cette transformation est largement utilisée dans les méthodes de classification (chapitre 13) et les méthodes factorielles (chapitre 12). \\[\\begin{equation} z= \\frac{x_i-\\mu}{\\sigma} \\tag{2.29} \\end{equation}\\] La transformation en rang qui consiste simplement à trier une variable en ordre croissant, puis à affecter le rang de chaque observation de 1 à \\(n\\). Cette transformation est très utilisée quand la variable est très anormalement distribuée, notamment pour calculer le coefficient de corrélation de Spearman (section 4.3.3) et certains tests non paramétriques (sections 6.1.2 et 6.2.2). La transformation sur une échelle de 0 à 1 (ou de 0 à 100) qui consiste à soustraite à chaque observation la valeur minimale et à diviser le tout par létendue (équation (2.30)). \\[\\begin{equation} X_{\\in\\lbrack0-1\\rbrack}= \\frac{x_i-max}{max-min} \\text{ ou } X_{\\in\\lbrack0-100\\rbrack}= \\frac{x_i-min}{max-min}\\times100 \\tag{2.30} \\end{equation}\\] Tableau 2.9: Illustration des trois transformations Observation \\(x_i\\) Côte \\(z\\) Rang 0 à 1 1 22,00 -1,45 1 0,00 2 27,00 -0,65 3 0,28 3 25,00 -0,97 2 0,17 4 30,00 -0,16 4 0,44 5 37,00 0,97 7 0,83 6 32,00 0,16 5 0,56 7 35,00 0,65 6 0,72 8 40,00 1,45 8 1,00 Moyenne 31,00 0,00 Écart-type 6,19 1,00 Pour un DataFrame, nommé df, comprenant une variable X, la syntaxe ci-dessous illustre comment obtenir quatre transformations (côte \\(z\\), rang, 0 à 1 et 0 à 100). df2 &lt;- data.frame(X = c(22,27,25,30,37,32,35,40)) # Transformation centrée réduite : côte Z df2$zX &lt;- (df2$X-mean(df2$X))/sd(df2$X) # ou encore avec la fonction scale df2$zX &lt;- scale(df2$X, center = TRUE, scale = TRUE) # Transformation en rang avec la fonction rank df2$rX &lt;- rank(df2$X) # Transformation de 0 à 1 ou de 0 à 100 df2$X01 &lt;- (df2$X-min(df2$X))/(max(df2$X)-min(df2$X)) df2$X0100 &lt;- (df2$X-min(df2$X))/(max(df2$X)-min(df2$X))*100 Ces trois transformations sont parfois utilisées pour générer un indice composite à partir de plusieurs variables ou encore dans une analyse de sensibilité avec les indices de Sobol (1993). 2.5.6 Mise en uvre dans R Il existe une multitude de packages dédiés au calcul des statistiques descriptives univariées. Par parcimonie, nous en utiliserons uniquement trois : DescTools, nortest et stats. Libre à vous de faire vos recherches sur Internet pour utiliser dautres packages au besoin. Les principales fonctions que nous utilisons ici sont : summary : pour obtenir un résumé sommaire des statistiques descriptives (minimum, Q1, Q2, Q3, maximum) mean : moyenne min : minimum max : maximum range : minimum et maximum quantile : quartiles quantile((x, probs = seq(.0, 1, by = .2)) : quintiles quantile((x, probs = seq(.0, 1, by = .1)) : déciles var : variance sd : écart-type Skew du package DescTools : coefficient dasymétrie Kurt du package DescTools : coefficient daplatissement ks.test(x, \"pnorm\", mean=mean(x), sd=sd(x)) du package nortest : test de Kolmogorov-Smirnov shapiro.test du package DescTools : test de Shapiro-Wilk lillie.test du package DescTools : du package nortest : test de Lilliefors ad.test du package DescTools : test dAnderson-Darling JarqueBeraTest du package DescTools : test de Jarque-Bera 2.5.6.1 Application à une seule variable Admettons que vous voulez obtenir des statistiques pour une seule variable présente dans un DataFrame (dataMTL$PctFRev) : library(DescTools) library(stats) library(nortest) # Importation du fichier csv dans un DataFrame dataMTL &lt;- read.csv(&quot;data/univariee/DataSR2016.csv&quot;) # Tableau sommaire pour la variable PctFRev summary(dataMTL$PctFRev) ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 1.846 11.242 15.471 16.822 20.229 68.927 # PARAMÈTRES DE TENDANCE CENTRALE mean(dataMTL$PctFRev) # Moyenne ## [1] 16.82247 median(dataMTL$PctFRev) # Médiane ## [1] 15.471 # PARAMÈTRES DE POSITION # Quartiles quantile(dataMTL$PctFRev) ## 0% 25% 50% 75% 100% ## 1.8460 11.2420 15.4710 20.2285 68.9270 # Quintiles quantile(dataMTL$PctFRev, probs = seq(.0, 1, by = .2)) ## 0% 20% 40% 60% 80% 100% ## 1.846 10.294 13.626 16.918 21.756 68.927 # Déciles quantile(dataMTL$PctFRev, probs = seq(.0, 1, by = .1)) ## 0% 10% 20% 30% 40% 50% 60% 70% 80% 90% 100% ## 1.846 8.402 10.294 12.172 13.626 15.471 16.918 18.868 21.756 26.854 68.927 # Percentiles personnalisés avec apply quantile(dataMTL$PctFRev, probs = c(0.01,.05,0.10,.25,.50,.75,.90,.95,.99)) ## 1% 5% 10% 25% 50% 75% 90% 95% 99% ## 5.2290 7.1470 8.4020 11.2420 15.4710 20.2285 26.8540 31.7530 45.6010 # PARAMÈTRES DE DISPERSION range(dataMTL$PctFRev) # Min et Max ## [1] 1.846 68.927 # Étendue max(dataMTL$PctFRev)-min(dataMTL$PctFRev) ## [1] 67.081 # Écart interquartile quantile(dataMTL$PctFRev)[4]-quantile(dataMTL$PctFRev)[2] ## 75% ## 8.9865 var(dataMTL$PctFRev) # Variance ## [1] 66.62482 sd(dataMTL$PctFRev) # Écart-type ## [1] 8.162403 sd(dataMTL$PctFRev) / mean(dataMTL$PctFRev) # CV ## [1] 0.4852083 # PARAMÈTRES DE FORME Skew(dataMTL$PctFRev) # Skewness ## [1] 1.67367 Kurt(dataMTL$PctFRev) # Kurtosis ## [1] 4.858815 # TESTS D&#39;HYPOTHÈSE SUR LA NORMALITÉ # K-Smirnov ks.test(dataMTL$PctFRev, &quot;pnorm&quot;, mean=mean(dataMTL$PctFRev), sd=sd(dataMTL$PctFRev)) ## ## One-sample Kolmogorov-Smirnov test ## ## data: dataMTL$PctFRev ## D = 0.10487, p-value = 1.646e-09 ## alternative hypothesis: two-sided shapiro.test(dataMTL$PctFRev) ## ## Shapiro-Wilk normality test ## ## data: dataMTL$PctFRev ## W = 0.88748, p-value &lt; 2.2e-16 lillie.test(dataMTL$PctFRev) ## ## Lilliefors (Kolmogorov-Smirnov) normality test ## ## data: dataMTL$PctFRev ## D = 0.10487, p-value &lt; 2.2e-16 ad.test(dataMTL$PctFRev) ## ## Anderson-Darling normality test ## ## data: dataMTL$PctFRev ## A = 21.072, p-value &lt; 2.2e-16 JarqueBeraTest(dataMTL$PctFRev) ## ## Robust Jarque Bera Test ## ## data: dataMTL$PctFRev ## X-squared = 2173.1, df = 2, p-value &lt; 2.2e-16 Pour construire un histogramme avec la courbe normale, consultez la section 3.2.1.3 ou la syntaxe ci-dessous. moyenne &lt;- mean(dataMTL$PctFRev) ecart_type &lt;- sd(dataMTL$PctFRev) ggplot(data = dataMTL) + geom_histogram(aes(x = PctFRev, y = ..density..), bins = 30, color = &quot;#343a40&quot;, fill = &quot;#a8dadc&quot;) + labs(x=&quot;personnes à faible revenu (%)&quot;, y = &quot;densité&quot;)+ stat_function(fun = dnorm, args = list(mean = moyenne, sd = ecart_type), color = &quot;#e63946&quot;, size = 1.2, linetype = &quot;dashed&quot;) Figure 2.35: Histogramme avec courbe normale 2.5.6.2 Application à plusieurs variables Pour obtenir des sorties de statistiques descriptives pour plusieurs variables, nous vous conseillons : de créer un vecteur avec les noms des variables (VarsSelect dans la syntaxe ci-dessous); dutiliser ensuite les fonctions sapply et apply. # Noms des variables du DataFrame names(dataMTL) ## [1] &quot;CTNAME&quot; &quot;PopTotal&quot; &quot;HabKm2&quot; ## [4] &quot;PctFRev&quot; &quot;TxChomage&quot; &quot;PctImmigrant&quot; ## [7] &quot;PctImgRecent&quot; &quot;PctMenage1pers&quot; &quot;PctFamilleMono&quot; ## [10] &quot;PctLangueMaternelleFR&quot; &quot;PctLangueMaternelleAN&quot; &quot;PctLangueMaternelleAU&quot; # Vecteur pour trois variables VarsSelect &lt;- c(&quot;HabKm2&quot;, &quot;TxChomage&quot;, &quot;PctFRev&quot; ) # Tableau sommaire pour les 3 variables summary(dataMTL[VarsSelect]) ## HabKm2 TxChomage PctFRev ## Min. : 18 Min. : 1.942 Min. : 1.846 ## 1st Qu.: 1980 1st Qu.: 5.482 1st Qu.:11.242 ## Median : 3773 Median : 7.130 Median :15.471 ## Mean : 5513 Mean : 7.743 Mean :16.822 ## 3rd Qu.: 7916 3rd Qu.: 9.391 3rd Qu.:20.229 ## Max. :50282 Max. :26.882 Max. :68.927 # PARAMÈTRES DE TENDANCE CENTRALE sapply(dataMTL[VarsSelect], mean) # Moyenne ## HabKm2 TxChomage PctFRev ## 5512.830705 7.743329 16.822470 sapply(dataMTL[VarsSelect], median) # Médiane ## HabKm2 TxChomage PctFRev ## 3773.000 7.130 15.471 # PARAMÈTRES DE POSITION # Quartiles sapply(dataMTL[VarsSelect], quantile) ## HabKm2 TxChomage PctFRev ## 0% 18.0 1.9420 1.8460 ## 25% 1980.5 5.4825 11.2420 ## 50% 3773.0 7.1300 15.4710 ## 75% 7915.5 9.3910 20.2285 ## 100% 50282.0 26.8820 68.9270 # Quintiles apply(dataMTL[VarsSelect], 2, function(x) quantile(x, probs = seq(.0, 1, by = .2))) ## HabKm2 TxChomage PctFRev ## 0% 18 1.942 1.846 ## 20% 1525 5.116 10.294 ## 40% 2953 6.422 13.626 ## 60% 4971 7.973 16.918 ## 80% 9509 10.000 21.756 ## 100% 50282 26.882 68.927 # Déciles apply(dataMTL[VarsSelect], 2, function(x) quantile(x, probs = seq(.0, 1, by = .1))) ## HabKm2 TxChomage PctFRev ## 0% 18 1.942 1.846 ## 10% 455 4.369 8.402 ## 20% 1525 5.116 10.294 ## 30% 2298 5.780 12.172 ## 40% 2953 6.422 13.626 ## 50% 3773 7.130 15.471 ## 60% 4971 7.973 16.918 ## 70% 6918 8.909 18.868 ## 80% 9509 10.000 21.756 ## 90% 13055 11.749 26.854 ## 100% 50282 26.882 68.927 # Percentiles personnalisés avec apply apply(dataMTL[VarsSelect], 2, function(x) quantile(x, probs = c(0.01,.05,0.10,.25,.50,.75,.90,.95,.99))) ## HabKm2 TxChomage PctFRev ## 1% 58.5 2.9665 5.2290 ## 5% 178.0 3.8980 7.1470 ## 10% 455.0 4.3690 8.4020 ## 25% 1980.5 5.4825 11.2420 ## 50% 3773.0 7.1300 15.4710 ## 75% 7915.5 9.3910 20.2285 ## 90% 13055.0 11.7490 26.8540 ## 95% 15355.0 13.8400 31.7530 ## 99% 18578.5 17.1920 45.6010 # PARAMÈTRES DE DISPERSION sapply(dataMTL[VarsSelect], range) # Min et Max ## HabKm2 TxChomage PctFRev ## [1,] 18 1.942 1.846 ## [2,] 50282 26.882 68.927 # Étendue sapply(dataMTL[VarsSelect], max) - sapply(dataMTL[VarsSelect], min) ## HabKm2 TxChomage PctFRev ## 50264.000 24.940 67.081 # Écart interquartile sapply(dataMTL[VarsSelect], quantile)[4,] - sapply(dataMTL[VarsSelect], quantile)[2,] ## HabKm2 TxChomage PctFRev ## 5935.0000 3.9085 8.9865 sapply(dataMTL[VarsSelect], var) # Variance ## HabKm2 TxChomage PctFRev ## 2.633462e+07 9.880932e+00 6.662482e+01 sapply(dataMTL[VarsSelect], sd) # Écart-type ## HabKm2 TxChomage PctFRev ## 5131.726785 3.143395 8.162403 # Coefficient de variation sapply(dataMTL[VarsSelect], sd) / sapply(dataMTL[VarsSelect], mean) ## HabKm2 TxChomage PctFRev ## 0.9308696 0.4059488 0.4852083 # PARAMÈTRES DE FORME sapply(dataMTL[VarsSelect], Skew) # Skewness ## HabKm2 TxChomage PctFRev ## 1.967468 1.280216 1.673670 sapply(dataMTL[VarsSelect], Kurt) # Kurtosis ## HabKm2 TxChomage PctFRev ## 8.546403 2.892443 4.858815 # TESTS D&#39;HYPOTHÈSE POUR LA NORMALITÉ # K-Smirnov apply(dataMTL[VarsSelect], 2, function(x) ks.test(x, &quot;pnorm&quot;, mean=mean(x), sd=sd(x))) ## $HabKm2 ## ## One-sample Kolmogorov-Smirnov test ## ## data: x ## D = 0.14899, p-value &lt; 2.2e-16 ## alternative hypothesis: two-sided ## ## ## $TxChomage ## ## One-sample Kolmogorov-Smirnov test ## ## data: x ## D = 0.080183, p-value = 9.778e-06 ## alternative hypothesis: two-sided ## ## ## $PctFRev ## ## One-sample Kolmogorov-Smirnov test ## ## data: x ## D = 0.10487, p-value = 1.646e-09 ## alternative hypothesis: two-sided sapply(dataMTL[VarsSelect], shapiro.test) # Shapiro-Wilk ## HabKm2 TxChomage ## statistic 0.8385086 0.9235146 ## p.value 5.648795e-30 1.451222e-21 ## method &quot;Shapiro-Wilk normality test&quot; &quot;Shapiro-Wilk normality test&quot; ## data.name &quot;X[[i]]&quot; &quot;X[[i]]&quot; ## PctFRev ## statistic 0.8874803 ## p.value 1.00278e-25 ## method &quot;Shapiro-Wilk normality test&quot; ## data.name &quot;X[[i]]&quot; sapply(dataMTL[VarsSelect], lillie.test) # Lilliefors ## HabKm2 ## statistic 0.148988 ## p.value 5.689619e-58 ## method &quot;Lilliefors (Kolmogorov-Smirnov) normality test&quot; ## data.name &quot;X[[i]]&quot; ## TxChomage ## statistic 0.0801829 ## p.value 7.758887e-16 ## method &quot;Lilliefors (Kolmogorov-Smirnov) normality test&quot; ## data.name &quot;X[[i]]&quot; ## PctFRev ## statistic 0.1048704 ## p.value 7.43257e-28 ## method &quot;Lilliefors (Kolmogorov-Smirnov) normality test&quot; ## data.name &quot;X[[i]]&quot; sapply(dataMTL[VarsSelect], ad.test) # Anderson-Darling ## HabKm2 TxChomage ## statistic 36.40276 14.9237 ## p.value 3.7e-24 3.7e-24 ## method &quot;Anderson-Darling normality test&quot; &quot;Anderson-Darling normality test&quot; ## data.name &quot;X[[i]]&quot; &quot;X[[i]]&quot; ## PctFRev ## statistic 21.07194 ## p.value 3.7e-24 ## method &quot;Anderson-Darling normality test&quot; ## data.name &quot;X[[i]]&quot; sapply(dataMTL[VarsSelect], JarqueBeraTest) # Jarque-Bera ## HabKm2 TxChomage ## statistic 4270.113 639.2741 ## parameter 2 2 ## p.value 0 0 ## method &quot;Robust Jarque Bera Test&quot; &quot;Robust Jarque Bera Test&quot; ## data.name &quot;X[[i]]&quot; &quot;X[[i]]&quot; ## PctFRev ## statistic 2173.082 ## parameter 2 ## p.value 0 ## method &quot;Robust Jarque Bera Test&quot; ## data.name &quot;X[[i]]&quot; 2.5.6.3 Transformation dune variable dans R La syntaxe ci-dessous illustre trois exemples de transformation (logarithme, racine carrée et inverse de la variable). Rappelez-vous quil faut comparer les valeurs de skewness et de kurtosis et des tests de Shapiro-Wilk avant et après les transformations pour identifier celle qui est la plus efficace. library(ggpubr) # Importation du fichier csv dans un DataFrame dataMTL &lt;- read.csv(&quot;data/univariee/DataSR2016.csv&quot;) # Noms des variables du DataFrame names(dataMTL) ## [1] &quot;CTNAME&quot; &quot;PopTotal&quot; &quot;HabKm2&quot; ## [4] &quot;PctFRev&quot; &quot;TxChomage&quot; &quot;PctImmigrant&quot; ## [7] &quot;PctImgRecent&quot; &quot;PctMenage1pers&quot; &quot;PctFamilleMono&quot; ## [10] &quot;PctLangueMaternelleFR&quot; &quot;PctLangueMaternelleAN&quot; &quot;PctLangueMaternelleAU&quot; # Transformations dataMTL$HabKm2_log &lt;- log10(dataMTL$HabKm2) dataMTL$HabKm2_sqrt &lt;- sqrt(dataMTL$HabKm2) dataMTL$HabKm2_inv &lt;- 1/dataMTL$HabKm2 # Vecteur pour la variable et les trois transformations VarsSelect &lt;- c(&quot;HabKm2&quot;, &quot;HabKm2_log&quot;, &quot;HabKm2_sqrt&quot;, &quot;HabKm2_inv&quot;) # paramètres de forme sapply(dataMTL[VarsSelect], Skew) # Skewness ## HabKm2 HabKm2_log HabKm2_sqrt HabKm2_inv ## 1.9674683 -1.2071326 0.4179037 8.2536901 sapply(dataMTL[VarsSelect], Kurt) # Kurtosis ## HabKm2 HabKm2_log HabKm2_sqrt HabKm2_inv ## 8.54640302 1.55670769 0.04563433 82.85604898 # TESTS D&#39;HYPOTHÈSE SUR LA NORMALITÉ sapply(dataMTL[VarsSelect], shapiro.test) ## HabKm2 HabKm2_log ## statistic 0.8385086 0.9113234 ## p.value 5.648795e-30 4.11156e-23 ## method &quot;Shapiro-Wilk normality test&quot; &quot;Shapiro-Wilk normality test&quot; ## data.name &quot;X[[i]]&quot; &quot;X[[i]]&quot; ## HabKm2_sqrt HabKm2_inv ## statistic 0.9771699 0.2530266 ## p.value 4.638049e-11 8.324983e-52 ## method &quot;Shapiro-Wilk normality test&quot; &quot;Shapiro-Wilk normality test&quot; ## data.name &quot;X[[i]]&quot; &quot;X[[i]]&quot; # Histogrammes avec courbe normale Graph1 &lt;- ggplot(data = dataMTL) + geom_histogram(aes(x = HabKm2, y = ..density..), bins = 30, color = &quot;#343a40&quot;, fill = &quot;#a8dadc&quot;) + labs(x=expression(&quot;Habitants au km&quot;^2), y = &quot;densité&quot;)+ stat_function(fun = dnorm, args = list(mean = mean(dataMTL$HabKm2), sd = sd(dataMTL$HabKm2)), color = &quot;#e63946&quot;, size = 1.2) Graph2 &lt;- ggplot(data = dataMTL) + geom_histogram(aes(x = HabKm2_log, y = ..density..), bins = 30, color = &quot;#343a40&quot;, fill = &quot;#a8dadc&quot;) + labs(x=expression(&quot;Logarithme d&#39;habitants au km&quot;^2), y = &quot;densité&quot;)+ stat_function(fun = dnorm, args = list(mean = mean(dataMTL$HabKm2_log), sd = sd(dataMTL$HabKm2_log)), color = &quot;#e63946&quot;, size = 1.2) Graph3 &lt;- ggplot(data = dataMTL) + geom_histogram(aes(x = HabKm2_sqrt, y = ..density..), bins = 30, color = &quot;#343a40&quot;, fill = &quot;#a8dadc&quot;) + labs(x=expression(&quot;Racine carrée d&#39;habitants au km&quot;^2), y = &quot;densité&quot;)+ stat_function(fun = dnorm, args = list(mean = mean(dataMTL$HabKm2_sqrt), sd = sd(dataMTL$HabKm2_sqrt)), color = &quot;#e63946&quot;, size = 1.2) Graph4 &lt;- ggplot(data = dataMTL) + geom_histogram(aes(x = HabKm2_inv, y = ..density..), bins = 30, color = &quot;#343a40&quot;, fill = &quot;#a8dadc&quot;) + labs(x=expression(&quot;Inverse d&#39;habitants au km&quot;^2), y = &quot;densité&quot;)+ stat_function(fun = dnorm, args = list(mean = mean(dataMTL$HabKm2_inv), sd = sd(dataMTL$HabKm2_inv)), color = &quot;#e63946&quot;, size = 1.2) ggarrange(plotlist = list(Graph1, Graph2, Graph3, Graph4), ncol = 2, nrow=2) Figure 2.36: Histogramme des transformations La variable HabKm2 est asymétrique positive et leptokurtique. Les valeurs des statistiques de forme et du test de Shapiro-Wilk ainsi que les histogrammes semblent démontrer que la transformation la plus efficace est la racine carrée. Si la variable originale est asymétrique positive, sa transformation logarithme est par contre asymétrique négative. Cela démontre que la transformation logarithmique nest pas toujours la panacée. References "],["sect026.html", "2.6 Statistiques descriptives sur des variables qualitatives et semi-qualitatives", " 2.6 Statistiques descriptives sur des variables qualitatives et semi-qualitatives 2.6.1 Fréquences En guise de rappel, les variables nominales, ordinales et semi-quantitatives comprennent plusieurs modalités pour lesquelles plusieurs types de fréquences sont généralement calculées. Pour illustrer le tout, nous avons extrait du recensement de 2016 de Statistique Canada les effectifs des modalités de la variable sur le principal mode de transport utilisé pour les déplacements domicile-travail, et ce, pour la subdivision de recensement (MRC) de lîle de Montréal (tableau 2.10). Les différents types de fréquences sont les suivantes : Les fréquences absolues simples (FAS) ou fréquences observées représentent le nombre dobservations pour chacune des modalités. Par exemple, sur 857 540 personnes réalisant des trajets domicile-travail (ligne totale), seulement 30 645 optent pour le vélo, alors que 427 530 conduisent un véhicule motorisé (automobile, camion ou fourgonnette) comme principal mode de transport. Les fréquences relatives simples (FRS) sont les proportions de chaque modalité sur le total (\\(\\mbox{30 645}/\\mbox{857 540}=\\mbox{0,036}\\)); leur somme est égale à 1. Elles peuvent bien entendu être exprimées en pourcentage (\\(\\mbox{30 645}/\\mbox{857 540} \\times \\mbox{100}=\\mbox{3,57}\\)); leur somme est alors égale à 100 %. Par exemple, 3,7 % de ces personnes utilisent le vélo comme mode de transport principal. Les fréquences absolues cumulées (FAC) représentent la fréquence observée (FAS) de la modalité à laquelle sont additionnées celles qui la précèdent. La valeur de la FAC pour la dernière est donc égale au total. À partir des fréquences absolues cumulées (FAC), il est alors possible de calculer les fréquences relatives cumulées (FRC) en proportion (\\(\\mbox{453 930}/\\mbox{857 540} = \\mbox{0,529}\\)) et en pourcentage (\\(\\mbox{453 930} / \\mbox{857 540} \\times \\mbox{100}= \\mbox{52,93}\\)). Par exemple, plus de la moitié des personnes utilisent lautomobile comme mode de transport principal (passagerère ou conductrice). Tableau 2.10: Différents types de fréquences sur une variable qualitative ou semi-qualitative Mode de transport FAS FRS FRS (%) FAC FRC FRC (%) Véhicule motorisé (conducteur(trice)) 427 530 0,499 49,86 427 530 0,499 49,86 Véhicule motorisé (passager(ère)) 26 400 0,031 3,08 453 930 0,529 52,93 Transport en commun 295 860 0,345 34,50 749 790 0,874 87,43 À pied 69 410 0,081 8,09 819 200 0,955 95,53 Bicyclette 30 645 0,036 3,57 849 845 0,991 99,10 Autre moyen 7 695 0,009 0,90 857 540 1,000 100,00 Total 857 540 1,000 100,00 Les fréquences cumulées : peu pertinentes pour les variables nominales Le calcul et lanalyse des fréquences cumulées (absolues et relatives) sont très souvent inutiles pour les variables nominales. Par exemple, au tableau 2.10, la fréquence cumulée relative (en %) est de 87,43 % pour la troisième ligne. Cela signifie que 87,43 % des navetteur(ve)s se déplacent en véhicule motorisé (conducteur(trice) ou passager(ère)) ou en transport en commun. Par contre, si la troisième modalité avait été à pied, le pourcentage aurait été de 61,02 (\\(\\mbox{52,93}+\\mbox{8,09}\\)). Si vous souhaitez calculer les fréquences cumulées sur une variable nominale, assurez-vous que lordre des modalités vous convient et de le modifier au besoin. Sinon, abstenez-vous de les calculer! Les fréquences cumulées : très utiles pour lanalyse des variables ordinales ou semi-quantitatives Pour des modalités hiérarchisées (variable ordinale ou semi-quantitative), lanalyse des fréquences cumulées (absolues et relatives) est par contre très intéressante. Par exemple, au tableau 2.11, elle permet de constater rapidement que sur lîle de Montréal, plus du quart de la population à moins de 25 ans (27,91 %) et 83,33 %, moins de 65 ans. Tableau 2.11: Différents types de fréquences sur une variable semi-qualitative Groupes dâge FAS FRS FRS (%) FAC FRC FRC (%) 0 à 14 ans 304 470 0,157 15,68 304 470 0,157 15,68 15 à 24 ans 237 555 0,122 12,23 542 025 0,279 27,91 25 à 44 ans 582 150 0,300 29,98 1 124 175 0,579 57,89 45 à 64 ans 494 205 0,254 25,45 1 618 380 0,833 83,33 65 à 84 ans 271 560 0,140 13,98 1 889 940 0,973 97,32 85 ans et plus 52 100 0,027 2,68 1 942 040 1,000 100,00 Total 1 942 040 1,000 100,00 Différents graphiques peuvent être construits pour illustrer la répartition des observations : les graphiques en barre (verticale et horizontale) avec les fréquences absolues et les diagrammes circulaires ou en anneau pour les fréquences relatives (figure 2.37). Ces graphiques seront présentés plus en détail dans le chapitre suivant. Figure 2.37: Différents graphiques pour représenter les fréquences absolues et relatives 2.6.2 Mise en uvre dans R La syntaxe ci-dessous permet de calculer les différentes fréquences présentées au tableau 2.11. Notez que pour les fréquences cumulées, nous utilisons la fonction cumsum. # Vecteur pour les noms des modalités Modalite &lt;- c(&quot;0 à 14 ans&quot;, &quot;15 à 24 ans&quot;, &quot;25 à 44 ans&quot;, &quot;45 à 64 ans&quot;, &quot;65 à 84 ans&quot;, &quot;85 ans et plus&quot;) # Vecteur pour les fréquences absolues simples (FAS) Navetteurs &lt;- c(304470,237555,582150,494205,271560,52100) # Somme des FAS sumFAS &lt;- sum(Navetteurs) # Construction du DataFrame avec les deux vecteurs df &lt;- data.frame( GroupeAge = Modalite, FAS = Navetteurs, FRS = Navetteurs / sumFAS, FRSpct = Navetteurs / sumFAS * 100, FAC = cumsum(Navetteurs), FRC = cumsum(Navetteurs) / sumFAS, FRCpct = cumsum(Navetteurs) / sumFAS * 100 ) df ## GroupeAge FAS FRS FRSpct FAC FRC FRCpct ## 1 0 à 14 ans 304470 0.15677844 15.677844 304470 0.1567784 15.67784 ## 2 15 à 24 ans 237555 0.12232240 12.232240 542025 0.2791008 27.91008 ## 3 25 à 44 ans 582150 0.29976211 29.976211 1124175 0.5788629 57.88629 ## 4 45 à 64 ans 494205 0.25447725 25.447725 1618380 0.8333402 83.33402 ## 5 65 à 84 ans 271560 0.13983234 13.983234 1889940 0.9731725 97.31725 ## 6 85 ans et plus 52100 0.02682746 2.682746 1942040 1.0000000 100.00000 "],["sect027.html", "2.7 Statistiques descriptives pondérées : pour aller plus loin", " 2.7 Statistiques descriptives pondérées : pour aller plus loin Dans la section 2.5, les différentes statistiques descriptives sur des variables quantitatives  paramètres de tendance centrale, de position, de dispersion et de forme  ont été largement abordées. Il est possible de calculer ces différentes statistiques en tenant compte dune pondération. La statistique descriptive pondérée la plus connue est certainement la moyenne arithmétique pondérée. Son calcul est très simple. Pour chaque observation, deux valeurs sont disponibles : \\(x_i\\), soit la valeur de la variable \\(X\\) pour lobservation \\(i\\) \\(w_i\\), soit la valeur de la pondération pour \\(i\\). Prenez soin de comparer les deux équations ci-dessous (à gauche, la moyenne arithmétique; à droite, la moyenne arithmétique pondérée). Vous constaterez rapidement quil suffit simplement de multiplier chaque observation par sa pondération (numérateur) et de diviser ce produit par la somme des pondérations (dénominateur; et non par \\(n\\), soit le nombre dobservations comme pour la moyenne arithmétique non pondérée). \\[\\begin{equation} \\bar{x}=\\frac{\\sum_{i=1}^n x_i}{n} \\text { versus } \\bar{m}=\\frac{\\sum_{i=1}^n w_ix_i}{\\sum_{i=1}^nw_i} \\tag{2.31} \\end{equation}\\] Tableau 2.12: Calcul de la moyenne pondérée Observation \\(x_i\\) \\(w_i\\) \\(x_i \\times w_i\\) 1 200 20 4 000 2 225 80 18 000 3 275 50 13 750 4 300 200 60 000 Somme 1 000 350 95 750 Moyenne 250 Moyenne pondérée 274 Calcul dautres statistiques descriptives pondérées Nous ne reportons pas ici les formules des versions pondérées de toutes les statistiques descriptives. Retenez toutefois le principe suivant permettant de les calculer à partir de lexemple du tableau 2.12. Pour la variable X, dupliquons respectivement 20, 80, 50, 200 fois les observations 1 à 4. Si nous calculons la moyenne arithmétique sur ces valeurs dupliquées, alors cette valeur est identique à celle de la moyenne arithmétique pondérée. Le même principe reposant sur la duplication des valeurs sapplique à lensemble des statistiques descriptives. Dans un article récent, Alvarenga et al. (2018) évaluent laccessibilité aux aires de jeux dans les parcs de la Communauté métropolitaine de Montréal (CMM). Pour les 881 secteurs de recensement de la CMM, ils ont calculé la distance à pied à laire de jeux la plus proche à travers le réseau de rues. Ce résultat, cartographié à la figure 2.38, permet davancer le constat suivant : « la quasi-totalité des secteurs de recensement de lagglomération de Montréal présente des distances de laire de jeux la plus proche inférieures à 500 m, alors que les secteurs situés à plus dun kilomètre dune aire de jeux sont très majoritairement localisés dans les couronnes nord et sud de la CMM » (De Alvarenga, Apparicio et Séguin 2018, 238). Pour chaque secteur de recensement, Alvarenga et al. (2018) disposent des données suivantes : \\(x_i\\), soit la distance à laire de jeux la plus proche pour le secteur de recensement i; \\(w_i\\), la pondération, soit le nombre denfants de moins de dix ans. Il est alors possible de calculer les statistiques descriptives de la proximité à laire de jeux la plus proche en tenant compte du nombre denfants résidant dans chaque secteur de recensement (tableau 2.13). Cet exercice permet de conclure que : « [] globalement, les enfants ont une bonne accessibilité aux aires de jeux sur le territoire de la CMM. [] Les enfants sont en moyenne à un peu plus de 500 m de laire de jeux la plus proche (moyenne = 559; médiane = 512). Toutefois, les valeurs percentiles extrêmes signalent que respectivement 10 % et 5 % des enfants résident à près de 800 m et à plus de 1000 m de laire de jeux la plus proche » (2018, 236). Figure 2.38: Accessibilité aux aires de jeux par secteur de recensement, Communauté métropolitaine de Montréal, 2016 Tableau 2.13: Statistiques de laire de jeux la plus proche, par secteur de recensement, pondérées par la population de moins de 10 ans N Moyenne P5 P10 Q1 Médiane Q3 P90 P95 881 559 282 327 408 512 640 799 1 006 De nombreux packages sont disponibles pour calculer des statistiques pondérées, dont notamment Weighted.Desc.Stat et Hmisc utilisés dans la syntaxe ci-dessous. library(foreign) library(Hmisc) library(Weighted.Desc.Stat) df &lt;- read.dbf(&quot;data/bivariee/SR_AireJeux_PopMoins10.dbf&quot;) head(df, n = 5) ## SRNOM PopMoins10 AireJeux ## 1 0659.06 380 600.1921 ## 2 0410.02 390 324.4396 ## 3 0863.01 325 524.3323 ## 4 0734.05 875 574.6682 ## 5 0073.00 100 352.9505 # xi (variable) et wi (pondération) x &lt;- df$AireJeux w &lt;- df$PopMoins10 # Calcul des paramètres de position # Moyenne Hmisc::wtd.mean(x, w) ## [1] 559.8026 Weighted.Desc.Stat::w.mean(x, w) ## [1] 559.8026 # Quartiles et percentile Hmisc::wtd.quantile(x, weights=w, probs=c(.05, .10, .25, .50, .75, .90, .95)) ## 5% 10% 25% 50% 75% 90% 95% ## 281.3623 327.3056 406.0759 511.5880 639.4813 798.6559 1011.5493 # Paramètres de dispersion avec le package Weighted.Desc.Stat # Variance, écart-type et coefficient de variation w.var(x,w) ## [1] 82818.18 w.sd(x,w) ## [1] 287.7815 w.cv(x,w) ## [1] 0.5140767 # Paramètres de forme avec le package Weighted.Desc.Stat # Skewness et kurtosis w.skewness(x, w) ## [1] 4.735351 w.kurtosis(x, w) ## [1] 41.17146 References "],["sect028.html", "2.8 Quiz de révision du chapitre", " 2.8 Quiz de révision du chapitre Le mode de transport (auto, vélo, marche, transport en commun) est : Relisez au besoin la section 2.1.2. une variable ordinale une variable continue une variable discrète une variable nominale Laquelle de ces deux options est la bonne? Relisez au besoin le début de la section 1.2. Variables qualitatives (nominales ou ordinales); variables quantitatives (continues et discrètes) Variables qualitatives (nominales ou discrètes); variables quantitatives (ordinales et discrètes) Des données collectées sur le terrain avec un GPS sont des données primaires spatiales. Relisez au besoin la section 2.2. Vrai Faux Lerreur écologique consiste à : Relisez au besoin la section 2.2.4. attribuer des résultats à partir de données individuelles à des territoires attribuer des constats obtenus à partir de données agrégées pour un territoire aux individus Laquelle de ces deux options est la bonne? Relisez au besoin la section 2.4. Fonctions de masse pour les distributions discrètes, fonctions de densité pour les distributions continues Fonctions de masse pour les distributions continues, fonctions de densité pour les distributions discrètes Quels sont les trois paramètres de tendance centrale? Relisez au besoin la section 2.5.1. Moyenne Médiane Variance Intervalle interquartile Mode Quels sont les paramètres position? Relisez au besoin la section 2.5.2. Quartiles Déciles Variance Centiles Quels sont les paramètres de dispersion? Relisez au besoin la section 2.5.3. Étendue Intervalle interquartile Variance Écart-type Comment vérifie-t-on quune variable est normalement distribuée? Relisez au besoin la section 2.5.4. Coefficients dasymétrie et daplatissement (skewness et kurtosis) Graphiques : histogramme avec courbe normale et diagramme quantile-quantile Tests de normalité (comme celui de Shapiro-Wilk) Examen des valeurs minimale et maximale Le centrage et la réduction dune variable consistent à : Relisez au besoin la section 2.5.5.2. soustraire à chaque valeur sa moyenne (soit un centrage), puis à la diviser par son écart-type. simplement à trier une variable en ordre croissant, puis à affecter le rang de chaque observation de 1 à n soustraite à chaque observation la valeur minimale et à diviser le tout par létendue. Verifier Votre score "],["chap03.html", "Chapitre 3 Magie des graphiques", " Chapitre 3 Magie des graphiques Dans ce chapitre, nous découvrons les incroyables capacités graphiques de R. Pour ce faire, nous couvrons en profondeur les fonctionnalités du package ggplot2 du tidyverse. Selon nous, il sagit de loin du meilleur package pour réaliser des graphiques. Dans ce chapitre, nous utilisons les packages suivants : Pour créer des graphiques : ggplot2, le seul, lunique! ggpubr pour combiner des graphiques. ggthemes pour utiliser des thèmes complémentaires pour les graphiques. Pour les couleurs : RColorBrewer pour accéder à des palettes de couleurs. Pour les graphiques spéciaux : chorddiag pour construire des graphiques daccord. fmsb pour construire des graphiques en radar. treemap pour construire une carte proportionnelle. wordcloud2 et textrank pour construire un nuage de mots. Pour les cartes : classInt pour calculer les intervalles des classes. ggsn pour afficher une échelle. tmap pour la cartographie. Autres packages : dplyr et reshape2 pour manipuler des données. pdftools pour extraire les textes des fichiers pdf. udpipe pour obtenir des dictionnaires linguistiques. sf pour manipuler des simple feature collections. Quest-ce que la visualisation de données? La représentation visuelle de données consiste à transposer des informations en une représentation graphique facilitant la lecture de ces dernières. Il sagit autant dun ensemble de méthodes, dun art que dun moyen de communication. Voici deux exemples marquants avant de détailler ce propos. La première illustration permet de visualiser le volume de plastique que représente la consommation deau en bouteille : 480 milliards de bouteilles vendues en 10 ans! Ce chiffre astronomique est inimaginable. En revanche, une montagne de plastique de 2400 mètres surplombant Manhattan marque davantage les esprits. Le second graphique représente quatre informations pour 234 villes à travers le monde : la croissance démographique (axe des abscisses), la vulnérabilité au changement climatique (axe des ordonnées), la taille des villes (taille des cercles), le continent sur lequel est localisée chaque ville (couleur des cercles). Le graphique est à la fois très accrocheur et esthétique. En un coup dil, nous constatons que les villes avec une forte croissance démographique sont aussi les plus vénérables (lecture des deux axes) et quelles sont surtout localisées en Afrique et secondairement en Asie (en rouge et orange), quelle que soit leur taille (taille du cercle). À linverse, les villes européennes et américaines (en bleu) sont beaucoup moins vulnérables aux changements climatiques et une croissance démographique plus faible, quelles soient de petites, de moyennes ou de grandes villes. Souvent négligée, la visualisation de données est perçue comme une tâche triviale : il sagit simplement de représenter une donnée sous forme dun graphique, car cest loption la plus pratique ou qui prend le moins despace. Pourtant, les avantages de la visualisation des données sont nombreux. Par exemple, la visualisation de données intègre aujourdhui des supports dynamiques comme des animations, des figures interactives ou des applications web. R offre dailleurs des possibilités très intéressantes en la matière avec des packages comme shiny, plotly ou leaflet. Toutefois, nous ne couvrons pas ici ces méthodes plus récentes en visualisation des données qui devraient faire lobjet dun autre livre. Les principaux avantages de la visualisation des données : Analyse exploratoire des données (exploratory data analysis - EDA en anglais). Visualiser des données est crucial pour détecter des problèmes en tout genre (données manquantes, valeurs extrêmes ou aberrantes, non-respect de conditions dapplication de tests statistiques, etc.), mais aussi pour repérer de nouvelles associations entre les variables. Communication de vos résultats. La raison dêtre dun graphique est de livrer un message clair relatif à un résultat obtenu suite à une analyse rigoureuse de vos données. Si votre graphique napporte aucune information claire, il vaut mieux ne pas le présenter, ni le diffuser. Les représentations ne sont pas neutres. Les couleurs et les formes ont des significations particulières en fonction de la culture et du contexte. Posez-vous donc toujours la question : à quel public est destiné le message? Évitez de surcharger vos visualisations de données, sinon lessence du message sera perdue. Aide à la décision. Une illustration (graphique ou carte) peut être un outil facilitant la prise de décisions. "],["sect031.html", "3.1 Philosophie du ggplot2", " 3.1 Philosophie du ggplot2 Le package ggplot2 fait partie du tidyverse et dispose dune logique de fonctionnement particulière. Cette dernière se nomme The Grammar of Graphics (les deux G sont dailleurs à lorigine du nom ggplot2), proposée par Hadley Wickham (le créateur du tidyverse!) dans un article intitulé A layered grammar of graphics (Wickham 2010). Nous proposons de synthétiser ici les concepts et principes centraux qui sous-tendent la production de graphiques avec ggplot2. 3.1.1 Grammaire Hadley Wickham propose une grammaire pour unifier la création de graphiques. Lidée est donc de dépasser les simples dénominations comme un nuage de points, un diagramme en boîte, un graphique en ligne, etc., pour comprendre ce qui relie tous ces graphiques. Ces éléments communs et centraux sont les géométries, les échelles et systèmes de coordonnées, et les annotations (figure 3.1) : Figure 3.1: Trois composantes dun graphique, adapté de Wickham (2010) Les géométries sont les formes utilisées pour représenter les données. Il peut sagir de points, de lignes, de cercles, de rectangles, darcs de cercle, etc. Les échelles et systèmes de coordonnées permettent de contrôler la localisation des éléments dans un graphique en convertissant les données depuis leur échelle originale (dollars, kilomètres, pourcentages, etc.) vers léchelle du graphique (pixels). Les annotations recoupent lensemble des informations complémentaires ajoutées au graphique comme son titre et sous-titre, la source des données, la mention sur les droits dauteurs, etc. En plus de ces trois éléments, il est bien sûr nécessaire de disposer de données. Ces dernières sont assignées à des dimensions du graphique pour être représentées (notamment les axes X et Y et la couleur). Cette étape est appelée aesthetics mapping dans ggplot2. Lorsque nous combinons des données, leur assignation a des dimensions, un type de géométries, des échelles et un système de coordonnées, nous obtenons un calque (layer en anglais). Un graphique peut comprendre plusieurs calques comme nous le verrons dans les prochaines sections. Prenons un premier exemple très simple et construisons un nuage de points à partir du jeu de données iris fourni de base dans R. Nous représentons la relation qui existe entre la longueur et la largeur des sépales de ces fleurs. Pour commencer, nous devons charger le package ggplot2 et instancier un graphique avec la fonction ggplot. library(ggplot2) data(iris) names(iris) ## [1] &quot;Sepal.Length&quot; &quot;Sepal.Width&quot; &quot;Petal.Length&quot; &quot;Petal.Width&quot; &quot;Species&quot; ggplot() Figure 3.2: Base dun graphique Pour le moment, le graphique est vide (figure 3.2). La seconde étape consiste à lui ajouter des données (au travers du paramètre data) et à définir les dimensions à associer aux données (avec le paramètre mapping et la fonction aes()). Dans notre cas, nous voulons utiliser les coordonnées X pour représenter la largeur des sépales, et les coordonnées Y pour représenter la longueur des sépales. Enfin, nous souhaitons représenter les observations par des points, nous utiliserons donc la géométrie geom_point. ggplot(mapping = aes(x = Sepal.Length, y = Sepal.Width), data = iris) + geom_point() Figure 3.3: Ajout des dimensions au graphique Ce graphique ne comprend quun seul calque avec une géométrie de type point (figure 3.3). Chaque calque est ajouté avec lopérateur + qui permet de superposer des calques, le dernier apparaissant au-dessus des autres. Les arguments mapping et data sont définis ici dans la fonction ggplot et sont donc appliqués à tous les calques qui composent le graphique. Il est aussi possible de définir mapping et data au sein des fonctions des géométries : ggplot() + geom_point(mapping = aes(x = Sepal.Length, y = Sepal.Width), data = iris) Figure 3.4: Autre spécification des arguments mapping et data La troisième étape consiste à ajouter au graphique des annotations. Pour notre cas, il faudrait ajouter un titre, un sous-titre et des intitulés plus clairs pour les axes X et Y, ce quil est possible de faire avec la fonction labs (figure 3.5). ggplot() + geom_point(mapping = aes(x = Sepal.Length, y = Sepal.Width), data = iris) + labs(title = &quot;Morphologie des sépales des iris&quot;, subtitle = &quot;n = 150&quot;, x = &quot;Longueur des sépales&quot;, y = &quot;Largeur des sépales&quot;) Figure 3.5: Ajout de titres 3.1.2 Types de géométries Le package ggplot2 permet dutiliser un très grand nombre de géométries différentes. Dans le tableau 3.1, nous avons reporté les principales géométries disponibles afin que vous puissiez vous faire une idée du « bestiaire » existant. Il ne sagit que dun extrait des principales fonctions. Sachez quil existe aussi des packages proposant des géométries supplémentaires pour compléter ggplot2. Tableau 3.1: Principales géométries proposées par ggplot2 Géométrie Fonction point geom_point ligne geom_line chemin geom_path boîte à moustaches geom_boxplot diagramme violon geom_violin histogramme geom_histogram barre geom_bar densité geom_density texte geom_label barre derreur geom_errorbar surface geom_ribbon 3.1.3 Habillage Dans le premier exemple, nous avons montré comment ajouter le titre, le sous-titre et les titres des axes sur un graphique. Il est aussi possible dajouter du texte sous le graphique (généralement la source des données avec largument caption) et des annotations textuelles (annotate). Pour ces dernières, il convient de spécifier leur localisation (coordonnées x et y) et le texte à intégrer (label); elles sont ensuite ajoutées au graphique avec lopérateur +. Ajoutons deux annotations pour identifier deux fleurs spécifiques. ggplot() + geom_point(mapping = aes(x = Sepal.Length, y = Sepal.Width), data = iris) + labs(title = &quot;Morphologie des sépales des iris&quot;, subtitle = &quot;n = 150&quot;, x = &quot;Longueur des sépales&quot;, y = &quot;Largeur des sépales&quot;, caption = &quot;Source : jeu de données iris&quot;) + annotate(&quot;text&quot;, x = 6.7, y = 2.5, # position de la note label = &quot;une virginica&quot;, # texte de la note hjust = &quot;left&quot;, vjust = &quot;top&quot;, # ajustement size = 3, fontface = &quot;italic&quot;) + annotate(&quot;text&quot;, x = 5.7, y = 4.4, # position de la note label = &quot;une setosa&quot;, # texte de la note hjust = &quot;left&quot;, vjust = &quot;top&quot;, # ajustement size = 3, fontface = &quot;italic&quot;) Figure 3.6: Ajout dannotations textuelles Comme vous pouvez le constater, de nombreux paramètres permettent de contrôler le style des annotations. Pour avoir la liste des arguments disponibles, nhésitez pas à afficher laide de la fonction : help(annotate). En plus des annotations de type texte, il est possible dajouter des annotations de type géométrique. Nous pourrions ainsi délimiter une boîte encadrant les fleurs de lespère setosa. setosas &lt;- subset(iris, iris$Species == &quot;setosa&quot;) sepal.length_extent &lt;- c(min(setosas$Sepal.Length),max(setosas$Sepal.Length)) sepal.width_extent &lt;- c(min(setosas$Sepal.Width),max(setosas$Sepal.Width)) ggplot() + geom_point(mapping = aes(x = Sepal.Length, y = Sepal.Width), data = iris) + labs(title = &quot;Morphologie des sépales des iris&quot;, subtitle = &quot;n = 150&quot;, x = &quot;Longueur des sépales&quot;, y = &quot;Largeur des sépales&quot;, caption = &quot;Source : jeu de données iris&quot;) + annotate(&quot;text&quot;, x = 6.7, y = 2.5, # position de la note label = &quot;une virginica&quot;, # texte de la note hjust = &quot;left&quot;, vjust = &quot;top&quot;, # ajustement size = 3, fontface = &quot;italic&quot;) + annotate(&quot;text&quot;, x = 5.7, y = 4.4, # position de la note label = &quot;une setosa&quot;, # texte de la note hjust = &quot;left&quot;, vjust = &quot;top&quot;, # ajustement size = 3, fontface = &quot;italic&quot;) + annotate(&quot;rect&quot;, ymin = sepal.width_extent[[1]], ymax = sepal.width_extent[[2]], xmin = sepal.length_extent[[1]], xmax = sepal.length_extent[[2]], fill = rgb(0.7,0.7,0.7,.5), # remplissage transparent à 50% color = &quot;black&quot;) # contour de couleur verte Figure 3.7: Ajout dannotations géométriques Comme le dernier calque ajouté au graphique est le rectangle, vous noterez quil recouvre tous les calques existant, y compris les précédentes annotations. Pour corriger cela, il suffit de changer lordre des calques. ggplot() + annotate(&quot;rect&quot;, ymin = sepal.width_extent[[1]], ymax = sepal.width_extent[[2]], xmin = sepal.length_extent[[1]], xmax = sepal.length_extent[[2]], fill = rgb(0.7,0.7,0.7,.5), # remplissage transparent à 50% color = &quot;green&quot;) + # contour de couleur verte geom_point(mapping = aes(x = Sepal.Length, y = Sepal.Width), data = iris) + labs(title = &quot;Morphologie des sépales des iris&quot;, subtitle = &quot;n = 150&quot;, x = &quot;Longueur des sépales&quot;, y = &quot;Largeur des sépales&quot;, caption = &quot;Source : jeu de données iris&quot;) + annotate(&quot;text&quot;, x = 6.7, y = 2.5, # position de la note label = &quot;une virginica&quot;, # texte de la note hjust = &quot;left&quot;, vjust = &quot;top&quot;, # ajustement size = 3, fontface = &quot;italic&quot;) + annotate(&quot;text&quot;, x = 5.7, y = 4.4, # position de la note label = &quot;une setosa&quot;, # texte de la note hjust = &quot;left&quot;, vjust = &quot;top&quot;, # ajustement size = 3, fontface = &quot;italic&quot;) Figure 3.8: Gestion de lordre des annotations 3.1.4 Utilisation des thèmes De nombreux autres éléments peuvent être modifiés dans un graphique comme les paramètres des polices, larrière-plan, la grille de repères, etc. Il peut être fastidieux de paramétrer tous ces éléments. Une option intéressante est dutiliser des thèmes déjà préconstruits. Le package ggplot2 propose une dizaine de thèmes : constatons leur impact sur le graphique précédent. Le thème classique (theme_classic) (figure 3.9) ggplot() + geom_point(mapping = aes(x = Sepal.Length, y = Sepal.Width), data = iris) + labs(title = &quot;Morphologie des sépales des iris&quot;, subtitle = &quot;n = 150&quot;, x = &quot;Longueur des sépales&quot;, y = &quot;Largeur des sépales&quot;, caption = &quot;Source : jeu de données iris&quot;) + theme_classic() Figure 3.9: Thème classique Le thème gris (theme_gray) (figure 3.10) ggplot() + geom_point(mapping = aes(x = Sepal.Length, y = Sepal.Width), data = iris) + labs(title = &quot;Morphologie des sépales des iris&quot;, subtitle = &quot;n = 150&quot;, x = &quot;Longueur des sépales&quot;, y = &quot;Largeur des sépales&quot;, caption = &quot;Source : jeu de données iris&quot;) + theme_gray() Figure 3.10: Thème gris Le thème noir et blanc (theme_bw) (figure 3.11) ggplot() + geom_point(mapping = aes(x = Sepal.Length, y = Sepal.Width), data = iris) + labs(title = &quot;Morphologie des sépales des iris&quot;, subtitle = &quot;n = 150&quot;, x = &quot;Longueur des sépales&quot;, y = &quot;Largeur des sépales&quot;, caption = &quot;Source : jeu de données iris&quot;) + theme_bw() Figure 3.11: Thème noir et blanc Le thème minimal (theme_minimal) (figure 3.12) ggplot() + geom_point(mapping = aes(x = Sepal.Length, y = Sepal.Width), data = iris) + labs(title = &quot;Morphologie des sépales des iris&quot;, subtitle = &quot;n = 150&quot;, x = &quot;Longueur des sépales&quot;, y = &quot;Largeur des sépales&quot;, caption = &quot;Source : jeu de données iris&quot;) + theme_minimal() Figure 3.12: Thème minimal Il est aussi possible dutiliser le package ggthemes qui apporte des thèmes complémentaires intéressants dont : Le thème tufte (theme_tufte, à lancienne) (figure 3.13) library(ggthemes) ggplot() + geom_point(mapping = aes(x = Sepal.Length, y = Sepal.Width), data = iris) + labs(title = &quot;Morphologie des sépales des iris&quot;, subtitle = &quot;n = 150&quot;, x = &quot;Longueur des sépales&quot;, y = &quot;Largeur des sépales&quot;, caption = &quot;Source : jeu de données iris&quot;) + theme_tufte() Figure 3.13: Thème tufte Le thème economist (theme_economist, inspiré de la revue du même nom) (figure 3.14) ggplot() + geom_point(mapping = aes(x = Sepal.Length, y = Sepal.Width), data = iris) + labs(title = &quot;Morphologie des sépales des iris&quot;, subtitle = &quot;n = 150&quot;, x = &quot;Longueur des sépales&quot;, y = &quot;Largeur des sépales&quot;, caption = &quot;Source : jeu de données iris&quot;) + theme_economist() Figure 3.14: Thème economist Le thème solarized (theme_solarized, plus original) (figure 3.15) ggplot() + geom_point(mapping = aes(x = Sepal.Length, y = Sepal.Width), data = iris) + labs(title = &quot;Morphologie des sépales des iris&quot;, subtitle = &quot;n = 150&quot;, x = &quot;Longueur des sépales&quot;, y = &quot;Largeur des sépales&quot;, caption = &quot;Source : jeu de données iris&quot;) + theme_solarized() Figure 3.15: Thème solarized Il en existe bien dautres et vous pouvez composer vos propres thèmes. Nhésitez pas à explorer la documentation de ggplot2 et de ggthemes pour en apprendre plus! 3.1.5 Composition dune figure avec plusieurs graphiques Il est très fréquent de vouloir combiner plusieurs graphiques dans une même figure. Deux cas se distinguent : Les données pour les différents graphiques proviennent du même DataFrame et peuvent être distinguées selon une variable catégorielle. Lobjectif est alors de dupliquer le même graphique, mais pour des sous-groupes de données. Dans ce cas, nous recommandons dutiliser la fonction facet_wrap de ggplot2. Les graphiques sont complètement indépendants. Dans ce cas, nous recommandons dutiliser la fonction ggarrange du package ggpubr. 3.1.5.1 ggplot2 et ses facettes Nous pourrions souhaiter réaliser une figure composite avec le jeu de données iris et séparer notre nuage de points en trois graphiques distincts selon lespèce des iris (figure 3.16). Pour cela, il faut au préalable convertir la variable espèce en facteur. iris$Species_fac &lt;- as.factor(iris$Species) ggplot() + geom_point(mapping = aes(x = Sepal.Length, y = Sepal.Width), data = iris) + labs(title = &quot;Morphologie des sépales des iris&quot;, subtitle = &quot;n = 150&quot;, x = &quot;Longueur des sépales&quot;, y = &quot;Largeur des sépales&quot;, caption = &quot;Source : jeu de données iris&quot;) + facet_wrap(vars(Species_fac), ncol=2) Figure 3.16: Graphique à facettes Notez que le nom de la variable (ici Species_fac) doit être spécifié au sein dune sous-fonction vars : vars(Species_fac). Nous aurions aussi pu réaliser le graphique sur une seule ligne en spécifiant ncol = 3 (figure 3.17). ggplot() + geom_point(mapping = aes(x = Sepal.Length, y = Sepal.Width), data = iris) + labs(title = &quot;Morphologie des sépales des iris&quot;, subtitle = &quot;n = 150&quot;, x = &quot;Longueur des sépales&quot;, y = &quot;Largeur des sépales&quot;, caption = &quot;Source : jeu de données iris&quot;) + facet_wrap(vars(Species_fac), ncol=3) Figure 3.17: Graphique à facettes en une ligne 3.1.5.2 Arrangement des graphiques La solution avec les facettes est très pratique, mais également très limitée puisquelle ne permet pas de créer une figure avec des graphiques combinant plusieurs types de géométries. ggarrange du package ggpubr permet tout simplement de combiner des graphiques déjà existant. Créons deux nuages de points comparant plusieurs variables en fonction de lespèce des iris, puis combinons-les (figure 3.18). Attribuons également aux points une couleur en fonction de lespèce des fleurs, afin de mieux les distinguer en associant la variable Species au paramètre color. library(ggpubr) plot1 &lt;- ggplot(data = iris) + geom_point(aes(x = Sepal.Length, y = Sepal.Width, color = Species)) + labs(subtitle = &quot;Caractéristiques des sépales&quot;, x = &quot;Longueur&quot;, y = &quot;Largeur&quot;, color = &quot;Espèce&quot;) plot2 &lt;- ggplot(data = iris) + geom_point(aes(x = Petal.Length, y = Petal.Width, color = Species)) + labs(subtitle = &quot;Caractéristiques des pétales&quot;, x = &quot;Longueur&quot;, y = &quot;Largeur&quot;, color = &quot;Espèce&quot;) liste_plots &lt;- list(plot1, plot2) comp_plot &lt;- ggarrange(plotlist = liste_plots, ncol = 2, nrow = 1, common.legend = TRUE, legend = &quot;bottom&quot;) #gérer la légende annotate_figure(comp_plot, top = text_grob(&quot;Morphologie des sépales et pétales des iris&quot;, face = &quot;bold&quot;, size = 12, just = &quot;center&quot;), bottom = text_grob(&quot;Source : jeu de données iris&quot;, face = &quot;italic&quot;, size = 8, just = &quot;left&quot;) ) Figure 3.18: Figure avec plusieurs graphiques avec ggarrange Quatre étapes sont nécessaires : Créer les graphiques et les enregistrer dans des objets (ici plot1 et plot2). Encapsuler ces objets dans une liste (ici liste_plots). Composer la figure finale avec la fonction ggarrange. Ajouter les annotations à la figure composite. Largument common.legend permet dindiquer à la fonction ggarrange de regrouper les légendes des deux graphiques. Dans notre cas, les deux graphiques ont les mêmes légendes, il est donc judicieux de les regrouper. Largument legend contrôle la position de la légende et peut prendre les valeurs : top, bottom, left, right ou none (absence de légende). La fonction annotate_figure permet dajouter des éléments de texte au-dessus, au-dessous et sur les cotés de la figure composite. 3.1.6 Couleur Dans un graphique, la couleur peut être utilisée à la fois pour représenter une variable quantitative (dégradé de couleur ou mise en classes), ou une variable qualitative (couleur par catégorie). Dans ggplot2, il est possible dattribuer une couleur au contour des géométries avec largument color et au remplissage avec largument fill. Il est possible de spécifier une couleur de trois façons dans R : En utilisant le nom de la couleur dans une chaîne de caractère : \"chartreuse4\". R dispose de 657 noms de couleurs prédéfinis. Pour tous les afficher, utilisez la fonction colors(), qui permet de les visualiser (figure 3.19). Figure 3.19: Couleurs de base En indiquant le code hexadécimal de la couleur. Il sagit dune suite de six lettres et de chiffres précédée par un dièse : \"#99ff33\". En utilisant une notation RGB (rouge, vert, bleu, transparence). Cette notation doit contenir quatre nombres entre 0 et 1 (0 % et 100 %), indiquant respectivement la quantité de rouge, de vert, de bleu et la transparence. Ces quatre nombres sont donnés comme argument à la fonction rgb : rgb(0.6, 1, 0.2, 0). Le choix des couleurs est un problème plus complexe que la manière de les spécifier. Il existe dailleurs tout un pan de la sémiologie graphique dédié à la question du choix et de lassociation des couleurs. Une première ressource intéressante est ColorBrewer. Il sagit dune sélection de palettes de couleurs particulièrement efficaces et dont certaines sont même adaptées pour les personnes daltoniennes (figure 3.20). Il est possible daccéder directement aux palettes dans R grâce au package RColorBrewer et la fonction brewer.pal : library(RColorBrewer) display.brewer.all() Figure 3.20: Palette de couleurs de ColorBrewer Une autre ressource pertinente est le site web coolors.co qui propose de nombreuses palettes à portée de clic. References "],["sect032.html", "3.2 Principaux graphiques", " 3.2 Principaux graphiques Puisque vous avez désormais une certaine connaissance des bases de la grammaire des graphiques implémentées par ggplot2, vous apprendrez dans les sous-sections suivantes à construire les principaux graphiques que vous utiliserez régulièrement ou que vous présenterez dans un article scientifique. 3.2.1 Histogramme Lhistogramme permet de décrire graphiquement la forme de la distribution dune variable. Pour le réaliser, nous utilisons la fonction geom_histogram. Le paramètre le plus important est le nombre de barres (bins) qui composent lhistogramme. Plus ce nombre est grand, plus lhistogramme est précis et, à linverse, plus il est petit, plus lhistogramme est simplifié. En revanche, il faut éviter dutiliser un nombre de barres trop élevé comparativement au nombre dobservations disponibles dans le jeu de données, sinon lhistogramme risque davoir plein de trous. 3.2.1.1 Histogramme simple Générons quatre variables ayant respectivement une distribution gaussienne, Student, Gamma et bêta, puis réalisons un histogramme pour chacune de ces variables et combinons-les avec la fonction ggarrange (figure 3.21). distribs &lt;- data.frame( gaussien = rnorm(1000, mean = 5, sd = 1.5), gamma = rgamma(1000, shape = 2, rate = 12), beta = rbeta(1000,shape1 = 5, shape2 = 1, ncp = 2), student = rt(1000,ncp = 20, df = 5) ) plot1 &lt;- ggplot(data = distribs) + geom_histogram(aes(x = gaussien), bins = 50, color = &quot;#343a40&quot;, fill = &quot;#e63946&quot;)+ labs(y=&quot;fréquences&quot;)+ylim(c(0,130)) plot2 &lt;- ggplot(data = distribs) + geom_histogram(aes(x = gamma), bins = 50, color = &quot;#343a40&quot;, fill = &quot;#f1faee&quot;)+ labs(y=&quot;fréquences&quot;)+ylim(c(0,130)) plot3 &lt;- ggplot(data = distribs) + geom_histogram(aes(x = beta), bins = 50, color = &quot;#343a40&quot;, fill = &quot;#a8dadc&quot;)+ labs(y=&quot;fréquences&quot;)+ylim(c(0,130)) plot4 &lt;- ggplot(data = distribs) + geom_histogram(aes(x = student), bins = 50, color = &quot;#343a40&quot;, fill = &quot;#1d3557&quot;)+ labs(y=&quot;fréquences&quot;)+ylim(c(0,130)) histogrammes &lt;- list(plot1, plot2, plot3, plot4) ggarrange(plotlist = histogrammes, ncol = 2, nrow = 2) Figure 3.21: Histogrammes Notez que cette syntaxe est très lourde. Dans le cas présent, il serait plus judicieux dutiliser la fonction facet_wrap. Pour cela, nous devons au préalable empiler nos données, ce qui signifie changer la forme du DataFrame actuel, qui comprend quatre colonnes (gaussien, Gamma, bêta et student) et 1000 observations, pour quil nait plus que deux colonnes (la valeur originale et le nom de lancienne colonne) et 4000 observations. La figure 3.22 décrit graphiquement ce processus qui peut être effectué avec la fonction melt du package reshape2. Figure 3.22: Empiler les données dun DataFrame library(reshape2) #faire fondre le jeu de données melted_distribs &lt;- melt(distribs, measure.vars = c(&quot;gaussien&quot;, &quot;gamma&quot;, &quot;beta&quot;,&quot;student&quot;)) #renommer les colonnes du nouveau DataFrame names(melted_distribs) &lt;- c(&quot;distribution&quot;, &quot;valeur&quot;) #convertir la variable catégorielle en facteur melted_distribs$distribution &lt;- as.factor(melted_distribs$distribution) ggplot(data = melted_distribs)+ geom_histogram(aes(x = valeur, fill = distribution), bins = 50, color = &quot;#343a40&quot;) + ylim(c(0,130)) + labs(x = &quot;valeur&quot;, y = &quot;fréquences&quot;)+ scale_fill_manual(values = c(&quot;#e63946&quot;,&quot;#f1faee&quot;,&quot;#a8dadc&quot;,&quot;#1d3557&quot;))+ facet_wrap(vars(distribution), ncol=2, scales = &quot;free&quot;)+ theme(legend.position = &quot;none&quot;) Figure 3.23: Histogrammes à facettes 3.2.1.2 Histogramme de densité Les histogrammes que nous venons de construire utilisent la fréquence des observations pour délimiter la hauteur des barres. Il est possible de changer ce comportement pour plutôt utiliser la densité. Lintérêt est notamment de se rapprocher encore de la définition dune distribution puisquavec cette configuration, la somme totale de la surface de lhistogramme est égale à 1. La hauteur de chaque barre représente alors la probabilité dobtenir létendue de valeurs représentées par cette barre. Prenons pour exemple la variable avec la distribution normale que nous venons de voir. plot1 &lt;- ggplot(data = distribs) + geom_histogram(aes(x = gaussien, y = ..density..), bins = 30, color = &quot;#343a40&quot;, fill = &quot;#1d3557&quot;)+ labs(x = &quot;gaussien&quot;, y = &quot;densité&quot;) plot2 &lt;- ggplot(data = distribs) + geom_histogram(aes(x = gaussien, y = ..count..), bins = 30, color = &quot;#343a40&quot;, fill = &quot;#a8dadc&quot;)+ labs(x = &quot;gaussien&quot;, y = &quot;fréquences&quot;) ggarrange(plotlist = list(plot1, plot2), ncol = 2) Figure 3.24: Histogrammes de densité Le graphique de droite (fréquence) nous indique donc que plus de 60 observations ont une valeur denviron 5 (entre 4,76 et 5,34, compte tenu de la largeur de la barre), ce qui se traduit par une probabilité de presque 30 % dobtenir cette valeur en tirant une observation au hasard dans le jeu de données. 3.2.1.3 Histogramme avec courbe de distribution Les histogrammes sont souvent utilisés pour vérifier graphiquement si une distribution empirique sapproche dune courbe normale. Pour cela, nous ajoutons sur lhistogramme de la variable empirique la forme quaurait une distribution normale parfaite en utilisant la moyenne et lécart type de la distribution empirique. Pour créer cette figure dans ggplot2, il suffit dutiliser la fonction stat_function pour créer un nouveau calque. Il est aussi possible dajouter une ligne verticale (geom_vline) pour indiquer la moyenne de la distribution. moyenne &lt;- mean(distribs$gaussien) ecart_type &lt;- sd(distribs$gaussien) ggplot(data = distribs) + geom_histogram(aes(x = gaussien, y = ..density..), bins = 30, color = &quot;#343a40&quot;, fill = &quot;#a8dadc&quot;) + labs(x = &quot;gaussien&quot;, y = &quot;densité&quot;)+ stat_function(fun = dnorm, args = list(mean = moyenne, sd = ecart_type), color = &quot;#e63946&quot;, size = 1.2, linetype = &quot;dashed&quot;) + geom_vline(xintercept = moyenne, color = &#39;red&#39;, size = 1)+ annotate(&quot;text&quot;, x = round(moyenne,2)+0.5, y = 0.31, hjust = &#39;left&#39;, label = paste(&#39;moyenne : &#39;,round(moyenne,2),sep=&#39;&#39;)) Figure 3.25: Histogramme et courbe normale Dans notre cas, nous savons que notre variable est normalement distribuée (car produite avec la fonction rnorm), et nous pouvons constater la grande proximité entre lhistogramme et la courbe normale. 3.2.1.4 Histogramme avec coloration des valeurs extrêmes Il peut être nécessaire dattirer le regard sur certaines parties de lhistogramme, comme sur des valeurs extrêmes. Si nous reprenons notre distribution de Student, nous pouvons clairement distinguer un ensemble de valeurs fortes à droite de la distribution. Nous pourrions, dans notre cas, considérer que des valeurs au-delà de 50 constituent des cas extrêmes que nous souhaitons représenter dans une autre couleur. Pour cela, nous devons créer une variable catégorielle nous permettant de distinguer ces cas particuliers. distribs$cas_extreme &lt;- ifelse(distribs$student &gt;=50, &quot;extrême&quot;, &quot;normale&quot;) ggplot(data = distribs) + geom_histogram(aes(x = student, y = ..count.., fill = cas_extreme), bins = 30, color = &quot;#343a40&quot;)+ scale_fill_manual(&quot;&quot;, values = c(&quot;#a8dadc&quot;,&quot;#e63946&quot;))+ labs(title = &#39;Distribution de Student&#39;,x = &quot;valeur&quot;, y = &quot;fréquence&quot;) Figure 3.26: Histogramme coloré 3.2.2 Graphique de densité Lhistogramme est utilisé pour approximer graphiquement la distribution dune variable. Sa principale limite est de représenter la variable de façon discontinue. Une option intéressante est dutiliser une version lissée de lhistogramme, soit le graphique de densité. Cette opération de lissage est réalisée le plus souvent à partir de fonctions kernel. Reconstruisons notre figure avec les quatre distributions, mais en utilisant cette fois-ci des graphiques de densité. ggplot(data = melted_distribs)+ geom_density(aes(x = valeur, fill = distribution), color = &quot;#343a40&quot;) + scale_fill_manual(values = c(&quot;#e63946&quot;,&quot;#f1faee&quot;,&quot;#a8dadc&quot;,&quot;#1d3557&quot;))+ facet_wrap(vars(distribution), ncol=2, scales = &quot;free&quot;)+ theme(legend.position = &quot;none&quot;) Figure 3.27: Graphiques de densité à facette Les graphiques de densité sont souvent utilisés pour comparer la distribution dune variable pour plusieurs sous-groupes dune population. Si nous reprenons le jeu de données iris, nous pouvons comparer les longueurs de sépales en fonction des espèces. Nous constatons ainsi que les setosas ont une nette tendance à avoir des sépales plus courts et quà linverse, les virginicas ont les sépales généralement les plus longs. ggplot(data = iris)+ geom_density(aes(x = Sepal.Length, fill = Species), color = &quot;#343a40&quot;, alpha = 0.4)+ labs(x = &#39;Longueur de sépales&#39;, y = &#39;&#39;, fill = &#39;Espèce&#39;) Figure 3.28: Graphiques de densité superposés 3.2.3 Nuage de points Un nuage de points est un outil très intéressant pour visualiser la relation existante entre deux variables. Prenons un exemple concret et analysons le volume de CO2 produit annuellement par habitant en comparaison avec le niveau durbanisation dans lensemble des pays à travers le monde. Nous avons extrait ces données sur le site web de la Banque mondiale, puis nous les avons structurés dans un fichier csv. data_co2 &lt;- read.csv(&quot;data/graphique/world_urb_co2.csv&quot;, encoding = &quot;UTF-8&quot;) names(data_co2) ## [1] &quot;country_code&quot; &quot;year&quot; &quot;Population&quot; &quot;Urbanisation&quot; &quot;CO2_kt&quot; ## [6] &quot;Country.Name&quot; &quot;CO2t_hab&quot; &quot;region7&quot; &quot;region23&quot; 3.2.3.1 Nuage de points simple Commençons par un nuage de points simple avec lensemble des données. ggplot(data = data_co2)+ geom_point(aes(x = Urbanisation, y = CO2t_hab))+ labs(x = &quot;Niveau d&#39;urbanisation (%)&quot;, y = &#39;Tonnes de CO2 annuelle / habitant&#39;, title = &#39;Relation entre urbanisation et production de CO2 par habitant&#39;) Figure 3.29: Nuage de points simple À la première lecture de ce graphique, nous observons immédiatement un ensemble de points étranges dont le volume de CO2 par habitant annuel est au-dessus de 150 tonnes et dont le niveau durbanisation est proche de 50 %. Isolons ces données pour observer de quoi il sagit. cas_etrange &lt;- subset(data_co2, data_co2$CO2t_hab &gt;= 150) print(cas_etrange$Country.Name) ## [1] &quot;Aruba&quot; &quot;Aruba&quot; &quot;Aruba&quot; &quot;Aruba&quot; &quot;Aruba&quot; &quot;Aruba&quot; &quot;Aruba&quot; &quot;Aruba&quot; &quot;Aruba&quot; ## [10] &quot;Aruba&quot; &quot;Aruba&quot; &quot;Aruba&quot; &quot;Aruba&quot; &quot;Aruba&quot; &quot;Aruba&quot; &quot;Aruba&quot; &quot;Aruba&quot; &quot;Aruba&quot; ## [19] &quot;Aruba&quot; &quot;Aruba&quot; &quot;Aruba&quot; &quot;Aruba&quot; &quot;Aruba&quot; &quot;Aruba&quot; &quot;Aruba&quot; Il sagit dune petite île néerlandaise des Caraïbes nommée Aruba disposant dune faible population, mais avec des activités très polluantes (raffinerie et extraction dor). Nous faisons ici le choix de retirer ces observations puisquelles sont assez peu représentatives de la tendance mondiale. Cette démarche si simple relève ainsi de lanalyse exploratoire des données! Sans ce graphique, nous naurions probablement jamais identifié ces cas problématiques. data_co2 &lt;- subset(data_co2, data_co2$CO2t_hab &lt;= 150) Reconstruisons le nuage de points maintenant que ces données aberrantes ont été retirées. graphique &lt;- ggplot(data = data_co2)+ geom_point(aes(x = Urbanisation, y = CO2t_hab))+ labs(x = &quot;Niveau d&#39;urbanisation (%)&quot;, y = &#39;Tonnes de CO2 annuelle / habitant&#39;, title = &#39;Relation entre urbanisation et production de CO2 par habitant&#39;) Voilà qui est mieux! Cependant, le grand nombre de points restant rend la lecture du graphique assez difficile puisquils se superposent. Une première option à envisager, dans ce cas, est à la fois dajouter de la transparence aux points et de réduire leur taille : ggplot(data = data_co2)+ geom_point(aes(x = Urbanisation, y = CO2t_hab), alpha = 0.2, size = 0.5)+ labs(x = &quot;Niveau d&#39;urbanisation (%)&quot;, y = &#39;Tonnes de CO2 annuelle / habitant&#39;, title = &#39;Relation entre urbanisation et production de CO2 par habitant&#39;) Figure 3.30: Nuage de points simple avec transparence 3.2.3.2 Nuage de points avec densité Bien que la transparence nous aide un peu à distinguer les secteurs du graphique avec le plus de points, il serait plus efficace dabandonner la géométrie des points pour la remplacer par une géométrie de densité en deux dimensions. Une première approche consiste à diviser lespace du graphique en petits carrés et à compter le nombre de points tombant dans chaque carré (en somme, un histogramme en deux dimensions). ggplot(data = data_co2)+ geom_bin2d(aes(x = Urbanisation, y = CO2t_hab), bins = 50) + scale_fill_continuous(type = &quot;viridis&quot;) + labs(x = &quot;Niveau d&#39;urbanisation (%)&quot;, y = &#39;Tonnes de CO2 annuelle / habitant&#39;, fill = &quot;Effectif&quot;, title = &#39;Relation entre urbanisation et production de CO2 par habitant&#39;) Figure 3.31: Nuage de points simple Nous observons ainsi une forte concentration dans le bas du graphique; les pays avec des rejets annuels de CO2 supérieurs à 15 tonnes par habitant sont relativement rares. Pour les personnes préférant les représentations plus élaborées, il est aussi possible de diviser lespace du graphique avec des hexagones en utilisant le package hexbin. ggplot(data = data_co2)+ geom_hex(aes(x = Urbanisation, y = CO2t_hab), bins = 50) + scale_fill_continuous(type = &quot;viridis&quot;) + labs(x = &quot;Niveau d&#39;urbanisation (%)&quot;, y = &#39;Tonnes de CO2 annuelle / habitant&#39;, fill = &quot;Effectif&quot;, title = &#39;Relation entre urbanisation et production de CO2 par habitant&#39;) Figure 3.32: Densité en deux dimensions par hexagones Enfin, il est aussi possible de réaliser une version lissée de ces graphiques avec une fonction kernel en deux dimensions (stat_density_2d) : ggplot(data = data_co2)+ stat_density_2d(aes(x = Urbanisation, y = CO2t_hab, fill = ..density..), geom = &quot;raster&quot;, n = 50, contour = FALSE) + scale_fill_continuous(type = &quot;viridis&quot;) + labs(x = &quot;Niveau d&#39;urbanisation (%)&quot;, y = &#39;Tonnes de CO2 annuelle / habitant&#39;, fill = &quot;densité&quot;, title = &#39;Relation entre urbanisation et production de CO2 par habitant&#39;)+ ylim(0,25) Figure 3.33: Densité lissée en deux dimensions 3.2.3.3 Nuage de points et droite de régression Afin de faire ressortir une éventuelle relation entre les variables représentées sur les deux axes, il est possible dafficher la droite de régression sur le graphique entre X et Y. Cette opération seffectue avec la fonction geom_smooth. graphique &lt;- ggplot(data = data_co2)+ geom_point(aes(x = Urbanisation, y = CO2t_hab), alpha = 0.2, size = 0.5)+ geom_smooth(aes(x = Urbanisation, y = CO2t_hab), method = lm, color = &quot;red&quot;)+ labs(x = &quot;Niveau d&#39;urbanisation (%)&quot;, y = &#39;Tonnes de CO2 annuelle / habitant&#39;, title = &#39;Relation entre urbanisation et production de CO2 par habitant&#39;) Notez que largument method = lm permet dindiquer que nous souhaitons utiliser une régression linéaire (linear model) pour tracer la géométrie (une droite de régression). La droite semble bien indiquer une relation positive entre les deux variables : une augmentation de lurbanisation serait associée à une augmentation de la production annuelle de CO2 par habitant. Nous pourrions également vérifier si une relation non linéaire serait plus adaptée au jeu de données. Dans notre cas, une relation quadratique pourrait produire un meilleur ajustement. ggplot(data = data_co2)+ geom_point(aes(x = Urbanisation, y = CO2t_hab), alpha = 0.2, size = 0.7)+ geom_smooth(aes(x = Urbanisation, y = CO2t_hab), method = lm, color = &quot;red&quot;, formula = y ~ I(x**2))+ labs(x = &quot;Niveau d&#39;urbanisation (%)&quot;, y = &#39;Tonnes de CO2 annuelle / habitant&#39;, title = &#39;Relation entre urbanisation et production de CO2 par habitant&#39;) Figure 3.34: Nuage de points avec droite de régression quadratique La régression quadratique (avec x au carré) nous indique ainsi que limpact du niveau durbanisation est plus important à mesure que ce niveau augmente. Vous pouvez également constater que la courbe ne prédit pas de valeurs négatives comparativement à la droite précédente. Il est également possible dajuster une courbe sans choisir au préalable sa forme (dans le cas précédent \\(x^2\\)) en utilisant une méthode dajustement local appelée loess. graphique &lt;- ggplot(data = data_co2)+ geom_point(aes(x = Urbanisation, y = CO2t_hab), alpha = 0.2, size = 0.5)+ geom_smooth(aes(x = Urbanisation, y = CO2t_hab), method = loess, color = &quot;red&quot;)+ labs(x = &quot;Niveau d&#39;urbanisation (%)&quot;, y = &#39;Tonnes de CO2 annuelle / habitant&#39;, title = &#39;Relation entre urbanisation et production de CO2 par habitant&#39;) La relation non linéaire révèle davantage dinformations : laugmentation de lurbanisation est associée à une augmentation de lémission de CO2 par habitant uniquement jusquà 75 % durbanisation; au-delà de ce seuil, la relation ne tient plus. Ces résultats semblent cohérents avec lévolution classique de léconomie dun pays passant progressivement dune économie agricole, à une économie industrialisée et finalement une économie de services. 3.2.4 Graphique en ligne Un graphique en ligne permet de représenter lévolution dune variable, généralement dans le temps. Dans le jeu de données précédent, nous disposons des émissions de CO2 par habitant de nombreux pays sur plusieurs années. Nous pouvons ainsi représenter lévolution des émissions pour chaque pays avec un graphique en ligne. Pour éviter de le surcharger, cet exercice est réalisé uniquement sur les pays de lEurope de lOuest. # conversion de la variable year textuelle en variable numérique data_co2$an &lt;- as.numeric(data_co2$year) # extraction des données d&#39;Europe de l&#39;Ouest data_europe &lt;- subset(data_co2, data_co2$region23 == &quot;Europe de l&#39;Ouest&quot;) # choix des valeurs pour l&#39;axe des x x_ticks &lt;- seq(1960,2020,10) ggplot(data = data_europe)+ geom_path(aes(x = an, y = CO2t_hab, color = Country.Name))+ labs(x = &quot;Années&quot;, y = &#39;Tonnes de CO2 annuelle / habitant&#39;, color = &quot;Pays&quot;, title = &#39;Évolution de la production de CO2 par habitant&#39;) + scale_x_continuous(breaks = x_ticks, labels = x_ticks)+ theme_tufte() Figure 3.35: Graphique en ligne Nous remarquons notamment quaucune donnée, avant 2005, nest disponible pour le Liechtenstein. 3.2.4.1 Barre derreur et en bande Sur un graphique, il est souvent pertinent de représenter lincertitude que nous avons sur nos données. Cela peut être fait à laide de barres derreur ou à laide de polygones délimitant les marges dincertitude. En guise dexemple, admettons que les données précédentes sont fiables à plus ou moins 10 %. En dautres termes, la valeur démission de CO2 annuelle serait relativement incertaine et pourrait se situer dans un intervalle de 10 % autour de la valeur fournie par la Banque mondiale. Nous obtenons ainsi une borne inférieure (valeur donnée - 10 %) et une borne supérieure (valeur donnée + 10 %). Nous pouvons facilement calculer ces bornes et les faire apparaître dans notre graphique précédent. data_europe$borne_basse &lt;- data_europe$CO2t_hab - 0.1 * data_europe$CO2t_hab data_europe$borne_haute &lt;- data_europe$CO2t_hab + 0.1 * data_europe$CO2t_hab ggplot(data = data_europe)+ geom_point(aes(x = an, y = CO2t_hab, color = Country.Name), size = 0.7)+ geom_errorbar(aes(x = an, ymin = borne_basse, ymax = borne_haute, color = Country.Name))+ labs(x = &quot;Années&quot;, y = &#39;Tonnes de CO2 annuelle / habitant&#39;, color = &quot;Pays&quot;, title = &#39;Évolution de la production de CO2 par habitant&#39;) + scale_x_continuous(breaks = x_ticks, labels = x_ticks)+ theme_tufte() Figure 3.36: Graphique en ligne avec barres derreur Ces barres derreurs indiquent notamment quil ny a finalement aucun écart significatif entre la Belgique, les Pays-Bas et lAllemagne à partir des années 1990. Une autre option de représentation est dutiliser des polygones avec la fonction geom_ribbon. ggplot(data = data_europe)+ geom_path(aes(x = an, y = CO2t_hab, color = Country.Name), size = 0.7)+ geom_ribbon(aes(x = an, ymin = borne_basse, ymax = borne_haute, fill = Country.Name), alpha = 0.4)+ labs(x = &quot;Années&quot;, y = &#39;Tonnes de CO2 annuelle / habitant&#39;, color = &quot;Pays&quot;, title = &#39;Évolution de la production de CO2 par habitant&#39;) + scale_x_continuous(breaks = x_ticks, labels = x_ticks)+ theme_tufte()+ guides( fill = FALSE) Figure 3.37: Graphique en ligne avec marge derreur Le message du graphique est le même. Notez que nous avons utilisé ici la fonction guides pour retirer de la légende les couleurs associées au remplissage des marges derreur. Ces couleurs sont les mêmes que celles des lignes et il nest pas utile de dédoubler la légende. De nombreuses méthodes statistiques produisent des résultats accompagnés dune mesure de lincertitude associée à ces résultats. Représenter cette incertitude est crucial pour que le lecteur puisse délimiter la portée des conclusions de vos analyses. 3.2.5 Boîte à moustaches Les boîtes à moustaches (box plot en anglais) sont des graphiques permettant de comparer les moyennes et les intervalles interquartiles dune variable continue selon plusieurs groupes dune population. Si nous reprenons notre exemple précédent, nous pourrions comparer, en fonction de la région du monde, la moyenne de production annuelle de CO2 par habitant. Pour cela, il suffit dutiliser la fonction geom_boxplot. #retirer les observations n&#39;étant pas associées à une région data_co2_comp &lt;- subset(data_co2, is.na(data_co2$region7) == F) ggplot(data = data_co2_comp)+ geom_boxplot(aes(y = region7, x = CO2t_hab))+ labs(x=&quot;Tonnes de CO2 par an et habitant&quot;, y=&quot;Région&quot;) Figure 3.38: Boîtes à moustaches La barre centrale dune boîte représente la moyenne. Les extrémités de la boîte représentent le premier et le troisième quartile. Plus une boîte est allongée, plus les situations sont diversifiées pour les observations appartenant au groupe représenté par la boîte. Au contraire, une boîte étroite indique un groupe homogène. Notez quen inversant les variables dans les axes X et Y, nous obtiendrions des boîtes à moustaches verticales. Cependant, les noms des régions étant assez longs, cela nécessiterait davoir un graphique très large. Améliorons quelque peu le rendu de ce graphique en ajoutant des titres. ggplot(data = data_co2_comp)+ geom_boxplot(aes(y = region7, x = CO2t_hab))+ xlim(c(0,50))+ labs(x = &quot;Tonnes de CO2 par an et habitant&quot;, y = &#39;Région&#39;) Figure 3.39: Boîtes à moustaches améliorées Les points noirs sur le graphique représentent des valeurs extrêmes, soit des observations situées à plus de 1,5 intervalle interquartile dune extrémité de la boîte. Pour mieux rendre compte de la densité dobservations le long de chaque boîte à moustaches, il est possible de les représenter directement avec la fonction geom_jitter. Figure 3.40: Boîtes à moustaches avec observations Notez que pour éviter que les valeurs extrêmes identifiées par la fonction geom_boxplot se superposent avec les points représentant les observations, nous les avons supprimées avec largument outlier.shape = NA. 3.2.6 Graphique en violon Les boîtes à moustaches donnent des informations pertinentes sur le centre et la dispersion dune variable en fonction de sous groupes de la population. Cependant, une grande partie de linformation reste masquée par la représentation sous forme de boîte. Une solution est de remplacer la simple boîte par la distribution de la variable étudiée. Nous obtenons ainsi des graphiques en violon (geom_violin). Considérant les très grands écarts que nous avons observés entre les régions avec les boîtes à moustaches, il est préférable de tracer les graphiques en violon en excluant les régions Afrique Sub-Saharienne et Asie du Sud. # retirons les observations de régions que nous ne souhaitons par garder data_co2_comp &lt;- subset(data_co2, (! data_co2$region7 %in% c(&quot;Sub-Saharan Africa&quot;, &quot;South Asia&quot;)) &amp; is.na(data_co2$region7)==FALSE) ggplot(data = data_co2_comp)+ geom_violin(aes(y = region7,x = CO2t_hab))+ xlim(c(0,50))+ labs(x = &quot;Tonnes de CO2 annuelle / habitant&quot;, y = &#39;&#39;)+ geom_vline(xintercept = 12, linetype = &#39;dashed&#39;, color = &#39;blue&#39;) Figure 3.41: Graphiques en violon Ces distributions permettent notamment de souligner que deux groupes distincts se retrouvent en Amérique du Nord. Lun dont les émissions annuelles de CO2 par habitant sont inférieures à 12 tonnes (ligne bleue) et lautre pour lequel elles sont supérieures. En explorant les données, nous constatons que les Bermudes appartiennent au groupe Amérique du Nord, mais ont des niveaux démission inférieurs à ceux du Canada et des États-Unis, ce qui explique cette distribution bimodale. Cette information était masquée avec les boîtes à moustaches. Finalement, il est aussi possible de superposer un graphique en violon et une boîte à moustaches pour bénéficier des avantages des deux. ggplot(data = data_co2_comp)+ geom_violin(aes(y = region7,x = CO2t_hab))+ geom_boxplot(aes(y = region7,x = CO2t_hab), width = 0.15)+ xlim(c(0,50))+ labs(x = &quot;Tonnes de CO2 annuelle / habitant&quot;, y = &#39;&#39;) Figure 3.42: Graphiques en violon et boîtes à moustaches 3.2.7 Graphique en barre Les graphiques en barre permettent de représenter des quantités (hauteur des barres) réparties dans des catégories (une barre par catégorie). Nous proposons ici un exemple avec des données de déplacements issues de lEnquête origine-destination 2017 - Région Québec-Lévis, au niveau des grands secteurs. La figure 3.42, tirée du rapport intitulé La mobilité des personnes dans la région de Québec-Lévis (Volet Enquête-ménages : faits saillants) délimite ces grands secteurs. Figure 3.43: Grands secteurs de Québec Nous représentons pour chaque secteur le nombre moyen de déplacements entrant et sortant un jour de semaine en heures de pointe. Les données sont présentées sous forme dune matrice carrée (avec autant de lignes que de colonnes). Lintersection de la ligne A et de la colonne C indique le nombre de personnes partant du secteur A pour se rendre au secteur C. À linverse, lintersection de la ligne C et de la colonne A indique le nombre de personnes partant du secteur C pour se rendre au secteur A. En sommant les valeurs de chaque ligne, nous obtienons le nombre total de départs par secteur tandis que le nombre darrivées est la somme de chaque colonne. Ces opérations peuvent simplement être effectuées avec les fonctions rowSums et colSums. # Chargement des donneées matriceOD &lt;- read.csv(&#39;data/graphique/Quebec_2017_OD_MJ.csv&#39;, header = FALSE, sep = &#39;;&#39;) # fichier csv sans entête # Calcul des sommes en lignes et en colonnes tot_depart &lt;- rowSums(matriceOD) tot_arrivee &lt;- colSums(matriceOD) # Création d&#39;un DataFrame avec les valeurs et les noms des secteurs df &lt;- data.frame(depart = tot_depart, arrivee = tot_arrivee, secteur = c(&#39;Arr. de Beauport (Québec)&#39;, &#39;Arr. de Charlesbourg (Québec)&#39;, &#39;Arr. des Rivières (Québec)&#39;, &#39;Arr. de la Cité-Limoilou (Québec)&#39;, &#39;Arr. de la Haute-Saint-Charles (Québec)&#39;, &#39;Arr. de Sainte-Foy-Sillery-Cap-Rouge (Québec)&#39;, &#39;Arr.de Desjardins (Lévis)&#39;, &#39;Arr. des Chutesde-la-Chaudière-Est (Lévis)&#39;, &#39;Arr. des Chutes de la Chaudière-Ouest (Lévis)&#39;, &#39;Ceinture Nord&#39;, &#39;Ceinture Sud&#39;, &#39;Hors Territoire&#39;), code = c(&#39;A&#39;,&#39;B&#39;,&#39;C&#39;,&#39;D&#39;,&#39;E&#39;,&#39;F&#39;,&#39;G&#39;,&#39;H&#39;,&#39;I&#39;,&#39;J&#39;,&#39;K&#39;,&#39;X&#39;)) # Création des deux graphiques en barre plot1 &lt;- ggplot(data = df)+ geom_bar(aes(x = code, weight = depart))+ labs(subtitle = &#39;Départs&#39;, x = &#39;total&#39;, y = &#39;&#39;) plot2 &lt;- ggplot(data = df)+ geom_bar(aes(x = code, weight = arrivee))+ labs(subtitle = &#39;Arrivées&#39;, x = &#39;total&#39;, y = &#39;&#39;) # Stocker les graphiques dans une liste et composer une figure list_plot &lt;- list(plot1, plot2) tot_plot &lt;- ggarrange(plotlist = list_plot, ncol = 1) # Création d&#39;une légende pour associer le code de chaque secteur # à son nom. Pour cela nous concaténons en premier les lettres et les noms. # Nous fusionons ensuite le tout en les séparant par le symbole \\n représentant # un saut de ligne. nom_secteurs &lt;- paste(df$code, df$secteur, sep= &#39; : &#39;) string_names &lt;- paste(nom_secteurs, collapse = &#39;\\n&#39;) titre &lt;- &quot;Déplacements journaliers moyens en heures de pointe&quot; # Production finale de la figure annotate_figure(tot_plot, top = text_grob(titre, face = &quot;bold&quot;, size = 11, just = &quot;left&quot;), right = text_grob(string_names, face = &quot;italic&quot;, size = 8, just = &quot;left&quot;, x = 0.05) # position du texte ) Figure 3.44: Graphiques en barre simples Plutôt que de représenter les arrivées et les départs dans deux graphiques séparés, il est possible de les empiler dans un même graphique en barre. Nous devons au préalable « faire fondre nos données » avec la fonction melt. # Faire fondre le jeu de données (empiler les colonnes depart et arrivee) melted_df &lt;- melt(df, id.vars = c(&#39;code&#39;), measure.vars = c(&#39;depart&#39;,&#39;arrivee&#39;)) names(melted_df) &lt;- c(&#39;code&#39;,&#39;deplacement&#39;,&#39;effectif&#39;) # Ajouter les accents dans la colonne déplacement melted_df$deplacement &lt;- ifelse(melted_df$deplacement == &#39;depart&#39;, &#39;départs&#39;, &#39;arrivées&#39;) # Comparaison du format original et du format &quot;fondu&quot; head(df) ## depart arrivee secteur code ## V1 49241 34777 Arr. de Beauport (Québec) A ## V2 48909 36344 Arr. de Charlesbourg (Québec) B ## V3 48044 67198 Arr. des Rivières (Québec) C ## V4 63132 108138 Arr. de la Cité-Limoilou (Québec) D ## V5 57367 30859 Arr. de la Haute-Saint-Charles (Québec) E ## V6 86504 112379 Arr. de Sainte-Foy-Sillery-Cap-Rouge (Québec) F head(melted_df) ## code deplacement effectif ## 1 A départs 49241 ## 2 B départs 48909 ## 3 C départs 48044 ## 4 D départs 63132 ## 5 E départs 57367 ## 6 F départs 86504 # Réalisation du graphique plot1 &lt;- ggplot(data = melted_df)+ geom_bar(aes(x = code,weight = effectif, fill = deplacement),color = &#39;#e3e3e3&#39;)+ scale_fill_manual(values = c(&quot;#e63946&quot;,&quot;#1d3557&quot;))+ labs(title = titre, y = &#39;Effectifs&#39;, x = &#39;&#39;, fill = &#39;Déplacements&#39;) annotate_figure(plot1,right = text_grob(string_names, face = &quot;italic&quot;, size = 7, just = &quot;left&quot;, x = 0.05)) # position du texte) Figure 3.45: Graphique en barre empilée 3.2.8 Graphique circulaire Une option directe au graphique en barre est le graphique ou diagramme circulaire, appelé aussi graphique en tarte (pour les personnes à la dent sucrée) ou en camembert (pour celles amatrices de fromage). Il est suffissamment connu et utilisé pour quaucune présentation ne simpose. Pour être exact, un graphique en tarte nest rien dautre quun graphique en barre dont le système de coordonnées a été modifié. Cela impose cependant de calculer à lavance la position des étiquettes que nous souhaitons ajouter sur le graphique. Reprenons les données de production mondiale de CO2 et calculons les productions totales par région géographique en 2015. library(dplyr) # Extraire les données de 2018 pour lesquelles nous connaissons la région data_co2_2015 &lt;- subset(data_co2,data_co2$year == &quot;2015&quot; &amp; ! is.na(data_co2$region7)) # Effectuer la somme du CO2 par région co2_2015 &lt;- data_co2_2015 %&gt;% group_by(region7) %&gt;% summarise(total_co2 = sum(CO2_kt,na.rm = TRUE)) # Attribuer un code à chaque région pour faciliter la lecture co2_2015$code &lt;- c(&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;,&quot;E&quot;,&quot;F&quot;,&quot;G&quot;) # Modifier l&#39;ordre des données, calculer les proportions et la position des labels df &lt;- co2_2015 %&gt;% arrange(desc(code)) %&gt;% mutate(prop = total_co2 / sum(co2_2015$total_co2) *100) %&gt;% mutate(ypos = cumsum(prop)- 0.5*prop ) # Préparer la légende (pourcentages et vrais noms) nom_region &lt;- rev(paste(df$code, &quot; : &quot;, df$region7, &quot;(&quot;, round(df$prop,1),&quot;%)&quot;)) string_region &lt;- paste(nom_region, collapse = &#39;\\n&#39;) # Construire le graphique plot1 &lt;- ggplot(df, aes(x=&quot;&quot;, y=prop, fill=code)) + geom_bar(stat=&quot;identity&quot;, width=1, color=&quot;white&quot;) + coord_polar(&quot;y&quot;, start=0) + theme_void() + theme(legend.position=&quot;none&quot;) + geom_text(aes(y = ypos, label = code), color = &quot;white&quot;, size=3) + scale_fill_grey()+ labs(title = &quot;Proportion du CO2 émis en 2015&quot;) # Ajouter la légende annotate_figure(plot1,right = text_grob(string_region, face = &quot;italic&quot;, size = 9, just = &quot;left&quot;, x = 0.05)) # position du texte) Figure 3.46: Graphique en tarte Si à la place de la géométrie geom_bar, vous utilisez geom_rect, vous pouvez convertir votre graphique en tarte en graphique en anneau (ou en beigne, pour les personnes à la dent sucrée) : # Calculer la limite inférieure et supérieure du beigne df$ymax &lt;- cumsum(df$prop) df$ymin &lt;- c(0, head(df$ymax, n=-1)) # Construire le graphique plot1 &lt;- ggplot(df, aes(ymax=ymax, ymin=ymin, xmax=4, xmin=3, y=prop, fill=code)) + geom_rect(stat=&quot;identity&quot;, color=&quot;white&quot;) + coord_polar(&quot;y&quot;, start=0) + theme_void() + theme(legend.position=&quot;none&quot;) + geom_text(aes(x = 3.5,y = ypos, label = code), color = &quot;white&quot;, size=3) + scale_fill_grey()+ xlim(c(2,4))+ labs(title = &quot;Proportion du CO2 émis en 2015&quot;) # Ajouter la légende annotate_figure(plot1,right = text_grob(string_region, face = &quot;italic&quot;, size = 8, just = &quot;left&quot;, x = 0.05)) # position du texte) Figure 3.47: Graphique en anneau "],["sect033.html", "3.3 Graphiques spéciaux", " 3.3 Graphiques spéciaux Dans cette dernière section, nous abordons des graphiques plus rarement utilisés. Ils sont toutefois très utiles dans certains contextes du fait de leur capacité à synthétiser des informations complexes. 3.3.1 Graphique en radar Les graphiques en radar (ou en toile daraignée) sont utilisés pour comparer une série de variables continues pour plusieurs observations ou groupes dobservations. Chaque variable est associée à un axe et chaque observation est représentée avec un polygone. Prenons lexemple de données relatives aux logements par secteur de recensement dans la région métropolitaine de Montréal en 2016. Nous pourrions souhaiter comparer la moyenne des pourcentages des différents types de logements pour les régions des Laurentides, de la Montérégie, de Laval, de Longueuil et de Montréal. Malheureusement, ggplot2 ne permet pas de dessiner des graphiques en radar satisfaisants, nous devons donc utiliser le package fmsb. library(fmsb) data &lt;- read.csv(&#39;data/bivariee/sr_rmr_mtl_2016.csv&#39;, header = T, encoding = &#39;UTF-8&#39;) # Agréger les données au niveau des régions en calculant la moyenne des pourcentages variables &lt;- c(&quot;MaisonIndi&quot;,&quot;App5Plus&quot;,&quot;MaisRangee&quot;,&quot;AppDuplex&quot;,&quot;Proprio&quot;,&quot;Locataire&quot;) data_region &lt;- data[c(&quot;Region&quot;,variables)] %&gt;% group_by(Region) %&gt;% summarise_all(.funs = list(mean)) # Gérer le nom des colonnes pour ajuster les données aux besoins de # la fonction radachart new_names &lt;- c(&quot;Region&quot;,paste(variables,&quot;_mean&quot;,sep=&quot;&quot;)) names(data_region) &lt;- new_names data_region &lt;- data.frame(data_region) rownames(data_region) &lt;- data_region$Region data_region$Region &lt;- NULL # Ajouter deux lignes aux données avec les valeurs maximales et minimales # de chaque colonne. Ces informations aideront la fonction radachart à # dessiner chacun des axes du radar data_chart &lt;- rbind(apply(data_region,MARGIN = 2, FUN = max), apply(data_region,MARGIN = 2, FUN = min), data_region ) # Choisir les couleurs pour l&#39;intérieur des polygones (avec transparence) couleurs &lt;- c( rgb(0.94, 0.28, 0.44, 0.25), rgb(1.00, 0.82, 0.40, 0.25), rgb(0.02, 0.84, 0.63, 0.25), rgb(0.07, 0.54, 0.70, 0.25), rgb(0.03, 0.23, 0.30, 0.25) ) # Choisir les couleurs pour l&#39;intérieur des polygones (sans transparence) couleurs_contour &lt;- c( rgb(0.94, 0.28, 0.44), rgb(1.00, 0.82, 0.40), rgb(0.02, 0.84, 0.63), rgb(0.07, 0.54, 0.70), rgb(0.03, 0.23, 0.30) ) # Dessiner du graphique radarchart(data_chart, title = &quot;Comparaison des types de logements dans la RMR&quot;, pcol = couleurs_contour, pfcol = couleurs, plwd = 2, plty=1, cglcol=&quot;grey&quot;, cglty=1, axislabcol=&quot;grey&quot;, cglwd=0.8, vlcex=0.8, vlabels = c(&quot;maison individuelle&quot;, &quot;immeuble d&#39;appartements&quot;, &quot;maison \\nen rangée&quot;, &quot;duplex&quot;, &quot;propriétaire&quot;, &quot;locataire&quot;) ) # Ajouter une légende legend(x=1.3, y=1, legend = rownames(data_chart[-c(1,2),]), bty = &quot;n&quot;, pch=20 , col=couleurs , text.col = &quot;black&quot;, cex=0.9, pt.cex=1.5) Figure 3.48: Graphique en anneau À la lecture du graphique, nous constatons rapidement que lîle de Montréal a une situation très différente des trois autres régions. Laval se distingue également avec une part importante de logements dans des immeubles dappartements. Ce type de graphique a pour objectif dorienter le regard sur de potentielles différences dans un contexte multidimensionnel, mais il présente quelques inconvénients : Les échelles de chaque axe sont différentes. Il est donc essentiel de se rapporter aux valeurs exactes pour estimer si les écarts sont importants en termes absolus. La superposition de plusieurs polygones peut rendre la lecture difficile. Une solution envisageable est de réaliser un graphique par polygone, mais cela prend beaucoup de place dans un document. Lutilisation de polygones donne parfois de fausses impressions décarts. Dans le précédent graphique, lil est attiré en bas à gauche par le polygone de Montréal qui est très différent des autres. Cependant, les écarts sur laxe maison en rangée sont relativement petits comparativement à laxe locataire situé à lopposé. 3.3.2 Diagramme daccord Les diagrammes daccord (chord diagram en anglais) sont utilisés pour représenter des échanges ou des connexions entre des entités. Il peut sagir par exemple de marchandises importées / exportées entre pays, des messages envoyés entre personnes via un réseau social, de flux de population, etc. Reprenons nos données de lEnquête origine-destination 2017 - Région Québec-Lévis pour illustrer le tout. Nous utilisons le package chorddiag, très facile dutilisation et produisant des graphiques interactifs, pour faciliter grandement la lecture de ce type de graphique. Cependant, ce package ne fait pas partie du répertoire CRAN, nous devons linstaller directement depuis github avec la fonction devtools::install_github. devtools::install_github(&#39;mattflor/chorddiag&#39;) library(chorddiag) # Chargement des données matriceOD &lt;- read.csv(&#39;data/graphique/Quebec_2017_OD_MJ.csv&#39;, header = FALSE, sep = &#39;;&#39;) # fichier csv sans entête # Transformation du DataFrame en matrice matriceOD &lt;- as.matrix(matriceOD) codes &lt;- c(&#39;A&#39;,&#39;B&#39;,&#39;C&#39;,&#39;D&#39;,&#39;E&#39;,&#39;F&#39;,&#39;G&#39;,&#39;H&#39;,&#39;I&#39;,&#39;J&#39;,&#39;K&#39;,&#39;X&#39;) secteurs &lt;- c(&#39;Arr. de Beauport&#39;, &#39;Arr. de Charlesbourg&#39;, &#39;Arr. des Rivières&#39;, &#39;Arr. de la Cité-Limoilou&#39;, &#39;Arr. de la Haute-St-Charles&#39;, &#39;Arr. de Sainte-Foy-Sillery-Cap-Rouge&#39;, &#39;Arr.de Desjardins&#39;, &#39;Arr. des Chutesde-la-Chaudière-Est&#39;, &#39;Arr. Les Chutes de la-Chaudière-Ouest&#39;, &#39;Ceinture Nord&#39;, &#39;Ceinture Sud&#39;, &#39;Hors Territoire&#39;) # Ajout de noms aux colonnes et aux lignes de la matrice rownames(matriceOD) &lt;- secteurs colnames(matriceOD) &lt;- secteurs # Nous supprimons les trois secteurs Ceinture Nord, Sud et Hors territoire # qui comprennent de toute façon peu de déplacements mat &lt;- matriceOD[1:8,1:8] # Choix aléatoire de couleurs pour les lignes # col &lt;- sample(colors(),nrow(mat),replace = F) # Choix de couleurs col &lt;- c(&quot;#a491d3&quot;, &quot;#818aa3&quot;, &quot;#C5DCA0&quot;, &quot;#F5F2B8&quot;, &quot;#F9DAD0&quot;, &quot;#F45B69&quot;, &quot;#22181C&quot;, &quot;#5A0001&quot;) # Réalisation du graphique : sortie HTLM if(knitr::is_html_output()){ chorddiag(mat, groupColors = col, showTicks = F, type = &#39;bipartite&#39;, chordedgeColor = &#39;white&#39;, groupnameFontsize = 12, groupnamePadding = 5) } Figure 3.49: Diagramme daccord # Pour la sortie PDF if(knitr::is_latex_output()){ knitr::include_graphics(&#39;images/magie_graphiques/chord_diagramme.png&#39;, dpi = NA) } Le graphique permet de remarquer que la plupart des flux seffectuent au sein dun même secteur. La majorité des déplacements se font au sein du secteur Sainte-Foy (segment rouge central). Nous pouvons cependant constater que les secteurs des Rivières, de la Cité-Limoilou et de la Haute-Saint-Charles attirent une plus grande quantité et diversité de flux. Si vous lisez ce livre dans un navigateur web (et pas au format pdf), le graphique est interactif! En plaçant votre souris sur un lien, vous verrez safficher le nombre de déplacements quil représente. 3.3.3 Nuage de mots Un nuage de mots est un graphique utilisé en analyse de texte pour représenter les mots les plus importants dun document. Mesurer limportance des termes dans un document est une discipline à part entière (Natural Language Processing). Nous proposons un simple exemple ici avec la méthode TextRank (basée sur la théorie des graphes) proposée par Mihalcea et Tarau (2004) et implémentée dans le package textrank. Nous avons également besoin des packages udpipe (fournissant des dictionnaires linguistiques), RColorBrewer (pour sélectionner une palette de couleurs) et wordcloud2 (pour générer le graphique). En guise dexemple, nous avons choisi dextraire les textes de deux schémas daménagement et de développement (SAD), ceux des agglomérations de Québec et de Montréal en vigueur en 2020. Il sagit de deux documents de planification définissant les lignes directrices de lorganisation physique du territoire des municipalités régionales de comté (MRC) ou des agglomérations. Pour ces deux documents, nous nous concentrons sur le chapitre portant sur les grandes orientations daménagement et de développement, soit les pages 30 à 135 pour Québec et 30 à 97 pour Montréal. Pour extraire les textes des fichiers pdf, nous utilisons le package pdftools. Nous devons donc réaliser les étapes suivantes pour produire le nuage de mots : Extraire les sections qui nous intéressent des fichiers pdf. Extraire le texte de ces sections. Retirer les caractères représentant les sauts de lignes et les sauts de paragraphes (\\n et \\r). Concaténer tout le texte en une seule longue chaîne de caractère. Utiliser un dictionnaire pour déterminer la nature des mots du texte (nom, adjectif, verbe, etc.). Utiliser lalgorithme TextRank pour identifier les mots clefs. Nettoyer les erreurs potentielles parmi les mots clefs. Construire le nuage de mots. Notez que toutes ces étapes de nettoyage ne seraient pas nécessaires si nous utilisions un simple fichier texte comme point de départ. Cependant, comme il est plus courant de rencontrer des fichiers pdf, cet exercice est donc davantage révélateur de la difficulté réelle de la réalisation dun nuage de mots. library(wordcloud2) library(udpipe) library(RColorBrewer) library(pdftools) library(textrank) # Étape 1 : extraire les sections pertinentes des fichiers pdf extrait_qc &lt;- pdf_subset(&quot;data/graphique/SAD_quebec.pdf&quot;, pages = c(30:135), output = &quot;data/graphique/SAD_quebec_ext.pdf&quot;) extrait_mtl &lt;- pdf_subset(&quot;data/graphique/SAD_montreal.pdf&quot;, pages = c(30:97), output = &quot;data/graphique/SAD_montral_ext.pdf&quot;) # Étape 2 : extraire le texte des fichiers pdf sous forme de vecteur de texte file_qc &lt;- pdf_text(extrait_qc) file_mtl &lt;- pdf_text(extrait_mtl) # Étape 3 : retirer les sauts de lignes et les paragraphes file_qc &lt;- gsub(&quot;\\r&quot;,&quot;&quot;,x = file_qc) file_qc &lt;- gsub(&quot;\\n&quot;,&quot;&quot;,x = file_qc) file_mtl &lt;- gsub(&quot;\\r&quot;,&quot;&quot;,x = file_mtl) file_mtl &lt;- gsub(&quot;\\n&quot;,&quot;&quot;,x = file_mtl) # Étape 4 : créer une seule longue chaîne de caractères # à partir des vecteurs de texte text_qc &lt;- paste(file_qc, collapse = &quot; &quot;) text_mtl &lt;- paste(file_mtl, collapse = &quot; &quot;) # charger le modèle linguistique français model &lt;- udpipe_load_model(&#39;data/graphique/french-sequoia-ud-2.4-190531.udpipe&#39;) # pour télécharger le modèle si ce n&#39;est pas encore fait : # model &lt;- udpipe_download_model(&quot;french-sequoia&quot;) # model &lt;- udpipe_load_model(model) # Étape 5 : analyse de la nature des mots du texte avec le dictionnaire fr # Nous obtenons des DataFrames décrivant les mots des textes annote_qc &lt;- udpipe_annotate(model, text_qc) df_qc &lt;- data.frame(annote_qc) annote_mtl &lt;- udpipe_annotate(model, text_mtl) df_mtl &lt;- data.frame(annote_mtl) # Étape 6 : utilisation de la méthode TextRank stats_qc &lt;- textrank_keywords(df_qc$lemma, relevant = df_qc$upos %in% c(&quot;NOUN&quot;, &quot;ADJ&quot;), ngram_max=2) stats_mtl &lt;- textrank_keywords(df_mtl$lemma, relevant = df_mtl$upos %in% c(&quot;NOUN&quot;,&quot;ADJ&quot;), ngram_max=2) # Étape 7 : nettoyer les coquilles dans les mots clefs # Note : nous faisons ici le choix de garder des mots clefs uniques (ngram == 1) # Il serait aussi possible de garder des associations de plusieurs mots dfstats_qc &lt;- subset(stats_qc$keywords, stats_qc$keywords$ngram == 1 &amp; nchar(stats_qc$keywords$keyword)&gt;2) dfstats_qc$keyword &lt;- gsub(&quot;d&quot;,&quot;&quot;,dfstats_qc$keyword,fixed = T) dfstats_qc$keyword &lt;- gsub(&quot;l&quot;,&quot;&quot;,dfstats_qc$keyword,fixed = T) dfstats_mtl &lt;- subset(stats_mtl$keywords, stats_mtl$keywords$ngram == 1 &amp; nchar(stats_mtl$keywords$keyword)&gt;2) dfstats_mtl$keyword &lt;- gsub(&quot;d&quot;,&quot;&quot;,dfstats_mtl$keyword,fixed = T) dfstats_mtl$keyword &lt;- gsub(&quot;l&quot;,&quot;&quot;,dfstats_mtl$keyword,fixed = T) # Étape 8 : réaliser les nuages de mots couleurs &lt;- sample(brewer.pal(12, &quot;Paired&quot;)) # mise en désordre des couleurs wordcloud2(data = dfstats_mtl[c(&quot;keyword&quot;, &quot;freq&quot;)], color = couleurs, size = 0.5, shuffle = F) wordcloud2(data = dfstats_qc[c(&quot;keyword&quot;, &quot;freq&quot;)], color = couleurs, size = 0.6, shuffle = F) Figure 3.50: Nuage de mots pour le SAD de Montréal Figure 3.51: Nuage de mots pour le SAD de Québec Notez quà chaque génération du nuage de mots, vous obtiendrez une disposition différente. Nhésitez pas à en essayer plusieurs jusquà ce que vous trouviez celle qui vous semble optimale. 3.3.4 Carte proportionnelle Une carte proportionnelle ou carte à cases (treemap en anglais) est un graphique permettant de représenter une quantité partagée entre plusieurs observations structurées dans une hiérarchie de groupe. Le jeu de données portant sur les émissions de CO2 se prête tout à fait à une représentation par treemap. La variable de quantité est bien sûr les émissions de CO2 par pays; ces pays sont regroupés dans un premier ensemble de régions (découpage en 23 régions), qui elles-mêmes sont regroupées dans des régions plus larges (découpage en sept régions). Pour construire un treemap, nous allons utilisons le package treemap. library(treemap) library(RColorBrewer) # extraire les données de CO2 en 2015 data_co2_2015 &lt;- subset(data_co2,data_co2$year == &quot;2015&quot; &amp; ! is.na(data_co2$region7)) # construire le treemap treemap(data_co2_2015, index=c(&quot;region7&quot;,&quot;region23&quot;), vSize=&quot;CO2_kt&quot;, type=&quot;index&quot;, title = &quot;CO2 rejetés par pays en 2015&quot;, fontsize.labels=c(12,8), # taille des étiquettes fontcolor.labels=c(&quot;white&quot;,&quot;black&quot;), # couleur des étiquettes fontface.labels=c(2,1), # style des polices bg.labels=c(&quot;transparent&quot;), # arrière-plan des étiquettes align.labels=list( c(&quot;center&quot;, &quot;center&quot;), c(&quot;right&quot;, &quot;bottom&quot;) ), # localisation des étiquettes dans les boîtes overlap.labels=0.5, # tolérance de superposition inflate.labels=F, # agrandir la taille des étiquettes ou non palette = brewer.pal(7,&#39;Paired&#39;) ) Figure 3.52: Treemap References "],["sect034.html", "3.4 Cartes", " 3.4 Cartes Toute comme un graphique, une carte est aussi une illustration visuelle. Avec la généralisation des données géographiques, il peut être utile de savoir représenter ce type de données. Si R nest pas un logiciel de cartographie, il est possible de réaliser des cartes assez facilement, directement avec ggplot2. Nous avons cependant une préférence pour le package tmap, qui propose de nombreuses fonctionnalités. Pour tracer des cartes, tmap et ggplot2 ont besoin dutiliser un format de données comprenant la géométrie (polygones, lignes ou points), la localisation et le système de projection des entités spatiales étudiées. Le format de fichier le plus courant pour ce type de données est le shapefile (.shp), mais vous pourrez parfois croiser des fichiers geojson (.js), ou encore geopackages (.gpkg). Pour lire ces fichiers, il est possible dutiliser la fonction readOGR du package rgdal, ou la fonction st_read du package sf. Notez ici que ces deux fonctions ne produisent pas de DataFrame, mais respectivement un SpatialDataFrame et un objet sf (spatial feature collection). Sans entrer dans les détails, sachez que deux packages permettent de manipuler des objets spatiaux dans R : le traditionnel sp (avec les SpatialDataFrames) et le plus récent sf (avec les spatial feature collections). Il est assez facile de convertir un objet de sp vers sf (et inversement) et cette opération est souvent nécessaire, car de nombreux packages dédiés à lanalyse spatiale utilisent lun ou lautre des formats. Dans le cas de tmap, des objets sp et sf peuvent être utilisés sans distinction. En revanche, pour cartographier directement avec ggplot2, il est plus facile dutiliser un objet de type sf. Toutefois, nous vous recommandons fortement dutiliser le package sf, puisque sp (et son format SpatialDataFrame) est progressivement délaissé dans R. Une carte thématique permet de représenter la répartition spatiale de variables qualitatives ou quantitatives. Nous la distinguons des cartes topographiques, dont lobjectif est de représenter la localisation dobjets spécifiques (route, habitation, rivière, lac, etc.). La première est relativement facile à construire dans R, car elle se limite à quelques symboles relativement simples. Pour la seconde, nous préférons généralement utiliser un logiciel comme QGIS. Créons une carte thématique à partir des données de densité de végétation sur lîle de Montréal avec les packages ggplot2 puis tmap. Avec ggplot2, nous avons aussi besoin des packages classInt pour calculer les intervalles des classes et ggsn pour afficher une échelle. library(sf) library(classInt) library(ggsn) # chargement des données spatialdf &lt;- st_read(&quot;data/bivariee/IlotsVeg2006.shp&quot;) ## Reading layer `IlotsVeg2006&#39; from data source ## `D:\\Articles et colloque\\Livre en cours\\AnalysesQuanti\\Livre\\livre_statistique_Phil_Jere\\data\\bivariee\\IlotsVeg2006.shp&#39; ## using driver `ESRI Shapefile&#39; ## Simple feature collection with 10213 features and 12 fields ## Geometry type: MULTIPOLYGON ## Dimension: XY ## Bounding box: xmin: 267518.7 ymin: 5029292 xmax: 306663.7 ymax: 5062652 ## Projected CRS: NAD83 / MTM zone 8 # création d&#39;une discrétisation en 7 classes égales values &lt;- c(max(spatialdf$ArbPct)+0.01,spatialdf$ArbPct) quant &lt;- classIntervals(values, n = 7, style = &quot;quantile&quot;, intervalClosure = &#39;right&#39;) spatialdf$class_col &lt;- cut(spatialdf$ArbPct, breaks = quant$brks, right = F) # cartographie avec ggplot2 ggplot(data = spatialdf) + geom_sf(aes(fill = class_col), color = rgb(0,0,0,0))+ scale_fill_brewer(palette = &quot;Greens&quot;)+ labs(title = &quot;Végétation dans les îlos de recensement&quot;, &#39;fill&#39; = &#39;Densité de la canopée (%)&#39;)+ theme(axis.line=element_blank(),axis.text.x=element_blank(), axis.text.y=element_blank(),axis.ticks=element_blank(), axis.title.x=element_blank(), axis.title.y=element_blank(), panel.background=element_blank(), panel.border=element_blank(),panel.grid.major=element_blank(), panel.grid.minor=element_blank(),plot.background=element_blank(), legend.key.size = unit(0.5, &quot;cm&quot;))+ scalebar(spatialdf, dist = 5, st.size=3, height=0.01, model = &#39;WGS84&#39;, dist_unit = &quot;km&quot;, transform = F, location = &#39;bottomright&#39;) Figure 3.53: Carte thématique avec ggplot2 Il est possible darriver à un résultat similaire avec tmap avec moins de code! library(tmap) colors &lt;- brewer.pal(7,&quot;Greens&quot;) tm_shape(spatialdf) + tm_polygons(&quot;ArbPct&quot;, palette = colors, border.alpha = 0, n = 7, style = &#39;quantile&#39;, title = &#39;Densité de la canopée (%)&#39;)+ tm_scale_bar(breaks = c(0,5,10)) + tm_layout(title = &quot;Végétation dans les îlos de recensement&quot;, attr.outside = TRUE, frame = FALSE) Figure 3.54: Carte thématique avec tmap Les graphiques créés par tmap ne peuvent malheureusement pas être combinés avec la fonction ggarrange, mais tmap dispose de sa propre fonction tmap_arrange si vous souhaitez combiner plusieurs cartes. library(tmap) colors &lt;- brewer.pal(7,&quot;Greens&quot;) colors2 &lt;- brewer.pal(7,&quot;Reds&quot;) carte1 &lt;- tm_shape(spatialdf) + tm_polygons(&quot;ArbPct&quot;, palette = colors, border.alpha = 0, n = 7, style = &#39;quantile&#39;, title = &#39;Densité de la canopée (%)&#39;) + tm_scale_bar(breaks = c(0,5,10)) + tm_layout(attr.outside = TRUE, frame = FALSE) carte2 &lt;- tm_shape(spatialdf) + tm_polygons(&quot;LogDens&quot;, palette = colors2, border.alpha = 0, n = 7, style = &#39;quantile&#39;, title = &#39;Densité de logement&#39;) + tm_scale_bar(breaks = c(0,5,10)) + tm_layout(attr.outside = TRUE, frame = FALSE) tmap_arrange(carte1, carte2, ncol = 2) Figure 3.55: Combiner des cartes avec tmap "],["sect035.html", "3.5 Exportation des graphiques", " 3.5 Exportation des graphiques Tous les graphiques que nous avons construits dans ce chapitre peuvent être exportés assez facilement. Dans RStudio, vous pouvez directement cliquer sur le bouton Export (figure 3.56) pour enregistrer votre figure au format image ou au format pdf (vectoriel). Notez quavec la seconde option, vous pourrez retoucher votre graphique avec un logiciel externe comme Inkscape ou Illustrator. Figure 3.56: Exporter un graphique dans RStudio Lorsque vous créez un graphique avec ggplot2, il est aussi possible de lexporter avec la fonction ggsave. Cette fonctionnalité est très pratique lorsque vous souhaitez automatiser la production de graphiques et ne pas avoir à tous les exporter à la main. data(iris) plot1 &lt;- ggplot() + geom_point(mapping = aes(x = Sepal.Length, y = Sepal.Width), data = iris) ggsave(filename = &#39;graphique.pdf&#39;, path = &#39;mon/dossier&#39;, plot = plot1, width = 10, height = 10, units = &quot;cm&quot;) Pour les graphiques nétant pas réalisés avec ggplot2, la solution de remplacement à la fonction ggsave est lensemble de fonctions png, bmp, jpeg, tiff et pdf, qui permettent dexporter nimporte quel graphique dans ces différents formats. Le processus comprend trois étapes : Ouvrir une connexion vers le fichier dans lequel le graphique sera exporté avec une des fonctions png, bmp, jpeg, tiff et pdf. Réaliser son graphique comme si nous souhaitions lafficher dans RSudio. Il napparaîtra cependant pas, car il sera écrit dans le fichier en question à la place. Fermer la connexion au fichier avec la fonction dev.off pour définitivement enregistrer le graphique. data(iris) # 1. Ouvrir la connexion png(filename = &#39;mon/dossier/graphique.png&#39;) # 2. Afficher le graphique ggplot() + geom_point(mapping = aes(x = Sepal.Length, y = Sepal.Width), data = iris) # 3. fermer la connexion dev.off() "],["sect036.html", "3.6 Conclusion sur les graphiques", " 3.6 Conclusion sur les graphiques Vous avez pu constater que les capacités de représentation graphique de R sont vastes et pourtant nous navons quobservé la partie émergée de liceberg dans ce chapitre. Il est également possible de réaliser une visualisation en 3D dans R (plot3D, rgl), danimer des graphiques pour en faire des GIF ou des vidéos (gganimate), de rendre des graphiques interactifs, ou même de construire des plateformes de visualisation de données disponibles en ligne (shiny). Vous continuerez à découvrir de nouvelles formes de représentations au fur et à mesure de votre pratique, en apprenant de nouvelles méthodes nécessitant des visualisations spécifiques. Voici également deux références très utiles qui nous ont notamment aidé à construire ce chapitre : The R Graph Gallery, probablement LE site web proposant le plus de matériel sur la réalisation des graphiques dans R. Data to viz, si vous ne savez pas quel graphique pourrait le mieux correspondre à vos données, Data to viz est là pour vous aider. Vous y trouverez un arbre de décision pour vous indiquer quel graphique utiliser dans quelle situation, ainsi que de nombreux conseils sur la visualisation de données. "],["chap04.html", "Chapitre 4 Relation linéaire entre deux variables quantitatives", " Chapitre 4 Relation linéaire entre deux variables quantitatives Dans le cadre de ce chapitre, nous présentons les trois principales méthodes permettant dexplorer la relation linéaire entre deux variables quantitatives, soit la covariance, la corrélation et la régression linéaire simple. Dans ce chapitre, nous utilisons les packages suivants : Pour créer des graphiques : ggplot2, le seul, lunique! ggpubr pour combiner des graphiques et réaliser des diagrammes quantiles-quantiles. Pour manipuler des données : dplyr notamment pour les fonctions group_by, summarize et les pipes %&gt;%. Pour les corrélations : boot pour réaliser des corrélations avec bootstrap. correlation, de lensemble de packages easy_stats, offrant une large panoplie de mesures de corrélation. corrplot pour créer des graphiques de matrices de corrélation. Hmisc pour calculer des corrélations de Pearson et Spearman. ppcor pour calculer des corrélations partielles. psych pour obtenir une matrice de corrélation (Pearson, Spearman et Kendall), les intervalles de confiance et les valeurs de p. stargazer pour créer de beaux tableaux dune matrice de corrélation en HTML, en LaTeX ou en ASCII. Autres packages : foreign pour importer des fichiers externes. MASS pour générer des échantillons normalement distribués. stargazer pour imprimer des tableaux. Deux variables continues varient-elles dans le même sens ou bien en sens contraire? Répondre à cette question est une démarche exploratoire classique en sciences sociales puisque les données socioéconomiques sont souvent associées linéairement. En dautres termes, lorsque lune des deux variables tant à augmenter, lautre augmente également ou diminue systématiquement. En études urbaines, nous pourrions vouloir vérifier si certaines variables socioéconomiques sont associées positivement ou négativement à des variables environnementales jugées positives (comme la couverture végétale ou des mesures daccessibilité spatiale aux parcs) ou négatives (pollutions atmosphériques et sonores). Par exemple, au niveau des secteurs de recensement dune ville canadienne, nous pourrions vouloir vérifier si le revenu médian des ménages et le coût moyen du loyer varient dans le même sens que la couverture végétale; ou encore sils varient en sens inverse des niveaux moyens de dioxyde dazote ou de bruit routier. Pour évaluer la linéarité entre deux variables continues, deux statistiques descriptives sont utilisées : la covariance (section 4.2) et la corrélation (section 4.3). "],["sect041.html", "4.1 Bref retour sur le postulat de la relation linéaire", " 4.1 Bref retour sur le postulat de la relation linéaire Vérifier le postulat de la linéarité consiste à évaluer si deux variables quantitatives varient dans le même sens ou bien en sens contraire. Toutefois, la relation entre deux variables quantitatives nest pas forcément linéaire. En guise dillustration, la figure 4.1 permet de distinguer quatre types de relations : Le cas a illustre une relation linéaire positive entre les deux variables puisquelles vont dans le même sens. Autrement dit, quand les valeurs de X augmentent, celles de Y augmentent aussi. En guise dexemple, pour les secteurs de recensement dune métropole donnée, il est fort probable que le coût moyen du loyer soit associé positivement avec le revenu médian des ménages. Graphiquement parlant, il est clair quune droite dans ce nuage de points résumerait efficacement la relation entre ces deux variables. Le cas b illustre une relation linéaire négative entre les deux variables puisquelles vont en sens inverse. Autrement dit, quand les valeurs de X augmentent, celles de Y diminuent, et inversement. En guise dexemple, pour les secteurs de recensement dune métropole donnée, il est fort probable que le revenu médian des ménages soit associé négativement avec le taux de chômage. De nouveau, une droite résumerait efficacement cette relation. Pour le cas c, il y a une relation entre les deux variables, mais qui nest pas linéaire. Le nuage de points entre les deux variables prend dailleurs une forme parabolique qui traduit une relation curvilinéaire. Concrètement, nous observons une relation positive jusquà un certain seuil, puis une relation négative. Pour le cas d, la relation entre les deux variables est aussi curvilinéaire; dabord négative, puis positive. Figure 4.1: Relations linéaires et curvilinéaires entre deux variables continues Prenons un exemple concret pour illuster le cas c. Dans une étude portant sur léquité environnementale et la végétation à Montréal, Pham et al. (2012) ont montré quil existe une relation curvilinéaire entre lâge médian des bâtiments résidentiels (axe des abscisses) et les couvertures végétales (axes des ordonnées) : La couverture de la végétation totale et celle des arbres augmentent quand lâge médian des bâtiments croît jusquà atteindre un pic autour de 60 ans (autour de 1950). Nous pouvons supposer que les secteurs récemment construits, surtout ceux dans les banlieues, présentent des niveaux de végétation plus faibles. Au fur et à mesure que le quartier vieillit, les arbres plantés lors du développement résidentiel deviennent matures  canopée plus importante , doù laugmentation des valeurs de la couverture végétale totale et de celle des arbres. Par contre, dans les secteurs développés avant les années 1950, la densité du bâti est plus forte, laissant ainsi moins de place pour la végétation, ce qui explique une diminution des variables relatives à la couverture végétale (figure 4.2). Figure 4.2: Exemples de relations curvilinéaires Dans les sous-sections suivantes, nous décrivons deux statistiques descriptives et exploratoires  la covariance (section 4.2) et la corrélation (section 4.3)  utilisées pour évaluer la relation linéaire entre deux variables continues (cas a et b à la figure 4.1). Ces deux mesures permettent de mesurer le degré dassociation entre deux variables, sans que lune soit la variable dépendante (variable à expliquer) et lautre, la variable indépendante (variable explicative). Puis, nous décrivons la régression linéaire simple (section 4.4) qui permet justement de prédire une variable dépendante (Y) à partir dune variable indépendante (X). References "],["sect042.html", "4.2 Covariance", " 4.2 Covariance 4.2.1 Formulation La covariancecovariance (équation (4.1)), écrite \\(cov(x,y)\\), est égale à la moyenne du produit des écarts des valeurs des deux variables par rapport à leurs moyennes respectives : \\[\\begin{equation} cov(x,y) = \\frac{\\sum_{i=1}^n (x_{i}-\\bar{x})(y_{i}-\\bar{y})}{n-1} = \\frac{covariation}{n-1} \\tag{4.1} \\end{equation}\\] avec \\(n\\) étant le nombre dobservations; \\(\\bar{x}\\) et \\(\\bar{y}\\) (prononcez x et y barre) étant les moyennes respectives des variables X et Y. 4.2.2 Interprétation Le numérateur de léquation (4.1) représente la covariationcovariance, soit la somme du produit des déviations des valeurs \\(x_{i}\\) et \\(y_{i}\\) par rapport à leurs moyennes respectives (\\(\\bar{x}\\) et \\(\\bar{y}\\)). La covariance est donc la covariation divisée par le nombre dobservations, soit la moyenne de la covariation. Sa valeur peut être positive ou négative : Positive quand les deux variables varient dans le même sens, cest-à-dire lorsque les valeurs de la variable X séloignent de la moyenne, les valeurs de Y séloignent aussi dans le même sens; et elle est négative pour une situation inverse. Quand la covariance est égale à 0, il ny a pas de relation entre les variables X et Y. Plus sa valeur absolue est élevée, plus la relation entre les deux variables X et Y est importante. Ainsi, la covariance correspond à un centrage des variables, cest-à-dire à soustraire à chaque valeur de la variable sa moyenne correspondante. Linconvénient majeur de lutilisation de la covariance est quelle est tributaire des unités de mesure des deux variables. Par exemple, si nous calculons la covariance entre le pourcentage de personnes à faible revenu et la densité de population (habitants au km2) au niveau des secteurs de recensement de la région métropolitaine de Montréal, nous obtenons une valeur de covariance de 33 625. En revanche, si la densité de population est exprimée en milliers dhabitants au km2, la valeur de la covariance sera de 33,625, alors que la relation linéaire entre les deux variables reste la même comme illustré à la figure 4.3. Pour remédier à ce problème, nous privilégions lutilisation du coefficient de corrélation. Figure 4.3: Covariance et unités de mesure "],["sect043.html", "4.3 Corrélation", " 4.3 Corrélation 4.3.1 Formulation Le coefficient de corrélation de Pearson (\\(r\\)) est égal à la covariance (numérateur) divisée par le produit des écarts-types des deux variables X et Y (dénominateur). Il représente une standardisation de la covariance. Autrement dit, le coefficient de corrélation repose sur un centrage (moyenne = 0) et une réduction (variance = 1) des deux variables, cest-à-dire quil faut soustraire de chaque valeur sa moyenne correspondante et la diviser par son écart-type. Il correspond ainsi à la moyenne du produit des deux variables centrées réduites. Il sécrit alors : \\[\\begin{equation} r_{xy} = \\frac{\\sum_{i=1}^n (x_{i}-\\bar{x})(y_{i}-\\bar{y})}{(n-1)\\sqrt{\\sum_{i=1}^n(x_i - \\bar{x})^2(y_i - \\bar{y})^2}}=\\sum_{i=1}^n\\frac{Zx_iZy_i}{n-1} \\tag{4.2} \\end{equation}\\] La syntaxe ci-dessous démontre que le coefficient de corrélation de Pearson est bien égal à la moyenne du produit de deux variables centrées réduites. library(&quot;MASS&quot;) N &lt;- 1000 # nombre d&#39;observations moy_x &lt;- 50 # moyenne de x moy_y &lt;- 40 # moyenne de y sd_x &lt;- 10 # écart-type de x sd_y &lt;- 8 # écart-type de y rxy &lt;- .80 # corrélation entre X et Y ## création de deux variables fictives normalement distribuées et corrélées entre elles # Création d&#39;une matrice de covariance cov &lt;- matrix(c(sd_x^2, rxy*sd_x*sd_y, rxy*sd_x*sd_y, sd_y^2), nrow=2) # Création du tableau de données avec deux variables df1 &lt;- as.data.frame(mvrnorm(N, c(moy_x, moy_y), cov)) # Centrage et réduction des deux variables df1$zV1 &lt;- scale(df1$V1, center = TRUE, scale = TRUE) df1$zV2 &lt;- scale(df1$V2, center = TRUE, scale = TRUE) # Corrélation de Pearson cor1 &lt;- cor(df1$V1, df1$V2) cor2 &lt;- sum(df1$zV1*df1$zV2) / (nrow(df1)-1) cat(&quot;Corrélation de Pearson = &quot;,round(cor1,5), &quot;\\nMoyenne du produit des variables centrées-réduites =&quot;, round(cor2,5)) ## Corrélation de Pearson = 0.80112 ## Moyenne du produit des variables centrées-réduites = 0.80112 4.3.2 Interprétation Le coefficient de corrélation \\(r\\) varie de 1 à 1 avec : 0 quand il ny a pas de relation linéaire entre les variables X et Y; 1 quand il y a relation linéaire négative parfaite; 1 quand il y a une relation linéaire positive parfaite (figure 4.4). Figure 4.4: Relations entre deux variables continues et coefficients de corrélation de Pearson Concrètement, le signe du coefficient de corrélation indique si la relation est positive ou négative et la valeur absolue du coefficient indique le degré dassociation entre les deux variables. Reste à savoir comment déterminer quune valeur de corrélation est faible, moyenne ou forte. En sciences sociales, nous utilisons habituellement les intervalles de valeurs reportés au tableau 4.1. Toutefois, ces seuils sont tout à fait arbitraires. En effet, dépendamment de la discipline de recherche (sciences sociales, sciences de la santé, sciences physiques, etc.) et des variables à létude, linterprétation dune valeur de corrélation peut varier. Par exemple, en sciences sociales, une valeur de corrélation de 0,2 est considérée comme très faible alors quen sciences de la santé, elle pourrait être considérée comme intéressante. À lopposé, une valeur de 0,9 en sciences physiques pourrait être considérée comme faible. Il convient alors dutiliser ces intervalles avec précaution. Tableau 4.1: Intervalles pour linterprétation du coefficient de corrélation habituellement utilisés en sciences sociales Corrélation Négative Positive Faible de -0,3 à 0,0 de 0,0 à 0,3 Moyenne de -0,5 à -0,3 de 0,3 à 0,5 Forte de -1,0 à -0,5 de 0,5 à 1,0 Le coefficient de corrélation mis au carré représente le coefficient de détermination et indique la proportion de la variance de la variable Y expliquée par la variable X et inversement. Par exemple, un coefficient de corrélation de 0,70 signale que 49 % de la variance de la variable de Y est expliquée par X (figure 4.5). Figure 4.5: Coefficient de corrélation et proportion de la variance expliquée Condition dapplication. Lutilisation du coefficient de corrélation de Pearson nécessite que les deux variables continues soient normalement distribuées et quelles ne comprennent pas de valeurs aberrantes ou extrêmes. Dailleurs, plus le nombre dobservations est réduit, plus la présence de valeurs extrêmes a une répercussion importante sur le résultat du coefficient de corrélation de Pearson. En guise dexemple, dans le nuage de points à gauche de la figure 4.6, il est possible didentifier des valeurs extrêmes qui se démarquent nettement dans le jeu de données : six observations avec une densité de population supérieure à 20 000 habitants au km2 et deux observations avec un pourcentage de 65 ans et plus supérieur à 55 %. Si lon supprime ces observations (ce qui est défendable dans ce contexte)  soit moins dun pour cent des observations du jeu de données initial , la valeur du coefficient de corrélation passe de 0,158 à 0,194, signalant une augmentation du degré dassociation entre les deux variables. Figure 4.6: Illustation de leffet des valeurs extrêmes sur le coefficient de Pearson 4.3.3 Corrélations pour des variables anormalement distribuées (coefficient de Spearman, tau de Kendall) Lorsque les variables sont fortement anormalement distribuées, le coefficient de corrélation de Pearson est peu adapté pour analyser leurs relations linéaires. Il est alors conseillé dutiliser deux statistiques non-paramétriques : principalement, le coefficient de corrélation de Spearman (rho) et secondairement, le tau (\\(\\tau\\)) de Kendall, qui varient aussi tous deux de 1 à 1. Calculé sur les rangs des deux variables, le coefficient de Spearman est le rapport entre la covariance des deux variables de rangs sur les écarts-types des variables de rangs. En dautres termes, il représente simplement le coefficient de Pearson calculé sur les rangs des deux variables : \\[\\begin{equation} r_{xy} = \\frac{cov(rg_{x},rg_{y})}{\\sigma_{rg_{x}}\\sigma_{rg_{y}}} \\tag{4.3} \\end{equation}\\] La syntaxe ci-dessous démontre clairement que le coefficient de Spearman est bien le coefficient de Pearson calculé sur les rangs (4.3.1). df &lt;- read.csv(&quot;data/bivariee/sr_rmr_mtl_2016.csv&quot;) # Transformation des deux variables en rangs df$HabKm2_rang &lt;- rank(df$HabKm2) df$A65plus_rang &lt;- rank(df$A65plus) # Coefficient de Spearman avec la fonction cor et la méthode spearman cat(&quot;Coefficient de Spearman = &quot;, round(cor(df$HabKm2, df$A65plus, method = &quot;spearman&quot;),5)) ## Coefficient de Spearman = -0.11953 # Coefficient de Pearson sur les variables transformées en rangs cat(&quot;Coefficient de Pearson calculé sur les variables transformées en rangs = &quot;, round(cor(df$HabKm2_rang, df$A65plus_rang, method = &quot;pearson&quot;),5)) ## Coefficient de Pearson calculé sur les variables transformées en rangs = -0.11953 # Vérification avec l&#39;équation cat(&quot;Covariance divisée par le produit des écarts-types sur les rangs :&quot;, round(cov(df$HabKm2_rang, df$A65plus_rang) / (sd(df$HabKm2_rang)*sd(df$A65plus_rang)),5)) ## Covariance divisée par le produit des écarts-types sur les rangs : -0.11953 Le tau de Kendall est une autre mesure non paramétrique calculée comme suit : \\[\\begin{equation} \\tau = \\frac{n_{c}-n_{d}}{\\frac{1}{2}n(n-1)} \\tag{4.4} \\end{equation}\\] avec \\(n_{c}\\) et \\(n_{d}\\) qui sont respectivement les nombres de paires dobservations concordantes et discordantes; et le dénominateur étant le nombre total de paires dobservations. Des paires sont dites concordantes quand les valeurs des deux observations vont dans le même sens pour les deux variables (\\(x_{i}&gt;x_{j}\\) et \\(y_{i}&gt;y_{j}\\) ou \\(x_{i}&lt;x_{j}\\) et \\(y_{i}&lt;y_{j}\\)), et discordantes quand elles vont en sens contraire (\\(x_{i}&gt;x_{j}\\) et \\(y_{i}&lt;y_{j}\\) ou \\(x_{i}&lt;x_{j}\\) et \\(y_{i}&gt;y_{j}\\)). Contrairement au calcul du coefficient de Spearman, celui du tau Kendall peut être chronophage : plus le nombre dobservations est élevé, plus les temps de calcul et la mémoire utilisée sont importants. En effet, avec n=1000, le nombre de paires dobservations (\\({\\mbox{0,5}\\times n(n-1)}\\)) est de 499 500, contre près de 50 millions avec n=10 000 (49 995 000). Figure 4.7: Comparaison des coefficients de Pearson, Spearman et Kendall sur deux variables anormalement distribuées À la lecture des deux histogrammes à la figure 4.7, il est clair que les variables densité de population et pourcentage de personnes ayant 65 ou plus sont très anormalement distribuées. Dans ce contexte, lutilisation du coefficient de Pearson peut nous amener à mésestimer la relation existant entre les deux variables. Notez que les coefficients de Spearman et de Kendall sont tous les deux plus faibles. 4.3.4 Corrélations robustes (Biweight midcorrelation, Percentage bend correlation et la corrélation pi de Shepherd) Dans lexemple donné à la figure 4.6, nous avions identifié des valeurs extrêmes et les avons retirées du jeu de données. Cette pratique peut tout à fait se justifier quand les données sont erronées (un capteur de pollution renvoyant une valeur négative, un questionnaire rempli par un mauvais plaisantin, etc.), mais parfois les cas extrêmes font partie du phénomène à analyser. Dans ce contexte, les identifier et les retirer peut paraître arbitraire. Une solution plus élégante est dutiliser des méthodes dites robustes, cest à dire moins sensibles aux valeurs extrêmes. Pour les corrélations, la Biweight midcorrelation (Wilcox 1994) est au coefficient de Pearson ce que la médiane est à la moyenne. Il est donc pertinent de lutiliser pour des jeux de données présentant potentiellement des valeurs extrêmes. Elle est calculée comme suit : \\[\\begin{equation} \\begin{aligned} &amp;u_{i} = \\frac{x_{i} - med(x)}{9 \\times (med(|x_{i} - med(x)|))} \\text{ et } v_{i} = \\frac{y_{i} - med(y)}{9 \\times (med(|y_{i} - med(y)|))}\\\\ &amp;w_{i}^{(x)} = (1 - u_{i}^2)^2 I(1 - |u_{i}|) \\text{ et } w_{i}^{(y)} = (1 - v_{i}^2)^2 I(1 - |v_{i}|)\\\\ &amp;I(x) = \\begin{cases} 1, \\text{si } x = 1\\\\ 0, \\text{sinon} \\end{cases}\\\\ &amp;\\tilde{x}_{i} = \\frac{(x_{i} - med(x))w_{i}^{(x)}}{\\sqrt{(\\sum_{j=1}^m)[(x_{j} - med(x))w_{j}^{(x)}]^2}} \\text{ et } \\tilde{y}_{i} = \\frac{(y_{i} - med(y))w_{i}^{(y)}}{\\sqrt{(\\sum_{j=1}^m)[(y_{j} - med(y))w_{j}^{(y)}]^2}}\\\\ &amp;bicor(x,y) = \\sum_{i=1}^m \\tilde{x_i}\\tilde{y_i} \\end{aligned} \\tag{4.5} \\end{equation}\\] Comme le souligne léquation (4.5), la Biweight midcorrelation est basée sur les écarts à la médiane, plutôt que sur les écarts à la moyenne. Assez proche de la Biweight midcorrelation, la Percentage bend correlation se base également sur la médiane des variables X et Y. Le principe général est de donner un poids plus faible dans le calcul de cette corrélation à un certain pourcentage des observations (20 % sont généralement recommandés) dont la valeur est éloignée de la médiane. Pour une description complète de la méthode, vous pouvez lire larticle de Wilcox (1994). Enfin, une autre option est lutilisation de la corrélation \\(pi\\) de Sherphred (Schwarzkopf, Haas et Rees 2012). Il sagit simplement dune méthode en deux étapes. Premièrement, les valeurs extrêmes sont identifiées à laide dune approche par bootstrap utilisant la distance de Mahalanobis (calculant les écarts multivariés entre les observations). Deuxièmement, le coefficient de Spearman est calculé sur les observations restantes. Appliquons ces corrélations aux données précédentes. Notez que ce simple code dune dizaine de lignes permet dexplorer rapidement la corrélation entre deux variables selon six mesures de corrélation. library(&quot;correlation&quot;) df1 &lt;- read.csv(&quot;data/bivariee/sr_rmr_mtl_2016.csv&quot;) methods &lt;- c(&quot;Pearson&quot;,&quot;Spearman&quot;,&quot;Biweight&quot;,&quot;Percentage&quot;,&quot;Shepherd&quot;) rs &lt;- lapply(methods,function(m){ test &lt;- correlation::cor_test(data = df1, x=&quot;Hab1000Km2&quot;,y=&quot;A65plus&quot;,method = m, ci=0.95) return(c(test$r,test$CI_low, test$CI_high)) }) dfCorr &lt;- data.frame(do.call(rbind,rs)) names(dfCorr) &lt;- c(&quot;r&quot;,&quot;IC_2.5&quot;,&quot;IC_97.5&quot;) dfCorr$method &lt;- methods # Impression du tableau avec le package stargazer library(stargazer) stargazer(dfCorr, type=&quot;text&quot;, summary=FALSE, rownames=FALSE, align = FALSE, digits = 3, title=&quot;Comparaison de différentes corrélations pour les deux variables&quot;) Tableau 4.2: Comparaison de différentes corrélations pour les deux variables r IC 2,5 % IC 97,5 % Méthode -0,158 -0,219 -0,095 Pearson -0,120 -0,184 -0,055 Spearman -0,137 -0,199 -0,074 Biweight -0,174 -0,235 -0,111 Percentage -0,119 -0,185 -0,052 Shepherd Il est intéressant de mentionner que ces trois corrélations sont rarement utilisées malgré leur pertinence dans de nombreux cas dapplication. Nous faisons face ici à un cercle vicieux dans la recherche : les méthodes les plus connues sont les plus utilisées, car elles sont plus facilement acceptées par la communauté scientifique. Des méthodes plus élaborées nécessitent davantage de justification et de discussion, ce qui peut conduire à de multiples sessions de corrections/resoumissions pour quun article soit accepté, malgré le fait quelles puissent être plus adaptées au jeu de données à létude. 4.3.5 Significativité des coefficients de corrélation Quelle que soit la méthode utilisée, il convient de vérifier si le coefficient de corrélation est ou non statistiquement différent de 0. En effet, nous travaillons la plupart du temps avec des données déchantillonnage, et très rarement avec des populations complètes. En collectant un nouvel échantillon, aurions-nous obtenu des résultats différents? Le calcul de ce degré de significativité permet de quantifier le niveau de certitude quant à lexistence dune corrélation entre les deux variables, positive ou négative. Cet objectif est réalisé en calculant la valeur de t et le nombre de degrés de liberté : \\(t=\\sqrt{\\frac{n-2}{1-r^2}}\\) et \\(dl = n-2\\) avec \\(r\\) et \\(n\\) étant respectivement le coefficient de corrélation et le nombre dobservations. De manière classique, nous utiliserons la table des valeurs critiques de la distribution de \\(t\\) : si la valeur de \\(t\\) est supérieure à la valeur critique (avec p = 0,05 et le nombre de degrés de liberté), alors le coefficient est significatif à 5 %. En dautres termes, si la vraie corrélation entre les deux variables (calculable uniquement à partir des populations complètes) était 0, alors la probabilité de collecter notre échantillon serait inférieure à 5 %. Dans ce contexte, nous peuvons raisonnablement rejeter lhypothèse nulle (corrélation de 0). La courte syntaxe ci-dessous illustre comment calculer la valeur de \\(t\\), le nombre de degrés de liberté et la valeur de p pour une corrélation donnée. df &lt;- read.csv(&quot;data/bivariee/sr_rmr_mtl_2016.csv&quot;) r &lt;- cor(df$A65plus, df$LogTailInc) # Corrélation n &lt;- nrow(df) # Nombre d&#39;observations dl &lt;- nrow(df)-2 # degrés de liberté t &lt;- r*sqrt((n-2)/(1-r^2)) # Valeur de T p &lt;- 2*(1-pt(abs(t),dl)) # Valeur de p cat(&quot;\\nCorrélation =&quot;, round(r, 4), &quot;\\nValeur de t =&quot;, round(t, 4), &quot;\\nDegrés de liberté =&quot;, dl, &quot;\\np=&quot;, round(p, 4)) ## ## Corrélation = -0.0693 ## Valeur de t = -2.1413 ## Degrés de liberté = 949 ## p= 0.0325 Plus simplement, la fonction cor.test permet dobtenir en une seule ligne de code le coefficient de corrélation, lintervalle de confiance à 95 % et les valeurs de t et de p, comme illustré dans la syntaxe ci-dessous. Si lintervalle de confiance est à cheval sur 0, cest-à-dire que la borne inférieure est négative et la borne supérieure positive, alors le coefficient de corrélation nest pas significatif au seuil choisi (95 % habituellement). Dans lexemple ci-dessous, la relation linéaire entre les deux variables est significativement négative avec une corrélation de Pearson de 0,158 (p = 0,000) et un intervalle de confiance à 95 % de 0,219 à 0,095. # Intervalle de confiance à 95 % cor.test(df$HabKm2, df$A65plus, conf.level = .95) ## ## Pearson&#39;s product-moment correlation ## ## data: df$HabKm2 and df$A65plus ## t = -4.9318, df = 949, p-value = 9.616e-07 ## alternative hypothesis: true correlation is not equal to 0 ## 95 percent confidence interval: ## -0.2194457 -0.0954687 ## sample estimates: ## cor ## -0.1580801 # Vous pouvez accéder à chaque sortie de la fonction cor.test comme suit : p &lt;- cor.test(df$HabKm2, df$A65plus) cat(&quot;Valeur de corrélation = &quot;, round(p$estimate,3), &quot;\\n&quot;, &quot;Intervalle à 95 % = [&quot;, round(p$conf.int[1],3), &quot; &quot;, round(p$conf.int[2],3), &quot;]&quot;, &quot;\\n&quot;, &quot;Valeur de t = &quot;, round(p$statistic,3), &quot;\\n&quot;, &quot;Valeur de p = &quot;, round(p$p.value,3),&quot;\\n&quot;, sep=&quot;&quot;) ## Valeur de corrélation = -0.158 ## Intervalle à 95 % = [-0.219 -0.095] ## Valeur de t = -4.932 ## Valeur de p = 0 # Corrélation de Spearman cor.test(df$HabKm2, df$A65plus, method = &quot;spearman&quot;) ## ## Spearman&#39;s rank correlation rho ## ## data: df$HabKm2 and df$A65plus ## S = 160482182, p-value = 0.0002202 ## alternative hypothesis: true rho is not equal to 0 ## sample estimates: ## rho ## -0.1195333 # Corrélation de Kendall cor.test(df$HabKm2, df$A65plus, method=&quot;kendall&quot;) ## ## Kendall&#39;s rank correlation tau ## ## data: df$HabKm2 and df$A65plus ## z = -3.7655, p-value = 0.0001662 ## alternative hypothesis: true tau is not equal to 0 ## sample estimates: ## tau ## -0.08157061 On pourra aussi modifier lintervalle de confiance, par exemple à 90 % ou 99 %. Lintervalle de confiance et le seuil de significativité doivent être définis avant létude. Leur choix doit sappuyer sur les standards de la littérature du domaine étudié, du niveau de preuve attendu et de la quantité de données. # Intervalle à 90 % cor.test(df$HabKm2, df$A65plus, method =&quot;pearson&quot;, conf.level = .90) ## ## Pearson&#39;s product-moment correlation ## ## data: df$HabKm2 and df$A65plus ## t = -4.9318, df = 949, p-value = 9.616e-07 ## alternative hypothesis: true correlation is not equal to 0 ## 90 percent confidence interval: ## -0.2096826 -0.1055995 ## sample estimates: ## cor ## -0.1580801 # Intervalle à 99 % cor.test(df$HabKm2, df$A65plus, method =&quot;pearson&quot;, conf.level = .99) ## ## Pearson&#39;s product-moment correlation ## ## data: df$HabKm2 and df$A65plus ## t = -4.9318, df = 949, p-value = 9.616e-07 ## alternative hypothesis: true correlation is not equal to 0 ## 99 percent confidence interval: ## -0.23839910 -0.07561336 ## sample estimates: ## cor ## -0.1580801 Corrélation et bootstrap. Il est possible destimer la corrélation en mobilisant la notion de bootstrap, soit des méthodes dinférence statistique basées sur des réplications des données initiales par rééchantillonnage. Concrètement, la méthode du bootstrap permet une mesure de la corrélation avec un intervalle de confiance à partir de r réplications, comme illustré à partir de la syntaxe ci-dessous. library(&quot;boot&quot;) df &lt;- read.csv(&quot;data/bivariee/sr_rmr_mtl_2016.csv&quot;) # Fonction pour la corrélation correlation &lt;- function(df, i, X, Y, cor.type=&quot;pearson&quot;){ # Paramètres de la fonction : # data : DataFrame # X et Y : noms des variables X et Y # cor.type : type de corrélation : c(&quot;pearson&quot;,&quot;spearman&quot;,&quot;kendall&quot;) # i : indice qui sera utilisé par les réplications (à ne pas modifier) cor(df[[X]][i], df[[Y]][i], method=cor.type) } # Calcul du Bootstrap avec 5000 réplications corBootstraped &lt;- boot(data=df, # nom du tableau statistic = correlation, # appel de la fonction à répliquer R=5000, # nombre de réplications X = &quot;A65plus&quot;, Y =&quot;HabKm2&quot;, cor.type=&quot;pearson&quot;) # Histogramme pour les valeurs de corrélation issues du Bootstrap plot(corBootstraped) Figure 4.8: Histogramme pour les valeurs de corrélation issues du Bootstrap # Corrélation &quot;bootstrapée&quot; corBootstraped ## ## ORDINARY NONPARAMETRIC BOOTSTRAP ## ## ## Call: ## boot(data = df, statistic = correlation, R = 5000, X = &quot;A65plus&quot;, ## Y = &quot;HabKm2&quot;, cor.type = &quot;pearson&quot;) ## ## ## Bootstrap Statistics : ## original bias std. error ## t1* -0.1580801 -0.0008186283 0.03956123 # Intervalle de confiance du bootstrap à 95 % boot.ci(boot.out = corBootstraped, conf = 0.95, type = &quot;all&quot;) ## BOOTSTRAP CONFIDENCE INTERVAL CALCULATIONS ## Based on 5000 bootstrap replicates ## ## CALL : ## boot.ci(boot.out = corBootstraped, conf = 0.95, type = &quot;all&quot;) ## ## Intervals : ## Level Normal Basic ## 95% (-0.2348, -0.0797 ) (-0.2437, -0.0869 ) ## ## Level Percentile BCa ## 95% (-0.2293, -0.0725 ) (-0.2177, -0.0522 ) ## Calculations and Intervals on Original Scale # Comparaison de l&#39;intervalle classique basé sur la valeur de T p &lt;- cor.test(df$HabKm2, df$A65plus) cat(round(p$estimate,5), &quot; [&quot;, round(p$conf.int[1],4), &quot; &quot;,round(p$conf.int[2],4), &quot;]&quot;, sep=&quot;&quot;) ## -0.15808 [-0.2194 -0.0955] Le bootstrap renvoie un coefficient de corrélation de Pearson de 0,158. Les intervalles de confiance obtenus à partir des différentes méthodes destimation (normale, basique, pourcentage et BCa) ne sont pas à cheval sur 0, indiquant que le coefficient est significatif à 5 %. 4.3.6 Corrélation partielle Quelle est la relation entre deux variables continues une fois prise en compte une autre variable dite de contrôle? En études urbaines, nous pourrions vouloir vérifier si deux variables sont ou non associées après avoir contrôlé la densité de population ou encore la distance au centre-ville. La corrélation partielle permet dévaluer la relation linéaire entre deux variables quantitatives continues, après avoir contrôlées une ou plusieurs autres variables quantitatives (dites variables de contrôle). Le coefficient de corrélation partielle peut être calculé pour plusieurs mesures de corrélation (notamment, Pearson, Spearman et Kendall). Variant aussi de 1 à 1, il est calculé comme suit : \\[\\begin{equation} r_{ABC} = \\frac{r_{AB}-r_{AC}r_{BC}}{\\sqrt{(1-r_{AC}^2)(1-r_{BC}^2)}} \\tag{4.6} \\end{equation}\\] avec A et B étant les deux variables pour lesquelles nous souhaitons évaluer la relation linéaire, une fois contrôlée la variable C; \\(r\\) étant le coefficient de corrélation (Pearson, Spearman ou Kendall) entre deux variables. Dans lexemple ci-dessous, nous voulons estimer la relation linéaire entre le pourcentage de personnes à faible revenu et la couverture végétale au niveau des îlots de lîle de Montréal, une fois contrôlée la densité de population. En effet, plus cette dernière est forte, plus la couverture végétale est faible (\\(r\\) de Pearson = 0,563). La valeur du \\(r\\) de Pearson sélève à 0,513 entre le pourcentage de personnes à faible revenu dans la population totale de lîlot et la couverture végétale. Une fois la densité de population contrôlée, elle chute à 0,316. Pour calculer la corrélation partielle, nous pouvons utiliser la fonction pcor.test du package ppcor. library(&quot;foreign&quot;) library(&quot;ppcor&quot;) dfveg &lt;- read.dbf(&quot;data/bivariee/IlotsVeg2006.dbf&quot;) # Corrélation entre les trois variables round(cor(dfveg[, c(&quot;VegPct&quot;, &quot;Pct_FR&quot;,&quot;LogDens&quot;)], method=&quot;p&quot;), 3) ## VegPct Pct_FR LogDens ## VegPct 1.000 -0.513 -0.563 ## Pct_FR -0.513 1.000 0.513 ## LogDens -0.563 0.513 1.000 # Corrélation partielle avec la fonction pcor.test entre : # la couverture végétale de l&#39;îlot (%) et # le pourcentage de personnes à faible revenu # une fois contrôlée la densité de population pcor.test(dfveg$Pct_FR, dfveg$VegPct, dfveg$LogDens, method=&quot;p&quot;) ## estimate p.value statistic n gp Method ## 1 -0.3155194 8.093159e-235 -33.59772 10213 1 pearson # Calcul de la corrélation partielle avec la formule corAB &lt;- cor(dfveg$VegPct, dfveg$Pct_FR, method = &quot;p&quot;) corAC &lt;- cor(dfveg$VegPct, dfveg$LogDens, method = &quot;p&quot;) corBC &lt;- cor(dfveg$Pct_FR, dfveg$LogDens, method = &quot;p&quot;) CorP &lt;- (corAB - (corAC*corBC)) / sqrt((1-corAC^2)*(1-corBC^2)) cat(&quot;Corr. partielle avec ppcor = &quot;, round(pcor.test(dfveg$Pct_FR, dfveg$VegPct, dfveg$LogDens, method=&quot;p&quot;)$estimate,5), &quot;\\nCorr. partielle (formule) = &quot;, round(CorP, 5)) ## Corr. partielle avec ppcor = -0.31552 ## Corr. partielle (formule) = -0.31552 4.3.7 Mise en uvre dans R Comme vous laurez compris, il est possible darriver au même résultat par différents moyens. Pour calculer les corrélations, nous avons utilisé jusquà présent les fonctions de base cor et cor.test. Il est aussi possible de recourir à des fonctions dautres packages, dont notamment : Hmisc, dont la fonction rcorr permet de calculer des corrélations de Pearson et de Spearman (mais non celle de Kendall) avec les valeurs de p. psych, dont la fonction corr.test permet dobtenir une matrice de corrélation (Pearson, Spearman et Kendall), les intervalles de confiance et les valeurs de p. stargazer pour créer de beaux tableaux dune matrice de corrélation en HTML, en LaTeX ou en ASCII. apaTables pour créer un tableau avec une matrice de corrélation dans un fichier Word. correlation pour aller plus loin et explorer les corrélations bayésiennes, robustes, non linéaires ou multiniveaux. df1 &lt;- read.csv(&quot;data/bivariee/sr_rmr_mtl_2016.csv&quot;) library(&quot;Hmisc&quot;) library(&quot;stargazer&quot;) library(&quot;apaTables&quot;) library(&quot;dplyr&quot;) # Corrélations de Pearson et Spearman et valeurs de p # avec la fonction rcorr de Hmisc pour deux variables Hmisc::rcorr(df1$RevMedMen, df1$Locataire, type=&quot;pearson&quot;) ## x y ## x 1.00 -0.78 ## y -0.78 1.00 ## ## n= 951 ## ## ## P ## x y ## x 0 ## y 0 Hmisc::rcorr(df1$RevMedMen, df1$Locataire, type=&quot;spearman&quot;) ## x y ## x 1.00 -0.91 ## y -0.91 1.00 ## ## n= 951 ## ## ## P ## x y ## x 0 ## y 0 # Matrice de corrélation avec la fonction rcorr de Hmisc pour plus de variables # Nous créons au préalable un vecteur avec les noms des variables à sélectionner Vars &lt;- c(&quot;RevMedMen&quot;,&quot;Locataire&quot;, &quot;LogTailInc&quot;,&quot;A65plus&quot;,&quot;ImgRec&quot;, &quot;HabKm2&quot;, &quot;FaibleRev&quot;) Hmisc::rcorr(df1[, Vars] %&gt;% as.matrix()) ## RevMedMen Locataire LogTailInc A65plus ImgRec HabKm2 FaibleRev ## RevMedMen 1.00 -0.78 -0.46 -0.07 -0.46 -0.49 -0.74 ## Locataire -0.78 1.00 0.56 0.00 0.64 0.71 0.88 ## LogTailInc -0.46 0.56 1.00 -0.07 0.82 0.48 0.62 ## A65plus -0.07 0.00 -0.07 1.00 -0.06 -0.16 -0.01 ## ImgRec -0.46 0.64 0.82 -0.06 1.00 0.56 0.68 ## HabKm2 -0.49 0.71 0.48 -0.16 0.56 1.00 0.64 ## FaibleRev -0.74 0.88 0.62 -0.01 0.68 0.64 1.00 ## ## n= 951 ## ## ## P ## RevMedMen Locataire LogTailInc A65plus ImgRec HabKm2 FaibleRev ## RevMedMen 0.0000 0.0000 0.0441 0.0000 0.0000 0.0000 ## Locataire 0.0000 0.0000 0.9594 0.0000 0.0000 0.0000 ## LogTailInc 0.0000 0.0000 0.0325 0.0000 0.0000 0.0000 ## A65plus 0.0441 0.9594 0.0325 0.0682 0.0000 0.6796 ## ImgRec 0.0000 0.0000 0.0000 0.0682 0.0000 0.0000 ## HabKm2 0.0000 0.0000 0.0000 0.0000 0.0000 0.0000 ## FaibleRev 0.0000 0.0000 0.0000 0.6796 0.0000 0.0000 # # Avec la fonction corr.test du package psych pour avoir la matrice de corrélation # # (Pearson, Spearman et Kendall), les intervalles de confiance et les valeurs de p # print(psych::corr.test(df[, Vars], # method = &quot;kendall&quot;, # ci=TRUE, alpha = 0.05), short=FALSE) # Création d&#39;un tableau pour une matrice de corrélation # changer le paramètre type pour &#39;html&#39; or &#39;latex&#39; si souhaité p &lt;- cor(df1[, Vars], method=&quot;pearson&quot;) stargazer(p, title=&quot;Correlation Matrix&quot;, type = &quot;text&quot;) ## ## Correlation Matrix ## ========================================================================= ## RevMedMen Locataire LogTailInc A65plus ImgRec HabKm2 FaibleRev ## ------------------------------------------------------------------------- ## RevMedMen 1 -0.785 -0.461 -0.065 -0.458 -0.489 -0.743 ## Locataire -0.785 1 0.562 -0.002 0.645 0.708 0.879 ## LogTailInc -0.461 0.562 1 -0.069 0.816 0.475 0.622 ## A65plus -0.065 -0.002 -0.069 1 -0.059 -0.158 -0.013 ## ImgRec -0.458 0.645 0.816 -0.059 1 0.561 0.678 ## HabKm2 -0.489 0.708 0.475 -0.158 0.561 1 0.642 ## FaibleRev -0.743 0.879 0.622 -0.013 0.678 0.642 1 ## ------------------------------------------------------------------------- # Créer un tableau avec la matrice de corrélation # dans un fichier Word (.doc) apaTables::apa.cor.table(df1[, c(&quot;RevMedMen&quot;,&quot;Locataire&quot;,&quot;LogTailInc&quot;)], filename = &quot;data/bivariee/TitiLaMatrice.doc&quot;, show.conf.interval = TRUE, landscape = TRUE) ## ## ## Means, standard deviations, and correlations with confidence intervals ## ## ## Variable M SD 1 2 ## 1. RevMedMen 66065.50 26635.27 ## ## 2. Locataire 45.05 26.33 -.78** ## [-.81, -.76] ## ## 3. LogTailInc 5.54 4.82 -.46** .56** ## [-.51, -.41] [.52, .60] ## ## ## Note. M and SD are used to represent mean and standard deviation, respectively. ## Values in square brackets indicate the 95% confidence interval. ## The confidence interval is a plausible range of population correlations ## that could have caused the sample correlation (Cumming, 2014). ## * indicates p &lt; .05. ** indicates p &lt; .01. ## Une image vaut mille mots, surtout pour une matrice de corrélation! Le package corrplot vous permet justement de construire de belles figures avec une matrice de corrélation (figures 4.9 et 4.10). Lintérêt de ce type de figure est de repérer rapidement des associations intéressantes lorsque nous calculons les corrélations entre un grand nombre de variables. library(&quot;corrplot&quot;) library(&quot;ggpubr&quot;) df1 &lt;- read.csv(&quot;data/bivariee/sr_rmr_mtl_2016.csv&quot;) Vars &lt;- c(&quot;RevMedMen&quot;,&quot;Locataire&quot;, &quot;LogTailInc&quot;,&quot;A65plus&quot;,&quot;ImgRec&quot;, &quot;HabKm2&quot;, &quot;FaibleRev&quot;) p &lt;- cor(df1[, Vars], method=&quot;pearson&quot;) couleurs &lt;- colorRampPalette(c(&quot;#053061&quot;, &quot;#2166AC&quot;,&quot;#4393C3&quot;, &quot;#92C5DE&quot;, &quot;#D1E5F0&quot;, &quot;#FFFFFF&quot;, &quot;#FDDBC7&quot;, &quot;#F4A582&quot;, &quot;#D6604D&quot;, &quot;#B2182B&quot;, &quot;#67001F&quot;)) corrplot::corrplot(p, addrect = 3, method=&quot;number&quot;, diag=FALSE, col=couleurs(100)) Figure 4.9: Matrice de corrélation avec corrplot (chiffres) fig2 &lt;- corrplot.mixed(p, lower=&quot;number&quot;, lower.col = &quot;black&quot;, upper = &quot;ellipse&quot;, upper.col=couleurs(100)) Figure 4.10: Matrice de corrélation avec corrplot (chiffres et ellipses) 4.3.8 Comment rapporter des valeurs de corrélations? Bien quil ny ait pas quune seule manière de reporter des corrélations, voici quelques lignes directrices pour vous guider : Signaler si la corrélation est faible, modérée ou forte. Indiquer si la corrélation est positive ou négative. Toutefois, ce nest pas une obligation, car nous pouvons rapidement le constater avec le signe du coefficient. Mettre le r et le p en italique et en minuscules. Deux décimales uniquement pour le \\(r\\) (sauf si une plus grande précision se justifie dans le domaine détude). Trois décimales pour la valeur de p. Si elle est inférieure à 0,001, écrire plutôt p &lt; 0,001. Indiquer éventuellement le nombre de degrés de liberté, soit \\(r(dl)=...\\) Voici des exemples : La corrélation entre les variables revenu médian des ménages et pourcentage de locataires est fortement négative (r = 0,78, p &lt; 0,001). La corrélation entre les variables revenu médian des ménages et pourcentage de locataires est forte (r(949) = 0,78, p &lt; 0,001). La corrélation entre les variables densité de population et revenu médian des ménages est modérée (r = 0,49, p &lt; 0,001). La corrélation entre les variables densité de population et pourcentage de 65 ans et plus nest pas significative (r = 0,08, p = 0,07). Pour un texte en anglais, référez-vous à : https://www.socscistatistics.com/tutorials/correlation/default.aspx. References "],["sect044.html", "4.4 Régression linéaire simple", " 4.4 Régression linéaire simple Comment expliquer et prédire une variable continue en fonction dune autre variable? Répondre à cette question relève de la statistique inférentielle. Il sagit en effet détablir une équation simple du type \\(Y = a + bX\\) pour expliquer et prédire les valeurs dune variable dépendante (Y) à partir dune variable indépendante (X). Léquation de la régression est construite grâce à un jeu de données (un échantillon). À partir de cette équation, il est possible de prédire la valeur attendue de Y pour nimporte quelle valeur de X. Nous appelons cette équation un modèle, car elle cherche à représenter la réalité de façon simplifiée. La régression linéaire simple relève ainsi de la statistique inférentielle et se distingue ainsi de la covariance (section 4.2) et de la corrélation (section 4.3) qui relèvent quant à eux de la statistique bivariée descriptive et exploratoire. Par exemple, la régression linéaire simple pourrait être utilisée pour expliquer les notes dun groupe détudiants et détudiantes à un examen (variable dépendante Y) en fonction du nombre dheures consacrées à la révision des notes de cours (variable indépendante X). Une fois léquation de régression déterminée et si le modèle est efficace, nous pourrons prédire les notes des personnes inscrites au cours la session suivante en fonction du temps quils ou quelles prévoient passer à étudier, et ce, avant lexamen. Formulons un exemple dapplication de la régression linéaire simple en études urbaines. Dans le cadre dune étude sur les îlots de chaleur urbains, la température de surface (variable dépendante) pourrait être expliquée par la proportion de la superficie de lîlot couverte par de la végétation (variable indépendante). Nous supposons alors que plus cette proportion est importante, plus la température est faible et inversement, soit une relation linéaire négative. Si le modèle est efficace, nous pourrions prédire la température moyenne des îlots dune autre municipalité pour laquelle nous ne disposons pas dune carte de température, et repérer ainsi les îlots de chaleur potentiels. Bien entendu, il est peu probable que nous arrivions à prédire efficacement la température moyenne des îlots avec uniquement la couverture végétale comme variable explicative. En effet, bien dautres caractéristiques de la forme urbaine peuvent influencer ce phénomène comme la densité du bâti, la couleur des toits, les occupations du sol présentes, leffet des canyons urbains, etc. Il faudrait alors inclure non pas une, mais plusieurs variables explicatives (indépendantes). Ainsi, nous distinguons la régression linéaire simple (une seule variable indépendante) de la régression linéaire multiple (plusieurs variables indépendantes); cette dernière est largement abordée au chapitre 7. Dans cette section, nous décrivons succinctement la régression linéaire simple. Concrètement, nous voyons comment déterminer la droite de régression, interpréter ses différents paramètres du modèle et évaluer la qualité dajustement du modèle. Nous nabordons ni les hypothèses liées au modèle de régression linéaire des moindres carrés ordinaires (MCO) ni les conditions dapplication. Ces éléments sont expliqués au chapitre 7, consacré à la régression linéaire multiple. Corrélation, régression simple et causalité : attention aux raccourcis! Si une variable X explique et prédit efficacement une variable Y, cela ne veut pas dire pour autant quX cause Y. Autrement dit, la corrélation, soit le degré dassociation entre deux variables, ne signifie pas quil existe un lien de causalité entre elles. Premièrement, la variable explicative (X, indépendante) doit absolument précéder la variable à expliquer (Y, dépendante). Par exemple, lâge (X) peut influencer le sentiment de sécurité (Y). Mais, le sentiment de sécurité ne peut en aucun cas influencer lâge. Par conséquent, lâge ne peut conceptuellement pas être la variable dépendante dans cette relation. Deuxièmement, bien quune variable puisse expliquer efficacement une autre variable, elle peut être un facteur confondant. Prenons deux exemples bien connus : Avoir les doigts jaunes est associé au cancer du poumon. Bien entendu, les doigts jaunes ne causent pas le cancer : cest un facteur confondant puisque fumer augmente les risques du cancer du poumon et jaunit aussi les doigts. Dans un article intitulé Chocolate Consumption, Cognitive Function, and Nobel Laureates, Messerli (2012) a trouvé une corrélation positive entre la consommation de chocolat par habitant et le nombre de prix Nobel pour dix millions dhabitants pour 23 pays. Ce résultat a dailleurs été rapporté par de nombreux médias, sans pour autant que Messerli (2012) et les journalistes concluent à un lien de causalité entre les deux variables : Radio Canada (https://ici.radio-canada.ca/nouvelle/582457/chocolat-consommateurs-nobels) La Presse (https://www.lapresse.ca/vivre/sante/nutrition/201210/11/01-4582347-etude-plus-un-pays-mange-de-chocolat-plus-il-a-de-prix-nobel.php) Le Point (https://www.lepoint.fr/insolite/le-chocolat-dope-aussi-l-obtention-de-prix-nobel-12-10-2012-1516159_48.php). Les chercheurs et les chercheures savent bien que la consommation de chocolat ne permet pas dobtenir des résultats intéressants et de les publier dans des revues prestigieuses; cest plutôt le café ! Plus sérieusement, il est probable que les pays les plus riches investissent davantage dans la recherche et obtiennent ainsi plus de prix Nobel. Dans les pays les plus riches, il est aussi probable que lon consomme plus de chocolat, considéré comme un produit de luxe dans les pays les plus pauvres. Pour approfondir le sujet sur la confusion entre corrélation, régression simple et causalité, vous pouvez visionner cette courte vidéo ludique de vulgarisation (https://www.youtube.com/embed/A-_naeATJ6o). Lassociation entre deux variables peut aussi être simplement le fruit du hasard. Si nous explorons de très grandes quantités de données (avec un nombre impressionnant dobservations et de variables), soit une démarche relevant du forage ou de la fouille de données (data mining en anglais), le hasard fera que nous risquons dobtenir des corrélations surprenantes entre certaines variables. Prenons un exemple concret : admettons que nous ayons collecté 100 variables et que nous calculons les corrélations entre chaque paire de variables. Nous obtenons une matrice de corrélation de 100 x 100, à laquelle nous pouvons enlever la diagonale et une moitié de la matrice, ce qui nous laisse un total de 4950 corrélations différentes. Admettons que nous choisissions un seuil de significativité de 5 %, nous devons alors nous attendre à ce que le hasard produise des résultats significatifs dans 5 % des cas. Sur 4950 corrélations, cela signifie quenviron 247 corrélations seront significatives, et ce, indépendamment de la nature des données. Nous pouvons aisément illustrer ce fait avec la syntaxe suivante : library(&quot;Hmisc&quot;) nbVars &lt;- 100 # nous utilisons 100 variables générées aléatoirement pour l&#39;expérience nbExperiment &lt;- 1000 # nous reproduirons 1000 fois l&#39;expérience avec les 100 variables # Le nombre de variables significatives par expérience est enregistré dans Results Results &lt;- c() # itérons pour chaque expérimentation (1000 fois) for(i in 1:nbExperiment){ Datas &lt;- list() # générons 100 variables aléatoires normalement distribuées for (j in 1:nbVars){ Datas[[j]] &lt;- rnorm(150) } DF &lt;- do.call(&quot;cbind&quot;,Datas) # calculons la matrice de corrélation pour les 100 variables cor_mat &lt;- rcorr(DF) # comptons combien de fois les corrélations étaient significatives Sign &lt;- table(cor_mat$P&lt;0.05) NbPairs &lt;- Sign[[&quot;TRUE&quot;]]/2 # ajoutons les résultats dans Results Results &lt;- c(Results,NbPairs) } # transformons Results en un DataFrame df &lt;- data.frame(Values = Results) # affichons le résultat ggplot(df, aes(x = Values)) + geom_histogram(aes(y =..density..), colour = &quot;black&quot;, fill = &quot;white&quot;) + stat_function(fun = dnorm, args = list(mean = mean(df$Values), sd = sd(df$Values)),color=&quot;blue&quot;)+ geom_vline(xintercept = mean(df$Values),color=&quot;red&quot;, size=1.2)+ annotate(&quot;text&quot;, x=0, y = 0.028, label = paste(&quot;Nombre moyen de corrélations significatives\\n sur 1000 réplications : &quot;, round(mean(df$Values),0), sep=&quot;&quot;), hjust=&quot;left&quot;)+ xlab(&quot;Nombre de corrélations significatives&quot;)+ ylab(&quot;densité&quot;) Figure 4.11: Corrélations significatives obtenues aléatoirement 4.4.1 Principe de base de la régression linéaire simple La régression linéaire simple vise à déterminer une droite (une fonction linéaire) qui résume le mieux la relation linéaire entre une variable dépendante (Y) et une variable indépendante (X) : \\[\\begin{equation} \\widehat{y_i} = \\beta_{0} + \\beta_{1}x_{i} \\tag{4.7} \\end{equation}\\] avec \\(\\widehat{y_i}\\) et \\(x_{i}\\) qui sont respectivement la valeur prédite de la variable dépendante et la valeur de la variable indépendante pour lobservation \\(i\\). \\(\\beta_{0}\\) est la constante (intercept en anglais) et représente la valeur prédite de la variable Y quand X est égale à 0. \\(\\beta_{1}\\) est le coefficient de régression pour la variable X, soit la pente de la droite. Ce coefficient nous informe sur la relation entre les deux variables : sil est positif, la relation est positive; sil est négatif, la relation est négative; sil est proche de 0, la relation est nulle (la droite est alors horizontale). Plus la valeur absolue de \\(\\beta_{1}\\) est élevée, plus la pente est forte et plus la variable Y varie à chaque changement dune unité de la variable X. Considérons un exemple fictif de dix municipalités dune région métropolitaine pour lesquelles nous disposons de deux variables : le pourcentage de personnes occupées se rendant au travail principalement à vélo et la distance entre chaque municipalité et le centre-ville de la région métropolitaine (tableau 4.3). Tableau 4.3: Données fictives sur lutilisation du vélo par municipalité Municipalité Vélo KMCV A 12,5 14,135 B 13,5 10,065 C 15,8 7,762 D 15,9 11,239 E 17,6 7,706 Municipalité Vélo KMCV F 18,5 7,195 G 21,2 7,953 H 23,0 4,293 I 25,3 5,225 J 30,2 2,152 Demblée, à la lecture du nuage de points (figure 4.12), nous décelons une forte relation linéaire négative entre les deux variables : plus la distance entre la municipalité et le centre-ville de la région métropolitaine augmente, plus le pourcentage de cyclistes est faible, ce qui est confirmé par le coefficient de corrélation (r = 0,90). La droite de régression (en rouge à la figure 4.12) qui résume le mieux la relation entre Vélo (variable dépendante) et KmCV (variable indépendante) sécrit alors : Vélo = 30,603  1,448 x KmCV. La valeur du coefficient de régression (\\(\\beta_{1}\\)) est de 1,448. Le signe de ce coefficient décrit une relation négative entre les deux variables. Ainsi, à chaque ajout dune unité de la distance entre la municipalité et le centre-ville (exprimée en kilomètres), le pourcentage de cyclistes diminue de 1,448. Retenez que lunité de mesure de la variable dépendante est très importante pour bien interpréter le coefficient de régression. En effet, si la distance au centre-ville nétait pas exprimée en kilomètres, mais plutôt en mètres, \\(\\beta_1\\) serait égal à 0,001448. Dans la même optique, lajout de 10 km de distance entre une municipalité et le centre-ville fait diminuer le pourcentage de cyclistes de 14,48 points de pourcentage. Avec, cette équation de régression, il est possible de prédire le pourcentage de cyclistes pour nimporte quelle municipalité de la région métropolitaine. Par exemple, pour des distances de 5, 10 ou 20 kilomètres, les pourcentages de cyclistes seraient de : \\(\\widehat{y_i} = \\mbox{30,603} + (\\mbox{-1,448} \\times \\mbox{5 km) = 23,363}\\) \\(\\widehat{y_i} = \\mbox{30,603} + (\\mbox{-1,448} \\times \\mbox{10 km) = 8,883}\\) \\(\\widehat{y_i} = \\mbox{30,603} + (\\mbox{-1,448} \\times \\mbox{20 km) = 1,643}\\) Figure 4.12: Relation linéaire entre lutilisation du vélo et la distance au centre-ville 4.4.2 Formulation de la droite de régression des moindres carrés ordinaires Reste à savoir comment sont estimés les différents paramètres de léquation, soit \\(\\beta_0\\) et \\(\\beta_1\\). À la figure 4.13, les points noirs représentent les valeurs observées (\\(y_i\\)) et les points bleus, les valeurs prédites (\\(\\widehat{y_i}\\)) par léquation du modèle. Les traits noirs verticaux représentent, pour chaque observation \\(i\\), lécart entre la valeur observée et la valeur prédite, dénommé résidu (\\(\\epsilon_i\\), prononcez epsilon de i ou plus simplement le résidu pour i ou le terme derreur de i). Si un point est au-dessus de la droite de régression, la valeur observée est alors supérieure à la valeur prédite (\\(y_i &gt; \\widehat{y_i}\\)) et inversement, si le point est au-dessous de la droite (\\(y_i &lt; \\widehat{y_i}\\)). Plus cet écart (\\(\\epsilon_i\\)) est important, plus lobservation séloigne de la prédiction du modèle et, par extension, moins bon est le modèle. Au tableau 4.4, vous constaterez que la somme des résidus est égale à zéro. La méthode des moindres carrés ordinaires (MCO) vise à minimiser les écarts au carré entre les valeurs observées (\\(y_i\\)) et prédites (\\(\\beta_0+\\beta_1 x_i\\), soit \\(\\widehat{y_i}\\)) : \\[\\begin{equation} min\\sum_{i=1}^n{(y_i-(\\beta_0+\\beta_1 x_i))^2} \\tag{4.8} \\end{equation}\\] Pour minimiser ces écarts, le coefficient de régression \\(\\beta_1\\) représente le rapport entre la covariance entre X et Y et la variance de Y (équation (4.9)), tandis que la constante \\(\\beta_0\\) est la moyenne de la variable Y moins le produit de la moyenne de X et de son coefficient de régression (équation (4.10)). \\[\\begin{equation} \\beta_1 = \\frac{\\sum_{i=1}^n (x_{i}-\\bar{x})(y_{i}-\\bar{y})}{\\sum_{i=1}^n (x_i-\\bar{x})^2} = \\frac{cov(X,Y)}{var(X)} \\tag{4.9} \\end{equation}\\] \\[\\begin{equation} \\beta_0 = \\widehat{Y}-\\beta_1 \\widehat{X} \\tag{4.10} \\end{equation}\\] Figure 4.13: Droite de régression, valeurs observées, prédites et résidus Tableau 4.4: Valeurs observées, prédites et résidus Municipalité Vélo KmCV Valeur prédite Résidu Résidu au carré A 12,5 14,135 10,138 2,362 5,579 B 13,5 10,065 16,031 -2,531 6,406 C 15,8 7,762 19,365 -3,565 12,709 D 15,9 11,239 14,331 1,569 2,462 E 17,6 7,706 19,446 -1,846 3,408 F 18,5 7,195 20,186 -1,686 2,843 G 21,2 7,953 19,089 2,111 4,456 H 23,0 4,293 24,388 -1,388 1,927 I 25,3 5,225 23,038 2,262 5,117 J 30,2 2,152 27,488 2,712 7,355 Somme 0,000 52,262 4.4.3 Mesure de la qualité dajustement du modèle Les trois mesures les plus courantes pour évaluer la qualité dajustement dun modèle de régression linéaire simple sont lerreur quadratique moyenne (root-mean-square error en anglais, RMSE), le coefficient de détermination (R2) et la statistique F de Fisher. Pour mieux appréhender le calcul de ces trois mesures, rappelons que léquation de régression sécrit : \\[\\begin{equation} y_i = \\beta_0 + \\beta_1 x_1+ \\epsilon_i \\Rightarrow Y= \\beta_0 + \\beta_1 X + \\epsilon \\tag{4.11} \\end{equation}\\] Elle comprend ainsi une partie de Y qui est expliquée par le modèle et une autre partie non expliquée, soit \\(\\epsilon\\), appelée habituellement le terme derreur. Ce terme derreur pourrait représenter dautres variables explicatives qui nont pas été prises en compte pour prédire la variable indépendante ou une forme de variation aléatoire inexplicable présente lors de la mesure. \\[\\begin{equation} Y = \\underbrace{\\beta_0 + \\beta_1 X}_{\\mbox{partie expliquée par le modèle}}+ \\underbrace{\\epsilon}_{\\mbox{partie non expliquée}} \\tag{4.12} \\end{equation}\\] Par exemple, pour la municipalité A au tableau 4.4, nous avons : \\(y_A = \\widehat{y}_A - \\epsilon_A \\Rightarrow \\mbox{12,5} = \\mbox{10,138}+\\mbox{2,362}\\). Souvenez-vous que la variance dune variable est la somme des écarts à la moyenne, divisée par le nombre dobservations. Par extension, il est alors possible de décomposer la variance de Y comme suit : \\[\\begin{equation} \\underbrace{\\sum_{i=1}^n (y_{i}-\\bar{y})^2}_{\\mbox{variance de Y}} = \\underbrace{\\sum_{i=1}^n (\\widehat{y}_i-\\bar{y})^2}_{\\mbox{var. expliquée}} + \\underbrace{\\sum_{i=1}^n (y_{i}-\\widehat{y})^2}_{\\mbox{var. non expliquée}} \\Rightarrow SCT = SCE + SCR \\tag{4.13} \\end{equation}\\] avec : SCT est la somme des écarts au carré des valeurs observées à la moyenne (total sum of squares en anglais) SCE est la somme des écarts au carré des valeurs prédites à la moyenne (regression sum of squares en anglais) SCR est la somme des carrés des résidus (sum of squared errors en anglais). Autrement dit, la variance totale est égale à la variance expliquée plus la variance non expliquée. Au tableau 4.5, vous pouvez repérer les valeurs de SCT, SCE et SCR et constater que 279,30 = 227,04 + 52,26 et 27,93 = 22,70 + 5,23. Tableau 4.5: Calcul du coefficient de détermination Municipalité \\(y_i\\) \\(\\widehat{y}_i\\) \\(\\epsilon_i\\) \\((y_i-\\bar{y})^2\\) \\((\\widehat{y}_i-y_i)^2\\) \\(\\epsilon_i^2\\) A 12,50 10,14 2,36 46,92 84,86 5,58 B 13,50 16,03 -2,53 34,22 11,02 6,41 C 15,80 19,37 -3,57 12,60 0,00 12,71 D 15,90 14,33 1,57 11,90 25,19 2,46 E 17,60 19,45 -1,85 3,06 0,01 3,41 F 18,50 20,19 -1,69 0,72 0,70 2,84 G 21,20 19,09 2,11 3,42 0,07 4,46 H 23,00 24,39 -1,39 13,32 25,38 1,93 I 25,30 23,04 2,26 35,40 13,60 5,12 J 30,20 27,49 2,71 117,72 66,22 7,36 N 10,00 Somme 193,50 0,00 279,30 227,04 52,26 Moyenne 19,35 0,00 27,93 22,70 5,23 Calcul de lerreur quadratique moyenne La somme des résidus au carré (SCR) divisée par le nombre dobservations représente donc le carré moyen des erreurs (en anglais, mean square error - MSE), soit la variance résiduelle du modèle (52,26 / 10 = 5,23). Plus sa valeur est faible, plus le modèle est efficace pour prédire la variable indépendante. Lerreur quadratique moyenne (en anglais, root-mean-square error - RMSE) est simplement la racine carrée de la somme des résidus au carré divisée par le nombre dobservations (\\(n\\)) : \\[\\begin{equation} RMSE = \\sqrt{\\frac{\\sum_{i=1}^n (y_{i}-\\widehat{y})^2}{n}} \\tag{4.14} \\end{equation}\\] Elle représente ainsi une mesure absolue des erreurs qui est exprimée dans lunité de mesure de la variable dépendante. Dans le cas présent, nous avons : \\(\\sqrt{5,23}=2,29\\). Cela signifie quen moyenne, lécart absolu (ou erreur absolue) entre les valeurs observées et prédites est de 2,29 points de pourcentage. De nouveau, une plus faible valeur de RMSE indique un meilleur ajustement du modèle. Mais surtout, le RMSE permet dévaluer avec quelle précision le modèle prédit la variable dépendante. Il est donc particulièrement important si lobjectif principal du modèle est de prédire des valeurs sur un échantillon dobservations pour lequel la variable dépendante est inconnue. Calcul du coefficient de détermination Nous avons largement démontré que la variance totale est égale à la variance expliquée plus la variance non expliquée. La qualité du modèle peut donc être évaluée avec le coefficient de détermination (R2), soit le rapport entre les variances expliquée et totale : \\[\\begin{equation} R^2 = \\frac{SCE}{SCT} \\mbox{ avec } R^2 \\in \\left[0,1\\right] \\tag{4.15} \\end{equation}\\] Comparativement au RMSE qui est une mesure absolue, le coefficient de détermination est une mesure relative qui varie de 0 à 1. Il exprime la proportion de la variance de Y qui est expliquée par la variable X; autrement dit, plus sa valeur est élevée, plus X influence/est capable de prédire Y. Dans le cas présent, nous avons : R2 = 227,04 / 279,3 = 0,8129, ce qui signale que 81,3 % de la variance du pourcentage de cyclistes est expliquée par la distance entre la municipalité et le centre-ville de la région métropolitaine. Tel que signalé dans la section 4.3.2, la racine carrée du coefficient de détermination (R2) est égale au coefficient de corrélation (\\(r\\)) entre les deux variables. Calcul de la statistique F de Fisher La statistique F de Fisher permet de vérifier la significativité globale du modèle. \\[\\begin{equation} F = (n-2)\\frac{R^2}{1-R^2} = (n-2)\\frac{SCE}{SCR} \\tag{4.16} \\end{equation}\\] Lhypothèse nulle (H0 avec \\(\\beta_1=0\\)) est rejetée si la valeur calculée de F est supérieure à la valeur critique de la table F avec 1, n-2 degrés de liberté et un seuil \\(\\alpha\\) (p = 0,05 habituellement) (voir la table des valeurs critiques de F, section 14.2). Notez que nous utilisons rarement la table F puisquavec la fonction pf(f obtenu, 1, n-2, lower.tail = FALSE), nous obtenons obtient directement la valeur de p associée à la valeur de F. Concrètement, si le test F est significatif (avec p &lt; 0,05), plus la valeur de F est élevée, plus le modèle est efficace (et plus le R2 sera également élevé). Notez que la fonction summary renvoie les résultats du modèle, dont notamment le test F de Fisher. # utiliser la fonction summary summary(modele) ## ## Call: ## lm(formula = Velo ~ KmCV, data = data) ## ## Residuals: ## Min 1Q Median 3Q Max ## -3.5652 -1.8062 0.0906 2.2241 2.7125 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 30.6032 2.0729 14.763 4.36e-07 *** ## KmCV -1.4478 0.2456 -5.895 0.000364 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 2.556 on 8 degrees of freedom ## Multiple R-squared: 0.8129, Adjusted R-squared: 0.7895 ## F-statistic: 34.75 on 1 and 8 DF, p-value: 0.0003637 Dans le cas présent, \\(F = (10 - 2)\\frac{\\mbox{0,8129}}{\\mbox{1-0,8129}} = (10-2)\\frac{\\mbox{227,04}}{\\mbox{52,26}} = \\mbox{34,75}\\) avec une valeur de \\(\\mbox{p &lt; 0,001}\\). Par conséquent, le modèle est significatif. 4.4.4 Mise en uvre dans R Comment calculer une régression linéaire simple dans R. Rien de plus simple avec la fonction lm(formula = y ~ x, data= DataFrame). df1 &lt;- read.csv(&quot;data/bivariee/Reg.csv&quot;, stringsAsFactors = F) ## Création d&#39;un objet pour le modèle monmodele &lt;- lm(Velo ~ KmCV, df1) ## Résultats du modèle avec la fonction summary summary(monmodele) ## ## Call: ## lm(formula = Velo ~ KmCV, data = df1) ## ## Residuals: ## Min 1Q Median 3Q Max ## -3.5652 -1.8062 0.0906 2.2241 2.7125 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 30.6032 2.0729 14.763 4.36e-07 *** ## KmCV -1.4478 0.2456 -5.895 0.000364 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 2.556 on 8 degrees of freedom ## Multiple R-squared: 0.8129, Adjusted R-squared: 0.7895 ## F-statistic: 34.75 on 1 and 8 DF, p-value: 0.0003637 ## Calcul du MSE et du RMSE MSE &lt;- mean(monmodele$residuals^2) RMSE &lt;- sqrt(MSE) cat(&quot;MSE=&quot;, round(MSE, 2), &quot;; RMSE=&quot;, round(RMSE,2), sep=&quot;&quot;) ## MSE=5.23; RMSE=2.29 4.4.5 Comment rapporter une régression linéaire simple Nous avons calculé une régression linéaire simple pour prédire le pourcentage dactifs occupés utilisant le vélo pour se rendre au travail en fonction de la distance entre la municipalité et le centre-ville de la région métropolitaine (en kilomètres). Le modèle obtient un F de Fisher significatif (F(1,8) = 34,75, p &lt; 0,001) et un R2 de 0,813. Le pourcentage de cyclistes peut être prédit par léquation suivante : 30,603 - 1,448 x (distance au centre-ville en km). References "],["sect045.html", "4.5 Quiz de révision du chapitre", " 4.5 Quiz de révision du chapitre Daprès le nuage de points, les variables X et Y partagent une relation : relisez au besoin la section 4.1. linéaire positive linéaire négative curvilinéaire absence de relation Daprès le nuage de points, les deux variables partagent une relation : Relisez au besoin la section 4.1. linéaire positive linéaire négative curvilinéaire absence de relation La valeur de la covariance peut être positive ou négative. Plus sa valeur absolue est élevée : Relisez au besoin la section 4.2.2. plus la relation linéaire entre les deux variables est importante plus la relation linéaire entre les deux variables est faible curvilinéaire absence de relation Les coefficients de corrélation (Pearson, Speaman, etc.) varient de à : Relisez au besoin la section 4.3.3. 0 à 1 moins linfini à plus linfini 0 à 100 -1 à 1 Cette statistique est tributaire des unités de mesure des deux variables. Cet inconvénient sapplique à : Relisez au besoin la section 4.2.2. la corrélation de Pearson la corrélation de Spearman la covariance la corrélation de Kendall À la lecture du nuage de points, la corrélation de Pearson entre les deux variables est proche de : Relisez au besoin la section 4.1. 0 -1 1 Le coefficient de Spearman est le coefficient de Pearson calculé sur des variables transformées en : Relisez au besoin la section 4.3.3. rangs scores Z (variables centrées réduites) sur une échelle 0 à 100 Dans une régression linéaire, le résidu pour une observation est : Relisez au besoin la section 4.4.2. la différence entre la variance de Y et la variance expliquée la différence entre la valeur observée et la valeur prédite le carré de la différence entre la valeur observée et la valeur prédite Le coefficient de détermination (R2) varie de : Relisez au besoin la section 4.4.3. -1 à 1 -100 à 100 0 à 1 Un facteur confondant est une sorte de fondant au chocolat? Relire le deuxième encadré à la section 4.4. Vrai Faux Verifier Votre score "],["chap05.html", "Chapitre 5 Relation entre deux variables qualitatives", " Chapitre 5 Relation entre deux variables qualitatives Dans le cadre de ce chapitre, nous présentons les deux principales méthodes permettant dexplorer les associations entre deux variables qualitatives : la construction dun tableau de contingence et le test du khi-deux (\\(\\chi^2\\), appelé aussi khi carré). Dans ce chapitre, nous utilisons les packages suivants : gmodels pour construire des tableaux de contingence. vcd pour construire un graphique pour un tableau de contingence. DescTools pour calculer le khi-deux de Mantel-Haenszel. stargazer pour imprimer des tableaux. Deux variables qualitatives sont-elles associées entre elles? Plus spécifiquement, certaines modalités dune variable qualitative sont-elles associées significativement à certaines modalités dune autre variable qualitative? Prenons lexemple de deux variables qualitatives : lune intitulée groupe dâge comprenant trois modalités (15 à 29 ans, 30 à 44 ans, 45 à 64 ans); lautre intitulée mode de transport habituel pour se rendre au travail comprenant quatre modalités (véhicule motorisé, transport en commun, vélo, marche). Comparativement aux deux autres groupes, nous pourrions supposer que les jeunes se déplacent proportionnellement plus en modes de transport actif (vélo et marche) et en transport en commun. À linverse, il est possible que les 45 à 64 ans se déplacent majoritairement en véhicules motorisés. Pour vérifier lexistence dassociations significatives entre les modalités de deux variables qualitatives, il est possible de construire un tableau de contingence (section 5.1), puis de réaliser le test du khi-deux (section 5.2). "],["sect051.html", "5.1 Construction de tableau de contingence", " 5.1 Construction de tableau de contingence Les données du tableau de contingence suivant décrivent 279 projets dhabitation à loyer modique (HLM) dans lancienne ville de Montréal, croisant les modalités de la période de construction (en colonne) et de la taille (en ligne) des projets HLM (Apparicio 2002). Les différents éléments du tableau sont décrits ci-dessous. Les fréquences observées (Count au tableau ci-dessous), nommées communément \\(f_{ij}\\), correspondent aux observations appartenant à la fois à la ie modalité de la variable en ligne et à la je modalité de la variable en colonne. À titre dexemple, nous comptons 14 projets HLM construits entre 1985 et 1989 comprenant moins de 25 logements. Les marges du tableau sont les totaux pour chaque modalité en ligne (\\(n_{i.}\\)) et en colonne (\\(n_{j.}\\)). En guise dexemple, sur les 279 projets HLM, 53 comprennent de 25 à 49 logements et 56 ont été construites entre 1968 et 1974. Bien entendu, la somme des marges en ligne (\\(n_{i.}\\)) est égale au nombre total dobservations (\\(n_{ij}\\)), tout comme la somme de marges en colonne (\\(n_{.j}\\)). Trois pourcentages sont disponibles (total, en ligne, en colonne; Total Percent, Row Percent et Column Percent au tableau ci-dessous). Ils sont respectivement la fréquence observée divisée par le nombre dobservations (\\(f_{ij}/n_{ij}\\times100\\)), par la marge en ligne (\\(f_{ij}/n_{i.} \\times 100\\)) et en colonne (\\(f_{ij}/n_{.j}\\times100\\)). En guise dexemple, 5 % des 279 projets HLM ont été construites entre 1985 et 1989 et comprennent moins de 25 logements (pourcentage total, soit 14 / 279 × 100). Aussi, plus de la moitié des habitations de moins de 25 logements ont été construits entre 1990 et 1994 (pourcentage en ligne, 41 / 80× 100). Finalement, près de 36 % des logements construits avant 1975 ont 100 logements et plus (20 / 56 × 100). Les fréquences théoriques (Expected Values au tableau ci-dessous), représentent les valeurs que lon devrait observer théoriquement sil y avait indépendance entre les modalités des deux variables; autrement dit, si la répartition des deux modalités des deux variables était dû au hasard. Pour le croisement de deux modalités, la fréquence théorique est égale au produit des marges divisé par le nombre total dobservations (\\(ft_{ij} = (n_{i.}n_{.j})/n_{ij}\\)). Par exemple, la fréquence théorique pour le croisement des modalités moins de 25 logements et avant 1975 est égale à : (80 × 56) / 279 = 16,06. Nous observons ici que la valeur théorique (16,06) est bien supérieure à la valeur réelle (6). Nous avons donc moins de projets HLM de moins de 25 logements avant 1975 à quoi nous pourrions nous attendre du hasard. La déviation (Residual au tableau ci-dessous) est la différence entre la fréquence observée et la fréquence théorique (\\(f_{ij}-ft_{ij}\\)). Plus la déviation est grande, plus nous nous écartons dune situation dindépendance entre les deux modalités i et j. La somme des déviations sur une ligne ou sur une colonne est nulle. Si la déviation ij est nulle, la fréquence théorique est égale à la fréquence observée, ce qui signifie quil y a indépendance entre les modalités i et j. Une déviation positive traduit, quant à elle, une attraction entre les modalités i et j ou, autrement dit, une surreprésentation du phénomène ij; tandis quune déviation négative renvoie à une répulsion entre les modalités i et j, soit une sous-représentation du phénomène ij. Dans le cas précédent, nous observions six habitations de moins de 25 logements construits avant 1975 et une fréquence théorique de 16,06. La déviation est donc -10,06, soit une sous-représentation du phénomène. La contribution au khi-deux (Chi-square contribution au tableau ci-dessous) est égale à la déviation au carré divisée par la fréquence théorique : \\(\\chi_{ij}^2 = (f_{ij}-ft_{ij})^2/ft_{ij}\\). Plus sa valeur est forte, plus il y a association entre les deux modalités. La somme des contributions au khi-deux représente le khi-deux total pour lensemble du tableau de contingence (ici à 63,54), que nous aborderons dans la section suivante. ## ## Cell Contents ## |-------------------------| ## | Count | ## | Expected Values | ## | Chi-square contribution | ## | Row Percent | ## | Column Percent | ## | Total Percent | ## | Residual | ## |-------------------------| ## ## Total Observations in Table: 279 ## ## | TabKhi2$Periode ## TabKhi2$Taille | Av. 1975 | 1975-79 | 1980-84 | 1985-89 | 1990-94 | Row Total | ## ---------------|-----------|-----------|-----------|-----------|-----------|-----------| ## &lt; 25 log. | 6 | 11 | 8 | 14 | 41 | 80 | ## | 16.06 | 13.76 | 13.76 | 13.48 | 22.94 | | ## | 6.30 | 0.55 | 2.41 | 0.02 | 14.22 | | ## | 7.50% | 13.75% | 10.00% | 17.50% | 51.25% | 28.67% | ## | 10.71% | 22.92% | 16.67% | 29.79% | 51.25% | | ## | 2.15% | 3.94% | 2.87% | 5.02% | 14.70% | | ## | -10.06 | -2.76 | -5.76 | 0.52 | 18.06 | | ## ---------------|-----------|-----------|-----------|-----------|-----------|-----------| ## 25-49 | 10 | 5 | 8 | 8 | 22 | 53 | ## | 10.64 | 9.12 | 9.12 | 8.93 | 15.20 | | ## | 0.04 | 1.86 | 0.14 | 0.10 | 3.05 | | ## | 18.87% | 9.43% | 15.09% | 15.09% | 41.51% | 19.00% | ## | 17.86% | 10.42% | 16.67% | 17.02% | 27.50% | | ## | 3.58% | 1.79% | 2.87% | 2.87% | 7.89% | | ## | -0.64 | -4.12 | -1.12 | -0.93 | 6.80 | | ## ---------------|-----------|-----------|-----------|-----------|-----------|-----------| ## 50-99 | 20 | 21 | 22 | 21 | 15 | 99 | ## | 19.87 | 17.03 | 17.03 | 16.68 | 28.39 | | ## | 0.00 | 0.92 | 1.45 | 1.12 | 6.31 | | ## | 20.20% | 21.21% | 22.22% | 21.21% | 15.15% | 35.48% | ## | 35.71% | 43.75% | 45.83% | 44.68% | 18.75% | | ## | 7.17% | 7.53% | 7.89% | 7.53% | 5.38% | | ## | 0.13 | 3.97 | 4.97 | 4.32 | -13.39 | | ## ---------------|-----------|-----------|-----------|-----------|-----------|-----------| ## 100 et + | 20 | 11 | 10 | 4 | 2 | 47 | ## | 9.43 | 8.09 | 8.09 | 7.92 | 13.48 | | ## | 11.83 | 1.05 | 0.45 | 1.94 | 9.77 | | ## | 42.55% | 23.40% | 21.28% | 8.51% | 4.26% | 16.85% | ## | 35.71% | 22.92% | 20.83% | 8.51% | 2.50% | | ## | 7.17% | 3.94% | 3.58% | 1.43% | 0.72% | | ## | 10.57 | 2.91 | 1.91 | -3.92 | -11.48 | | ## ---------------|-----------|-----------|-----------|-----------|-----------|-----------| ## Column Total | 56 | 48 | 48 | 47 | 80 | 279 | ## | 20.07% | 17.20% | 17.20% | 16.85% | 28.67% | | ## ---------------|-----------|-----------|-----------|-----------|-----------|-----------| ## ## ## Statistics for All Table Factors ## ## ## Pearson&#39;s Chi-squared test ## ------------------------------------------------------------ ## Chi^2 = 63.54291 d.f. = 12 p = 5.063109e-09 ## ## ## ## Minimum expected frequency: 7.917563 References "],["sect052.html", "5.2 Test du khi-deux", " 5.2 Test du khi-deux Avec le test du khi-deux, nous postulons quil y a indépendance entre les modalités des deux variables qualitatives, soit lhypothèse nulle (H0). Puis, nous calculons le nombre de degrés de liberté : \\(DL = (n-1)(l-1)\\), avec \\(l\\) et \\(n\\) étant respectivement les nombres de modalités en ligne et en colonne. Pour notre tableau de contingence, nous avons 12 degrés de liberté : \\((4-1)(5-1)=12\\). À partir du nombre de degrés de liberté et dun seuil critique de significativité (prenons 5 % ici), nous pouvons trouver la valeur critique de khi-deux dans la table des valeurs critiques du khi-deux, soit 21,03 (voir section 14.1). Puisque la valeur du khi-deux calculée dans le tableau de contingence (63,54) est bien supérieure à celle obtenue dans le tableau des valeurs critiques (21,03), nous pouvons rejeter lhypothèse dindépendance au seuil de 5 %. Autrement dit, si les deux variables nétaient pas associées, nous aurions eu moins de 5 % de chances de collecter des données avec ce niveau dassociation, ce qui nous permet de rejeter lhypothèse nulle (absence dassociation). Notez que le test reste significatif avec des seuils de 1 % (p = 0,01) et 0,1 % (p = 0,001) puisque les valeurs critiques sont de 26,22 et de 32,91. Bien entendu, une fois que nous connaissons le nombre de degrés de liberté, nous pouvons directement calculer les valeurs critiques pour différents seuils de signification et éviter ainsi de recourir à la table du du khi-deux. Dans la même veine, nous pouvons aussi calculer la valeur de p dun tableau de contingence en spécifiant le nombre de degrés de liberté et la valeur du khi-deux obtenue. cat(&quot;Valeurs critiques du khi-deux avec le nombre de degrés de liberté&quot;, &quot;\\n&quot;, round(qchisq(p=0.95, df=12, lower.tail = FALSE),3), &quot;avec p=0,05&quot;, &quot;\\n&quot;, round(qchisq(p=0.99, df=12, lower.tail = FALSE),3), &quot;avec p=0,01&quot;, &quot;\\n&quot;, round(qchisq(p=0.999, df=12, lower.tail = FALSE),3), &quot;avec p=0,0001&quot;) ## Valeurs critiques du khi-deux avec le nombre de degrés de liberté ## 5.226 avec p=0,05 ## 3.571 avec p=0,01 ## 2.214 avec p=0,0001 cat(&quot;Valeur de p du khi-deux obtenu (63,54291) avec 12 degrés de liberté :&quot;, &quot;\\n&quot;, pchisq(q=63.54291, df=12, lower.tail = FALSE)) ## Valeur de p du khi-deux obtenu (63,54291) avec 12 degrés de liberté : ## 5.063101e-09 Outre le khi-deux, dautres mesures dassociation permettent de mesurer le degré dassociation entre deux variables qualitatives. Les plus courantes sont reportées dans le tableau suivant. À des fins de comparaison, le khi-deux décrit précédemment est aussi reporté sur la première ligne du tableau. Tableau 5.1: Autres mesures dassociation entre deux variables qualitatives Statistique Formule Propriété et interprétation Khi-deux \\(\\chi^2 = \\sum \\frac{(f_{ij}-ft_{ij})^2}{ft_{ij}}\\) Mesure classique du khi-deux calculée à partir des différences entre les fréquences observées et attendues. Valeur de p disponible Ratio de vraisemblance du khi-deux \\(G^2 = 2 \\sum f_{ij} \\ln{(\\frac{f_{ij}}{ft_{ij}})}\\) Calculé à partir du ratio entre les fréquences observées et attendues. Valeur de p disponible khi-deux de Mantel-Haenszel \\(Q_{MH}=(N-1)r^2\\) avec r étant le coefficient de corrélation entre les deux variables qualitatives; par exemple, entre les valeurs des modalités de 1 à 5 de la variable période de construction et celles de 1 à 4 de la variable taille du projet HLM. Ce coefficient est très utile quand les deux variables qualitatives ne sont pas nominales, mais ordinales. Valeur de p disponible. Corrélation polychorique Obtenue itérativement par maximum de vraisemblance Dans le même esprit que le khi-deux de Mantel-Haenszel, la corrélation polychorique sapplique à deux variables ordinales. Plus spécifiquement, elle formule le postulat que deux variables théoriques normalement distribuées ont été mesurées de façon approximative avec deux échelles ordinales. Par exemple, en psychologie, le sentiment de bien-être et le sentiment de sécurité peuvent être conceptualisés comme deux variables continues normalement distribuées. Cependant, les mesurer directement est très difficile, nous avons donc recours à des échelles de Likert allant de 1 à 10. Pour cet exemple, il est pertinent dutiliser la corrélation polychorique. Comme pour une corrélation de Pearson, la corrélation polychorique varie de -1 à 1, une valeur négative indiquant une relation inverse entre les deux variables théoriques et inversement. Une valeur de p peut être obtenue. Coefficient Phi \\(\\phi=\\sqrt{\\frac{\\chi^2}{n}}\\) Simplement le khi-deux divisé par le nombre dobservations. Si les deux variables qualitatives comprennent deux modalités chacune alors \\(\\phi\\) varie de -1 à 1; sinon, de 0 à \\(min(\\sqrt{c-1}, \\sqrt{l-1})\\) avec c et l étant le nombre de modalités en colonne et en ligne. Par conséquent, ce coefficient est surtout utile pour les tableaux comprenant deux modalités pour chacune des variables. Pas de valeur de p disponible. V de Cramer \\(V=\\sqrt{\\frac{\\chi^2/n}{min(c-1,l-1)}}\\) Il représente un ajustement du coefficient Phi et varie de 0 à 1. Plus sa valeur est forte, plus les deux variables sont associées. À la lecture des deux formules, vous constaterez que, pour un tableau de 2x2, la valeur du V de Carmer sera égale à celle du Coefficient Phi. Pas de valeur de p disponible. "],["sect053.html", "5.3 Mise en uvre dans R", " 5.3 Mise en uvre dans R Pour calculer le khi-deux entre deux variables qualitatives, nous utilisons la fonction de base : chisq.test(x = ..., y = ...) qui renvoie le nombre de degrés de liberté, les valeurs du khi-deux et de p. # Importation du csv dataHLM &lt;- read.csv(&quot;data/bivariee/hlm.csv&quot;) # Calcul du khi-deux avec la fonction de base chisq.test chisq.test(x = dataHLM$Taille, y = dataHLM$Periode) ## ## Pearson&#39;s Chi-squared test ## ## data: dataHLM$Taille and dataHLM$Periode ## X-squared = 63.543, df = 12, p-value = 5.063e-09 Pour la construction du tableau de contingence, deux options sont possibles dépendamment de la structure de votre tableau de données. Premier cas de figure : votre tableau comprend une ligne par observation avec les différentes modalités dans deux colonnes (ici Periode et Taille). Dans la syntaxe ci-dessous, pour chacune des deux variables qualitatives, nous créons un facteur afin de spécifier un intitulé à chaque modalité (factor(levels =c(....), labels = c(..)). Puis, nous utilisons la fonction CrossTable du package gmodels. Pour obtenir les fréquences théoriques, les contributions locales au khi-deux et les déviations, nous spécifions les options suivantes : expected=TRUE, chisq=TRUE, resid=TRUE. library(&quot;gmodels&quot;) # Premiers enregistrements du tableau head(dataHLM) ## Periode Taille ## 1 5 1 ## 2 5 1 ## 3 5 2 ## 4 5 1 ## 5 5 1 ## 6 5 2 # La variable Periode comprend 5 modalités (de 1 à 5) table(dataHLM$Periode) ## ## 1 2 3 4 5 ## 56 48 48 47 80 # La variable Taille comprend 4 modalités (de 1 à 4) table(dataHLM$Taille) ## ## 1 2 3 4 ## 80 53 99 47 # Création d&#39;un facteur pour les cinq modalités de la période de construction dataHLM$Periode &lt;- factor(dataHLM$Periode, levels = c(1,2,3,4,5), labels = c(&quot;&lt;1975&quot;, &quot;1975-1979&quot;, &quot;1980-1984&quot;, &quot;1985-1989&quot;, &quot;1990-1994&quot;)) # Création d&#39;un facteur pour les quatre modalités de la taille des habitations dataHLM$Taille &lt;- factor(dataHLM$Taille, levels = c(1,2,3,4), labels = c(&quot;&lt;25 log.&quot;, &quot;25-49&quot;, &quot;50-99&quot;, &quot;100 et +&quot;)) # Pour construire un tableau de contingence, nous utilisons # la fonction CrossTable du package gmodels. # Les deux lignes ci-dessous sont mises en commentaire pour ne pas répéter le tableau. # CrossTable(x=dataHLM$Taille, y=dataHLM$Periode, digits = 2, # expected=TRUE, chisq = TRUE, resid = TRUE, format=&quot;SPSS&quot;) Deuxième cas de figure : vous disposez déjà dun tableau de contingence, soit les fréquences observées (\\(f_{ij}\\)). Nous nutilisons donc pas la fonction CrossTable, mais directement la fonction chisq.test. # Importation des données df1 &lt;- read.csv(&quot;data/bivariee/data_transport.csv&quot;, stringsAsFactors = FALSE) df1 # Visualisation du tableau ## ModeTransport Homme Femme ## 1 Automobile, camion ou fourgonnette - conducteur 689400 561830 ## 2 Automobile, camion ou fourgonnette - passager 21315 40010 ## 3 Transport en commun 181435 238330 ## 4 A pied 43715 54360 ## 5 Bicyclette 24295 13765 ## 6 Autre moyen 8395 6970 Matrice &lt;- as.matrix(df1[, c(&quot;Homme&quot;,&quot;Femme&quot;)]) dimnames(Matrice) &lt;- list(unique(df1$ModeTransport), Sexe=c(&quot;Homme&quot;,&quot;Femme&quot;)) # Notez que vous pouvez saisir vos données directement si vous avez peu d&#39;observations Femme &lt;- c(689400, 21315, 181435, 43715, 24295, 8395) # Vecteur de valeurs pour les femmes Homme &lt;- c(561830, 40010, 238330, 54360, 13765, 6970) # Vecteur de valeurs pour les hommes Matrice &lt;- as.table(cbind(Femme, Homme)) # Création du tableau # Nom des deux variables et de leurs modalités respectives dimnames(Matrice) &lt;- list(Transport=c(&quot;Automobile (conducteur)&quot;, &quot;Automobile (passager)&quot;, &quot;Transport en commun&quot;, &quot;À pied&quot;, &quot;Bicyclette&quot;, &quot;Autre moyen&quot;), Sexe=c(&quot;Homme&quot;,&quot;Femme&quot;)) # Test du khi-deux test &lt;- chisq.test(Matrice) print(test) ## ## Pearson&#39;s Chi-squared test ## ## data: Matrice ## X-squared = 29134, df = 5, p-value &lt; 2.2e-16 # Fréquences observées (Fij) test$observed ## Sexe ## Transport Homme Femme ## Automobile (conducteur) 689400 561830 ## Automobile (passager) 21315 40010 ## Transport en commun 181435 238330 ## À pied 43715 54360 ## Bicyclette 24295 13765 ## Autre moyen 8395 6970 # Fréquences théoriques (FTij) round(test$expected,0) ## Sexe ## Transport Homme Femme ## Automobile (conducteur) 643313 607917 ## Automobile (passager) 31530 29795 ## Transport en commun 215820 203945 ## À pied 50425 47650 ## Bicyclette 19568 18492 ## Autre moyen 7900 7465 # Déviations (Fij - FTij) round(test$observed-test$expected,0) ## Sexe ## Transport Homme Femme ## Automobile (conducteur) 46087 -46087 ## Automobile (passager) -10215 10215 ## Transport en commun -34385 34385 ## À pied -6710 6710 ## Bicyclette 4727 -4727 ## Autre moyen 495 -495 # Contributions au khi-deux round((test$observed-test$expected)^2/test$expected,2) ## Sexe ## Transport Homme Femme ## Automobile (conducteur) 3301.74 3493.98 ## Automobile (passager) 3309.37 3502.05 ## Transport en commun 5478.22 5797.18 ## À pied 892.81 944.80 ## Bicyclette 1141.71 1208.19 ## Autre moyen 31.04 32.85 # Marges en ligne et en colonne colSums(Matrice) ## Homme Femme ## 968555 915265 rowSums(Matrice) ## Automobile (conducteur) Automobile (passager) Transport en commun ## 1251230 61325 419765 ## À pied Bicyclette Autre moyen ## 98075 38060 15365 # Grand total sum(Matrice) ## [1] 1883820 # Pourcentages round(Matrice/sum(Matrice)*100,2) ## Sexe ## Transport Homme Femme ## Automobile (conducteur) 36.60 29.82 ## Automobile (passager) 1.13 2.12 ## Transport en commun 9.63 12.65 ## À pied 2.32 2.89 ## Bicyclette 1.29 0.73 ## Autre moyen 0.45 0.37 # Pourcentages en ligne round(Matrice/rowSums(Matrice)*100,2) ## Sexe ## Transport Homme Femme ## Automobile (conducteur) 55.10 44.90 ## Automobile (passager) 34.76 65.24 ## Transport en commun 43.22 56.78 ## À pied 44.57 55.43 ## Bicyclette 63.83 36.17 ## Autre moyen 54.64 45.36 # Pourcentages en colonne round(Matrice/colSums(Matrice)*100,2) ## Sexe ## Transport Homme Femme ## Automobile (conducteur) 71.18 58.01 ## Automobile (passager) 2.33 4.37 ## Transport en commun 18.73 24.61 ## À pied 4.78 5.94 ## Bicyclette 2.51 1.42 ## Autre moyen 0.92 0.76 Pour obtenir les autres mesures dassociation (tableau 5.2), nous pourrons utiliser la syntaxe suivante : df1 &lt;- read.csv(&quot;data/bivariee/hlm.csv&quot;) # Fonction pour calculer les autres mesures d&#39;association AutresMesuresKhi2 &lt;- function(x, y){ testChi2 &lt;- chisq.test(x, y) # Calcul du khi-deux n &lt;- sum(testChi2$observed) # Nombre d&#39;observations nc &lt;- ncol(testChi2$observed) # Nombre de colonnes l &lt;- nrow(testChi2$observed) # Nombre de lignes dl &lt;- (nc-1)*(l-1) # Nombre de degrés de libertés chi2 &lt;- testChi2$statistic # Valeur du khi-deux Pchi2 &lt;- testChi2$p.value # P pour le khi-deux #Ratio de vraisemblance du khi-deux G &lt;- 2*sum(testChi2$observed*log(testChi2$observed/testChi2$expected)) # G2 PG &lt;- pchisq(G, df=dl, lower.tail = FALSE) # P pour le G22 # khi-deux de Mantel-Haenszel avec le package DescTools MHTest &lt;- DescTools::MHChisqTest(testChi2$observed) MH &lt;- MHTest$statistic PMH &lt;- MHTest$p.value # Coefficient de correlation polychorique df1 &lt;- data.frame(&quot;x&quot; = as.factor(x), &quot;y&quot; = as.factor(y)) polychoricCorr &lt;- correlation::cor_test(df1,&quot;x&quot;,&quot;y&quot;,method = &quot;polychoric&quot;) polyR &lt;- polychoricCorr$rho polyP &lt;- polychoricCorr$p # Coefficient Phi et V de Cramer phi &lt;- sqrt(chi2/n) vc &lt;- sqrt(chi2/(n*min(nc-1,l-1))) # Tableau pour les résultats dfsortie &lt;- data.frame( Statistique = c(&quot;Khi-deux&quot;, &quot;Ratio de vraisemblance du khi-deux&quot;, &quot;Khi-deux de Mantel-Haenszel&quot;, &quot;Corrélation Polychorique&quot;, &quot;Coefficient de Phi&quot;, &quot;V de Cramer&quot;), Valeur = round(c(chi2, G, MH, polyR, phi, vc),3), P = round(c(Pchi2, PG, PMH, polyP , NA, NA),10)) return(dfsortie) } dfkhi2 &lt;- AutresMesuresKhi2(df1$Periode, df1$Taille) # Impression du tableau avec le package stargazer library(stargazer) stargazer(dfkhi2, type=&quot;text&quot;, summary=FALSE, rownames=FALSE, align = FALSE, digits = 3, title=&quot;Mesures d&#39;association entre les deux variables qualitatives&quot;) Tableau 5.2: Mesures dassociation entre deux variables qualitatives Statistique Valeur P Khi-deux 63,543 0 Ratio de vraisemblance du khi-deux 67,286 0 Khi-deux de Mantel-Haenszel 48,486 0 Corrélation Polychorique -0,479 0 Coefficient de Phi 0,477 V de Cramer 0,276 "],["sect054.html", "5.4 Interprétation dun tableau de contingence", " 5.4 Interprétation dun tableau de contingence Nous vous proposons une démarche très simple pour vérifier lassociation entre deux variables qualitatives avec les deux étapes suivantes : Nous posons lhypothèse nulle (H0), soit lindépendance entre les deux variables. Si la valeur du khi-deux total du tableau de contingence est inférieure à la valeur critique du khi-deux avec p = 0,05 et le nombre de degrés de liberté de la table T, alors il y a bien indépendance. La valeur de p est alors supérieure à 0,05. Lanalyse sarrête donc là! Autrement dit, il nest pas nécessaire danalyser le contenu de votre tableau de contingence puisquil ny pas dassociation significative entre les modalités des deux variables. Vous pouvez simplement signaler que selon les résultats du test du khi-deux, il ny a pas dassociation significative entre les deux variables (\\(\\chi\\) =  avec p= ). Sil y a dépendance (\\(khi_{observé}^2 &gt; khi_{critique}^2\\)), trouvez les cellules ij où les contributions au khi-deux sont les plus fortes, cest-à-dire où les associations entre les modalités i de la variable en ligne et les modalités j de la variable en colonne sont les plus marquées. Pour ces cellules, le phénomène ij est surreprésenté si la déviation est positive ou sous-représenté si la déviation est négative. Commentez ces associations et utilisez les pourcentages en ligne ou en colonne pour appuyer vos propos. Pour repérer rapidement les cellules où les contributions au khi-deux sont les plus fortes, vous pouvez construire un graphique avec la fonction mosaic du package vcd. À la figure 5.1, la taille des rectangles représente les effectifs entre les deux modalités tandis que les associations sont représentées comme suit : en gris lorsquelles ne sont pas significatives, en rouge pour des déviations significatives et négatives et en bleu pour des déviations significatives et positives. library(vcd) mosaic(~ Taille+Periode, data=dataHLM,shade=TRUE, legend=TRUE, labeling= labeling_border(rot_labels = c(45, 90), just_labels = c(&quot;left&quot;, &quot;center&quot;))) Figure 5.1: Figure avec la fonction mosaic du package vcd Exemple dinterprétation. « Les résultats du test du khi-deux signalent quil existe des associations entre les modalités de la taille et de la période de construction des projets dhabitation (\\(\\chi\\) = 63,5, p &lt; 0,001). Les fortes contributions au khi-deux et le signe positif ou négatif des déviations correspondantes permettent de repérer cinq associations majeures entre les modalités de taille et de période de construction des projets HLM : 1) la répulsion entre les projets dhabitation de moins de 25 logements et la période de construction 1964-1974; 2) lattraction entre les projets dhabitation de 100 logements et plus et la période de construction de 1969-1974; 3) lattraction entre les projets dhabitation de moins de 25 logements et la période de construction de 1990-1994; 4) la répulsion entre les projets dhabitation de 50 à 99 logements et la période de construction 1990-1994; 5) la répulsion entre les projets dhabitation de 100 logements et plus et la période de construction 1990-1994. On observe donc une tendance bien marquée dans lévolution du type de construction entre 1970 et 1994 : entre 1969 et 1974, on a construit de grandes habitations dépassant souvent 100 logements; du milieu des années 1970 à la fin des années 1980, on privilégie la construction dhabitations de taille plus modeste, entre 50 et 100 logements; tandis quau début des années 1990, on opte plutôt pour des habitations de taille réduite (moins de 50 logements). Quelques chiffres à lappui : sur les 56 habitations réalisées entre 1969 et 1974, 20 ont plus de 100 logements, 20 comprennent entre 50 et 99 logements et seules 10 ont moins de 25 logements. Près de la moitié des habitations construites entre 1975 et 1989 regroupent 50 à 99 logements (43,8 % pour la période 1975-1979, 45,8 % pour 1980-1984 et 44,7 % pour 1985-1989). Par contre, 51 % des habitations érigés à partir de 1990 disposent de moins de 25 logements » (Apparicio (2002), p. 117-118). Notez que cette évolution décroissante est aussi soutenue par le coefficient négatif de la corrélation polychorique. Vous pouvez aussi construire un graphique pour appuyer vos constats, soit avec les pourcentages en ligne ou en colonne (figure 5.2 tirée de Apparicio (2002)). Figure 5.2: Taille des projets dhabitation à loyer modique selon la période de construction Comment rapporter succinctement les résultats dun test du khi-deux? Le test du khi-deux a été réalisé pour examiner la relation entre la taille et la période de construction des habitations HLM. Cette relation est significative : \\(\\chi^2\\)(12, N = 279) = 63,5, p &lt; 0,001. Plus les projets ont été construits récemment, plus ils sont de taille réduite. Pour un texte en anglais, consultez https://www.socscistatistics.com/tutorials/chisquare/default.aspx. References "],["sect055.html", "5.5 Quiz de révision du chapitre", " 5.5 Quiz de révision du chapitre Pour analyser la relation entre deux variables qualitatives, vous utilisez : Relisez au besoin lintroduction du chapitre 5. la covariance la régression linéaire simple le coefficient de corrélation de Pearson un tableau de continence et un test du khi2 le coefficient de corrélation de Spearman un compteur Geiger Dans un tableau de contingence, quels sont les éléments disponibles? Relisez au besoin la section 5.1. Fréquences théoriques Fréquences observées Trois pourcentages (total, en lignes et en colonnes) Déviations Variance Contributions au khi-deux La corrélation polychorique est particulièrement bien adaptée pour mesurer lassociation entre deux variables qualitatives : Relisez au besoin lencadré à la section 5.2. ordinales nominales Sil y a indépendance entre les deux variables qualitatives (khi-deux observé inférieur au khi-deux critique), il nest pas nécessaire danalyser en détail le tableau de contingence. Relisez au besoin la section 5.4. Vrai Faux Verifier Votre score "],["chap06.html", "Chapitre 6 Relation entre une variable qualitative et une variable quantitative", " Chapitre 6 Relation entre une variable qualitative et une variable quantitative Dans le cadre de ce chapitre, nous présentons les principales méthodes permettant dexplorer les associations entre une variable quantitative et une variable qualitative avec deux modalités (tests de Student, de Welch et de Wilcoxon) ou avec plus de deux modalités (ANOVA et test de Kruskal-Wallis). Dans ce chapitre, nous utilisons les packages suivants : Pour créer des graphiques : ggplot2, le seul, lunique! ggpubr pour combiner des graphiques. Pour manipuler des données : dplyr, avec les fonctions group_by, summarize et les pipes %&gt;%. Pour les test t : sjstats pour réaliser des test t pondérés. effectsize pour calculer les tailles deffet de tests t. Pour la section sur les ANOVA : **car pour les ANOVA classiques. lmtest pour le test de Breusch-Pagan dhomogénéité des variances. rstatix intégrant de nombreux tests classiques (comme le test de Shapiro) avec tidyverse. Autre package : foreign pour importer des fichiers externes. "],["sect061.html", "6.1 Relation entre une variable quantitative et une variable qualitative à deux modalités", " 6.1 Relation entre une variable quantitative et une variable qualitative à deux modalités Les moyennes de deux groupes de population sont-elles significativement différentes? Nous souhaitons ici comparer deux groupes de population en fonction dune variable continue. Par exemple, pour deux échantillons respectivement dhommes et de femmes travaillant dans le même secteur dactivité, nous pourrions souhaiter vérifier si les moyennes des salaires des hommes et des femmes sont différentes et ainsi vérifier la présence ou labsence dune iniquité systématique. En études urbaines, dans le cadre dune étude sur un espace public, nous pourrions vouloir vérifier si la différence des moyennes du sentiment de sécurité des femmes et des hommes est significative (cest-à-dire différente de 0). Pour un même groupe, la moyenne de la différence dun phénomène donné mesuré à deux moments est-elle ou non égale à zéro? Autrement dit, nous cherchons à comparer un même groupe dindividus avant et après une expérimentation ou dans deux contextes différents. Prenons un exemple dapplication en études urbaines. Dans le cadre dune étude sur la perception des risques associés à la pratique du vélo en ville, 50 personnes utilisant habituellement lautomobile pour se rendre au travail sont recrutées. Lexpérimentation pourrait consister à leur donner une formation sur la pratique du vélo en ville et à les accompagner quelques jours durant leurs déplacements domicile-travail. Nous évaluerons la différence de leurs perceptions des risques associés à la pratique du vélo sur une échelle de 0 à 100 avant et après lexpérimentation. Nous pourrions supposer que la moyenne des différences est significativement négative, ce qui indiquerait que la perception du risque a diminué après lexpérimentation; autrement dit, la perception du risque serait plus faible en fin de période. 6.1.1 Test t et ses différentes variantes Le t de Student, appelé aussi test t (t-test en anglais), est un test paramétrique permettant de comparer les moyennes de deux groupes (échantillons), qui peuvent être indépendantes ou non : Échantillons indépendants (dits non appariés) : les observations de deux groupes qui nont aucun lien entre eux. Par exemple, nous souhaitons vérifier si les moyennes du sentiment de sécurité des hommes et des femmes, ou encore si, les moyennes des loyers entre deux villes sont statistiquement différentes. Ainsi, les tailles des deux échantillons peuvent être différentes (\\(n_a \\neq n_b\\)). Échantillons dépendants (dits appariés) : les individus des deux groupes sont les mêmes et sont donc associés par paires. Autrement dit, nous avons deux séries de valeurs de taille identique \\(n_a = n_b\\) et \\(n_{ai}\\) est le même individu que \\(n_{bi}\\). Ce type danalyse est souvent utilisée en études cliniques : pour \\(n\\) individus, nous disposons dune mesure quantitative de leur état de santé pour deux séries (lune avant le traitement, lautre une fois le traitement terminé). Cela permet de comparer les mêmes individus avant et après un traitement; nous parlons alors détude, dexpérience ou danalyse pré-post. Concrètement, nous cherchons à savoir si la moyenne des différences des observations avant et après est significativement différente de 0. Si cest le cas, nous pouvons conclure que lexpérimentation a eu un impact sur le phénomène mesuré (variable continue). Ce type danalyse pré-post peut aussi être utilisé pour évaluer limpact du réaménagement dun espace public (rue commerciale, place publique, parc, etc.). Par exemple, nous pourrions questionner le même échantillon de commerçant(e)s ou personnes lutilisant avant et après le réaménagement dune artère commerciale. Condition dapplication. Pour utiliser les tests de Student et de Welch, la variable continue doit être normalement distribuée. Si elle est fortement anormale, nous utiliserons le test non paramétrique de Wilcoxon (section 6.1.2). Il existe trois principaux tests pour comparer les moyennes de deux groupes : Test de Student (test t) avec échantillons indépendants et variances similaires (méthode pooled). Les variances de deux groupes sont semblables quand leur ratio varie de 0,5 à 2, soit \\(\\mbox{0,5}&lt; (S^2_{X_A}/S^2_{X_B})&lt;\\mbox{2}\\). Test de Welch (appelé aussi Satterthwaite) avec échantillons indépendants quand les variances des deux groupes sont dissemblables. Test de Student (test t) avec échantillons dépendants. Il sagit de vérifier si les moyennes des deux groupes sont statistiquement différentes avec les étapes suivantes : Nous posons lhypothèse nulle (H0), soit que les moyennes des deux groupes A et B ne sont pas différentes (\\(\\bar{X}_{A}=\\bar{X}_{B}\\)) ou, autrement dit, la différence des deux moyennes est nulle (\\(\\bar{X}_{A}-\\bar{X}_{B}=0\\)). Lhypothèse alternative (H1) est donc \\(\\bar{X}_{A}\\ne\\bar{X}_{B}\\). Nous calculons la valeur de t et le nombre de degrés de liberté. La valeur de t est négative quand la moyenne du groupe A est inférieure au groupe B et inversement. Nous comparons la valeur absolue de t (\\(\\mbox{|t|}\\)) avec celle issue de la table des valeurs critiques de T (voir section 14.2) avec le bon nombre de degrés de liberté et en choisissant un degré de signification (habituellement, p = 0,05). Si \\(\\mbox{|t|}\\) est supérieure à la valeur t critique, alors les moyennes sont statistiquement différentes au degré de signification retenu. Si les moyennes sont statistiquement différentes, nous pouvons calculer la taille de leffet. Cas 1. Test de Student pour des échantillons indépendants avec des variances similaires (méthode pooled). La valeur de t est le ratio entre la différence des moyennes des deux groupes (numérateur) et lerreur type groupée des deux échantillons (dénominateur) : \\[\\begin{equation} t = \\frac{\\bar{X}_{A}-\\bar{X}_{B}}{\\sqrt{\\frac{S^2_p}{n_A}+\\frac{S^2_p}{n_B}}}\\mbox{ avec } S^2_p = \\frac{(n_A-1)S^2_{X_A}+(n_B-1)S^2_{X_B}}{n_A+n_B-2} \\tag{6.1} \\end{equation}\\] avec \\(n_A\\),\\(n_B\\), \\(S^2_{X_A}\\) et \\(S^2_{X_B}\\) étant respectivement les nombres dobservations et les variances pour les groupes A et B, \\(S^2_p\\) étant la variance groupée des deux échantillons et \\(n_A+n_B-2\\) étant le nombre de degrés de liberté. Cas 2. Test de Welch pour des échantillons indépendants (avec variances dissemblables). Le test de Welch est très similaire au test de Student; seul le calcul de la valeur de t est différent, pour tenir compte des variances respectives des groupes : \\[\\begin{equation} t = \\frac{\\bar{X}_{A}-\\bar{X}_{B}}{\\sqrt{\\frac{S^2_{X_A}}{n_A}+\\frac{S^2_{X_B}}{n_B}}} \\mbox{ et } dl = \\frac{ \\left( \\frac{S^2_{X_A}}{n_A}+\\frac{S^2_{X_B}}{n_B} \\right)^2} {\\frac{S^4_{X_A}}{n^2_A(n_A-1)}+\\frac{S^4_{X_B}}{n^2_B(n_B-1)}} \\tag{6.2} \\end{equation}\\] Dans la syntaxe ci-dessous, nous avons écrit une fonction dénommée test_independants permettant de calculer les deux tests pour des échantillons indépendants. Dans cette fonction, vous pouvez repérer comment sont calculés les moyennes, les nombres dobservations et les variances pour les deux groupes, le nombre de degrés de liberté et les valeurs de t et de p pour les deux tests. Puis, nous avons créé aléatoirement deux jeux de données relativement à la vitesse de déplacement de cyclistes utilisant un vélo personnel ou un vélo en libre-service (généralement plus lourd) : Au cas 1, 60 cyclistes utilisant un vélo personnel roulant en moyenne à 18 km/h (écart-type de 1,5) et 50 autres utilisant un système de vélopartage avec une vitesse moyenne de 15 km/h (écart-type de 1,5). Au cas 2, 60 cyclistes utilisant un vélo personnel roulant en moyenne à 16 km/h (écart-type de 3) et 50 autres utilisant un système de vélopartage avec une vitesse moyenne de 15 km/h (écart-type de 1,5). Ce faible écart des moyennes, combiné à une plus forte variance réduit la significativité de la différence entre les deux groupes. Demblée, lanalyse visuelle des boîtes à moustaches (figure 6.1) signale quau cas 1, contrairement au cas 2, les groupes sont plus homogènes (boîtes plus compactes) et les moyennes semblent différentes (les boîtes sont centrées différemment sur laxe des ordonnées). Cela est confirmé par les résultats des tests. library(&quot;ggplot2&quot;) library(&quot;ggpubr&quot;) # fonction ------------------ tstudent_independants &lt;- function(A, B){ x_a &lt;- mean(A) # Moyenne du groupe A x_b &lt;- mean(B) # Moyenne du groupe B var_a &lt;- var(A) # Variance du groupe A var_b &lt;- var(B) # Variance du groupe B sd_a &lt;- sqrt(var_a) # Écart-type du groupe A sd_b &lt;- sqrt(var_b) # Écart-type du groupe B ratio_v &lt;- var_a / var_b # ratio des variances n_a &lt;- length(A) # nombre d&#39;observation du groupe A n_b &lt;- length(B) # nombre d&#39;observation du groupe B # T-test (variances égales) dl_test &lt;- n_a+n_b-2 # degrés de liberté PooledVar &lt;- (((n_a-1)*var_a)+((n_b-1)*var_b))/dl_test t_test &lt;- (x_a-x_b) / sqrt(((PooledVar/n_a)+(PooledVar/n_b))) p_test &lt;- 2*(1-(pt(abs(t_test), dl_test))) # Test Welch-Sattherwaite (variances inégales) t_welch &lt;- (x_a-x_b) / sqrt( (var_a/n_a) + (var_b/n_b)) dl_num = ((var_a/n_a) + (var_b/n_b))^2 dl_dem = ((var_a/n_a)^2/(n_a-1)) + ((var_b/n_b)^2/(n_b-1)) dl_welch = dl_num / dl_dem # degrés de liberté p_welch &lt;- 2*(1-(pt(abs(t_welch), dl_welch))) cat(&quot;\\n groupe A (n = &quot;, n_a,&quot;), moy = &quot;, round(x_a,1),&quot;, variance = &quot;, round(var_a,1),&quot;, écart-type = &quot;, round(sd_a,1), &quot;\\n groupe B (n = &quot;, n_b,&quot;), moy = &quot;, round(x_b,1),&quot;, variance = &quot;, round(var_b,1),&quot;, écart-type = &quot;, round(sd_b,1), &quot;\\n ratio variance = &quot;,round(ratio_v,2), &quot;\\n t-test (variances égales): t(dl = &quot;, dl_test, &quot;) = &quot;,round(t_test,4), &quot;, p = &quot;, round(p_test,6), &quot;\\n t-Welch (variances inégales): t(dl = &quot;, round(dl_welch,3), &quot;) = &quot;, round(t_welch,4), &quot;, p = &quot;, round(p_welch,6), sep=&quot;&quot;) if (ratio_v &gt; 0.5 &amp;&amp; ratio_v &lt; 2) { cat(&quot;\\n Variances semblables. Utilisez le test de Student!&quot;) p &lt;- p_test } else { cat(&quot;\\n Variances dissemblables. Utilisez le test de Welch-Satterwaithe!&quot;) p &lt;- p_welch } if (p &lt;=.05){ cat(&quot;\\n Les moyennes des deux groupes sont significativement différentes.&quot;) } else { cat(&quot;\\n Les moyennes des deux groupes ne sont pas significativement différentes.&quot;) } } # CAS 1 : données fictives ------------------ # Création du groupe A : 60 observations avec une vitesse moyenne de 18 et un écart-type de 1,5 Velo1A &lt;- rnorm(60,18,1.5) # Création du groupe B : 50 observations avec une vitesse moyenne de 15 et un écart-type de 1,5 Velo1B &lt;- rnorm(50,15,1.5) df1 &lt;- data.frame( vitesse = c(Velo1A,Velo1B), type = c(rep(&quot;Vélo personnel&quot;,length(Velo1A)), rep(&quot;Vélopartage&quot;,length(Velo1B))) ) boxplot1 &lt;- ggplot(data=df1, mapping=aes(x=type,y=vitesse, colour=type)) + geom_boxplot(width=0.2)+ ggtitle(&quot;Données fictives (cas 1)&quot;)+ xlab(&quot;Type de vélo&quot;)+ ylab(&quot;Vitesse de déplacement (km/h)&quot;)+ theme(legend.position = &quot;none&quot;) # CAS 2 : données fictives ------------------ # Création du groupe A : 60 observations avec une vitesse moyenne de 18 et un écart-type de 3 Velo2A &lt;- rnorm(60,16,3) # Création du groupe B : 50 observations avec une vitesse moyenne de 15 et un écart-type de 1,5 Velo2B &lt;- rnorm(50,15,1.5) df2 &lt;- data.frame( vitesse = c(Velo2A,Velo2B), type = c(rep(&quot;Vélo personnel&quot;,length(Velo2A)), rep(&quot;Vélopartage&quot;,length(Velo2B))) ) boxplot2 &lt;- ggplot(data=df2, mapping=aes(x=type,y=vitesse, colour=type)) + geom_boxplot(width=0.2)+ ggtitle(&quot;Données fictives (cas 2)&quot;)+ xlab(&quot;Type de vélo&quot;)+ ylab(&quot;Vitesse de déplacement (km/h)&quot;)+ theme(legend.position = &quot;none&quot;) ggarrange(boxplot1, boxplot2, ncol = 2, nrow = 1) Figure 6.1: Boîtes à moustaches sur des échantillons fictifs non appariés # Appel de la fonction pour le cas 1 tstudent_independants(Velo1A, Velo1B) ## ## groupe A (n = 60), moy = 18.2, ## variance = 2.9, écart-type = 1.7 ## groupe B (n = 50), moy = 15.1, ## variance = 2.1, écart-type = 1.4 ## ratio variance = 1.41 ## t-test (variances égales): t(dl = 108) = 9.9954, p = 0 ## t-Welch (variances inégales): t(dl = 107.984) = 10.1526, p = 0 ## Variances semblables. Utilisez le test de Student! ## Les moyennes des deux groupes sont significativement différentes. # Appel de la fonction pour le cas 2 tstudent_independants(Velo2A, Velo2B) ## ## groupe A (n = 60), moy = 15.9, ## variance = 9.1, écart-type = 3 ## groupe B (n = 50), moy = 15.2, ## variance = 2.2, écart-type = 1.5 ## ratio variance = 4.16 ## t-test (variances égales): t(dl = 108) = 1.6248, p = 0.107125 ## t-Welch (variances inégales): t(dl = 89.01) = 1.7188, p = 0.089132 ## Variances dissemblables. Utilisez le test de Welch-Satterwaithe! ## Les moyennes des deux groupes ne sont pas significativement différentes. 6.1.1.1 Principe de base et formulation pour des échantillons dépendants (appariés) Nous disposons de plusieurs personnes pour lesquelles nous avons mesuré un phénomène (variable continue) à deux temps différents : généralement avant et après une expérimentation (analyse pré-post). Il sagit de vérifier si la moyenne des différences des observations avant et après la période est différente de 0. Pour ce faire, nous réalisons les étapes suivantes : Nous posons lhypothèse nulle (H0), soit que la moyenne des différences entre les deux séries est égale à 0 (\\(\\bar{D} = 0\\) avec \\(d = {x}_{t_1}- {x}_{t_2}\\)). Lhypothèse alternative (H1) est donc \\(\\bar{D} \\ne 0\\). Notez que nous pouvons tester une autre valeur que 0. Nous calculons la valeur de t et le nombre de degrés de liberté. La valeur de t est négative quand la moyenne des différences entre \\({X}_{t_1}\\) et \\({X}_{t_2}\\) est négative et inversement. Nous comparons la valeur absolue de t (\\(\\mbox{|t|}\\)) avec celle issue de la table des valeurs critiques de T avec le nombre de degrés de liberté et en choisissant un degré de signification (habituellement, p = 0,05). Si \\(\\mbox{|t|}\\) est supérieure à la valeur t critique, alors les moyennes sont statistiquement différentes au degré de signification retenu. Pour le test de Student avec des échantillons appariés, la valeur de t se calcule comme suit : \\[\\begin{equation} t = \\frac{\\bar{D}-\\mu_0}{\\sigma_D / \\sqrt{n}} \\tag{6.3} \\end{equation}\\] avec \\(\\bar{D}\\) étant la moyenne des différences entre les observations appariées de la série A et de la série B, \\(\\sigma_D\\) lécart des différences, n le nombre dobservations, et finalement \\(\\mu_0\\) la valeur de lhypothèse nulle que nous voulons tester (habituellement 0). Bien entendu, il est possible de fixer une autre valeur pour \\(\\mu_0\\) : par exemple, avec \\(\\mu_0 = 10\\), nous chercherions ainsi à vérifier si la moyenne des différences est significativement différente de 10. Le nombre de degrés de liberté est égal à \\(n-1\\). Dans la syntaxe ci-dessous, nous avons écrit une fonction dénommée tstudent_dependants permettant de réaliser le test de Student pour des échantillons appariés. Dans cette fonction, vous pouvez repérer comment sont calculés la différence entre les observations pairées, la moyenne et lécart-type de cette différence, puis le nombre de degrés de liberté, les valeurs de t et de p pour les deux tests. Pour illustrer lutilisation de la fonction, nous avons créé aléatoirement deux jeux de données. Imaginons que ces données décrivent 50 personnes utilisant habituellement lautomobile pour se rendre au travail. Pour ces personnes, nous avons généré des valeurs du risque perçu de lutilisation du vélo (de 0 à 100), et ce, avant et après une période de 20 jours ouvrables durant lesquels elles devaient impérativement se rendre au travail à vélo. Au cas 1, les valeurs de risque ont une moyenne de 70 avant lexpérimentation et de 50 après lexpérimentation, avec des écarts-types de 5. Au cas 2, les valeurs de risque ont une moyenne de 70 avant et de 66 après, avec des écarts-types de 5. Demblée, lanalyse visuelle des boîtes à moustaches (figure 6.2) pairées montre que la perception du risque semble avoir nettement diminué après lexpérimentation pour le cas 1, mais pas pour le cas 2. Cela est confirmé par les résultats des tests. library(&quot;ggplot2&quot;) library(&quot;ggpubr&quot;) tstudent_dependants &lt;- function(A, B, mu=0){ d &lt;- A-B # différences entre les observations pairées moy &lt;- mean(d) # Moyenne des différences e_t &lt;- sd(d) # Écart-type des différences n &lt;- length(A) # nombre d&#39;observations dl &lt;- n-1 # nombre de degrés de liberté (variances égales) t &lt;- (moy- mu) / (e_t/sqrt(n)) # valeur de t p &lt;- 2*(1-(pt(abs(t), dl))) cat(&quot;\\n groupe A : moy = &quot;, round(mean(A),1),&quot;, var = &quot;, round(var(A),1),&quot;, sd = &quot;, round(sqrt(var(A)),1), &quot;\\n groupe B : moy = &quot;, round(mean(B),1),&quot;, var = &quot;, round(var(B),1),&quot;, sd = &quot;, round(sqrt(var(B)),1), &quot;\\n Moyenne des différences = &quot;, round(mean(moy),1), &quot;\\n Ecart-type des différences = &quot;, round(mean(e_t),1), &quot;\\n t(dl = &quot;, dl, &quot;) = &quot;,round(t,2), &quot;, p = &quot;, round(p,3), sep=&quot;&quot;) if (p &lt;=.05){ cat(&quot;\\n La moyenne des différences entre les échantillons est significative&quot;) } else{ cat(&quot;\\n La moyenne des différences entre les échantillons n&#39;est pas significative&quot;) } } # CAS 1 : données fictives ------------------ Avant1 &lt;- rnorm(50,70,5) Apres1 &lt;- rnorm(50,50,5) df1 &lt;- data.frame(Avant=Avant1, Apres=Apres1) boxplot1 &lt;- ggpaired(df1, cond1 = &quot;Avant&quot;, cond2 = &quot;Apres&quot;, fill = &quot;condition&quot;, palette = &quot;jco&quot;, xlab=&quot;&quot;, ylab=&quot;Sentiment de sécurité&quot;, title = &quot;Données fictives (cas 1)&quot;) # CAS 2 : données fictives ------------------ Avant2 &lt;- rnorm(50,70,5) Apres2 &lt;- rnorm(50,66,5) df2 &lt;- data.frame(Avant=Avant2, Apres=Apres2) boxplot2 &lt;- ggpaired(df2, cond1 = &quot;Avant&quot;, cond2 = &quot;Apres&quot;, fill = &quot;condition&quot;, palette = &quot;jco&quot;, xlab=&quot;&quot;, ylab=&quot;Sentiment de sécurité&quot;, title = &quot;Données fictives (cas 2)&quot;) ggarrange(boxplot1, boxplot2, ncol = 2, nrow = 1) Figure 6.2: Boites à moustaches sur des échantillons fictifs appariés # Test t : appel de la fonction tstudent_dependants tstudent_dependants(Avant1, Apres1, mu=0) ## ## groupe A : moy = 70.7, var = 30.1, sd = 5.5 ## groupe B : moy = 50, var = 17.1, sd = 4.1 ## Moyenne des différences = 20.7 ## Ecart-type des différences = 6.8 ## t(dl = 49) = 21.62, p = 0 ## La moyenne des différences entre les échantillons est significative tstudent_dependants(Avant2, Apres2, mu=0) ## ## groupe A : moy = 69.8, var = 19.3, sd = 4.4 ## groupe B : moy = 66.6, var = 25.3, sd = 5 ## Moyenne des différences = 3.2 ## Ecart-type des différences = 6.6 ## t(dl = 49) = 3.43, p = 0.001 ## La moyenne des différences entre les échantillons est significative 6.1.1.2 Mesure de la taille de leffet La taille de leffet permet dévaluer la magnitude (force) de leffet dune variable (ici la variable qualitative à deux modalités) sur une autre (ici la variable continue). Dans le cas dune comparaison de moyennes (avec des échantillons pairés ou non), pour mesurer la taille de leffet, nous utilisons habituellement le d de Cohen ou encore le g de Hedges; le second étant un ajustement du premier. Notez que nous analysons la taille de leffet uniquement si le test de Student ou de Welch sest révélé significatif (p &lt; 0,05). Pourquoi utiliser le d de Cohen? Deux propriétés en font une mesure particulièrement intéressante. Premièrement, elle est facile à calculer puisque d est le ratio entre la différence de deux moyennes de groupes (A, B) et lécart-type combiné des deux groupes. Deuxièmement, d représente ainsi une mesure standardisée de la taille de leffet; elle permet ainsi lévaluation de la taille de leffet indépendamment de lunité de mesure de la variable continue. Concrètement, cela signifie que, quelle que soit lunité de mesure de la variable continue X, d est toujours exprimée en unité décart-type de X. Cette propriété facilite ainsi grandement les comparaisons entre des valeurs de d calculées sur différentes combinaisons de variables (au même titre que le coefficient de variation ou le coefficient de corrélation, par exemple). Pour des échantillons indépendants de tailles différentes, le d de Cohen sécrit : \\[\\begin{equation} \\frac{\\bar{X}_{A}-\\bar{X}_{B}}{\\sqrt{\\frac{(n_A-1)S^2_A+(n_B-1)S^2_B}{n_A+n_B-2}}} \\tag{6.4} \\end{equation}\\] avec \\(n_A\\), \\(n_B\\), \\(S^2_{X_A}\\) et \\(S^2_{X_B}\\) étant respectivement les nombres dobservations et les variances pour les groupes A et B, \\(S^2_p\\). Si les échantillons sont de tailles identiques (\\(n_A=n_B\\)), alors d sécrit : \\[\\begin{equation} d = \\frac{\\bar{X}_{A}-\\bar{X}_{B}}{\\sqrt{(S^2_A+\\S^2_B)/2}} = \\frac{\\bar{X}_{A}-\\bar{X}_{B}}{(\\sigma_A+\\sigma_B)/2} \\tag{6.5} \\end{equation}\\] avec \\(\\sigma_A\\) et \\(\\sigma_B\\) étant les écarts-types des deux groupes (rappel : lécart-type est la racine carrée de la variance). Le g de Hedge est simplement une correction de d, particulièrement importante quand les échantillons sont de taille réduite. \\[\\begin{equation} g = d- \\left(1- \\frac{3}{4(n_A+n_B)-9} \\right) \\tag{6.6} \\end{equation}\\] Moins utilisé en sciences sociales, mais surtout en études cliniques, le delta de Glass est simplement la différence des moyennes des deux groupes indépendants (numérateur) sur lécart-type du deuxième groupe (démoninateur). Dans une étude clinique, nous avons habituellement un groupe qui subit un traitement (groupe de traitement) et un groupe qui reçoit un placebo (groupe de contrôle ou groupe témoin). Leffet de taille est ainsi évalué par rapport au groupe de contrôle : \\[\\begin{equation} \\Delta = \\frac{\\bar{X}_{A}-\\bar{X}_{B}}{\\sigma_B} \\tag{6.7} \\end{equation}\\] Finalement, pour des échantillons dépendants (pairés), le delta de Glass sécrit : \\(d = \\bar{D}/{\\sigma_D}\\) avec \\(\\bar{D}\\) et \\(\\sigma_D\\) étant la moyenne et lécart-type des différences entre les observations. Comment interpréter le d de Cohen? Un effet est considéré comme faible avec \\(\\lvert d \\rvert\\) à 0,2, modéré à 0,50 et fort à 0,80 (Cohen 1992). Notez que ces seuils ne sont que des conventions pour vous guider à interpréter la mesure de Cohen. Dailleurs, dans son livre intitulé Statistical power analysis for the behavioral sciences, il écrit : « all conventions are arbitrary. One can only demand of them that they not be unreasonable » (Cohen 2013). Plus récemment, Sawilowsky (2009) a ajouté dautres seuils à ceux proposés par Cohen (tableau 6.1). Tableau 6.1: Conventions pour linterprétation du d de Cohen Sawilowsky Cohen 0,1 : Très faible 0,2 : Faible 0,2 : Faible 0,5 : Moyen 0,5 : Moyen 0,8 : Fort 0,8 : Fort 1,2 : Très fort 2,0 : Énorme 6.1.1.3 Mise en uvre dans R Nous avons écrit précédemment les fonctions tstudent_independants et tstudent_dependants uniquement pour décomposer les différentes étapes de calcul des tests de Student et de Welch. Heureusement, il existe des fonctions de base (t.test et var.test) qui permettent de réaliser lun ou lautre de ces deux tests avec une seule ligne de code. La fonction t.test permet ainsi de calculer les tests de Student et de Welch : t.test(x ~ y, data=, mu = 0, paired = FALSE, var.equal = FALSE, conf.level = 0.95) ou t.test(x =, y =, mu = 0, paired = FALSE, var.equal = FALSE, conf.level = 0.95). Le paramètre paired est utilisé pour spécifier si les échantillons sont dépendants (paired=TRUE) ou indépendants (paired=FALSE). Le paramètre var.equal est utilisé pour spécifier si les variances sont égales pour le test de Student (var.equal=TRUE) ou dissemblables pour le test de Welch (var.equal=FALSE). var.test(x, y) ou var.test(x ~ y, data=) pour vérifier au préalable si les variances sont égales ou non et choisir ainsi un t de Student ou un t de Welch. Les fonctions cohens_d et hedges_g du package effectsize renvoient respectivement les mesures de d de Cohen et du g de Hedge : cohens_d(x ~ y, data = DataFrame, paired = FALSE, pooled_sd = TRUE) ou cohens_d(x, y, data = DataFrame, paired = FALSE, pooled_sd = TRUE) hedges_g(x ~ y, data = DataFrame, paired = FALSE, pooled_sd = TRUE) ou hedges_g(x, y, data = DataFrame, paired = FALSE, pooled_sd = TRUE) glass_delta(x ~ y, data = DataFrame, paired = FALSE, pooled_sd = TRUE) ou glass_delta(x, y, data = DataFrame, paired = FALSE, pooled_sd = TRUE) Notez que pour toutes ces fonctions, deux écritures sont possibles : x ~ y, data= avec un DataFrame dans lequel x est une variable continue et y et un facteur binaire x, y qui sont tous deux des vecteurs numériques (variable continue). Exemple de test pour des échantillons indépendants La figure 6.3 représente la cartographie du pourcentage de locataires par secteur de recensement (SR) pour la région métropolitaine de recensement de Montréal (RMR) en 2016, soit une variable continue. Lobjectif est de vérifier si la moyenne de ce pourcentage des SR de lagglomération de Montréal est significativement différente de celles de SR hors de lagglomération. Figure 6.3: Pourcentage de locataires par secteur de recensement, région métropolitaine de recensement de Montréal, 2016 Les résultats de la syntaxe ci-dessous signalent que le pourcentage de locataires par SR est bien supérieur dans lagglomération (moyenne = 59,7 %; écart-type = 21,4 %) quen dehors de lagglomération de Montréal (moyenne = 27,3 %; écart-type = 20,1 %). Cette différence de 32,5 points de pourcentage est dailleurs significative et très forte (t = -23,95; p &lt; 0,001, d de Cohen = 1,54). library(&quot;foreign&quot;) library(&quot;effectsize&quot;) library(&quot;ggplot2&quot;) library(&quot;dplyr&quot;) # Importation du fichier dfRMR &lt;- read.dbf(&quot;data/bivariee/SRRMRMTL2016.dbf&quot;) # Définition d&#39;un facteur binaire dfRMR$Montreal &lt;- factor(dfRMR$Montreal, levels= c(0,1), labels = c(&quot;Hors de Montréal&quot;,&quot;Montréal&quot;)) # Comparaison des moyennes ------------------------ #Boite à moustaches (boxplot) ggplot(data = dfRMR, mapping=aes(x=Montreal,y=Locataire,colour=Montreal)) + geom_boxplot(width=0.2)+ theme(legend.position=&quot;none&quot;)+ xlab(&quot;Zone&quot;)+ ylab(&quot;Pourcentage de locataires&quot;)+ ggtitle(&quot;Locataires par secteur de recensement&quot;, subtitle=&quot;région métropolitaine de recensement de Montréal, 2016&quot;) # nombre d&#39;observations, moyennes et écarts-types pour les deux échantillons group_by(dfRMR, Montreal) %&gt;% summarise( n = n(), moy = mean(Locataire, na.rm = TRUE), ecarttype = sd(Locataire, na.rm = TRUE) ) ## # A tibble: 2 x 4 ## Montreal n moy ecarttype ## &lt;fct&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Hors de Montréal 430 27.3 20.1 ## 2 Montréal 521 59.7 21.4 # Nous vérifions si les variances sont égales avec la fonction var.test # quand la valeur de P est inférieure à 0,05 alors les variances diffèrent v &lt;- var.test(Locataire ~ Montreal, alternative=&#39;two.sided&#39;, conf.level=.95, data=dfRMR) print(v) ## ## F test to compare two variances ## ## data: Locataire by Montreal ## F = 0.88156, num df = 429, denom df = 520, p-value = 0.1739 ## alternative hypothesis: true ratio of variances is not equal to 1 ## 95 percent confidence interval: ## 0.7361821 1.0573195 ## sample estimates: ## ratio of variances ## 0.8815563 Le test indique que nous navons aucune raison de rejeter lhypothèse nulle selon laquelle les variances sont égales. Pour lîle de Montréal, lécart-type est de 21,4; il est de 20,1 hors de lîle, soit une différence négligeable. # Calcul du T de Student ou du T de Welch p &lt;- v$p.value if(p &gt;= 0.05){ cat(&quot;\\n Les variances ne diffèrent pas!&quot;, &quot;\\n Nous utilisons le test de Student avec l&#39;option var.equal=TRUE&quot;, sep=&quot;&quot;) t.test(Locataire ~ Montreal, # variable continue ~ facteur binaire data=dfRMR, # nom du DataFrame conf.level=.95, # intervalle de confiance pour la valeur de t paired = FALSE, # échantillons non pairés (indépendants) var.equal=TRUE) # variances égales } else { cat(&quot;\\n Les variances diffèrent!&quot;, &quot;\\n Nous utiliseons le test de Welch avec l&#39;option var.equal=FALSE&quot;, sep=&quot;&quot;) t.test(Locataire ~ Montreal, # variable continue ~ facteur binaire data=dfRMR, # nom du DataFrame conf.level=.95, # intervalle de confiance pour la valeur de t paired = FALSE, # échantillons non pairés (indépendants) var.equal=FALSE) # variances différentes } ## ## Les variances ne diffèrent pas! ## Nous utilisons le test de Student avec l&#39;option var.equal=TRUE ## ## Two Sample t-test ## ## data: Locataire by Montreal ## t = -23.95, df = 949, p-value &lt; 2.2e-16 ## alternative hypothesis: true difference in means is not equal to 0 ## 95 percent confidence interval: ## -35.11182 -29.79341 ## sample estimates: ## mean in group Hors de Montréal mean in group Montréal ## 27.27340 59.72601 # Effet de taille à analyser uniquement si le test est significatif cohens_d(Locataire ~ Montreal, data = dfRMR, paired = FALSE) ## Cohen&#39;s d | 95% CI ## -------------------------- ## -1.56 | [-1.71, -1.41] ## ## - Estimated using pooled SD. hedges_g(Locataire ~ Montreal, data = dfRMR, paired = FALSE) ## Hedges&#39; g | 95% CI ## -------------------------- ## -1.56 | [-1.70, -1.41] ## ## - Estimated using pooled SD. ## - Bias corrected using Hedges and Olkin&#39;s method. Notez que les valeurs du d de Cohen et du g de Hedge sont très semblables; rappelons que le second est une correction du premier pour des échantillons de taille réduite. Avec 951 observations, nous disposons dun échantillon suffisamment grand pour que cette correction soit négligeable. Exemple de syntaxe pour un test de Student pour des échantillons dépendants library(&quot;ggpubr&quot;) library(&quot;dplyr&quot;) Pre &lt;- c(79,71,81,83,77,74,76,74,79,70,66,85,69,69,82, 69,81,70,83,68,77,76,77,70,68,80,65,65,75,84) Post &lt;- c(56,47,40,45,49,51,54,47,44,54,42,56,45,45,48, 55,59,58,56,41,56,51,45,55,49,49,48,43,60,50) # Première façon de faire un tableau : avec deux colonnes Avant et Après df1 &lt;- data.frame(Avant=Pre, Apres=Post) head(df1) ## Avant Apres ## 1 79 56 ## 2 71 47 ## 3 81 40 ## 4 83 45 ## 5 77 49 ## 6 74 51 ggpaired(df1, cond1 = &quot;Avant&quot;, cond2 = &quot;Apres&quot;, fill = &quot;condition&quot;, palette = &quot;jco&quot;, xlab=&quot;&quot;, ylab=&quot;Variable continue&quot;) # Nombre d&#39;observations, moyennes et écart-types cat(nrow(df1), &quot; observations&quot;, &quot;\\nPOST. moy = &quot;, round(mean(df1$Avant),1), &quot;, e.t. = &quot;, round(sd(df1$Avant),1), &quot;\\nPRE. moy = &quot;, round(mean(df1$Apres),1), &quot;, e.t. = &quot;, round(sd(df1$Apres),1), sep=&quot;&quot;) ## 30 observations ## POST. moy = 74.8, e.t. = 6.1 ## PRE. moy = 49.9, e.t. = 5.7 t.test(Pre, Post, paired = TRUE) ## ## Paired t-test ## ## data: Pre and Post ## t = 18.701, df = 29, p-value &lt; 2.2e-16 ## alternative hypothesis: true difference in means is not equal to 0 ## 95 percent confidence interval: ## 22.11740 27.54926 ## sample estimates: ## mean of the differences ## 24.83333 # Deuxième façon de faire un tableau : avec une colonne pour la variable continue # et une autre pour la variable qualitative n &lt;- length(Pre)*2 df2 &lt;- data.frame( id=(1:n), participant=(1:length(Pre)), risque=c(Pre,Post) ) df2$periode &lt;- ifelse(df2$id &lt;= length(Pre), &quot;Pré&quot;, &quot;Post&quot;) head(df2) ## id participant risque periode ## 1 1 1 79 Pré ## 2 2 2 71 Pré ## 3 3 3 81 Pré ## 4 4 4 83 Pré ## 5 5 5 77 Pré ## 6 6 6 74 Pré # nombre d&#39;observations, moyennes et écarts-types pour les deux échantillons group_by(df2, periode) %&gt;% summarise( n = n(), moy = mean(risque, na.rm = TRUE), et = sd(risque, na.rm = TRUE) ) ## # A tibble: 2 x 4 ## periode n moy et ## &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Post 30 49.9 5.67 ## 2 Pré 30 74.8 6.10 ggpaired(data=df2, x= &quot;periode&quot;, y=&quot;risque&quot;, fill = &quot;periode&quot;, xlab=&quot;&quot;, ylab=&quot;Variable continue&quot;) t.test(risque ~ periode, data=df2, paired = TRUE) ## ## Paired t-test ## ## data: risque by periode ## t = -18.701, df = 29, p-value &lt; 2.2e-16 ## alternative hypothesis: true difference in means is not equal to 0 ## 95 percent confidence interval: ## -27.54926 -22.11740 ## sample estimates: ## mean of the differences ## -24.83333 6.1.1.4 Comparaison des moyennes pondérées En études urbaines et en géographie, le recours aux données agrégées (non individuelles) est fréquent, par exemple au niveau des secteurs de recensement (comprenant généralement entre 2500 à 8000 habitants). Dans ce contexte, un secteur de recensement plus peuplé devrait avoir un poids plus important dans lanalyse. Il est possible dutiliser les versions pondérées des tests présentés précédemment. Prenons deux exemples pour illustrer le tout : Pour chaque secteur de recensement des îles de Montréal et de Laval, nous avons calculé la distance au parc le plus proche à travers le réseau de rues avec un système dinformation géographique (SIG). Nous souhaitons vérifier si les personnes âgées de moins de 15 ans résidant sur lîle de Montréal bénéficient en moyenne dune meilleure accessibilité au parc. Dans une étude sur la concentration de polluants atmosphériques dans lenvironnement autour des écoles primaires montréalaises, Carrier et al. (2014) souhaitaient vérifier si les élèves fréquentant les écoles les plus défavorisées sont plus exposé(e)s au dioxyde dazote (NO2) dans leur milieu scolaire. Pour ce faire, ils ont réalisé un test t sur un tableau avec comme observations les écoles primaires et trois variables : la moyenne de NO2 (variable continue), les quintiles extrêmes dun indice de défavorisation (premier et dernier quintiles, variable qualitative) et le nombre délèves par école (variable pour la pondération). Pour réaliser un test t pondéré, nous pouvons utiliser la fonction weighted_ttest du package sjstats. En guise dexemple appliqué, dans la syntaxe ci-dessous, nous avons refait le même test t que précédemment (Locataire ~ Montreal) en pondérant chaque secteur de recensement par le nombre de logements quil comprend. library(&quot;sjstats&quot;) library(&quot;dplyr&quot;) # Calcul des statistiques pondérées group_by(dfRMR, Montreal) %&gt;% summarise( n = sum(Logement), MoyPond = weighted_mean(Locataire, Logement), ecarttypePond = weighted_sd(Locataire, Logement) ) ## # A tibble: 2 x 4 ## Montreal n MoyPond ecarttypePond ## &lt;fct&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Hors de Montréal 856928 28.4 19.9 ## 2 Montréal 870354 60.0 20.8 # Test t non pondéré t.test(Locataire ~ Montreal, dfRMR, paired = FALSE, var.equal = TRUE, conf.level=.95) ## ## Two Sample t-test ## ## data: Locataire by Montreal ## t = -23.95, df = 949, p-value &lt; 2.2e-16 ## alternative hypothesis: true difference in means is not equal to 0 ## 95 percent confidence interval: ## -35.11182 -29.79341 ## sample estimates: ## mean in group Hors de Montréal mean in group Montréal ## 27.27340 59.72601 # Test t pondérée weighted_ttest(Locataire ~ Montreal + Logement, dfRMR, paired = FALSE, ci.lvl=.95) ## ## Two-Sample t-test (two.sided) ## ## # comparison of Locataire by Montreal ## # t=-23.91 df=928 p-value=0.000 ## ## mean in group Hors de Montréal: 28.396 ## mean in group Montréal : 60.003 ## difference of mean : -31.608 [-34.202 -29.013] 6.1.1.5 Comment rapporter un test de Student ou de Welch? Pour les différentes versions du test, il est important de rapporter les valeurs de t et de p, les moyennes et écarts-types des groupes. Voici quelques exemples. Test de Student ou de Welch pour échantillons indépendants Dans la région métropolitaine de Montréal en 2005, le revenu total des femmes (moyenne = 29 117 dollars; écart-type = 258 022) est bien inférieur à celui des hommes (moyenne = 44 463; écart-type = 588 081). La différence entre les moyennes des deux sexes (-15 345) en faveur des hommes est dailleurs significative (t = -27,09; p &lt; 0,001). Il y un effet significatif selon le sexe (t = -27,09; p &lt; 0,001), le revenu total des hommes (moyenne = 44 463; écart-type = 588 081) étant bien supérieur à celui des femmes (moyenne = 29 117; écart-type = 258 022). 50 personnes se rendent au travail à vélo (moyenne = 33,7; écart-type = 8,5) contre 60 en automobile (moyenne = 34; écart-type = 8,7). Il ny a pas de différence significative entre les moyennes dâge des deux groupes (t(108) = -0,79; p = 0,427). Test de Student échantillons dépendants (pairés) Nous constatons une diminution significative de la perception du risque après lactivité (moyenne = 49,9; écart-type = 5,7) comparativement à avant (moyenne = 74,8; écart-type = 6,1), avec une différence de -24,8 (t(29) = -18,7; p &lt; 0,001). Les résultats du pré-test (moyenne = 49,9; écart-type = 5,7) et du post-test (moyenne = 74,8; écart-type = 6,1) montrent quil y une diminution significative de la perception du risque (t(29) = -18,7; p &lt; 0,001). Pour un texte en anglais, consultez https://www.socscistatistics.com/tutorials/ttest/default.aspx. 6.1.2 Test non paramétrique de Wilcoxon Si la variable continue est fortement anormalement distribuée, il est déconseillé dutiliser les tests de Student et de Welch. Nous privilégions le test des rangs signés de Wilcoxon (Wilcoxon rank-sum test en anglais). Attention, il est aussi appelé test U de Mann-Whitney. Ce test permet alors de vérifier si les deux groupes présentent des médianes différentes. Pour ce faire, nous utilisons la fonction wilcox.test dans laquelle le paramètre paired permet de spécifier si les échantillons sont indépendants ou non (FALSE ou TRUE). Dans lexemple suivant, nous analysons le pourcentage de locataires dans les secteurs de recensement de la région métropolitaine de Montréal. Plus spécifiquement, nous comparons ce pourcentage entre les secteurs présents sur lîle et les secteurs hors de lîle. Il sagit donc dun test avec des échantillons indépendants. library(&quot;foreign&quot;) library(&quot;dplyr&quot;) ############################### # Échantillons indépendants ############################### dfRMR &lt;- read.dbf(&quot;data/bivariee/SRRMRMTL2016.dbf&quot;) # Définition d&#39;un facteur binaire dfRMR$Montreal &lt;- factor(dfRMR$Montreal, levels= c(0,1), labels = c(&quot;Hors de Montréal&quot;,&quot;Montréal&quot;)) # Calcul du nombre d&#39;observations, des moyennes et # des écarts-types des rangs pour les deux échantillons group_by(dfRMR, Montreal) %&gt;% summarise( n = n(), moy_rang = mean(rank(Locataire), na.rm = TRUE), med_rang = median(rank(Locataire), na.rm = TRUE), ecarttype_rang = sd(rank(Locataire), na.rm = TRUE) ) ## # A tibble: 2 x 5 ## Montreal n moy_rang med_rang ecarttype_rang ## &lt;fct&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Hors de Montréal 430 216. 216. 124. ## 2 Montréal 521 261 261 151. # Test des rangs signés de Wilcoxon sur des échantillons indépendants wilcox.test(Locataire ~ Montreal, dfRMR, paired = FALSE) ## ## Wilcoxon rank sum test with continuity correction ## ## data: Locataire by Montreal ## W = 33716, p-value &lt; 2.2e-16 ## alternative hypothesis: true location shift is not equal to 0 Nous observons bien ici une différence significative entre le pourcentage de locataires des secteurs de recensement sur lîle (rang médian = 216) et ceux en dehors de lîle (rang médian = 261). Pour le second exemple, nous générons deux jeux de données au hasard représentant une mesure dune variable pré-traitement (pre) et post-traitement (post) pour un même échantillon. ############################### # Échantillons dépendants ############################### pre &lt;- sample(60:80, 50, replace=T) post &lt;- sample(30:65, 50, replace=T) df1 &lt;- data.frame(Avant=pre, Apres=post) # Nombre d&#39;observations, moyennes et écart-types cat(nrow(df1), &quot; observations&quot;, &quot;\\nPOST. median = &quot;, round(median(df1$Avant),1), &quot;, moy = &quot;, round(mean(df1$Avant),1), &quot;\\nPRE. median = &quot;, round(median(df1$Apres),1), &quot;, moy = &quot;, round(mean(df1$Apres),1), sep=&quot;&quot;) ## 50 observations ## POST. median = 68, moy = 68.5 ## PRE. median = 48.5, moy = 48.2 wilcox.test(df1$Avant, df1$Apres, paired = TRUE) ## ## Wilcoxon signed rank test with continuity correction ## ## data: df1$Avant and df1$Apres ## V = 1219, p-value = 1.649e-09 ## alternative hypothesis: true location shift is not equal to 0 À nouveau, nous obtenons une différence significative entre les deux variables. Comment rapporter un test de Wilcoxon? Lorsque nous rapportons les résultats dun test de Wilcoxon, il est important de signaler la valeur du test (W), le degré de signification (valeur de p) et éventuellement la médiane des rangs ou de la variable originale pour les deux groupes. Voici quelques exemples : Les résultats du test des rangs signés de Wilcoxon signalent que les rangs de lîle de Montréal sont significativement plus élevés que ceux de lîle de Laval (W = 1223, p &lt; 0,001). Les résultats du test de Wilcoxon signalent que les rangs post-tests sont significativement plus faibles que ceux du pré-test (W = 1273,5, p &lt; 0,001). Les résultats du test de Wilcoxon signalent que la médiane des rangs pré-tests (médiane = 69) est significativement plus forte que celle du post-test (médiane = 50,5) (W = 1273,5, p &lt; 0,001). References "],["sect062.html", "6.2 Relation entre une variable quantitative et une variable qualitative à plus de deux modalités", " 6.2 Relation entre une variable quantitative et une variable qualitative à plus de deux modalités Existe-t-il une relation entre une variable continue et une variable qualitative comprenant plus de deux modalités? Pour répondre à cette question, nous avons recours à deux méthodes : lanalyse de variance  ANOVA, ANalysis Of VAriance en anglais  et le test non paramétrique de Kruskal-Wallis. La première permet de vérifier si les moyennes de plusieurs groupes dune population donnée sont ou non significativement différentes; la seconde, si leurs médianes sont différentes. 6.2.1 Analyse de variance Lanalyse de variance (ANOVA) est largement utilisée en psychologie, en médecine et en pharmacologie. Prenons un exemple classique en pharmacologie pour tester lefficacité dun médicament. Quatre groupes de population sont constitués : un premier groupe dindividus pour lequel nous administrons un placebo (un médicament sans substance active), soit le groupe de contrôle ou le groupe témoin; un second groupe auquel nous administrons le médicament avec un faible dosage; un troisième avec un dosage moyen; un quatrième avec un dosage élevé. La variable continue permet dévaluer lévolution de létat de santé des individus (par exemple, la variation du taux de globules rouges dans le sang avant et après le traitement). Si le traitement est efficace, nous nous attendons alors à ce que les moyennes des deuxième, troisième et quatrième groupes soient plus élevées que celle du groupe de contrôle. Les différences de moyennes entre les second, troisième et quatrième groupes permettent aussi de repérer le dosage le plus efficace. Si nous nobservons aucune différence significative entre les groupes, cela signifie que leffet du médicament ne diffère pas de leffet dun placébo. LANOVA est aussi très utilisée en études urbaines, principalement pour vérifier si un phénomène urbain varie selon plusieurs groupes dune population donnée ou de régions géographiques. En guise dexemple, le recours à lANOVA permet de répondre aux questions suivantes : Les moyennes des niveaux dexposition à un polluant atmosphérique (variable continue) varient-elles significativement selon le mode de transport utilisé (automobile, vélo, transport en commun) pour des trajets similaires en heures de pointe? Pour une métropole donnée, les moyennes des loyers (variable continue) sont-elles différentes entre les logements de la ville centre versus ceux localisés dans la première couronne et ceux de la seconde couronne? 6.2.1.1 Calcul des trois variances pour lANOVA LANOVA repose sur le calcul de trois variances : la variance totale (VT) de la variable dépendante continue, soit la somme des carrés des écarts à la moyenne de lensemble de la population (équation (6.8)); la variance intergroupe (Varinter) ou variance expliquée (VE), soit la somme des carrés des écarts entre la moyenne de chaque groupe et la moyenne de lensemble du jeu de données multipliées par le nombre dindividus appartenant à chacun des groupes (équation (6.9)); la variance intragroupe (Varintra) ou variance non expliquée (VNE), soit la somme des variances des groupes de la variable indépendante (équation (6.10)). \\[\\begin{equation} VT=\\sum_{i=1}^n (y_{i}-\\overline{y})^2 \\tag{6.8} \\end{equation}\\] \\[\\begin{equation} Var_{inter} \\mbox{ ou } VE=n_{g_1}\\sum_{i\\in{g_1}}(\\overline{y_{g_1}}-\\overline{y})^2 + n_{g_2}\\sum_{i\\in{g_2}}(\\overline{y_{g_2}}-\\overline{y})^2 + ... + n_{g_k}\\sum_{i\\in{g_n}}(\\overline{y_{g_k}}-\\overline{y})^2 \\tag{6.9} \\end{equation}\\] \\[\\begin{equation} Var_{intra} \\mbox{ ou } VNE=\\sum_{i\\in{g_1}}(y_{i}-\\overline{y_{g_1}})^2 + \\sum_{i\\in{g_2}}(y_{i}-\\overline{y_{g_2}})^2 + ... + \\sum_{i\\in{g_n}}(y_{i}-\\overline{y_{g_k}})^2 \\tag{6.10} \\end{equation}\\] où \\(\\overline{y}\\) est la moyenne de lensemble de la population; \\(\\overline{y_{g_1}}\\), \\(\\overline{y_{g_2}}\\), \\(\\overline{y_{g_k}}\\) sont respectivement les moyennes des groupes 1 à k (k étant le nombre de modalités de la variable qualitative) et \\(n_{g_1}\\),\\(n_{g_2}\\) et \\(n_{g_k}\\) sont les nombres dobservations dans les groupes 1 à k. La variance totale (VT) est égale à la somme de la variance intergroupe (expliquée) et la variance intragroupe (non expliquée) (équation (6.11)). Le ratio entre la variance intergroupe (expliquée) et la variance totale est dénommé Eta2 (équation (6.12)). Il varie de 0 à 1 et exprime la proportion de la variance de la variable continue qui est expliquée par les différentes modalités de la variable qualitative. \\[\\begin{equation} VT = Var_{inter} + Var_{intra} \\mbox{ ou } VT = VNE + VE \\tag{6.11} \\end{equation}\\] \\[\\begin{equation} \\eta^2= \\frac{Var_{inter}}{VT} \\mbox{ ou } \\eta^2= \\frac{VE}{VT} \\tag{6.12} \\end{equation}\\] La décomposition de la variance totale  égale à la somme des variances intragroupe et intergroupe  est fondamentale en statistique. Nous verrons quelle est aussi utilisée pour évaluer la qualité dune partition dune population en plusieurs groupes dans le chapitre sur les méthodes de classification (chapitre 13). En ANOVA, nous retenons que : plus la variance intragroupe est faible, plus les différents groupes sont homogènes; plus la variance intergroupe est forte, plus les moyennes des groupes sont différentes et donc plus les groupes sont dissemblables. Autrement dit, plus la variance intergroupe (dissimilarité des groupes) est maximisée et corollairement plus la variance intragroupe (homogénéité de chacun des groupes) est minimisée, plus les groupes sont clairement distincts et plus lANOVA est performante. Examinons un premier jeu de données fictives sur la vitesse de déplacement de cyclistes (variable continue exprimée en km/h) et une variable qualitative comprenant trois groupes de cyclistes utilisant soit un vélo personnel (nA = 5), soit en libre-service (nB = 7), soit électrique (nC = 6) (tableau 6.2). Demblée, nous notons que les moyennes de vitesse des trois groupes sont différentes : 17,6 km/h pour les cyclistes avec leur vélo personnel, 12,3 km/h celles et ceux avec des vélos en libre-service et 23,1 km/h pour les cyclistes avec un vélo électrique. Pour chaque observation, la troisième colonne du tableau représente les écarts à la moyenne globale mis au carré, tandis que les colonnes suivantes représentent la déviation au carré de chaque observation à la moyenne de son groupe dappartenance. Ainsi, pour la première observation, nous avons \\((\\mbox{16,900} - \\mbox{17,339})^2 = \\mbox{0,193}\\) et \\((\\mbox{16,900} - \\mbox{17,580})^2~ = \\mbox{0,462}\\). Les valeurs des trois variances sont les suivantes : la variance totale (VT) est donc égale à la somme de la troisième colonne (\\(\\mbox{424,663}\\)). la variance intergroupe (expliquée, VE), elle est égale à \\(\\mbox{5}\\times(\\mbox{17,580-17,339})^2+\\mbox{7}\\times(\\mbox{12,257-17,339})^2+\\mbox{6}\\times(\\mbox{23,067-17,339})^2 = \\mbox{377,904}\\). la variance intragroupe (non expliquée, VNE) est égale à \\(\\mbox{11,228+21,537+13,993=46,758}\\). Nous avons donc \\(VT = Var_{inter} + Var_{intra}\\), soit \\(\\mbox{424,663 = 377,904 + 46,758}\\) et \\(\\eta_2 = \\mbox{377,904 / 424,663 = 0,89}\\). Cela signale que 89 % de la variance de la vitesse des cyclistes est expliquée par le type de vélo utilisé. Tableau 6.2: Données fictives et calcul des trois variances (cas 1) Type de vélo km/h \\((y_{i}-\\overline{y})^2\\) \\((y_{i}-\\overline{y_{A}})^2\\) \\((y_{i}-\\overline{y_{B}})^2\\) \\((y_{i}-\\overline{y_{C}})^2\\) A. personnel 16,900 0,193 0,462 A. personnel 20,400 9,370 7,952 A. personnel 16,100 1,535 2,190 A. personnel 17,700 0,130 0,014 A. personnel 16,800 0,290 0,608 B. libre-service 13,400 15,515 1,306 B. libre-service 11,300 36,468 0,916 B. libre-service 14,000 11,148 3,038 B. libre-service 12,400 24,393 0,020 B. libre-service 13,700 13,242 2,082 B. libre-service 8,500 78,126 14,116 B. libre-service 12,500 23,415 0,059 C. électrique 22,900 30,926 0,028 C. électrique 26,000 75,015 8,604 C. électrique 23,600 39,202 0,284 C. électrique 21,000 13,404 4,271 C. électrique 22,300 24,613 0,588 C. électrique 22,600 27,679 0,218 grande moyenne 17,339 moyenne groupe A 17,580 moyenne groupe B 12,257 moyenne groupe C 23,067 Variance totale 424,663 Variance intragroupe 11,228 21,537 13,993 Examinons un deuxième jeu de données fictives pour lequel le type de vélo utilisé naurait que peu deffet sur la vitesse des cyclistes (tableau 6.3). Demblée, les moyennes des trois groupes semblent très similaires (19,3, 17,9 et 18,7). Les valeurs des trois variances sont les suivantes : la variance totale (VT) est égale à \\(\\mbox{121,756}\\). la variance intergroupe (expliquée, VE) est égale à \\(\\mbox{5}\\times(\\mbox{19,300-18,528})^2+\\mbox{7}\\times(\\mbox{17,871-18,528})^2+\\mbox{6}\\times(\\mbox{18,650-18,528})^2 = \\mbox{6,087}\\). la variance intragroupe (non expliquée, VNE) est égale à \\(\\mbox{9,140+50,254+56,275 = 115,669}\\). Nous avons donc \\(VT = Var_{inter} + Var_{intra}\\), soit \\(\\mbox{121,756 = 6,087 + 115,669}\\) et \\(\\eta_2 = \\mbox{6,087 / 121,756 = 0,05}\\). Cela signale que 5 % de la variance de la vitesse des cyclistes est uniquement expliquée par le type de vélo utilisé. Tableau 6.3: Données fictives et calcul des trois variances (cas 2) Type de vélo km/h \\((y_{i}-\\overline{y})^2\\) \\((y_{i}-\\overline{y_{A}})^2\\) \\((y_{i}-\\overline{y_{B}})^2\\) \\((y_{i}-\\overline{y_{C}})^2\\) A. personnel 17,500 1,056 3,24 A. personnel 19,000 0,223 0,09 A. personnel 19,700 1,374 0,16 A. personnel 18,700 0,030 0,36 A. personnel 21,600 9,439 5,29 B. libre-service 13,700 23,307 17,401 B. libre-service 20,800 5,163 8,577 B. libre-service 15,100 11,750 7,681 B. libre-service 18,800 0,074 0,862 B. libre-service 21,500 8,834 13,167 B. libre-service 16,500 4,112 1,881 B. libre-service 18,700 0,030 0,687 C. électrique 16,600 3,716 4,203 C. électrique 16,300 4,963 5,523 C. électrique 15,600 8,572 9,303 C. électrique 20,000 2,167 1,822 C. électrique 24,600 36,872 35,402 C. électrique 18,800 0,074 0,022 grande moyenne 18,528 moyenne groupe A 19,300 moyenne groupe B 17,871 moyenne groupe C 18,650 Variance totale 121,756 Variance intragroupe 9,14 50,254 56,275 6.2.1.2 Test de Fisher Pour vérifier si les moyennes sont statistiquement différentes (autrement dit, si leur différence est significativement différente de 0), nous avons recours au test F de Fisher. Pour ce faire, nous posons lhypothèse nulle (H0), soit que les moyennes des groupes sont égales; autrement dit que la variable qualitative na pas deffet sur la variable continue (indépendance entre les deux variables). Lhypothèse alternative (H1) est donc que les moyennes sont différentes. Pour nos deux jeux de données fictives ci-dessus comprenant trois groupes, H0 signifie que \\(\\overline{y_{A}}=\\overline{y_{B}}=\\overline{y_{C}}\\). La statistique F se calcule comme suit : \\[\\begin{equation} F = \\frac{\\frac{Var{inter}}{k-1}}{\\frac{Var{intra}}{n-k}}\\mbox{ ou } F = \\frac{\\frac{VE}{k-1}}{\\frac{VNE}{n-k}} \\tag{6.13} \\end{equation}\\] où \\(n\\) et \\(k\\) sont respectivement les nombres dobservations et de modalités de la variable qualitative. Lhypothèse nulle (les moyennes sont égales) est rejetée si la valeur du F calculé est supérieure à la valeur critique de la table F avec les degrés de liberté (k-1, n-k) et un seuil \\(\\alpha\\) (p=0,05 habituellement) (voir la table des valeurs critiques de F, section 14.2). Notez que nous utilisons rarement la table F puisquavec la fonction aov, nous obtenons directement la valeur F et celle de p qui lui est associée. Concrètement, si le test F est significatif (avec p &lt; 0,05), plus la valeur de F est élevée, plus la différence entre les moyennes est élevée. Appliquons rapidement la démarche du test F à nos deux jeux de données fictives qui comprennent 3 modalités pour la variable qualitative et 18 observations. Avec \\(\\alpha\\) = 0,05, 2 degrés de liberté (3-1) au numérateur et 15 au dénominateur (18-3), la valeur critique de F est de 3,68. Nous en concluons alors que : pour le cas A, le F calculé est égal à \\(\\mbox{(377,904 / 2) / (46,758 / 15) = 60,62}\\). Il est supérieur à la valeur F critique; les moyennes sont donc statistiquement différentes au seuil 0,05. Autrement dit, nous aurions eu moins de 5 % de chance dobtenir un échantillon produisant ces résultats si en réalité la différence entre les moyennes était de 0. pour le cas B, le F calculé est égal à \\(\\mbox{(6,087 / 2) / (115,669 / 15) = 0,39}\\). Il est inférieur à la valeur F critique; les moyennes ne sont donc pas statistiquement différentes au seuil de 0,05. 6.2.1.3 Conditions dapplication de lANOVA et solutions de rechange Trois conditions dapplication doivent être vérifiées avant deffectuer une analyse de variance sur un jeu de données : Normalité des groupes. Le test de Fisher repose sur le postulat que les échantillons (groupes) sont normalement distribués. Pour le vérifier, nous avons recours au test de normalité de ShapiroWilk (section 2.5.4.1.3). Rappelez-vous toutefois que ce test est très restrictif, surtout pour de grands échantillons. Homoscédasticité. La variance dans les échantillons doit être la même (homogénéité des variances). Pour vérifier cette condition, nous utilisons les tests de Levene, de Bartlett ou de Breusch-Pagan. Indépendance des observations (pseudo-réplication). Chaque individu doit appartenir à un et un seul groupe. En dautres termes, les observations ne sont pas indépendantes si plusieurs mesures (variable continue) sont faites sur un même individu. Si cest le cas, nous utiliserons alors une analyse de variance sur des mesures répétées (voir le bloc à la fin du chapitre). Quelles sont les conséquences si les conditions dapplication ne sont pas respectées? La non-vérification des conditions dapplication cause deux problèmes distincts : elle affecte la puissance du test (sa capacité à détecter un effet, si celui-ci existe réellement) et le taux derreur de type 1 (la probabilité de trouver un résultat significatif alors quaucune relation nexiste réellement, soit un faux-positif) (Glass, Peckham et Sanders 1972; Lix, Keselman et Keselman 1996). Si la distribution est asymétrique plutôt que centrée (comme pour une distribution normale), la puissance et le taux derreur de type 1 sont tous les deux peu affectés, car le test est non orienté (la différence de moyennes peut être négative ou positive). Si la distribution est leptocurtique (pointue, avec des extrémités de la distribution plus importantes), le taux derreur de type 1 est peu affecté; en revanche, la puissance du test est réduite. Linverse sobserve si la distribution est platicurtique (aplatie, cest-à-dire avec des extrémités de la distribution plus réduites. Si les groupes ont des variances différentes, le taux derreur de type 1 augmente légèrement. Si les observations ne sont pas indépendantes, à la fois le taux derreur de type 1 et la puissance du test sont fortement affectés. Si les échantillons sont petits, les effets présentés ci-dessus sont démultipliés. Si plusieurs conditions ne sont pas respectées, les conséquences présentées ci-dessus sadditionnent, voire se combinent. Que faire quand les conditions dapplication relatives à la normalité ou à lhomoscédasticité ne sont vraiment pas respectées? Signalons demblée que le non-respect de ces conditions ne change rien à la décomposition de la variance (VT = Vintra+Vinter). Cela signifie que vous pouvez toujours calculer Eta2. Par contre, le test de Fisher ne peut pas être utilisé, car il est biaisé comme décrit précédemment. Quatre solutions sont envisageables : Lorsque les échantillons sont fortement anormalement distribués, certains auteurs vont simplement transformer leur variable en appliquant une fonction logarithme (le plus souvent) ou racine carrée, inverse ou exponentielle, et reporter le test de Fisher calculé sur cette transformation. Attention toutefois! Transformer une variable ne va pas systématiquement la rapprocher dune distribution normale et complique linterprétation finale des résultats. Par conséquent, avant de recalculer votre test F, il convient de réaliser un test de normalité de ShapiroWilk et un test dhomoscédasticité (Levene, Bartlett ou Breusch-Pagan) sur la variable continue transformée. Détecter les observations qui contribuent le plus à lanormalité et à lhétéroscédasticité (valeurs aberrantes ou extrêmes). Supprimez-les et refaites votre ANOVA en vous assurant que les conditions sont désormais respectées. Notez que supprimer des observations peut être une pratique éthiquement questionnable en statistique. Si vos échantillons sont bien constitués et que la mesure collectée nest pas erronée, pourquoi donc la supprimer? Si vous optez pour cette solution, prenez soin de comparer les résultats avant et après la suppression des observations. Si les conditions sont respectées après la suppression et que les résultats de lANOVA (Eta2 et test F de Fisher) sont très semblables, conservez donc les résultats de lANOVA initiale et signalez que vous avez procédé aux deux tests. Lorsque les variances des groupes sont dissemblables, vous pouvez utiliser le test de Welch pour lANOVA au lieu du test F de Fisher. Dernière solution, lorsque les deux conditions ne sont vraiment pas respectées, utilisez le test non paramétrique de Kruskal-Wallis. Par analogie au t de Student, il correspond au test des rangs signés de Wilcoxon. Ce test est décrit dans la section suivante. Vous laurez compris, dans de nombreux cas en statistique, les choix méthodologiques dépendent en partie de la subjectivité des chercheur(e)s. Il faut sadapter au jeu de données et à la culture statistique en vigueur dans votre champ détudes. Nhésitez pas à réaliser plusieurs tests différents pour évaluer la robustesse de vos conclusions et fiez-vous en premier lieu à ceux pour lesquels votre jeu de données est le plus adapté. 6.2.2 Test non paramétrique de Kruskal-Wallis Le test non paramétrique de Kruskal-Wallis est une solution de rechange à lANOVA classique lorsque le jeu de données présente de graves problèmes de normalité et dhétéroscédasticité. Cette méthode représente une ANOVA appliquée à une variable continue transformée préalablement en rangs. Du fait de la transformation en rangs, nous ne vérifions plus si les moyennes sont différentes, mais bel et bien si les médianes de la variable continue sont différentes. Pour ce faire, nous utiliserons la fonction kruskal.test. 6.2.3 Mise en uvre dans R Dans une étude récente, Apparicio et al. (2018) ont comparé les expositions au bruit et à la pollution atmosphérique aux heures de pointe à Montréal en fonction du mode de transport utilisé. Pour ce faire, trois équipes de trois personnes ont été constituées : une personne à vélo, une autre en automobile et une dernière se déplaçant en transport en commun, équipées de capteurs de pollution, de sonomètres, de vêtements biométriques et dune montre GPS. Chaque matin, à huit heures précises, les membres de chaque équipe ont réalisé un trajet dun quartier périphérique de Montréal vers un pôle denseignement (université) ou demploi localisé au centre-ville. Le trajet inverse était réalisé le soir à 17 h. Au total, une centaine de trajets ont ainsi été réalisés. Des analyses de variance ont ainsi permis de comparer les trois modes (automobile, vélo et transport en commun) en fonction des temps de déplacement, des niveaux dexposition au bruit, des niveaux dexposition au dioxyde dazote et de la dose totale inhalée de dioxyde dazote. Nous vous proposons ici danalyser une partie de ces données. 6.2.3.1 Première ANOVA : différences entre les temps de déplacement Comme première analyse de variance, nous vérifions si les moyennes des temps de déplacement sont différentes entre les trois modes de transport. Dans un premier temps, nous calculons les moyennes des différents groupes. Nous pouvons alors constater que les moyennes sont très semblables : 37,7 minutes pour lautomobile versus 38,4 et 41,6 pour le vélo et le transport en commun. Aussi, les variances des trois groupes sont relativement similaires. library(&quot;rstatix&quot;) # chargement des DataFrames load(&quot;data/bivariee/dataPollution.RData&quot;) # Statistiques descriptives pour les groupes (moyenne et écart-type) df_TrajetsDuree %&gt;% # Nom du DataFrame group_by(Mode) %&gt;% # Variable qualitative get_summary_stats(DureeMinute, type = &quot;mean_sd&quot;) # Variable continue ## # A tibble: 3 x 5 ## Mode variable n mean sd ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1. Auto DureeMinute 33 37.7 12.8 ## 2 2. Velo DureeMinute 33 38.4 15.2 ## 3 3. TC DureeMinute 33 41.6 11.4 Pour visualiser la distribution des données pour les trois groupes, vous pouvez créer des graphiques de densité et en violon (figure 6.4). La juxtaposition des trois distributions montre que les distributions des valeurs pour les trois groupes sont globalement similaires. Cela est corroboré par le fait que les boîtes du graphique en violon sont situées à la même hauteur. Autrement dit, à la lecture des deux graphiques, il ne semble pas y avoir de différences significatives entre les trois groupes en termes de temps de déplacement. library(&quot;ggplot2&quot;) library(&quot;ggpubr&quot;) # Graphique de densité GraphDens &lt;- ggplot(data = df_TrajetsDuree, mapping=aes(x=DureeMinute,colour=Mode,fill=Mode)) + geom_density(alpha=0.55,mapping=aes(y=..scaled..))+ labs(title=&quot;a. Graphique de densité&quot;, x = &quot;Densité&quot;, y = &quot;Durée du trajet (en minutes)&quot;) # Graphique en violon GraphViolon &lt;- ggplot(df_TrajetsDuree, aes(x=Mode, y=DureeMinute)) + geom_violin(fill=&quot;white&quot;) + geom_boxplot(width=0.1, aes(x=Mode, y=DureeMinute,fill=Mode))+ labs(title=&quot;b. Graphique en violon&quot;, x = &quot;Mode de transport&quot;, y = &quot;Durée du trajet (en minutes)&quot;)+ theme(legend.position = &quot;none&quot;) ggarrange(GraphDens, GraphViolon) Figure 6.4: Graphiques de densité et en violon Nous pouvons vérifier si les échantillons sont normalement distribués avec la fonction shapiro_test du package rstatix. À titre de rappel, lhypothèse nulle (H0) de ce test est que la distribution est normale. Par conséquent, quand la valeur de p associée à la statistique de Shapiro est supérieure à 0,05, alors nous ne pouvons rejeter lhypothèse dune distribution normale (autrement dit, la distribution est anormale). À la lecture des résultats ci-dessous, seul le groupe utilisant le transport en commun présente une distribution proche de la normalité (p = 0,0504). Ce test étant très restrictif, il est fortement conseillé de visualiser le diagramme quantile-quantile pour chaque groupe (graphique QQ plot) (figure 6.5). Ces graphiques sont utilisés pour déterminer visuellement si une distribution empirique (observée sur des données), sapproche dune distribution théorique (ici la loi normale). Si effectivement les deux distributions sont proches, les points du diagramme devraient tous tomber sur une ligne droite parfaite. Un intervalle de confiance (représenté ici en gris) peut être construit pour obtenir une interprétation plus nuancée. Dans notre cas, seules deux observations pour le vélo et deux autres pour lautomobile séloignent vraiment de la ligne droite. Nous pouvons considérer que ces trois distributions sapprochent dune distribution normale. library(&quot;dplyr&quot;) library(&quot;ggpubr&quot;) library(&quot;rstatix&quot;) # Condition 1 : normalité des échantillons # Test pour la normalité des échantillons (groupes) : test de Shapiro df_TrajetsDuree %&gt;% # Nom du DataFrame group_by(Mode) %&gt;% # Variable qualitative shapiro_test(DureeMinute) # Variable continue ## # A tibble: 3 x 4 ## Mode variable statistic p ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1. Auto DureeMinute 0.905 0.00729 ## 2 2. Velo DureeMinute 0.797 0.0000288 ## 3 3. TC DureeMinute 0.936 0.0504 # Graphiques qqplot pour les groupes ggqqplot(df_TrajetsDuree, &quot;DureeMinute&quot;, facet.by = &quot;Mode&quot;, xlab=&quot;Théorique&quot;, ylab=&quot;Échantillon&quot;) Figure 6.5: QQ Plot pour les groupes Pour vérifier lhypothèse dhomogénéité des variances, vous pouvez utiliser les tests de Levene, de Bartlett ou de Breusch-Pagan. Les valeurs de p, toutes supérieures à 0,05, signalent que la condition dhomogénéité des variances est respectée. library(&quot;rstatix&quot;) library(&quot;lmtest&quot;) library(&quot;car&quot;) # Condition 2 : homogénéité des variances (homocédasticité) leveneTest(DureeMinute ~ Mode, data = df_TrajetsDuree) ## Levene&#39;s Test for Homogeneity of Variance (center = median) ## Df F value Pr(&gt;F) ## group 2 0.2418 0.7857 ## 96 bartlett.test(DureeMinute ~ Mode, data = df_TrajetsDuree) ## ## Bartlett test of homogeneity of variances ## ## data: DureeMinute by Mode ## Bartlett&#39;s K-squared = 2.6718, df = 2, p-value = 0.2629 bptest(DureeMinute ~ Mode, data = df_TrajetsDuree) ## ## studentized Breusch-Pagan test ## ## data: DureeMinute ~ Mode ## BP = 1.3322, df = 2, p-value = 0.5137 Deux fonctions peuvent être utilisées pour calculer lanalyse de variance : la fonction de base aov(variable continue ~ variable qualitative, data = votre DataFrame) ou bien la fonction anova_test(variable continue ~ variable qualitative, data = votre DataFrame) du package rstatix. Comparativement à aov, lavantage de la fonction anova_test est quelle calcule aussi le Eta2. library(&quot;rstatix&quot;) library(&quot;car&quot;) library(&quot;effectsize&quot;) # ANOVA avec la fonction aov aov1 &lt;- aov(DureeMinute ~ Mode, data = df_TrajetsDuree) summary(aov1) ## Df Sum Sq Mean Sq F value Pr(&gt;F) ## Mode 2 287 143.2 0.82 0.444 ## Residuals 96 16781 174.8 # calcul de Eta2 avec la fonction eta_squared du package effectsize effectsize::eta_squared(aov1) ## Parameter | Eta2 | 90% CI ## ------------------------------- ## Mode | 0.02 | [0.00, 0.07] # ANOVA avec la fonction anova_test du package rstatix anova_test(DureeMinute ~ Mode, data = df_TrajetsDuree) ## ANOVA Table (type II tests) ## ## Effect DFn DFd F p p&lt;.05 ges ## 1 Mode 2 96 0.82 0.444 0.017 La valeur de p associée à la statistique F (0,444) nous permet de conclure quil ny a pas de différences significatives entre les moyennes des temps de déplacement des trois modes de transport. 6.2.3.2 Deuxième ANOVA : différences entre les niveaux dexposition au bruit Dans ce second exercice, nous analysons les différences dexposition au bruit. Demblée, les statistiques descriptives révèlent que les moyennes sont dissemblables : 66,8 dB(A) pour lautomobile versus 68,8 et 74 pour le vélo et le transport en commun. Aussi, la variance du transport en commun est très différente des autres. library(&quot;rstatix&quot;) # chargement des DataFrames load(&quot;data/bivariee/dataPollution.RData&quot;) # Statistiques descriptives pour les groupes (moyenne et écart-type) df_Bruit %&gt;% # Nom du DataFrame group_by(Mode) %&gt;% # Variable qualitative get_summary_stats(laeq, type = &quot;mean_sd&quot;) # Variable continue ## # A tibble: 3 x 5 ## Mode variable n mean sd ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1. Auto laeq 1094 66.8 4.56 ## 2 2. Velo laeq 1124 68.8 4.29 ## 3 3. TC laeq 1207 74.0 6.79 À la lecture des graphiques de densité et en violon (figure 6.6), il semble clair que les niveaux dexposition au bruit sont plus faibles pour les automobilistes et plus élevés pour les cyclistes et surtout les personnes en transport en commun. En outre, la distribution des valeurs dexposition au bruit dans le transport en commun semble bimodale. Cela sexplique par le fait que les niveaux de bruit sont beaucoup plus élevés dans le métro que dans les autobus. library(&quot;ggplot2&quot;) library(&quot;ggpubr&quot;) # Graphique en densité GraphDens &lt;- ggplot(data = df_Bruit, mapping=aes(x=laeq,colour=Mode,fill=Mode)) + geom_density(alpha=0.55,mapping=aes(y=..scaled..))+ labs(title=&quot;a. graphique de densité&quot;, x=&quot;Exposition au bruit (dB(A))&quot;) # Graphique en violon GraphViolon &lt;- ggplot(df_Bruit, aes(x=Mode, y=laeq)) + geom_violin(fill=&quot;white&quot;) + geom_boxplot(width=0.1, aes(x=Mode, y=laeq,fill=Mode))+ labs(title=&quot;b. Graphique en violon&quot;, x = &quot;Mode de transport&quot;, y=&quot;Exposition au bruit (dB(A))&quot;)+ theme(legend.position = &quot;none&quot;) ggarrange(GraphDens, GraphViolon) Figure 6.6: Graphique de densité et en violon Le test de Shapiro et les graphiques QQ plot (figure 6.7) révèlent que les distributions des trois groupes sont anormales. Ce résultat nest pas surprenant si lon tient compte de la nature logarithmique de léchelle décibel. library(&quot;dplyr&quot;) library(&quot;ggpubr&quot;) library(&quot;rstatix&quot;) # Condition 1 : normalité des échantillons # Test pour la normalité des échantillons (groupes) : test de Shapiro df_Bruit %&gt;% # Nom du DataFrame group_by(Mode) %&gt;% # Variable qualitative shapiro_test(laeq) # Variable continue ## # A tibble: 3 x 4 ## Mode variable statistic p ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1. Auto laeq 0.971 4.92e-14 ## 2 2. Velo laeq 0.992 5.12e- 6 ## 3 3. TC laeq 0.966 3.34e-16 # Graphiques qqplot pour les groupes ggqqplot(df_Bruit, &quot;laeq&quot;, facet.by = &quot;Mode&quot;, xlab=&quot;Théorique&quot;, ylab=&quot;Échantillon&quot;) Figure 6.7: QQ Plot pour les groupes En outre, selon les valeurs des tests de Levene, de Bartlett ou de Breusch-Pagan, les variances ne sont pas égales. library(&quot;rstatix&quot;) library(&quot;lmtest&quot;) library(&quot;car&quot;) # Condition 2 : homogénéité des variances (homocédasticité) leveneTest(laeq ~ Mode, data = df_Bruit) ## Levene&#39;s Test for Homogeneity of Variance (center = median) ## Df F value Pr(&gt;F) ## group 2 190.3 &lt; 2.2e-16 *** ## 3422 ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 bartlett.test(laeq ~ Mode, data = df_Bruit) ## ## Bartlett test of homogeneity of variances ## ## data: laeq by Mode ## Bartlett&#39;s K-squared = 306.64, df = 2, p-value &lt; 2.2e-16 bptest(laeq ~ Mode, data = df_Bruit) ## ## studentized Breusch-Pagan test ## ## data: laeq ~ Mode ## BP = 279.85, df = 2, p-value &lt; 2.2e-16 Étant donné que les deux conditions (normalité et homogénéité des variances) ne sont pas respectées, il est préférable dutiliser un test non paramétrique de Kruskal-Wallis. Calculons toutefois préalablement lANOVA classique et lANOVA de Welch puisque les variances ne sont pas égales. Les valeurs de p des deux tests (Fisher et Welch) signalent que les moyennes dexposition au bruit sont statistiquement différentes entre les trois modes de transport. library(&quot;rstatix&quot;) # ANOVA avec la fonction anova_test du package rstatix anova_test(laeq ~ Mode, data = df_Bruit) ## ANOVA Table (type II tests) ## ## Effect DFn DFd F p p&lt;.05 ges ## 1 Mode 2 3422 544.214 6.12e-206 * 0.241 # ANOVA avec le test de Welch puisque les variances ne sont pas égales welch_anova_test(laeq ~ Mode, data = df_Bruit) ## # A tibble: 1 x 7 ## .y. n statistic DFn DFd p method ## * &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 laeq 3425 446. 2 2248. 9.47e-164 Welch ANOVA Une fois démontré que les moyennes sont différentes, le test de Tukey est particulièrement intéressant puisquil nous permet de repérer les différences de moyennes significatives deux à deux, tout en ajustant les valeurs de p obtenues en fonction du nombre de comparaisons effectuées. Ci-dessous, nous constatons que toutes les paires sont statistiquement différentes et que la différence de moyennes entre les automobilistes et les cyclistes est de 1,9 dB(A) et surtout de 7,1 dB(A) entre les automobilistes et les personnes ayant pris le transport en commun. aov2 &lt;- aov(laeq ~ Mode, data = df_Bruit) # Test de Tukey pour comparer les moyennes entre elles TukeyHSD(aov2, conf.level = 0.95) ## Tukey multiple comparisons of means ## 95% family-wise confidence level ## ## Fit: aov(formula = laeq ~ Mode, data = df_Bruit) ## ## $Mode ## diff lwr upr p adj ## 2. Velo-1. Auto 1.941698 1.406343 2.477053 0 ## 3. TC-1. Auto 7.113506 6.587309 7.639703 0 ## 3. TC-2. Velo 5.171808 4.649307 5.694309 0 Le calcul du test non paramétrique de Kruskal-Wallis avec la fonction kruskal.test démontre aussi que les médianes des groupes sont différentes (p &lt; 0,001). De manière comparable au test de Tukey, la fonction pairwise.wilcox.test permet aussi de repérer les différences significatives entre les paires de groupes. Pour conclure, tant lANOVA que le test non paramétrique de Kruskal-Wallis indiquent que les trois modes de transport sont significativement différents quant à lexposition au bruit, avec des valeurs plus faibles pour les automobilistes comparativement aux cyclistes et aux personnes ayant pris le transport en commun. # Test de Kruskal-Wallis kruskal.test(laeq ~ Mode, data = df_Bruit) ## ## Kruskal-Wallis rank sum test ## ## data: laeq by Mode ## Kruskal-Wallis chi-squared = 784.74, df = 2, p-value &lt; 2.2e-16 # Calcul de la moyenne des rangs pour les trois groupes df_Bruit$laeqRank &lt;- rank(df_Bruit$laeq) df_Bruit %&gt;% group_by(Mode) %&gt;% get_summary_stats(laeqRank, type = &quot;mean&quot;) ## # A tibble: 3 x 4 ## Mode variable n mean ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1. Auto laeqRank 1094 1188. ## 2 2. Velo laeqRank 1124 1572. ## 3 3. TC laeqRank 1207 2320. # Comparaison des groupes avec la fonction pairwise.wilcox.test pairwise.wilcox.test(df_Bruit$laeq, df_Bruit$Mode, p.adjust.method = &quot;BH&quot;) ## ## Pairwise comparisons using Wilcoxon rank sum test with continuity correction ## ## data: df_Bruit$laeq and df_Bruit$Mode ## ## 1. Auto 2. Velo ## 2. Velo &lt;2e-16 - ## 3. TC &lt;2e-16 &lt;2e-16 ## ## P value adjustment method: BH 6.2.4 Comment rapporter les résultats dune ANOVA et du test de Kruskal-Wallis Plusieurs éléments doivent être reportés pour détailler les résultats dune ANOVA ou dun test de Kruskal-Wallis : la valeur de F, de W (dans le cas dune ANOVA de Welch) ou du 2 (Kruskal-Wallis), les valeurs de p, les moyennes ou médianes respectives des groupes et éventuellement un tableau détaillant les écarts intergroupes obtenus avec les tests de Tukey ou Wilcoxon par paires. Les résultats de lanalyse de variance à un facteur démontrent que le mode de transport utilisé na pas deffet significatif sur le temps de déplacement en heures de pointe à Montréal (F(2,96) = 0,82, p = 0,444). En effet, pour des trajets de dix kilomètres entre un quartier périphérique et le centre-ville, les cyclistes (Moy = 38,4, ET = 15,2) arrivent en moyenne moins dune minute après les automobilistes (Moy = 37,7, ET = 12,8) et moins de quatre minutes comparativement aux personnes ayant pris le transport en commun (Moy = 41,6, ET = 11,4). Les résultats de lanalyse de variance à un facteur démontrent que le mode de transport utilisé a un impact significatif sur le niveau dexposition en heures de pointe à Montréal (F(2,96) = 544, p &lt; 0,001 et Welch(2,96) = 446, p &lt; 0,001). En effet, les personnes en transport en commun (Moy = 74,0, ET = 6,79) et les cyclistes (Moy = 68,8, ET = 4,3) ont des niveaux dexposition au bruit significativement plus élevés que les automobilistes (Moy = 66,8, ET = 4,56). Les résultats du test de Kruskal-Wallis démontrent quil existe des différences significatives dexposition au bruit entre les trois modes de transport (2(2) = 784,74, p &lt; 0,001) avec des moyennes de rangs de 1094 pour lautomobile, de 1124 pour le vélo et de 1207 pour le transport en commun. Nous avons vu que lANOVA permet de comparer les moyennes dune variable continue à partir dune variable qualitative comprenant plusieurs modalités (facteur) pour des observations indépendantes. Il y a donc une seule variable dépendante (continue) et une seule variable indépendante. Sachez quil existe de nombreuses extensions de lANOVA classique : une ANOVA à deux facteurs, soit avec une variable dépendante continue et deux variables indépendantes qualitatives (two-way ANOVA en anglais). Nous évaluons ainsi les effets des deux variables (a, b) et de leur interaction (ab) sur une variable continue. une ANOVA multifacteur avec une variable dépendante continue et plus de deux variables indépendantes qualitatives. Par exemple, avec trois variables qualitatives pour expliquer la variable continue, nous incluons les effets de chaque variable qualitative (a, b, c), ainsi que de leurs interactions (ab, ac, bc, abc). Lanalyse de covariance (ANCOVA, ANalysis of COVAriance en anglais) comprend une variable dépendante continue, une variable indépendante qualitative (facteur) et plusieurs variables indépendantes continues dites covariables. Lobjectif est alors de vérifier si les moyennes dune variable dépendante sont différentes pour plusieurs groupes dune population donnée, après avoir contrôlé leffet dune ou de plusieurs variables continues. Par exemple, pour une métropole donnée, nous pourrions vouloir comparer les moyennes de loyers entre la ville-centre et ceux des première et seconde couronnes (facteur), une fois contrôlée la taille de ces derniers (variable covariée continue). En effet, une partie de la variance des loyers sexplique certainement par la taille des logements. Lanalyse de variance multivariée (MANOVA, Multivariate ANalysis Of VAriance en anglais) comprend deux variables dépendantes continues ou plus et une variable indépendante qualitative (facteur). Par exemple, nous souhaiterions comparer les moyennes dexposition au bruit et à différents polluants (dioxyde dazote, particules fines, ozone) (variables dépendantes continues) selon le mode de transport utilisé (automobile, vélo, transport en commun), soit le facteur. Lanalyse de covariance multivariée (MANCOVA, Multivariate ANalysis of COVAriance en anglais), soit une analyse qui comprend deux variables dépendantes continues ou plus (comme la MANOVA) et une variable qualitative comme variable indépendante (facteur) et une covariable continue ou plus. Pour le test t, nous avons vu quil peut sappliquer soit à deux échantillons indépendants (non appariés), soit à deux échantillons dépendants (appariés). Notez quil existe aussi des extensions de lANOVA pour des échantillons pairés. Nous parlons alors danalyse de variance sur des mesures répétées. Par exemple, nous pourrions évaluer la perception du sentiment de sécurité relativement à la pratique du vélo dhiver pour un échantillon de cyclistes ayant décidé de ladopter récemment, et ce, à plusieurs moments : avant leur première saison, à la fin de leur premier hiver, à la fin de leur second hiver. Autre exemple, nous pourrions sélectionner un échantillon dindividus (100, par exemple) pour lesquels nous évaluerions leurs perceptions de lenvironnement sonore dans différents lieux de la ville. Comme pour lANOVA classique (échantillons non appariés), il existe des extensions de lANOVA sur des mesures répétées permettant dinclure plusieurs facteurs (groupes de population); nous mesurons alors une variable continue pour plusieurs groupes dindividus à différents moments ou pour des conditions différentes. Il est aussi possible de réaliser une ANOVA pour des mesures répétées avec une ou plusieurs covariables continues. Bref, si lANOVA était un roman, elle serait certainement « un monde sans fin » de Ken Follett! Notez toutefois que la SUPERNOVA, la BOSSA-NOVA et le CASANOVA ne sont pas des variantes de lANOVA! References "],["sect063.html", "6.3 Conclusion sur la troisième partie", " 6.3 Conclusion sur la troisième partie Dans le cadre de cette troisième partie du livre, nous avons abordé les principales méthodes exploratoires et confirmatoires bivariées permettant dévaluer la relation entre deux variables. La figure 6.8 propose un résumé de ces méthodes. Figure 6.8: Les principales méthodes bivariées "],["sect064.html", "6.4 Quiz de révision du chapitre", " 6.4 Quiz de révision du chapitre Comment comparer les moyennes de deux groupes? Relisez au besoin la section 6.1.1. t de Student (test t) Analyse de variance (ANOVA) Covariance et corrélation Test de Kruskal-Wallis Comment comparer les médianes de plus de deux groupes? Relisez au besoin la section 6.1.2. t de Student (test t) Analyse de variance (ANOVA) Test de Kruskal-Wallis Test de Wilcoxon Les observations de deux groupes qui nont aucun lien entre eux; les tailles des deux échantillons peuvent être différentes. Cette affirmation sapplique à des Relisez au besoin le début de la section 6.1.1. échantillons indépendants (dits non appariés) échantillons dépendants (dits appariés) Lorsque les variances des deux groupes sont dissemblables, quel test utilisez-vous? Relisez au besoin la section 6.1.1. Test de Student (test t) Test de Welch (appelé aussi Satterthwaite) Analyse de variance (ANOVA) Ces boîtes à moustaches sappliquent à des : Relisez au besoin la section 6.1.1.1. échantillons dépendants (dits appariés) échantillons indépendants (dits non appariés) Plus la variance intergroupe (dissimilarité des groupes) est maximisée et corollairement plus la variance intragroupe (homogénéité de chacun des groupes) est minimisée, plus les groupes sont clairement distincts et plus lANOVA est performante. Selon vous, à la lecture de ces graphiques, lANOVA risque-t-elle dêtre très performante? Relisez au besoin la section 6.2.1.1. Oui Non Quelles sont les trois conditions dapplication de lANOVA? Relisez au besoin la section 6.2.1.3. Normalité des groupes Homogénéité des variances des groupes (homoscédasticité) Indépendance des observations (pseudo-réplication) Il faut deux groupes Les groupes doivent être de taille égale Le test non paramétrique de Kruskal-Wallis permet de comparer les médianes de plus de deux groupes. Relisez au besoin la section 6.2.2. Vrai Faux Sur quelle(s) variances est basée lANOVA? Relire le deuxième encadré à la section 6.2.1.1. La variance totale La variance intragroupe La variance intergroupe Quelles sont les variantes de lANOVA? Relire le deuxième encadré à la section 6.2.4. Une ANOVA à deux facteurs Une ANOVA multifacteur Lanalyse de covariance (ANCOVA) Lanalyse de variance multivariée (MANOVA) Lanalyse de covariance multivariée (MANCOVA) La SUPERNOVA La BOSSANOVA Le CASANOVA Verifier Votre score "],["chap07.html", "Chapitre 7 Régression linéaire multiple", " Chapitre 7 Régression linéaire multiple Dans ce chapitre, nous présentons la méthode de régression certainement la plus utilisée en sciences sociales : la régression linéaire multiple. À titre de rappel, dans la section 4.4, nous avons vu que la régression linéaire simple, basée sur la méthode des moindres carrés ordinaires (MCO), permet dexpliquer et de prédire une variable continue en fonction dune autre variable. Toutefois, quel que soit le domaine détude, il est rare que le recours à une seule variable explicative (X) permette de prédire efficacement une variable continue (Y). La régression linéaire multiple est simplement une extension de la régression linéaire simple : elle permet ainsi de prédire et dexpliquer une variable dépendante (Y) en fonction de plusieurs variables indépendantes (explicatives). Plus spécifiquement, nous abordons ici les principes et les hypothèses de la régression linéaire multiple, comment mesurer la qualité dajustement du modèle, introduire des variables explicatives particulières (variable qualitative dichotomique ou polytomique, variable dinteraction, etc.), interpréter les sorties dun modèle de régression et finalement la mettre en oeuvre dans R. Dans ce chapitre, nous utilisons les packages suivants : Pour créer des graphiques : ggplot2, le seul, lunique! ggpubr pour combiner les graphiques Pour obtenir les coefficients standardisés : QuantPsyc avec la fonction lm.beta (section 7.4.2). Pour les effets marginaux des variables indépendantes : ggeffects avec la fonction ggpredict (section 7.7.4). Pour vérifier la normalité des résidus : DescTools avec les fonctions Skewness et Kurtosis et JarqueBeraTest (section 7.6.2). Pour vérifier lhomoscédasticité des résidus : lmtest avec la fonction bptest pour le test de Breusch-Pagan (section 7.7.3.3). Pour vérifier la multicolinéarité excessive : car avec la fonction vif (section 7.7.3.4). Autre package : foreign pour importer des fichiers externes. "],["sect071.html", "7.1 Objectifs de la régression linéaire multiple et construction dun modèle de régression", " 7.1 Objectifs de la régression linéaire multiple et construction dun modèle de régression Selon Barbara G. Tabachnich et Linda S. Fidell (2007), un modèle de régression permet de répondre à deux objectifs principaux relevant chacun dune approche de modélisation particulière. La première approche a pour objectif didentifier les relations entre une variable dépendante (VD) et plusieurs variables indépendantes (VI). Il sagit alors de déterminer si ces relations sont positives ou négatives, significatives ou non et dévaluer leur ampleur. La construction du modèle de régression repose alors sur un cadre théorique et la formulation dhypothèses, sur les relations entre chacune des VI et la VD. La seconde approche est exploratoire et très utilisée en forage ou en fouille de données (data mining en anglais). Parmi un grand ensemble de variables disponibles dans un jeu de données, elle vise à identifier la ou les variables permettant de prédire le plus efficacement (précisément) une variable dépendante. Parfois, ce type de démarche ne repose ni sur un cadre théorique ni sur la formulation dhypothèses entre les VI et la VD. Dans des cas extrêmes, on sintéresse uniquement à la capacité de prédiction du modèle, et ce, sans analyser les associations entre les VI et la VD. Lobjectif étant dobtenir le modèle le plus efficace possible afin de prédire à lavenir la valeur de la variable dépendante pour des observations pour lesquelles elle est inconnue. Pour ce faire, nous avons recours à des régressions séquentielles (stepwise regressions) dans lesquelles les variables peuvent être ajoutées une à une au modèle ou retirées de celui-ci; nous conserverons dans le modèle final uniquement celles qui ont un apport explicatif significatif. Signalons demblée que dans le reste du chapitre, comme du livre, nous ne nous étendons pas plus sur cette approche de modélisation, et ce, pour deux raisons. Dune part, cette approche met souvent en évidence des relations significatives entre des variables sans quil y ait une relation de causalité entre elles. Dautre part, en sciences sociales, un modèle de régression doit être basé sur un cadre théorique et conceptuel élaboré à la suite à dune revue de littérature rigoureuse. Cadre conceptuel et élaboration dun modèle de régression Pour bien construire un modèle de régression, il convient de définir un cadre conceptuel élaboré à la suite à une revue de littérature sur le sujet de recherche. Ce cadre conceptuel permet didentifier les dimensions et les concepts clefs permettant dexpliquer le phénomène à létude. Par la suite, pour chacun de ces concepts ou les dimensions, il est alors possible 1) didentifier les différentes variables indépendantes qui sont introduites dans le modèle et 2) de formuler une hypothèse pour chacune delles. Par exemple, pour telle ou telle variable explicative, on sattendra à ce quelle fasse augmenter ou diminuer significativement la variable dépendante. De nouveau, la formulation de cette hypothèse doit sappuyer sur une interprétation théorique de la relation entre la VI et la VD. Prenons en guise dexemple une étude récente portant sur la multiexposition des cyclistes au bruit et à la pollution atmosphérique (Gelb et Apparicio 2020). Dans cet article, les auteurs sintéressent aux caractéristiques de lenvironnement urbain qui contribuent à augmenter ou réduire lexposition des cyclistes à la pollution de lair et au bruit routier. Pour ce faire, une collecte de données primaires a été réalisée avec trois cyclistes dans les rues de Paris du 4 au 7 septembre 2017. Au total, 64 heures et 964 kilomètres ont ainsi été parcourus à vélo afin de maximiser la couverture de la ville de Paris et les types denvironnements urbains traversés. Leur cadre conceptuel est schématisé à la figure 7.1. Les deux variables indépendantes (à expliquer) sont lexposition au dioxyde dazote (NO2) et lexposition au bruit (mesurée en décibel dB(A)). Avant didentifier les caractéristiques de lenvironnement urbain affectant ces deux expositions, plusieurs facteurs, dits variables de contrôle, sont considérés. Par exemple, la concentration de NO2 varie en fonction des conditions météorologiques (vent, température et humidité) et de la pollution darrière-plan (variant selon le moment de la journée, le jour de la semaine et la localisation géographique au sein de la ville). Ces dimensions ne sont pas le centre dintérêt direct de létude. En effet, les auteurs sintéressent aux impacts des caractéristiques locales de lenvironnement urbain. Pour pouvoir les identifier sans biais, il est nécessaire de contrôler (filtrer) lensemble de ces autres facteurs. Dans leur cadre conceptuel, les auteurs regroupent les caractéristiques locales de lenvironnement urbain en trois grandes dimensions : les caractéristiques du segment (type de rues ou de voies cyclables empruntés, intersections traversées, pente et vitesse), celles de la forme urbaine (densité résidentielle, végétation, ouverture de la rue et occupations du sol) et celles du trafic (nombre et types de véhicules croisés, congestion et zones 30 km/h). Une fois ce cadre conceptuel construit, il reste alors à identifier les variables qui permettent dopérationnaliser chacun de concepts retenus. Figure 7.1: Exemple de cadre conceptuel Notion de variables de contrôle versus variables explicatives Dans un modèle de régression, nous distinguons habituellement trois types de variables : la variable dépendante (Y) que nous souhaitons prédire ou expliquer et les variables indépendantes (X) qui peuvent être soit des variables de contrôle (covariates en anglais), soit des variables explicatives. Les premières sont des facteurs quil faut prendre en compte (contrôler) avant dévaluer nos variables dintérêt (explicatives). Dans lexemple précédent, les chercheurs voulaient évaluer limpact des caractéristiques de lenvironnement urbain (variables explicatives) sur les expositions des cyclistes au dioxyde dazote et au bruit, et ce, une fois contrôlés les effets de facteurs reconnus comme ayant un impact significatif sur la concentration de ces polluants (conditions météorologiques et la pollution darrière-plan). Autrement dit, si les variables de contrôle navaient pas été prises en compte, létude des variables dintérêt serait biaisée par les effets de ces facteurs qui nauraient pas été contrôlés. À titre dexemple, il est possible que les zones de circulation limitées à 30 km/h soient concentrées dans les quartiers centraux et denses de Paris. Dans ces quartiers, la pollution darrière-plan a tendance à être supérieure. Si nous tenons pas compte de cette pollution darrière-plan, nous pourrions arriver à la conclusion que les zones de 30 km/h sont des milieux dans lesquels les cyclistes sont plus exposés à la pollution atmosphérique. Construction de modèles de régression imbriqués, incrémentiels En lien avec le cadre conceptuel du modèle, il est fréquent de construire plusieurs modèles emboîtés. Par exemple, à partir du cadre conceptuel (figure 7.1), les auteurs auraient très bien pu construire quatre modèles : un premier avec uniquement les variables de contrôle (modèle A); un second incluant les variables de contrôle et les variables explicatives de la dimension des caractéristiques du segment (modèle B); un troisième reprenant les variables du modèle B dans lequel sont introduites les variables explicatives relatives à la forme urbaine (modèle C); un dernier modèle dans lequel sont ajoutées les variables explicatives relatives aux conditions du trafic (modèle D). Lintérêt dune telle approche est quelle permet dévaluer successivement lapport explicatif de chacune des dimensions du modèle; nous y reviendrons dans la section 5.3. Nous disons alors que deux modèles sont imbriqués lorsque le modèle avec le plus de variables comprend également toutes les variables du modèle avec le moins de variables. References "],["sect072.html", "7.2 Principes de base de la régression linéaire multiple", " 7.2 Principes de base de la régression linéaire multiple 7.2.1 Un peu déquations La régression linéaire multiple vise à déterminer une équation qui résume le mieux les relations linéaires entre une variable dépendante (Y) et un ensemble de variables indépendantes (X). Léquation de régression sécrit alors : \\[\\begin{equation} y_i = \\beta_{0} + \\beta_{1}x_{1i} + \\beta_{2}x_{2i} +\\ldots+ \\beta_{k}x_{ki} + \\epsilon_{i} \\tag{7.1} \\end{equation}\\] avec : \\(y_i\\), la valeur de la variable dépendante Y pour lobservation i \\(\\beta_{0}\\), la constante, soit la valeur prédite pour Y quand toutes les variables indépendantes sont égales à 0 \\(k\\) le nombre de variables indépendantes \\(\\beta_{1}\\) à \\(\\beta_{k}\\), les coefficients de régression pour les variables indépendantes de 1 à k (\\(X_{1}\\) à \\(X_{k}\\)) \\(\\epsilon_{i}\\), le résidu pour lobservation de i, soit la partie de la valeur de \\(y_i\\) qui nest pas expliquée par le modèle de régression. Notez quil existe plusieurs écritures simplifiées de cette équation. Dune part, il est possible de ne pas indiquer lobservation i et de remplacer les lettres grecques bêta et epsilon (\\(\\beta\\) et \\(\\epsilon\\)) par les lettres b et e : \\[\\begin{equation} Y = b_{0} + b_{1}X_{1} + b_{2}X_{2} +\\ldots+ b_{k}X_{k} + e \\tag{7.2} \\end{equation}\\] Dautre part, cette équation peut être présentée sous forme matricielle. Rappelez-vous que, pour chacune des n observations de léchantillon, une équation est formulée : \\[\\begin{equation} \\left\\{\\begin{array}{l} y_{1}=\\beta_{0}+\\beta_{1} x_{1,1}+\\ldots+\\beta_{p} x_{1, k}+\\varepsilon_{1} \\\\ y_{2}=\\beta_{0}+\\beta_{1} x_{2,1}+\\ldots+\\beta_{p} x_{2, k}+\\varepsilon_{2} \\\\ \\cdots \\\\ y_{n}=\\beta_{0}+a_{1} x_{n, 1}+\\ldots+\\beta_{p} x_{n, k}+\\varepsilon_{n} \\end{array}\\right. \\tag{7.3} \\end{equation}\\] Par conséquent, sous forme matricielle, léquation sécrit : \\[\\begin{equation} \\left(\\begin{array}{c} y_{1} \\\\ \\vdots \\\\ y_{n} \\end{array}\\right)=\\left(\\begin{array}{cccc} 1 &amp; x_{1,1} &amp; \\cdots &amp; x_{1, k} \\\\ \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\\\ 1 &amp; x_{n, 1} &amp; \\cdots &amp; x_{n, k} \\end{array}\\right)\\left(\\begin{array}{c} \\beta_{0} \\\\ \\beta_{1} \\\\ \\vdots \\\\ \\beta_{k} \\end{array}\\right)+\\left(\\begin{array}{c} \\varepsilon_{1} \\\\ \\vdots \\\\ \\varepsilon_{n} \\end{array}\\right) \\tag{7.4} \\end{equation}\\] ou tout simplement : \\[\\begin{equation} Y = X\\beta + \\epsilon \\tag{7.5} \\end{equation}\\] avec : \\(Y\\), un vecteur de dimension \\(n \\times 1\\) pour la variable dépendante, soit une colonne avec n observations \\(X\\), une matrice de dimension \\(n \\times (k + 1)\\) pour les k variables indépendantes, incluant une autre colonne (avec la valeur de 1 pour les n observations) pour la constante doù \\(k + 1\\) \\(\\beta\\), un vecteur de dimension \\(k + 1\\), soit les coefficients de régression pour les k variables et la constante \\(\\epsilon\\), un vecteur de dimension \\(n \\times 1\\) pour les résidus. Vous aurez compris que, comme pour la régression linéaire simple (section 4.4), léquation de la régression linéaire multiple comprend aussi une partie expliquée et une autre non expliquée (stochastique) par le modèle : \\[\\begin{equation} Y = \\underbrace{\\beta_{0} + \\beta_{1}X_{i} + \\beta_{2}X_{i} +\\ldots+ \\beta_{k}X_{k}}_{\\mbox{partie expliquée par le modèle}}+ \\underbrace{\\epsilon}_{\\mbox{partie non expliquée (stochastique)}} \\tag{7.6} \\end{equation}\\] \\[\\begin{equation} Y = \\underbrace{X\\beta}_{\\mbox{partie expliquée par le modèle}}+ \\underbrace{\\epsilon}_{\\mbox{partie non expliquée (stochastique)}} \\tag{7.7} \\end{equation}\\] 7.2.2 Hypothèses de la régression linéaire multiple Un modèle est bien construit sil respecte plusieurs hypothèses liées à la régression, dont les principales étant : Hypothèse 1. La variable dépendante doit être continue et non-bornée. Quant aux variables indépendantes (VI), elles peuvent être quantitatives (discrètes ou continues) et qualitatives (nominale ou ordinale). Hypothèse 2. La variance de chaque VI doit être supérieure à 0. Autrement dit, toutes les observations ne peuvent avoir la même valeur. Hypothèse 3. Indépendance des termes derreur. Les résidus des observations (\\(\\epsilon_{1}, \\epsilon_{2}, \\ldots, \\epsilon_{n}\\)) ne doivent pas être corrélés entre eux. Autrement dit, les observations doivent être indépendantes les unes des autres, ce qui nest souvent pas le cas pour des mesures temporelles. Par exemple, lapplication du cadre conceptuel sur la modélisation de lexposition des cyclistes au bruit et à la pollution atmosphérique (figure 7.1) est basée sur des données primaires collectées lors de trajets réalisés à vélo dans une ville donnée. Par conséquent, deux observations qui se suivent ont bien plus de chances de se ressembler  du point de vue des mesures de pollution et des caractéristiques de lenvironnement urbain  que deux observations tirées au hasard dans le jeu de données. Ce problème dautocorrélation temporelle doit être contrôlé, sinon, les coefficients de régression seront biaisés. Hypothèse 4. Normalité des résidus avec une moyenne centrée sur zéro. Hypothèse 5. Absence de colinéarité parfaite entre les variables explicatives. Par exemple, dans un modèle, nous ne pouvons pas introduire à la fois les pourcentages de locataires et de propriétaires, car pour chaque observation, la somme des deux donne 100nbsp;%. Nous avons donc une corrélation parfaite entre ces deux variables : le coefficient de corrélation de Pearson entre ces deux variables est égal à 1. Par conséquent, le modèle ne peut pas être estimé avec ces deux variables et lune des deux est automatiquement ôtée. Hypothèse 6. Homoscédasticité des erreurs (ou absence dhétéroscédasticité). Les résidus doivent avoir une variance constante, cest-à-dire quelle doit être la même pour chaque observation. Il y a homoscédasticité lorsquil y a une absence de corrélation entre les résidus et les valeurs prédites. Si cette condition nest pas respectée, nous parlons alors dhétéroscédasticité. Hypothèse 7. Le modèle est bien spécifié. Un modèle est mal spécifié (construit) quand « une ou plusieurs variables non pertinentes sont incluses dans le modèle » ou « quune ou plusieurs variables pertinentes sont exclues du modèle » (Bressoux 2010, 138139). Concrètement, linclusion dune variable non pertinente ou lomission dune variable peut entraîner une mauvaise estimation des effets des variables explicatives du modèle. Pour connaître les conséquences de la violation de chacune de ces hypothèses, vous pourrez notamment consulter lexcellent ouvrage de Bressoux (2010, 103110). Retenez ici que le non-respect de ces hypothèses produit des coefficients de régression biaisés. References "],["sect073.html", "7.3 Évaluation de la qualité dajustement du modèle", " 7.3 Évaluation de la qualité dajustement du modèle Pour illustrer la régression linéaire multiple, nous utilisons un jeu de données tiré dun article portant sur la distribution spatiale de la végétation sur lîle de Montréal abordée sous langle de léquité environnementale (Apparicio, Pham et al. 2016). Dans cette étude, les auteurs veulent vérifier si certains groupes de population (personnes à faible revenu, minorités visibles, personnes âgées et enfants de moins de 15 ans) ont ou non une accessibilité plus limitée à la végétation urbaine. En dautres termes, cet article tente de répondre à la question suivante : une fois contrôlées les caractéristiques de la forme urbaine (densité de population et âge du bâti), est-ce que les quatre groupes de population résident dans des îlots urbains avec proportionnellement moins ou plus de végétation? Dans le tableau 7.1, sont reportées les variables utilisées (calculées au niveau des îlots de lîle de Montréal) introduites dans le modèle de régression : le pourcentage de la superficie de lîlot couverte par de la végétation, soit la variable indépendante (VI); deux variables indépendantes de contrôle (VC) relatives à la forme urbaine; les pourcentages des quatre groupes de population comme variables indépendantes explicatives (VE). Notez que ce jeu de données est utilisé tout au long du chapitre. Léquation de départ du premier modèle de régression est donc : VegPct ~ HABHA + AgeMedian + Pct_014 + Pct_65P + Pct_MV + Pct_FR Tableau 7.1: Statistiques descriptives pour les variables du modèle Nom Intitulé Type Moy. E.-T. Q1 Q2 Q3 VegPct Végétation (%) VD 35,1 18,6 20,3 33,8 49,0 HABHA Habitants au km2 VC 87,8 74,0 36,9 68,4 120,5 AgeMedian Âge médian des bâtiments VC 52,1 25,2 37,2 49,0 61,0 Pct_014 Moins de 15 ans (%) VE 15,9 5,3 12,5 15,9 19,3 Pct_65P 65 ans et plus (%) VE 14,9 8,3 9,6 13,9 18,2 Pct_MV Minorités visibles (%) VE 21,0 16,4 8,3 17,2 29,6 Pct_FR Personnes à faible revenu (%) VE 23,6 16,0 11,1 21,3 33,7 7.3.1 Mesures de la qualité dun modèle Comme pour la régression linéaire simple (section 4.4), les trois mesures les plus couramment utilisées pour évaluer la qualité dun modèle sont : Le coefficient de détermination (R2) qui indique la proportion de la variance de la variable dépendante expliquée par les variables indépendantes du modèle (équation (7.9)). Il varie ainsi de 0 à 1. La statistique de Fisher qui permet dévaluer la significativité globale du modèle (équation (7.10)). Dans le cas dune régression linéaire multiple, lhypothèse nulle du test F est que toutes les valeurs des coefficients de régression des variables indépendantes sont égales à 0; autrement dit, quaucune des variables indépendantes na deffet sur la variable dépendante. Tel que décrit à la section 4.4.3, il est possible dobtenir une valeur de p rattachée à la statistique F avec k degrés de liberté au dénominateur et n-k-1 degrés de liberté au numérateur (k et n étant respectivement le nombre de variables indépendantes et le nombre dobservations). Lorsque la valeur de p est inférieure à 0,05, nous pourrons en conclure que le modèle est globalement significatif, cest-à-dire quau moins un coefficient de régression est significativement différent de zéro. Notez quil est plutôt rare quun modèle de régression, comprenant plusieurs variables indépendantes, soit globalement non significatif (P &gt; 0,05), et ce, surtout sil est basé sur un cadre conceptuel et théorique solide. Le test de la statistique de Fisher est donc facile à passer et ne constitue pas une preuve absolue de la pertinence du modèle. Lerreur quadratique moyenne (RMSE) qui indique lerreur absolue moyenne du modèle exprimée dans lunité de mesure de la variable dépendante, autrement dit lécart absolu moyen entre les valeurs observées et prédites du modèle (équation (7.11)). Une valeur élevée indique que le modèle se trompe largement en moyenne et inversement. Rappel sur la décomposition de la variance et calcul du R2, de la statistique F et du RMSE Rappelez-vous que la variance totale (SCT) est égale à la somme de la variance expliquée (SCE) par le modèle et de la variance non expliquée (SCR) par le modèle. \\[\\begin{equation} \\underbrace{\\sum_{i=1}^n (y_{i}-\\bar{y})^2}_{\\mbox{variance de Y}} = \\underbrace{\\sum_{i=1}^n (\\widehat{y}_i-\\bar{y})^2}_{\\mbox{var. expliquée}} + \\underbrace{\\sum_{i=1}^n (y_{i}-\\widehat{y})^2}_{\\mbox{var. non expliquée}} \\Rightarrow SCT = SCE + SCR \\tag{7.8} \\end{equation}\\] avec : \\(y_{i}\\) est la valeur observée de la variable dépendante pour i; \\(\\bar{y}\\) est la valeur moyenne de la variable dépendante; \\(\\widehat{y}_i\\) est la valeur prédite de la variable dépendante pour i. À partir des trois variances (totale, expliquée et non expliquée), il est alors possible de calculer les trois mesures de la qualité dajustement du modèle. \\[\\begin{equation} R^2 = \\frac{\\sum_{i=1}^n (\\widehat{y}_i-\\bar{y})^2}{\\sum_{i=1}^n (y_{i}-\\bar{y})^2} = \\frac{SCE}{SCT} \\mbox{ avec } R^2 \\in \\left[0,1\\right] \\tag{7.9} \\end{equation}\\] \\[\\begin{equation} F = \\frac{\\frac{\\sum_{i=1}^n (\\widehat{y}_i-\\bar{y})^2}{k}}{\\frac{\\sum_{i=1}^n (y_{i}-\\widehat{y})^2}{n-k-1}} = \\frac{\\frac{SCE}{k}}{\\frac{SCR}{n-k-1}} = \\frac{\\frac{R^2}{k}} {\\frac{1-R^2}{n-k-1}} = \\frac{(n-k-1)R^2}{k(1-R^2)} \\tag{7.10} \\end{equation}\\] \\[\\begin{equation} RMSE = \\sqrt{\\frac{\\sum_{i=1}^n (y_{i}-\\widehat{y})^2}{n}} = \\sqrt{\\frac{SCR}{n}} \\tag{7.11} \\end{equation}\\] Globalement, plus un modèle de régression est efficace, plus les valeurs du R2 et de la statistique F sont élevées et inversement, plus celle de RMSE est faible. En effet, remarquez quà léquation (7.10), la statistique F peut être obtenue à partir du R2; par conséquent, plus la valeur du R2 est forte (proche de 1), plus celle de F est aussi élevée. Notez aussi que plus un modèle est performant, plus la partie expliquée par le modèle (SCE) est importante et plus celle non expliquée (SCR) est faible; ce qui signifie que plus le R2 est proche de 1 (équation (7.9)), plus le RMSE  calculé à partir du SCR  est faible (équation (7.11)). La syntaxe R ci-dessous illustre comment calculer les différentes variances (SCT, SCE et SCR) à partir des valeurs observées et prédites par le modèle, puis les valeurs du R2, de F et du RMSE. Nous verrons par la suite quil est possible dobtenir directement ces valeurs à partir de la fonction summary(VotreModele). # Chargement des données load(&quot;data/lm/DataVegetation.RData&quot;) # Construction du modèle de régression Modele1 &lt;- lm(VegPct ~ HABHA+AgeMedian+Pct_014+Pct_65P+Pct_MV+Pct_FR, data = DataFinal) # Nombre d&#39;observations n &lt;- nrow(DataFinal) # Nombre de variables indépendantes (coefficients moins la constante) k &lt;- length(Modele1$coefficients)-1 # Vecteur pour les valeurs observées Yobs &lt;- DataFinal$VegPct # Vecteur pour les valeurs prédites Ypredit &lt;- Modele1$fitted.values # Variance totale SCT &lt;- sum((Yobs-mean(Yobs))^2) # Variance expliquée SCE &lt;- sum((Ypredit-mean(Yobs))^2) # Variance résidelle SCR &lt;- sum((Yobs-Ypredit)^2) # Calcul du coefficient de détermination (R2) R2 &lt;- SCE / SCT # Calcul de la valeur de F valeurF &lt;- (R2 / k) /((1-R2)/(n-k-1)) cat(&quot;R2 =&quot;, round(SCE / SCT,4), &quot;\\nF de Fisher = &quot;, round(valeurF,0), &quot;\\nRMSE =&quot;, round(sqrt(SCR/ n),4) ) ## R2 = 0.4182 ## F de Fisher = 1223 ## RMSE = 14.1575 7.3.2 Comparaison des modèles incrémentiels Tel que signalé plus haut, il est fréquent de construire plusieurs modèles de régression imbriqués. Cette démarche est très utile pour évaluer lapport de lintroduction dun nouveau bloc de variables dans un modèle. De manière exploratoire, cela permet également de vérifier si lintroduction dune variable indépendante supplémentaire dans un modèle a ou non un apport significatif et ainsi de décider de la conserver, ou non, dans le modèle final selon le principe de parcimonie. Le principe de parcimonie Le principe de parcimonie appliqué aux régressions correspond à lidée quil est préférable de disposer dun modèle plus simple que dun modèle compliqué pour expliquer un phénomène si la qualité de leurs prédictions  qualité dajustement des deux modèles  est équivalente. Une première justification de ce principe trouve son origine dans la philosophie des sciences avec le rasoir dOckham. Il sagit dun principe selon lequel il est préférable de privilégier des théories faisant appel à un plus petit nombre dhypothèses. Lidée centrale étant déviter dapporter des réponses à une question qui soulèveraient davantage de nouvelles questions. Dans le cas dune régression, nous pourrions être tenté dajouter de nombreuses variables indépendantes pour améliorer la capacité de prédiction du modèle. Cette stratégie conduit généralement à observer des relations contraires à nos connaissances entre les variables du modèle, ce qui soulève de nouvelles questions de recherche (pas toujours judicieuses). Dans notre quotidien, si une casserole tombe de son support, il est plus raisonnable dimaginer que nous lavions mal fixée que démettre lhypothèse quun fantôme la volontairement fait tomber! Cette seconde hypothèse soulève dautres questions (pas toujours judicieuses) sur la nature dun fantôme, son identité, la raison le poussant à agir, etc. Une seconde justification de ce principe sobserve dans la pratique statistique : des modèles plus complexes ont souvent une plus faible capacité de généralisation. En effet, un modèle complexe et trop bien ajusté aux données observées est souvent incapable deffectuer des prédictions justes pour de nouvelles données. Ce phénomène est appelé surajustement ou surinterprétation (overfitting en anglais). Le surajustement résultant de modèles trop complexes entre en conflit direct avec lenjeu principal de linférence en statistique : pouvoir généraliser des observations faites sur un échantillon au reste dune population. Notez que ce principe de parcimonie ne signifie pas que vous devez systématiquement retirer toutes les variables non significatives de votre analyse. En effet, il peut y avoir un intérêt théorique à démontrer labsence de relation entre des variables. Il sagit plutôt dune ligne de conduite à garder à lesprit lors de lélaboration du cadre théorique et de linterprétation des résultats. Mathématiquement, plus nous ajoutons de variables supplémentaires dans un modèle, plus le R2 augmente. On ne peut donc pas utiliser directement le R2 pour comparer deux modèles de régression ne comprenant pas le même nombre de variables indépendantes. Nous privilégions alors lutilisation du R2 ajusté qui, comme illustré dans léquation (7.12), tient compte à la fois des nombres dobservations et des variables indépendantes utilisées pour construire le modèle. \\[\\begin{equation} R^2_{\\text {ajusté}}= 1 - \\frac{(1-R^2)(n-1)}{n-k-1} \\mbox{ avec } R^2_{\\text {ajusté}} \\in \\left[0,1\\right] \\tag{7.12} \\end{equation}\\] Si le R2 ajusté du second modèle est supérieur au premier modèle, cela signifie quil y a un gain de la variance expliquée entre le premier et le second modèle. Ce gain est-il pour autant significatif? Pour y répondre, il convient de comparer les valeurs des statistiques F des deux modèles. Pour ce faire, nous calculons le F incrémentiel et la valeur de p qui lui est associé avec comme degrés de liberté, le nombre de variables indépendantes ajoutées (\\(k_2-k_1\\)) et \\(n-k_2-1\\). Si la valeur de p &lt; 0,05, nous pouvons conclure que le gain de variance expliquée par le second modèle est significatif comparativement au premier modèle (au seuil de 5nbsp;%). \\[\\begin{equation} F_{\\text {incrémentiel}}= \\frac{\\frac{R^2_2-R^2_1}{k_2-k_1}} {\\frac{1-R^2_2}{n-k_2-1}} \\tag{7.13} \\end{equation}\\] avec \\(R^2_1\\) et \\(R^2_2\\) étant les coefficients de détermination des modèles 1 et 2 et \\(k_1\\) et \\(k_2\\) étant les nombres de variables indépendantes quils comprennent (\\(k_2 &gt; k_1\\)). Illustrons le tout avec deux modèles. Dans la syntaxe R ci-dessous, nous avons construit un premier modèle avec uniquement les variables de contrôle (modele1), soit deux variables indépendantes (HABHA et AgeMedian). Puis, dans un second modèle (modele2), nous ajoutons comme variables indépendantes les pourcentages des quatre groupes de population (Pct_014, Pct_65P, Pct_MV, Pct_FR). Repérez comment sont calculés les R2 ajustés pour les modèles et le F incrémentiel. Le R2 ajusté passe de 0,269 à 0,418 des modèles 1 à 2 signalant que lajout des quatre variables indépendantes augmente considérablement la variance expliquée. Autrement dit, le second modèle est bien plus performant. Le F incrémentiel sélève à 653,8 et est significatif (p &lt; 0,001). Notez que la syntaxe ci-dessous illustre comment calculer les valeurs du R2 ajusté et du F incrémentiel à partir des équations (7.12) et (7.13). Sachez toutefois quil est possible dobtenir directement le R2 ajusté avec la fonction summary(VotreModele) et le F incrémentiel avec la fonction anova(modele1, modele2). modele1 &lt;- lm(VegPct ~ HABHA+AgeMedian, data = DataFinal) modele2 &lt;- lm(VegPct ~ HABHA+AgeMedian+Pct_014+Pct_65P+Pct_MV+Pct_FR, data = DataFinal) # nombre d&#39;observations pour les deux modèles n1 &lt;- length(modele1$fitted.values) n2 &lt;- length(modele2$fitted.values) # nombre de variables indépendantes k1 &lt;- length(modele1$coefficients)-1 k2 &lt;- length(modele2$coefficients)-1 # coefficient de détermination R2m1 &lt;- summary(modele1)$r.squared R2m2 &lt;- summary(modele2)$r.squared # coefficient de détermination ajusté R2ajustm1 &lt;- 1-(((n1-1)*(1-R2m1)) / (n1-k1-1)) R2ajustm2 &lt;- 1-(((n2-1)*(1-R2m2)) / (n2-k2-1)) # Statistique F Fm1 &lt;- summary(modele1)$fstatistic[1] Fm2 &lt;- summary(modele2)$fstatistic[1] # F incrémentiel Fincrementiel &lt;- ((R2m2-R2m1) / (k2 - k1)) / ( (1-R2m2)/(n2-k2-1)) pFinc &lt;- pf(Fincrementiel, k2-k1, n2-k2-1, lower.tail = FALSE) cat(&quot;\\nR2 (modèle 1) =&quot;, round(R2m1,4), &quot;; R2 ajusté = &quot;, round(R2ajustm1,4), &quot;; F =&quot;, round(Fm1, 1), &quot;\\nR2 (modèle 2) =&quot;, round(R2m2,4), &quot;; R2 ajusté = &quot;, round(R2ajustm2,4), &quot;; F =&quot;, round(Fm2, 1), &quot;\\nF incrémentiel =&quot;, round(Fincrementiel,1), &quot;; p = &quot;, round(pFinc,3) ) ## ## R2 (modèle 1) = 0.2691 ; R2 ajusté = 0.269 ; F = 1879.2 ## R2 (modèle 2) = 0.4182 ; R2 ajusté = 0.4179 ; F = 1222.5 ## F incrémentiel = 653.8 ; p = 0 # F incrémentiel avec la fonction anova anova(modele1, modele2) ## Analysis of Variance Table ## ## Model 1: VegPct ~ HABHA + AgeMedian ## Model 2: VegPct ~ HABHA + AgeMedian + Pct_014 + Pct_65P + Pct_MV + Pct_FR ## Res.Df RSS Df Sum of Sq F Pr(&gt;F) ## 1 10207 2570964 ## 2 10203 2046427 4 524537 653.8 &lt; 2.2e-16 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 References "],["sect074.html", "7.4 Différentes mesures pour les coefficients de régression", " 7.4 Différentes mesures pour les coefficients de régression La fonction summary(nom du modèle) permet dobtenir les résultats du modèle de régression. Demblée, signalons que le modèle est globalement significatif (F(6,10203) = 1123, p = 0,000) avec un R2 de 0,4182 indiquant que les variables indépendantes du modèle expliquent 41,82nbsp;% de la variance du pourcentage de végétation dans les îlots de lîle de Montréal. modelereg &lt;- lm(VegPct ~ HABHA+AgeMedian+Pct_014+Pct_65P+Pct_MV+Pct_FR, data = DataFinal) summary(modelereg) ## ## Call: ## lm(formula = VegPct ~ HABHA + AgeMedian + Pct_014 + Pct_65P + ## Pct_MV + Pct_FR, data = DataFinal) ## ## Residuals: ## Min 1Q Median 3Q Max ## -48.876 -9.757 -0.232 9.499 103.830 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 26.355774 0.882235 29.874 &lt;2e-16 *** ## HABHA -0.070401 0.002202 -31.975 &lt;2e-16 *** ## AgeMedian 0.010790 0.006369 1.694 0.0902 . ## Pct_014 1.084478 0.032179 33.702 &lt;2e-16 *** ## Pct_65P 0.400531 0.018835 21.265 &lt;2e-16 *** ## Pct_MV -0.031112 0.010406 -2.990 0.0028 ** ## Pct_FR -0.348256 0.011640 -29.918 &lt;2e-16 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 14.16 on 10203 degrees of freedom ## Multiple R-squared: 0.4182, Adjusted R-squared: 0.4179 ## F-statistic: 1223 on 6 and 10203 DF, p-value: &lt; 2.2e-16 7.4.1 Coefficients de régression : évaluer leffet des variables indépendantes Les différents résultats pour les coefficients sont reportés au tableau 7.2. La constante (\\(\\beta_0\\)) est la valeur attendue de la variable dépendante (Y) quand les valeurs de toutes les variables indépendantes sont égales à 0. Pour ce modèle, quand les variables indépendantes sont égales à 0, plus du quart de la superficie des îlots serait en moyenne couverte par de la végétation (\\(\\beta_0\\) = 26,36). Notez que la constante na pas toujours une interprétation pratique. Il est par exemple très invraisemblable de trouver un îlot avec de la population dans lequel il ny aurait aucune personne à faible revenu, aucune personne ne déclarant appartenir à une minorité visible, aucun enfant de moins de 15 ans et aucune personne âgée 65 ans et plus. La constante a donc avant tout un rôle mathématique dans le modèle. Le coefficient de régression (\\(\\beta_1\\) à \\(\\beta_k\\)) indique le changement de la variable dépendante (Y) lorsque la variable indépendante augmente dune unité, toutes choses étant égales par ailleurs. Il permet ainsi dévaluer leffet dune augmentation dune unité dans laquelle est mesurée la VI sur la VD. Que signifie lexpression toutes choses étant égales par ailleurs pour un coefficient de régression? Après lapprentissage du grec, grâce aux nombreuses équations intégrées au livre, passons au latin! Lexpression toutes choses étant égales par ailleurs vient du latin ceteris paribus, à ne pas confondre avec cest terrible Paris en bus (petite blague formulée par un étudiant ayant suivi le cours Méthodes quantitatives appliquées en études urbaines à lINRS il y a quelques années)! Certains auteurs emploient encore ceteris paribus : il est donc possible que vous la retrouviez dans un article scientifique Plus sérieusement, lexpression toutes choses étant égales par ailleurs signifie que lon estime leffet de la variable indépendante sur la variable dépendante, si toutes les autres variables indépendantes restent constantes ou autrement dit, une fois contrôlés tous les autres prédicteurs. Tableau 7.2: Différentes mesures pour les coefficients Variable Coef. Erreur type Valeur de T P coef. 2,5 % coef. 97,5 % Constante 26,356 0,882 29,870 0,000 24,626 28,085 *** HABHA -0,070 0,002 -31,970 0,000 -0,075 -0,066 *** AgeMedian 0,011 0,006 1,690 0,090 -0,002 0,023 . Pct_014 1,084 0,032 33,700 0,000 1,021 1,148 *** Pct_65P 0,401 0,019 21,260 0,000 0,364 0,437 *** Pct_MV -0,031 0,010 -2,990 0,003 -0,052 -0,011 ** Pct_FR -0,348 0,012 -29,920 0,000 -0,371 -0,325 *** À partir des coefficients du tableau 7.2, léquation du modèle de régression sécrit alors comme suit : VegPct = 26,356  0,070 HABHA + 0,011 AgeMedian + 1,084 Pct_014 + 0,401 Pct_65P 0,031 Pct_MV  0,348 Pct_FR + e Comment interpréter un coefficient de régression pour une variable indépendante? Le signe du coefficient de régression indique si la variable indépendante est associée positivement ou négativement avec la variable dépendante. Par exemple, plus la densité de population est importante à travers les îlots de lîle de Montréal, plus la couverture végétale diminue. Quant à la valeur absolue du coefficient, elle indique la taille de leffet du prédicteur. Par exemple, 1,084 signifie que si toutes les autres variables indépendantes restent constantes, alors le pourcentage de végétation dans lîlot augmente de 1,084 points de pourcentage pour chaque différence dun point de pourcentage denfants de moins de 15 ans. Toutes choses étant égales par ailleurs, une augmentation de 10nbsp;% denfants dans un îlot entraîne alors une hausse de 10,8nbsp;% de la couverture végétale dans lîlot. Lanalyse des coefficients montre ainsi quune fois contrôlées les deux caractéristiques relatives à la forme urbaine (densité de population et âge médian des bâtiments), plus les pourcentages denfants et de personnes âgées sont élevés, plus la couverture végétale de lîlot est importante (B = 1,084 et 0,401), toutes choses étant égales par ailleurs. À linverse, de plus grands pourcentages de personnes à faible revenu et de minorités sont associés à une plus faible couverture végétale (B = 0,348 et 0,031). Lerreur type du coefficient de régression Lerreur type dun coefficient permet dévaluer son niveau de précision, soit le degré dincertitude vis-à-vis du coefficient. Succinctement, elle correspond à lécart-type de lestimation (coefficient); elle est ainsi toujours positive. Plus la valeur de lerreur type est faible, plus lestimation du coefficient est précise. Notez toutefois quil nest pas judicieux de comparer les erreurs types des coefficients pour des variables exprimées dans des unités de mesure différentes. Comme nous le verrons plus loin, lutilité principale de lerreur type est quelle permet de calculer la valeur de t et lintervalle de confiance du coefficient de régression. 7.4.2 Coefficients de régression standardisés : repérer les variables les plus importantes du modèle Un coefficient de régression est exprimé dans les unités de mesure des variables indépendante (VI) et dépendante (VD) : une augmentation dune unité de la VI a un effet de \\(\\beta\\) (valeur de coefficient) unité de mesure sur la VD, toutes choses étant égales par ailleurs. Prenons lexemple dun modèle fictif dans lequel une variable indépendante mesurée en mètres obtient un coefficient de régression de 0,000502. Si cette variable était exprimée en kilomètres et non en mètres, son coefficient serait alors de 0,502 (\\(0,000502 \\times 1000 = 0,502\\)). Cela explique que pour certaines variables, il est souvent préférable de modifier lunité de mesure, particulièrement pour les variables de distance ou de revenu. Par exemple, dans un modèle de régression, nous introduisons habituellement une variable de revenu par tranche de mille dollars ou le loyer mensuel par tranche de cent dollars, puisque les coefficients du revenu ou de loyer exprimé en dollars risquent dêtre extrêmement faibles. Concrètement, cela signifie que nous divisons la variable revenu par 1000 et celle du loyer par 100 avant de lintroduire dans le modèle. Du fait de leur unités de mesure souvent différentes, vous aurez compris que nous ne pouvons pas comparer directement les coefficients de régression afin de repérer la ou les variables indépendantes (X) qui ont les effets (impacts) les plus importants sur la variable dépendante (Y). Pour remédier à ce problème, nous utilisons les coefficients de régression standardisés. Ces coefficients standardisés sont simplement les valeurs de coefficients de régression qui seraient obtenus si toutes les variables du modèle (VD et VI) étaient préalablement centrées réduites (soit avec une moyenne égale à 0 et un écart-type égal à 1; consultez la section 2.5.5.2 pour un rappel). Puisque toutes les variables du modèle sont exprimées en écarts-types, les coefficients standardisés permettent ainsi dévaluer leffet relatif des VI sur la VD. Cela permet ainsi de repérer la ou les variables les plus « importantes » du modèle. Linterprétation dun coefficient de régression standardisé est donc la suivante : il indique le changement en termes dunités décart-type de la variable dépendante (Y) à chaque ajout dun écart-type de la variable indépendante, toutes choses étant égales par ailleurs. Le coefficient de régression standardisé peut être aussi facilement calculé en utilisant les écarts-types des deux variables VI et VD : \\[\\begin{equation} \\beta_{z}= \\beta \\frac{s_x}{s_y} \\tag{7.14} \\end{equation}\\] La syntaxe R ci-dessous illustre trois façons dobtenir les coefficients standardisés : en centrant et réduisant préalablement les variables avec la fonction scale avant de construire le modèle avec la fonction lm; en calculant les écarts-types de VD et de VI et en appliquant léquation (7.14); avec la fonction lm.beta du package QuantPsyc. Cette dernière méthode est moins « verbeuse » (deux lignes de code uniquement), mais nécessite de charger un package supplémentaire. # Modèle de régression Modele1 &lt;- lm(VegPct ~ HABHA+AgeMedian+Pct_014+Pct_65P+Pct_MV+Pct_FR, data = DataFinal) # Méthode 1 : lm sur des variables centrées réduites ModeleZ &lt;- lm(scale(VegPct) ~ scale(HABHA)+scale(AgeMedian)+ scale(Pct_014)+scale(Pct_65P)+ scale(Pct_MV)+scale(Pct_FR), data = DataFinal) coefs &lt;- ModeleZ$coefficients coefs[1:length(coefs)] ## (Intercept) scale(HABHA) scale(AgeMedian) scale(Pct_014) ## 3.721649e-16 -2.806891e-01 1.467299e-02 3.093456e-01 ## scale(Pct_65P) scale(Pct_MV) scale(Pct_FR) ## 1.788453e-01 -2.755087e-02 -3.004544e-01 # Méthode 2 : à partir de l&#39;équation # Écart-type de la variable dépendante VDet &lt;- sd(DataFinal$VegPct) cat(&quot;Écart-type de Y =&quot;, round(VDet,3)) ## Écart-type de Y = 18.562 # Écarts-types des variables indépendantes VI &lt;- c(&quot;HABHA&quot;,&quot;AgeMedian&quot;,&quot;Pct_014&quot;,&quot;Pct_65P&quot;,&quot;Pct_MV&quot;,&quot;Pct_FR&quot;) VIet &lt;- sapply(DataFinal[VI], sd) # Coefficients de régression du modèle sans la constante coefs &lt;- Modele1$coefficients[1:length(VIet)+1] # Coefficients de régression du modèle coefstand &lt;- coefs * (VIet / VDet) coefstand ## HABHA AgeMedian Pct_014 Pct_65P Pct_MV Pct_FR ## -0.28068906 0.01467299 0.30934560 0.17884535 -0.02755087 -0.30045437 # Méthode 3 : avec la fonction lm.beta du package QuantPsyc library(QuantPsyc) lm.beta(lm(VegPct ~ HABHA+AgeMedian+Pct_014+Pct_65P+Pct_MV+Pct_FR, data = DataFinal)) ## HABHA AgeMedian Pct_014 Pct_65P Pct_MV Pct_FR ## -0.28068906 0.01467299 0.30934560 0.17884535 -0.02755087 -0.30045437 Tableau 7.3: Calcul des coefficients standardisés Variable dépendante Écart-type Coef. Coef. standardisé HABHA 74,008 -0,070 -0,281 AgeMedian 25,241 0,011 0,015 Pct_014 5,295 1,084 0,309 Pct_65P 8,289 0,401 0,179 Pct_MV 16,438 -0,031 -0,028 Pct_FR 16,015 -0,348 -0,300 Par exemple, pour la variable Pct_014, le coefficient de régression standardisé est égal à : \\[\\begin{equation} \\beta_{z}= 1,084 \\times \\frac{5,295}{18,562}=0,309 \\tag{7.15} \\end{equation}\\] avec 1,084 étant le coefficient de régression de Pct_014, 5,295 et 18,562 étant respectivement les écarts-types de Pct_014 (variable indépendante) et de VegPct (variable dépendante). Au tableau 7.3, nous constatons que la valeur absolue du coefficient de régression pour HABHA est inférieure à celle de Pct_65P (0,070 versus 0,401), ce qui nest pas le cas pour leur coefficient standardisé (0,281 versus 0,179). Rappelez-vous aussi que nous ne pouvons pas directement comparer les effets de ces deux variables à partir des coefficients de régression puisquelles sont exprimées dans des unités de mesure différentes : HABHA est exprimée en habitants par hectare et Pct_65P en pourcentage. À la lecture des coefficients standardisés, nous pouvons en conclure que la variable HABHA a un effet relatif plus important que Pct_65P (0,281 versus 0,179). 7.4.3 Significativité des coefficients de régression : valeurs de t et de p Une fois les coefficients de régression obtenus, il convient de vérifier sils sont ou non significativement différents de 0. Si le coefficient de régression dune variable indépendante est significativement différent de 0, nous concluons que la variable a un effet significatif sur la variable dépendante, toutes choses étant égales par ailleurs. Pour ce faire, il suffit de calculer la valeur de t qui est simplement le coefficient de régression divisé par son erreur type. \\[\\begin{equation} t=\\frac{\\beta_k - 0}{s(\\beta_k)} \\tag{7.16} \\end{equation}\\] avec \\(s(\\beta_k)\\) étant lerreur type du coefficient de régression. Notez que dans léquation (7.16), nous indiquons habituellement \\(-0\\), pour signaler que lon veut vérifier si le coefficient est différent de 0. En guise dexemple, au tableau 7.2, la valeur de t de la variable HABHA est bien égale à : \\(\\mbox{0,070401 / 0,002202 = 31,975}\\). Démarche pour vérifier si un coefficient est significativement différent de 0 avec un seuil de confiance Poser lhypothèse nulle (H0) stipulant que le coefficient est égal à 0, soit \\(H_0 : \\beta_k = 0\\). Lhypothèse alternative (H1) est que le coefficient est différent de 0, soit \\(H_1 : B_k \\neq 0\\). Calculer la valeur de t, soit le coefficient de régression divisé par son erreur type (équation (7.16)). Calculer le nombre de degrés de liberté, soit \\(dl = n  k - 1\\), n et k étant respectivement les nombres dobservations et de variables indépendantes. Choisir un seuil de signification alpha (5 %, 1 % ou 0,1 %, soit p = 0,05, 0,01 ou 0,01). Trouver la valeur critique de t dans la table T de Student (14.3) avec p et le nombre de degrés de liberté (dl). Valider ou réfuter lhypothèse nulle (H0) : si la valeur de t est inférieure à la valeur critique de t avec dl et le seuil choisi, nous confirmons H0 : le coefficient nest pas significativement différent de 0. si la valeur de t est supérieure à la valeur critique de t avec dl et le seuil choisi, nous réfutons lhypothèse nulle, et choisissons lhypothèse alternative (H1) stipulant que le coefficient est significativement différent de 0. Valeurs critiques de la valeur de t à retenir! Lorsque le nombre de degrés de liberté (n  k - 1) est très important (supérieur à 2500), et donc le nombre dobservations de votre jeu de données, nous retenons habituellement les valeurs critiques suivantes : 1,65 (p = 0,10), 1,96 (p = 0,05), 2,58 (p = 0,01) et 3,29 (p=0,001). Concrètement, cela signifie que : une valeur de t supérieure à 1,96 ou inférieure à -1,96 nous informe que la relation entre la variable indépendante et la variable dépendante est significative positivement ou négativement au seuil de 5 %. Autrement dit, vous avez moins de 5 % de chances de vous tromper en affirmant que le coefficient de régression est bien significativement différent de 0. une valeur de t supérieure à 2,58 ou inférieure à -2,58 nous informe que la relation entre la variable indépendante et la variable dépendante est significative positivement ou négativement au seuil de 5 %. Autrement dit, vous avez moins de 1 % de chances de vous tromper en affirmant que le coefficient de régression est bien significativement différent de 0. une valeur de t supérieure à 3,29 ou inférieure à -3,29 nous informe que la relation entre la variable indépendante et la variable dépendante est significative positivement ou négativement au seuil de 5 %. Autrement dit, vous avez moins de 0,1 % de chances de vous tromper en affirmant que le coefficient de régression est bien significativement différent de 0. Concrètement, retenez et utilisez les seuils de \\(\\pm\\mbox{1,96}\\), \\(\\pm\\mbox{2,58}\\) et \\(\\pm\\mbox{3,29}\\) pour repérer les variables significatives positivement ou négativement aux seuils respectifs de 0,5, 0,1 et 0,001. Que signifient les seuils 0,10, 0,05 et 0,001? Linterprétation exacte des seuils de significativité des coefficients dune régression est quelque peu alambiquée, mais mérite de sy attarder. En effet, indiquer quun coefficient est significatif est souvent perçu comme un argument fort pour une théorie, il est donc nécessaire davoir du recul et de bien comprendre ce que lon entend par significatif. Si un coefficient est significatif au seuil de 5 % dans notre modèle, cela signifie que si, pour lensemble dune population, la valeur du coefficient est de 0 en réalité, alors nous avions moins de 5 % de chances de collecter un échantillon (pour cette population) ayant produit un coefficient aussi fort que celui que nous observons dans notre propre échantillon. Par conséquent, il serait très invraisemblable que le coefficient soit 0 puisque nous avons effectivement collecté un tel échantillon. Il sagit dune forme dargumentation par labsurde propre à la statistique fréquentiste. Notez que si 100 études étaient conduites sur le même sujet et dans les mêmes conditions, nous nous attendrions à ce que 5 dentre elles trouvent un coefficient significatif, du fait de la variation des échantillons. Ce constat souligne le fait que la recherche est un effort collectif et quune seule étude nest pas suffisante pour trancher sur un sujet. Les revues systématiques de la littérature sont donc des travaux particulièrement importants pour la construction du consensus scientifique. Ne pas confondre significativité et effet de la variable indépendante Attention, un coefficient significatif nest pas toujours intéressant! Autrement dit, bien quil soit significatif à un seuil donné (par exemple, p = 0,05), cela ne veut pas dire pour autant quil ait un effet important sur la variable dépendante. Il faut donc analyser simultanément les valeurs de p et des coefficients de régression. Afin de mieux saisir leffet dun coefficient significatif, il est intéressant de représenter graphiquement leffet marginal dune variable indépendante (VI) sur une variable dépendante (VD), une fois contrôlées les autres VI du modèle de régression (section 7.7.4). Prenons deux variables indépendantes du tableau 7.2  HABHA et AgeMedian  et vérifions si leurs coefficients de régression respectifs (0,070 et 0,011) sont significatifs. Appliquons la démarche décrite dans lencadré ci-dessus : Nous posons lhypothèse nulle stipulant que la valeur de ces deux coefficients est égale à 0, soit \\(H_0 : \\beta_k = 0\\). La valeur de t est égale à 0,070401 / 0,002202 = 31,97139 pour HABHA et à 0,010790 / 0,006369 = 1,694144 pour AgeMedian. Le nombre de degrés de liberté est égal à \\(\\mbox{dl} = \\mbox{n}-\\mbox{k}-\\mbox{1} = \\mbox{10 210}  \\mbox{6} - \\mbox{1} = \\mbox{10 203}\\). Nous choisissons respectivement les seuils \\(\\alpha\\) de 0,10, 0,05, 0,01 ou 0,001. Avec 10210 degrés de liberté, les valeurs critiques de la table T de Student (section 14.3) sont de 1,65 (p = 0,10), 1,96 (p = 0,05), 2,58 (p = 0,01), 3,29 (p = 0,001). Il reste à valider ou réfuter lhypothèse nulle (H0) : pour HABHA, la valeur absolue de t (31,975) est supérieure à la valeur critique de 3,29. Son coefficient de régression est donc significativement différent de 0. Autrement dit, ce prédicteur a un effet significatif et négatif sur la variable dépendante. pour AgeMedian, la valeur absolue de t (1,694) est supérieure à 1,65 (p = 0,10), mais inférieure à 1,96 (p = 0,05), à 2,58 (p = 0,01), à 3,29 (p = 0,001). Par conséquent, ce coefficient est différent de 0 uniquement au seuil de p = 0,10 et non au seuil de p = 0,05. Cela signifie que bous avons un peu moins de 10 % de chances de se tromper en affirmant que cette variable a un effet significatif sur la variable dépendante. Calculer et obtenir des valeurs de p dans R Il est très rare que dutiliser directement la table T de Student pour obtenir un seuil de significativité. Dune part, il est possible de calculer directement la valeur de p à partir de la valeur de t et du nombre de degrés de liberté avec la fonction pt avec les paramètres suivants : pt(q= abs(valeur de T), df= nombre de degrés de liberté, lower.tail = F) *2 # Degrés de liberté dl &lt;- nrow(DataFinal) - (length(Modele1$coefficients) - 1) + 1 # Valeurs de T ValeurT &lt;- summary(Modele1)$coefficients[,3] # Calcul des valeurs de P ValeurP &lt;- pt(q= abs(ValeurT), df= dl, lower.tail = F) *2 df_tp &lt;- data.frame( ValeurT = round(ValeurT,3), ValeurP = round(ValeurP,3) ) print(df_tp) ## ValeurT ValeurP ## (Intercept) 29.874 0.000 ## HABHA -31.975 0.000 ## AgeMedian 1.694 0.090 ## Pct_014 33.702 0.000 ## Pct_65P 21.265 0.000 ## Pct_MV -2.990 0.003 ## Pct_FR -29.918 0.000 Dautre part, la fonction summary renvoie demblée les valeurs de t et de p. Par convention, R, comme la plupart des logiciels danalyses statistiques, utilise aussi des symboles pour indiquer le seuil de signification du coefficient (voir tableau 7.3) : *** p &lt;= 0,001 ** p &lt;= 0,01 * p &lt;= 0,05 . p &lt;= 0,10 7.4.4 Intervalle de confiance des coefficients Finalement, il est possible de calculer lintervalle de confiance dun coefficient à partir dun niveau de signification (habituellement 0,95 ou encore 0,99). Pour ce faire, la fonction confint(nom du modèle, level=.95) est très utile. Lintérêt de ces intervalles de confiance pour les coefficients de régression est double : il permet de vérifier si le coefficient est ou non significatif au seuil retenu. Pour cela, la borne inférieure et la borne supérieure du coefficient doivent être toutes deux négatives ou positives. À linverse, un intervalle à cheval sur 0, soit avec une borne inférieure négative et une borne supérieure positive, nest pas significatif. il permet destimer la précision de lestimation; plus lintervalle du coefficient est réduit, plus lestimation de leffet de la variable indépendante est précise. Inversement, un intervalle large signale que le coefficient est incertain. Cela explique que de nombreux auteurs reportent les intervalles de confiance dans les articles scientifiques (habituellement à 95 %). Dans le modèle présenté ici, il est alors possible décrire : toutes choses étant égales par ailleurs, le pourcentage denfants de moins de 15 ans est positivement et significativement associé avec le pourcentage de la couverture végétale dans lîlot (B = 1,084; IC 95 % = [1,021 - 1,148], p &lt; 0,001). En guise dexemple, à la lecture de la sortie R ci-dessous, lestimation de leffet de la variable indépendante AgeMedian sur la variable VegPct se situe dans lintervalle -0,002 à 0,023 qui est à cheval sur 0. Contrairement aux autres variables, nous ne pouvons donc pas en conclure que cet effet est significatif avec p = 0,05. # Intervalle de confiance à 95 % des coefficients round(confint(Modele1, level=.95),3) ## 2.5 % 97.5 % ## (Intercept) 24.626 28.085 ## HABHA -0.075 -0.066 ## AgeMedian -0.002 0.023 ## Pct_014 1.021 1.148 ## Pct_65P 0.364 0.437 ## Pct_MV -0.052 -0.011 ## Pct_FR -0.371 -0.325 Comment est calculé un intervalle de confiance? Lintervalle du coefficient est obtenu à partir de : la valeur du coefficient (\\(\\beta_k\\)), la valeur de son erreur type \\(s(\\beta_k)\\) et la valeur critique de T (\\(t_{\\alpha/2}\\)) obtenue avec \\(n-k-1\\) degrés de liberté et le niveau de significativité retenu (95 %, 99 % ou 99,9 %). \\[\\begin{equation} IC_{\\beta_k}= \\left[ \\beta_k - t_{\\alpha/2} \\times s(\\beta_k) ; \\beta_k + t_{\\alpha/2} \\times s(\\beta_k) \\right] \\tag{7.17} \\end{equation}\\] Autrement dit, lorsque vous disposez dun nombre très important dobservations, les intervalles de confiance sécrivent simplement avec les fameuses valeurs critiques de T de 1,96, 2,58, 3,29 : \\[\\begin{equation} \\mbox{Intervalle à 95 \\%\\: } IC_{\\beta_k}= \\left[ \\beta_k - 1,96 \\times s(\\beta_k) ; \\beta_k + 1,96 \\times s(\\beta_k) \\right] \\tag{7.18} \\end{equation}\\] \\[\\begin{equation} \\mbox{Intervalle à 99 \\%\\: } IC_{\\beta_k}= \\left[ \\beta_k - 2,58 \\times s(\\beta_k) ; \\beta_k + 2,58 \\times s(\\beta_k) \\right] \\tag{7.19} \\end{equation}\\] \\[\\begin{equation} \\mbox{Intervalle à 99,9 \\%\\: } IC_{\\beta_k}= \\left[ \\beta_k - 3,29 \\times s(\\beta_k) ; \\beta_k + 3,29 \\times s(\\beta_k) \\right] \\tag{7.20} \\end{equation}\\] La syntaxe R ci-dessous illustre comment calculer les intervalles de confiance à 95 % à partir de léquation (7.17). Rappelez-vous toutefois quil est bien plus simple dutiliser la fonction confint: round(confint(Modele1, level=.95),3) round(confint(Modele1, level=.99),3) round(confint(Modele1, level=.999),3) # Coeffients de régression coefs &lt;- Modele1$coefficients # Erreur type des coef. coefs_se &lt;- summary(Modele1)$coefficients[,2] # Nombre de degrés de liberté n &lt;- length(Modele1$fitted.values) k &lt;- length(Modele1$coefficients)-1 dl &lt;- n-k-1 # valeurs critiques de T t95 &lt;- qt(p=1 - (0.05/2), df=dl) t99 &lt;- qt(p=1 - (0.01/2), df=dl) t99.9 &lt;- qt(p=1 - (0.001/2), df=dl) cat(&quot;Valeurs critiques de T en fonction du niveau de confiance&quot;, &quot;\\n et du nombre de degrés de liberté&quot;, &quot;\\n95 % : &quot;, t95, &quot;\\n99 % : &quot;, t99, &quot;\\n99,9 % : &quot;, t99.9 ) ## Valeurs critiques de T en fonction du niveau de confiance ## et du nombre de degrés de liberté ## 95 % : 1.960197 ## 99 % : 2.576311 ## 99,9 % : 3.291481 # Intervalle de confiance à 95 data.frame( IC2.5 = round(coefs-t95*coefs_se,3), IC97.5 = round(coefs+t95*coefs_se,3) ) ## IC2.5 IC97.5 ## (Intercept) 24.626 28.085 ## HABHA -0.075 -0.066 ## AgeMedian -0.002 0.023 ## Pct_014 1.021 1.148 ## Pct_65P 0.364 0.437 ## Pct_MV -0.052 -0.011 ## Pct_FR -0.371 -0.325 # Intervalle de confiance à 99 data.frame( IC0.5 = round(coefs-t99*coefs_se,3), IC99.5 = round(coefs+t99*coefs_se,3) ) ## IC0.5 IC99.5 ## (Intercept) 24.083 28.629 ## HABHA -0.076 -0.065 ## AgeMedian -0.006 0.027 ## Pct_014 1.002 1.167 ## Pct_65P 0.352 0.449 ## Pct_MV -0.058 -0.004 ## Pct_FR -0.378 -0.318 # Intervalle de confiance à 99.9 data.frame( IC0.05 = round(coefs-t99.9*coefs_se,3), IC99.95 = round(coefs+t99.9*coefs_se,3) ) ## IC0.05 IC99.95 ## (Intercept) 23.452 29.260 ## HABHA -0.078 -0.063 ## AgeMedian -0.010 0.032 ## Pct_014 0.979 1.190 ## Pct_65P 0.339 0.463 ## Pct_MV -0.065 0.003 ## Pct_FR -0.387 -0.310 "],["sect075.html", "7.5 Introduction de variables explicatives particulières", " 7.5 Introduction de variables explicatives particulières 7.5.1 Exploration des relations non linéaires 7.5.1.1 Variable indépendante avec une fonction polynomiale Dans la section 4.1, nous avons vu que la relation entre deux variables continues nest pas toujours linéaire; elle peut être aussi curvilinéaire. Pour explorer les relations curvilinéaires, nous introduisons la variable indépendante sous la forme polynomiale dordre 2 (voir le prochain encadré). Léquation de régression sécrit alors : \\[\\begin{equation} Y = b_{0} + b_{1}X_{1} + b_{11}X_{1}^2 + b_{2}X_{2} +\\ldots+ b_{k}X_{k} + e \\tag{7.21} \\end{equation}\\] Dans léquation (7.21), la première variable indépendante est introduite dans le modèle de régression à la fois dans sa forme originelle et mise au carré : \\(b_{1}X_{1} + b_{11}X_{1}^2\\). Un coefficient différent est ajusté pour chacune de ces deux versions de la variable \\(X_{1}\\). La démographie est probablement la discipline des sciences sociales qui a le plus recours aux régressions polynomiales. En effet, la variable âge est souvent introduite comme variable explicative dans sa forme originale et mise au carré. Lobjectif est de vérifier si lâge partage ou non une relation curvilinéaire avec un phénomène donné : par exemple, il pourrait y être associé positivement jusquà un certain seuil (45 ans par exemple), puis négativement à partir de ce seuil. Régression polynomiale et nombre dordres. Sachez quil est aussi possible de construire des régressions polynomiales avec plus deux ordres. Par exemple, une régression polynomiale dordre 3 comprend une variable dans sa forme originelle, puis mise au carré et au cube. Cela a linconvénient daugmenter corollairement le nombre de coefficients. Nous verrons au chapitre 11 quil existe une solution plus élégante et efficace : le recours aux modèles de régressions linéaires généralisés additifs avec des splines. Dans le cadre de cette section, nous nous limitons à des régressions polynomiales dordre 2. \\[\\begin{equation} \\mbox{Ordre 2 : } Y = b_{0} + b_{1}X_{1} + b_{11}X_{}^2 + b_{2}X_{2} +\\ldots+ b_{k}X_{k} + e \\tag{7.22} \\end{equation}\\] \\[\\begin{equation} \\mbox{Ordre 3 : } Y = b_{0} + b_{1}X_{1} + b_{11}X_{}^2 + b_{111}X_{}^3 + b_{2}X_{2} +\\ldots+ b_{k}X_{k} + e \\tag{7.23} \\end{equation}\\] \\[\\begin{equation} \\mbox{Ordre 4 : } Y = b_{0} + b_{1}X_{1} + b_{11}X_{}^2 + b_{111}X_{}^3 + b_{1111}X_{}^4 + b_{2}X_{2} +\\ldots+ b_{k}X_{k} + e \\tag{7.24} \\end{equation}\\] Pour construire une régression polynomiale dans R, il est possible dutiliser deux fonctions de R : I(VI^2) avec VI qui est la variable indépendante sur laquelle est appliquée la mise au carré. poly(VI,2) qui utilise une forme polynomiale orthogonale pour éviter les problèmes de corrélation entre les deux termes, cest-à-dire entre VI et VI2. Ces deux méthodes produisent les mêmes résultats pour les autres variables dépendantes et pour la qualité dajustement du modèle (R2, F, etc.). Nous privilégions la seconde fonction pour éviter de détecter à tort des problèmes de multicolinéarité excessive. Appliquons cette démarche à la variable AgeMedian (âge médian des bâtiments) afin de vérifier si elle partage ou non une relation curvilinéaire avec la couverture végétale de lîlot. À la lecture des résultats pour les deux modèles, les constats suivants peuvent être avancés : Le R2 ajusté passe de 0,4179 à 0,4378 du modèle 1 au modèle 2, ce qui signale un gain de variance expliquée. Le F incrémentiel entre les deux modèles sélève à 362,64 et est significatif (p &lt; 0,001). Nous pouvons donc en conclure que le second modèle est plus performant que le premier, ce qui signale que la forme curvilinéaire pour AgeMedian (modèle 2) est plus efficace que la forme linéaire (modèle 1). Dans le premier modèle, le coefficient de régression pour AgeMedian nest pas significatif. Lâge médian des bâtiments nest donc pas associé linéairement avec la variable dépendante. Dans le second modèle, la valeur du coefficient de poly(AgeMedian, 2)1 est positive et celle de poly(AgeMedian, 2)2 est négative et significative. Cela indique quil existe une relation linéaire en forme de U inversé. Si le premier coefficient avait été négatif et le second positif, nous aurions alors conclu que la forme curvilinéaire prend la forme dun U. # régression linéaire modele1 &lt;- lm(VegPct ~ HABHA+AgeMedian+Pct_014+Pct_65P+Pct_MV+Pct_FR, data = DataFinal) # régression polynomiale modele2 &lt;- lm(VegPct ~ HABHA+poly(AgeMedian,2)+Pct_014+Pct_65P+Pct_MV+Pct_FR, data = DataFinal) # affichage des résultats du modèle 1 summary(modele1) ## ## Call: ## lm(formula = VegPct ~ HABHA + AgeMedian + Pct_014 + Pct_65P + ## Pct_MV + Pct_FR, data = DataFinal) ## ## Residuals: ## Min 1Q Median 3Q Max ## -48.876 -9.757 -0.232 9.499 103.830 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 26.355774 0.882235 29.874 &lt;2e-16 *** ## HABHA -0.070401 0.002202 -31.975 &lt;2e-16 *** ## AgeMedian 0.010790 0.006369 1.694 0.0902 . ## Pct_014 1.084478 0.032179 33.702 &lt;2e-16 *** ## Pct_65P 0.400531 0.018835 21.265 &lt;2e-16 *** ## Pct_MV -0.031112 0.010406 -2.990 0.0028 ** ## Pct_FR -0.348256 0.011640 -29.918 &lt;2e-16 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 14.16 on 10203 degrees of freedom ## Multiple R-squared: 0.4182, Adjusted R-squared: 0.4179 ## F-statistic: 1223 on 6 and 10203 DF, p-value: &lt; 2.2e-16 # affichage des résultats du modèle 1 summary(modele2) ## ## Call: ## lm(formula = VegPct ~ HABHA + poly(AgeMedian, 2) + Pct_014 + ## Pct_65P + Pct_MV + Pct_FR, data = DataFinal) ## ## Residuals: ## Min 1Q Median 3Q Max ## -49.659 -9.361 -0.159 9.034 105.160 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 2.968e+01 7.535e-01 39.383 &lt; 2e-16 *** ## HABHA -7.107e-02 2.164e-03 -32.839 &lt; 2e-16 *** ## poly(AgeMedian, 2)1 1.134e+01 1.598e+01 0.710 0.47788 ## poly(AgeMedian, 2)2 -2.721e+02 1.429e+01 -19.043 &lt; 2e-16 *** ## Pct_014 9.969e-01 3.196e-02 31.198 &lt; 2e-16 *** ## Pct_65P 3.219e-01 1.896e-02 16.972 &lt; 2e-16 *** ## Pct_MV -2.888e-02 1.023e-02 -2.823 0.00476 ** ## Pct_FR -3.562e-01 1.145e-02 -31.116 &lt; 2e-16 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 13.92 on 10202 degrees of freedom ## Multiple R-squared: 0.4382, Adjusted R-squared: 0.4378 ## F-statistic: 1137 on 7 and 10202 DF, p-value: &lt; 2.2e-16 # test de Fisher pour comparer les modèles anova(modele1, modele2) ## Analysis of Variance Table ## ## Model 1: VegPct ~ HABHA + AgeMedian + Pct_014 + Pct_65P + Pct_MV + Pct_FR ## Model 2: VegPct ~ HABHA + poly(AgeMedian, 2) + Pct_014 + Pct_65P + Pct_MV + ## Pct_FR ## Res.Df RSS Df Sum of Sq F Pr(&gt;F) ## 1 10203 2046427 ## 2 10202 1976182 1 70245 362.64 &lt; 2.2e-16 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 Construction dun graphique des effets marginaux Pour visualiser la relation linéaire et curvilinéaire, nous vous proposons de réaliser un graphique des effets marginaux à partir de la syntaxe ci-dessous. Les graphiques des effets marginaux permettent de visualiser limpact dune variable indépendante sur la variable dépendante dune régression. Nous nous basons pour cela sur les prédictions effectuées par le modèle. Admettons que nous nous intéressons à leffet de la variable X1 sur la variable Y. Il est possible de créer de nouvelles données fictives pour lesquelles lensemble des autres variables X sont fixées à leur moyenne respective, et seule X1 est autorisée à varier. En utilisant léquation de régression du modèle sur ces données fictives, nous pouvons observer lévolution de la valeur prédite de Y quand X1 augmente ou diminue, et ce, toutes choses étant égales par ailleurs (puisque toutes les autres variables ont une valeur fixe). Cette approche est particulièrement intéressante pour décrire des effets non linéaires obtenus avec des polynomiales, mais aussi des interactions comme nous le verrons plus tard. Elle est également utilisée dans les modèles linéaires généralisés (GLM) et additifs (GAM) (chapitres 8 et 11). Notez quil est aussi important de représenter, sur ce type de graphique, lincertitude de la prédiction. Pour cela, il est possible de construire des intervalles de confiance à 95 % autour de la prédiction en utilisant lerreur standard de la prédiction (renvoyée par la fonction predict). library(ggplot2) # Statistique sur la variable AgeMedian qui varie de 0 à 226 ans summary(DataFinal$AgeMedian) ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 0.00 37.25 49.00 52.11 61.00 226.00 # Création d&#39;un DataFrame temporaire # remarquez que les autres variables indépendantes sont constantes : # nous leur avons attribué leur moyenne correspondante df &lt;- data.frame( HABHA = mean(DataFinal$HABHA), AgeMedian= seq(0,200, by = 2), AgeMedian2 = seq(0,200, by = 2)**2, Pct_014= mean(DataFinal$Pct_014), Pct_65P= mean(DataFinal$Pct_65P), Pct_MV= mean(DataFinal$Pct_MV), Pct_FR= mean(DataFinal$Pct_FR) ) # calcul de la valeur de t pour un intervalle à 95 % n &lt;- length(modele1$fitted.values) k &lt;- length(modele1$coefficients)-1 t95 &lt;- qt(p=1 - (0.05/2), df=n-k-1) # Calcul des valeurs prédites pour le 1er modèle # avec l&#39;intervalle de confiance à 95 % predsM1 &lt;- predict(modele1,se = T, newdata = df) df$predM1 &lt;- predsM1$fit df$lowerM1 &lt;- predsM1$fit - t95*predsM1$se.fit df$upperM1 &lt;- predsM1$fit + t95*predsM1$se.fit # Calcul des valeurs prédites pour le 2e modèle # avec l&#39;intervalle de confiance à 95 % predsM2 &lt;- predict(modele2,se = T, newdata = df) df$predM2 &lt;- predsM2$fit df$lowerM2 &lt;- predsM2$fit - t95*predsM2$se.fit df$upperM2 &lt;- predsM2$fit + t95*predsM2$se.fit # Graphique ggplot(data = df) + geom_ribbon(aes(x = AgeMedian, ymin = lowerM1, ymax = upperM1), fill = rgb(0.1,0.1,0.1,0.4)) + geom_path(aes(x = AgeMedian, y = predM1), color = &#39;blue&#39;, size = 1)+ geom_ribbon(aes(x = AgeMedian, ymin = lowerM2, ymax = upperM2), fill = rgb(0.1,0.1,0.1,0.4)) + geom_path(aes(x = AgeMedian, y = predM2), color = &#39;red&#39;, size = 1)+ labs(title=&quot;Effet marginal de l&#39;âge médian des bâtiments sur la&quot;, subtitle = &quot;couverture végétale des îlots de l&#39;île de Montréal&quot;, caption = &quot;bleu : relation linéaire; rouge : curvilinéaire&quot;, x = &quot;Âge médian des bâtiments&quot;, y = &quot;Couverture végétale (%)&quot;) Figure 7.2: Relations linéaire et curvilinéaire La figure 7.2 démontre bien que la relation linéaire nest pas significative : la pente est extrêmement faible, ce qui signale que leffet de lâge médian est presque nul (B = 0,0108, p = 0,0902). En revanche, la relation curvilinéaire est plus intéressante : la couverture végétale croît quand lâge médian des bâtiments dans lîlot augmente de 0 à 60 ans environ, puis elle décroît. 7.5.1.2 Variable indépendante sous forme logarithmique Une autre manière dexplorer une relation non linéaire est dintégrer la variable sous forme logarithmique (Hanck et al. 2019, 212218). Linterprétation du coefficient de régression est alors plus complexe : un 1 % daugmentation de la variable \\(X_k\\) entraîne un changement de \\(\\mbox{0,01} \\times \\beta_k\\) de la variable dépendante. Autrement dit, il nest plus exprimé dans les unités de mesure originales des deux variables. Au tableau 7.4, le coefficient de -6,855 pour la variable logHABHA sinterprète alors comme suit : un changement de 1 % de la variable densité de population entraîne une diminution de \\(\\mbox{0,01} \\times -\\mbox{6,855 =} -\\mbox{0,07}\\) de la couverture végétale dans lîle, toutes choses étant égales par ailleurs. Tableau 7.4: Modèle avec une variable indépendante sous forme logarithmique Variable Coef. Erreur type Valeur de T P coef. 2,5 % coef. 97,5 % Constante 52,831 1,001 52,780 0,000 50,868 54,793 *** logHABHA -6,855 0,168 -40,730 0,000 -7,185 -6,525 *** AgeMedian ordre 1 11,985 15,586 0,770 0,442 -18,568 42,537 AgeMedian ordre 2 -286,144 13,942 -20,520 0,000 -313,473 -258,816 *** Pct_014 0,941 0,031 30,090 0,000 0,879 1,002 *** Pct_65P 0,306 0,019 16,550 0,000 0,270 0,343 *** Pct_MV -0,036 0,010 -3,650 0,000 -0,056 -0,017 *** Pct_FR -0,344 0,011 -31,210 0,000 -0,366 -0,323 *** Puisque linterprétation du coefficient de régression de \\(log(\\beta_k)\\) est plus complexe, il convient de sassurer que son apport au modèle est justifié, et ce, de deux façons : Comparez les mesures dajustement des deux modèles (surtout les R2 ajustés). Si le R2 ajusté du modèle avec \\(log(\\beta_k)\\) est plus élevé que celui avec \\(\\beta_k\\), alors la transformation logarithmique fait de votre variable indépendante un meilleur prédicteur, toutes choses étant égales par ailleurs. Construisez les graphiques des effets marginaux de votre variable afin de vérifier si la relation quelle partage avec votre VD est plutôt logarithmique que linéaire (figure 7.3). Notez que cette approche graphique peut aussi ne donner aucune indication lorsque vos données sont très dispersées ou que la relation est faible entre votre variable dépendante et indépendante. library(ggpubr) library(ggplot2) library(ggeffects) # Modèles modele1a &lt;- lm(VegPct ~ HABHA+poly(AgeMedian,2)+ Pct_014+Pct_65P+Pct_MV+Pct_FR, data = DataFinal) modele1b &lt;- lm(VegPct ~ log(HABHA)+poly(AgeMedian,2)+ Pct_014+Pct_65P+Pct_MV+Pct_FR, data = DataFinal) # Valeurs prédites fit1a &lt;- ggpredict(modele1a, terms = &quot;HABHA&quot;) fit1b &lt;- ggpredict(modele1b, terms = &quot;HABHA&quot;) # Graphiques G1a &lt;- ggplot(fit1a, aes(x, predicted)) + geom_point(data = DataFinal, mapping = aes(x=HABHA, y = VegPct), size = 0.2, color = rgb(0.1,0.1,0.1,0.4)) + geom_ribbon(aes(ymin = conf.low, ymax = conf.high), alpha = .3, fill =&quot;red&quot;)+ geom_line(color = &quot;red&quot;) + labs(title=&quot;Variable non transformée&quot;, y=&quot;VD: valeur prédite&quot;, x = &quot;Habitants km2&quot;) + ylim(0,100) + xlim(0,600) G1b &lt;- ggplot(fit1b, aes(x, predicted)) + geom_point(data = DataFinal, mapping = aes(x=HABHA, y = VegPct), size = 0.2, color = rgb(0.1,0.1,0.1,0.4)) + geom_ribbon(aes(ymin = conf.low, ymax = conf.high), alpha = .3, fill =&quot;red&quot;)+ geom_line(color = &quot;red&quot;) + labs(title=&quot;Variable transformée (log)&quot;, y=&quot;VD: valeur prédite&quot;, x = &quot;Habitants km2&quot;) G1aG1b &lt;- ggarrange(G1a, G1b, nrow = 1) G1aG1b Figure 7.3: Effet marginal de la densité de population 7.5.2 Variable indépendante qualitative dichotomique Il est très fréquent dintroduire une variable qualitative dichotomique comme variable explicative ou de contrôle dans un modèle. À titre de rappel, une variable dichotomique comprend deux modalités (section 2.1.2). Dans le modèle ci-dessous, nous voulons vérifier si un îlot situé sur le territoire de la ville de Montréal a proportionnellement moins de végétation quun îlot situé dans une autre municipalité de lîle de Montréal, toutes choses étant égales par ailleurs. Pour ce faire, nous créons une variable binaire dénommée VilleMtl qui prend la valeur de 1 pour les îlots de la ville de Montréal et 0 pour ceux dune autre municipalité. Nous obtenons ainsi un coefficient de régression pour VilleMtl de -7,699 (tableau 7.5). Cela signifie que si toutes les autres variables indépendantes du modèle étaient constantes, alors un îlot de la ville de Montréal aurait en moyenne une valeur de -7,7 % de moins de végétation comparativement à un îlot situé dans une autre municipalité. # Création d&#39;une variable muette pour Montréal (0 ou 1) DataFinal$VilleMtl &lt;- ifelse(DataFinal$SDRNOM == &quot;Montréal&quot;, 1, 0) # Modèle avec la variable dichtonomique modele3 &lt;- lm(VegPct ~ VilleMtl+log(HABHA)+poly(AgeMedian,2)+ Pct_014+Pct_65P+Pct_MV+Pct_FR, data = DataFinal) Tableau 7.5: Modèle avec une variable dichotomique Variable Coef. Erreur type Valeur de T P coef. 2,5 % coef. 97,5 % Constante 57,676 1,009 57,140 0,000 55,697 59,654 *** VilleMtl -7,699 0,377 -20,430 0,000 -8,438 -6,960 *** log(HABHA) -6,174 0,168 -36,680 0,000 -6,504 -5,844 *** AgeMedian ordre 1 -14,871 15,334 -0,970 0,332 -44,929 15,186 AgeMedian ordre 2 -280,251 13,668 -20,500 0,000 -307,044 -253,459 *** Pct_014 0,794 0,031 25,230 0,000 0,732 0,856 *** Pct_65P 0,270 0,018 14,810 0,000 0,234 0,306 *** Pct_MV -0,028 0,010 -2,890 0,004 -0,047 -0,009 ** Pct_FR -0,294 0,011 -26,550 0,000 -0,316 -0,273 *** Bien interpréter un coefficient dune variable dichotomique Nous avons vu que le coefficient de régression (\\(\\beta_k\\)) indique le changement de la variable dépendante (Y), lorsque la variable indépendante augmente dune unité, toutes choses étant égales par ailleurs. Pour une variable dichotomique, le coefficient indique le changement de Y quand les observations appartiennent à la modalité qui a la valeur de 1 (ici la ville de Montréal), comparativement à celle qui a la valeur de 0 (autres municipalités de lîle de Montréal), toutes choses étant égales par ailleurs. La modalité qui a la valeur de 0 est alors appelée modalité ou catégorie de référence. Autrement dit, si la variable avait été codée : 0 pour la ville de Montréal et 1 pour les autres municipalités, alors le coefficient aurait été de 7,699. Pour éviter doublier quelle est la modalité de référence (valeur de 0), nous verrons plus tard (dans la section mise en uvre des modèles de régression dans R (section 7.7) quil peut être préférable de définir un facteur avec la fonction as.factor et dindiquer la catégorie de référence avec la fonction relevel(x, ref). Comme pour une variable indépendante introduite avec une fonction polynomiale, il peut être très intéressant dillustrer leffet marginal de la variable dichotomique avec un graphique qui montre lécart entre les moyennes des deux modalités, une fois contrôlées les autres variables indépendantes (figure 7.4). Notez que dans ce graphique, les barres derreurs situées au sommet des rectangles représentent les intervalles à 95 % des prédictions du modèle. Figure 7.4: Effet marginal dune variable dichotomique 7.5.3 Variable indépendante qualitative polytomique Il est possible dintroduire une variable qualitative polytomique comme variable explicative ou de contrôle dans un modèle. À titre de rappel, une variable polytomique comprend plus de deux modalités, quelle soit nominale ou ordinale (section 2.1.2). En guise dexemple, une variable qualitative pourrait être : différents groupes de population (groupes dâge, minorités visibles, catégories socioprofessionnelles, etc.), différents territoires ou régions (ville centrale, première couronne, deuxième couronne, etc.), une variable continue transformée en quatre ou cinq catégories ordinales selon les quartiles ou les quintiles. 7.5.3.1 Comment construire un modèle de régression avec une variable explicative qualitative polytomique? Prenons lexemple dun modèle de régression comprenant deux variables indépendantes : lune continue (X1), lautre qualitative (X2) avec quatre modalités (A, B, C et D). Lintroduction de la variable qualitative dans le modèle revient à : Transformer chaque modalité en variable muette (binaire). Nous avons ainsi quatre nouvelles variables binaires : X2A, X2B, X2C et X2D. Par exemple, pour X2A, les observations de la modalité A se verront affecter la valeur de 1 versus 0 pour les autres observations. La même démarche sapplique à X2B, X2C et X2D (voir tableau 7.6). Tableau 7.6: Transformation dune variable qualitative en variables muettes pour chaque modalité obs Y X1 X2 X2A X2B X2C X2D 1 55,20 11,92 A 1 0 0 0 2 48,48 23,55 A 1 0 0 0 3 37,67 16,37 A 1 0 0 0 4 61,83 23,20 B 0 1 0 0 5 46,23 13,85 B 0 1 0 0 6 51,25 13,89 B 0 1 0 0 7 46,80 21,86 C 0 0 1 0 8 36,69 24,75 C 0 0 1 0 9 40,63 18,51 D 0 0 0 1 10 59,00 17,90 D 0 0 0 1 Toutes les modalités transformées en variables muettes sont introduites dans le modèle comme variables indépendantes sauf celle servant de catégorie de référence. Pourquoi sauf une? Si nous mettions toutes les modalités en variable muette, alors chaque observation serait repérée par une valeur de 1, « il y aurait alors une parfaite multicolinéarité et aucune solution unique pour les coefficients de régression ne pourrait être trouvée » (Bressoux 2010, 128). Par exemple, si nous choisissons la modalité A comme catégorie de référence, léquation de régression sécrit alors : \\[\\begin{equation} Y = b_{0} + b_{1}X_{1} + b_{2B}X_{2B} + b_{2C}X_{2C} + b_{2D}X_{2D}+ e \\tag{7.25} \\end{equation}\\] Vous aurez compris que choisir la modalité D comme catégorie de référence revient à écrire léquation suivante : \\[\\begin{equation} Y = b_{0} + b_{1}X_{1} + b_{2A}X_{2A} + b_{2B}X_{2B} + b_{2C}X_{2C} + e \\tag{7.26} \\end{equation}\\] 7.5.3.2 Comment interpréter les coefficients des modalités dune variable explicative qualitative polytomique Les coefficients des différentes modalités sinterprètent en fonction de la catégorie de référence. Dans lexemple ci-dessous, nous avons inclus la ville de Montréal comme catégorie de référence (tableau 7.7). Toutes choses étant égales par ailleurs, nous pouvons alors constater que : en moyenne, les îlots résidentiels de Senneville et de Baie-DUrfé ont respectivement 23,235 % et 21,400 % plus de végétation que ceux de la ville de Montréal. la seule municipalité comprenant en moyenne moins de végétation dans ses îlots résidentiels est Montréal-Est (-13,334 %) nous remarquons aussi que les îlots des municipalités de Sainte-Anne-de-Bellevue, de Montréal-Ouest et de Côte-Saint-Luc ne présentent pas significativement moins ou plus de végétation que ceux de la ville de Montréal (leurs valeurs de p sont supérieures à 0,05). Par conséquent, les valeurs de t et de p pour une modalité permettent de vérifier si elle est ou non significativement différente de la catégorie de référence. Tableau 7.7: Modèle avec une variable polytomique (ville de Montréal en catégorie de référence) Variable Coef. Erreur type Valeur de T P Constante 48,193 0,992 48,580 0,000 *** log(HABHA) -5,836 0,168 -34,840 0,000 *** AgeMedian ordre 1 -11,807 15,648 -0,750 0,451 AgeMedian ordre 2 -266,469 13,613 -19,570 0,000 *** Pct_014 0,794 0,032 25,190 0,000 *** Pct_65P 0,277 0,018 15,130 0,000 *** Pct_MV -0,036 0,010 -3,740 0,000 *** Pct_FR -0,279 0,011 -25,340 0,000 *** Municipalité ref : Montréal      Baie-DUrfé 21,400 1,635 13,090 0,000 *** Beaconsfield 14,112 0,893 15,810 0,000 *** Côte-Saint-Luc 0,172 1,035 0,170 0,868 Dollard-Des Ormeaux 7,960 0,748 10,640 0,000 *** Dorval 11,157 0,971 11,490 0,000 *** Hampstead 3,080 1,599 1,930 0,054 . Kirkland 6,937 1,014 6,840 0,000 *** Mont-Royal 12,699 0,894 14,210 0,000 *** Montréal-Est -13,334 1,920 -6,940 0,000 *** Montréal-Ouest 3,306 1,819 1,820 0,069 . Pointe-Claire 9,896 0,866 11,430 0,000 *** Sainte-Anne-de-Bellevue 0,342 1,904 0,180 0,858 Senneville 23,235 3,793 6,130 0,000 *** Westmount 2,255 1,088 2,070 0,038 Utilisons maintenant comme référence la municipalité qui avait le coefficient le plus fort dans le modèle précédent, soit Senneville (tableau 7.8). Bien entendu, les coefficients des variables continues et de la constante ne changent pas. Par contre, les coefficients de toutes les municipalités sont négatifs puisque la municipalité de Senneville est celle qui a proportionnellement le plus de végétation dans ses îlots, toutes choses étant égales par ailleurs. Tableau 7.8: Modèle avec une variable polytomique (Senneville en catégorie de référence) Variable Coef. Erreur type Valeur de T P Constante 71,429 3,846 18,570 0,000 *** log(HABHA) -5,836 0,168 -34,840 0,000 *** AgeMedian ordre 1 -11,807 15,648 -0,750 0,451 AgeMedian ordre 2 -266,469 13,613 -19,570 0,000 *** Pct_014 0,794 0,032 25,190 0,000 *** Pct_65P 0,277 0,018 15,130 0,000 *** Pct_MV -0,036 0,010 -3,740 0,000 *** Pct_FR -0,279 0,011 -25,340 0,000 *** Municipalité ref : Senneville      Baie-DUrfé -1,835 4,093 -0,450 0,654 Beaconsfield -9,123 3,866 -2,360 0,018 Côte-Saint-Luc -23,064 3,918 -5,890 0,000 *** Dollard-Des Ormeaux -15,275 3,852 -3,970 0,000 *** Dorval -12,078 3,891 -3,100 0,002 ** Hampstead -20,156 4,094 -4,920 0,000 *** Kirkland -16,298 3,911 -4,170 0,000 *** Mont-Royal -10,537 3,875 -2,720 0,007 ** Montréal -23,235 3,793 -6,130 0,000 *** Montréal-Est -36,570 4,231 -8,640 0,000 *** Montréal-Ouest -19,930 4,187 -4,760 0,000 *** Pointe-Claire -13,339 3,865 -3,450 0,001 *** Sainte-Anne-de-Bellevue -22,893 4,225 -5,420 0,000 *** Westmount -20,980 3,927 -5,340 0,000 *** À linverse, si nous utilisons Montréal-Est comme modalité de référence, soit la municipalité avec le coefficient le plus faible dans le premier modèle, tous les coefficients deviendront positifs (tableau 7.9). Tableau 7.9: Modèle avec une variable polytomique (Montréal-Est en catégorie de référence) Variable Coef. Erreur type Valeur de T P Constante 34,859 2,109 16,530 0,000 *** log(HABHA) -5,836 0,168 -34,840 0,000 *** AgeMedian ordre 1 -11,807 15,648 -0,750 0,451 AgeMedian ordre 2 -266,469 13,613 -19,570 0,000 *** Pct_014 0,794 0,032 25,190 0,000 *** Pct_65P 0,277 0,018 15,130 0,000 *** Pct_MV -0,036 0,010 -3,740 0,000 *** Pct_FR -0,279 0,011 -25,340 0,000 *** Municipalité ref : Montréal-Est      Baie-DUrfé 34,735 2,495 13,920 0,000 *** Beaconsfield 27,446 2,091 13,130 0,000 *** Côte-Saint-Luc 13,506 2,167 6,230 0,000 *** Dollard-Des Ormeaux 21,294 2,053 10,370 0,000 *** Dorval 24,491 2,134 11,480 0,000 *** Hampstead 16,414 2,478 6,620 0,000 *** Kirkland 20,272 2,159 9,390 0,000 *** Mont-Royal 26,033 2,101 12,390 0,000 *** Montréal 13,334 1,920 6,940 0,000 *** Montréal-Ouest 16,640 2,628 6,330 0,000 *** Pointe-Claire 23,230 2,087 11,130 0,000 *** Sainte-Anne-de-Bellevue 13,676 2,687 5,090 0,000 *** Senneville 36,570 4,231 8,640 0,000 *** Westmount 15,590 2,196 7,100 0,000 *** Comment choisir la catégorie de référence? Plusieurs options sont possibles. Vous pouvez retenir : la modalité comprenant le plus dobservations; la modalité avec la plus forte valeur pour la variable dépendante; la modalité avec la plus faible valeur pour la variable dépendante; la modalité qui fait le plus de sens avec votre cadre théorique. Prenons lexemple dune variable qualitative comprenant plusieurs groupes dâge (15-29 ans, 30-39 ans, 40-49 ans, 50-54 ans, 65 ans et plus). Si votre étude porte sur les jeunes et que vous souhaitez comparer leur situation comparativement aux autres groupes dâge, toutes choses étant égales par ailleurs, sélectionnez bien évidemment la modalité des 15 à 29 ans comme catégorie de référence. Mais surtout, évitez de choisir une catégorie comprenant très peu dobservations. 7.5.3.3 Effet marginal dune variable explicative qualitative polytomique Comme pour une variable dichotomique, il est possible dillustrer leffet marginal de la variable qualitative dichotomique avec un graphique. Quelle que soit la catégorie de référence choisie, le graphique est le même. La figure 7.5 illustre ainsi la valeur moyenne, avec son intervalle de confiance à 95 %, de la végétation dans les îlots résidentiels de chacune des municipalités de la région de Montréal, ceteris paribus. Figure 7.5: Effet marginal dune variable polytomique 7.5.4 Variables dinteraction 7.5.4.1 Variable dinteraction entre deux variables continues Une interaction entre deux variables indépendantes continues consiste à simplement les multiplier (\\(X_1 \\times X_2\\)). Le modèle sécrit alors : \\[\\begin{equation} Y = \\beta_{0} + \\beta_{1}X_{1} + \\beta_{2}X_{2} + \\beta_{3}(X_{1}\\times X_{2}) +\\ldots+ \\beta_{k}X_{k} + e\\tag{7.27} \\end{equation}\\] Un nouveau coefficient (\\(\\beta_{3}\\)) sajoute pour linteraction (la multiplication) entre les deux variables continues. Pourquoi ajouter une interaction entre deux variables? Lobjectif est dévaluer leffet dune augmentation de \\(\\beta_{1}\\) en fonction dun niveau donné de \\(\\beta_{2}\\) et inversement. Cela permet ainsi de répondre à la question suivante : leffet de la variable \\(\\beta_{1}\\) est-il influencé par la variable \\(\\beta_{2}\\) et inversement? Prenons un exemple concret pour illustrer le tout. Premièrement, nous ajoutons DistCBDkm comme VI, soit la distance au centre-ville exprimée en kilomètres. Notez que pour ne pas surspécifier le modèle, les variables dichotomique VilleMtl ou polytomique Municipalité ont été préalablement ôtées. Le coefficient (B = 0,659, p &lt; 0,001) signale que plus nous nous éloignons du centre-ville, plus la couverture végétale des îlots augmente significativement. En guise dexemple, toutes choses étant égales par ailleurs, un îlot situé à dix kilomètres du centre-ville aura en moyenne 6,59 % plus de végétation (tableau 7.10). Tableau 7.10: Modèle avec la distance au centre-ville (km) Variable Coef. Erreur type Valeur de T P Constante 41,061 1,085 37,830 0,000 *** log(HABHA) -5,555 0,172 -32,300 0,000 *** AgeMedian ordre 1 176,921 16,582 10,670 0,000 *** AgeMedian ordre 2 -298,735 13,560 -22,030 0,000 *** Pct_014 0,763 0,031 24,440 0,000 *** Pct_65P 0,321 0,018 17,860 0,000 *** Pct_MV -0,018 0,010 -1,880 0,060 . Pct_FR -0,288 0,011 -26,260 0,000 *** DistCBDkm 0,659 0,027 24,460 0,000 *** Dans ce modèle (tableau 7.10), les pourcentages denfants de moins de 15 ans et de 65 ans et plus (Pct_014 et Pct_65P) sont associés positivement à la variable dépendante tandis que le pourcentage de personnes à faible revenu (Pct_FR) est associé négativement. Que se passe-t-il si nous introduisons une variable dinteraction entre DistCBDkm et Pct_FR (tableau 7.11)? Leffet du pourcentage de personnes à faible revenu (%) est significatif et négatif lorsquil est mis en interaction avec la distance au centre-ville. Cela indique que plus lîlot est éloigné du centre-ville, plus Pct_FR a un effet négatif sur la couverture végétale (B = 0,011, p &lt; 0,001). Tableau 7.11: Modèle avec une variable dinteraction entre deux VI continues Variable Coef. Erreur type Valeur de T P Constante 38,382 1,137 33,760 0,000 *** log(HABHA) -5,505 0,172 -32,080 0,000 *** AgeMedian ordre 1 160,523 16,672 9,630 0,000 *** AgeMedian ordre 2 -310,666 13,610 -22,830 0,000 *** Pct_014 0,786 0,031 25,130 0,000 *** Pct_65P 0,345 0,018 18,960 0,000 *** Pct_MV -0,018 0,010 -1,820 0,069 . Pct_FR -0,191 0,017 -11,500 0,000 *** DistCBDkm 0,821 0,034 24,060 0,000 *** DistCBDkmX_Pct_FR -0,011 0,001 -7,700 0,000 *** À nouveau, il est possible de représenter leffet de cette interaction à laide dun graphique des effets marginaux. Notez cependant que nous devons représenter leffet simultané de deux variables indépendantes sur notre variable dépendante, ce quil est possible de faire avec une carte de chaleur. La figure 7.6 représente donc leffet moyen de linteraction sur la prédiction dans le premier panneau, ainsi que lintervalle de confiance à 95 % de la prédiction dans les deuxième et troisième panneaux. Nous constatons ainsi que le modèle prédit des valeurs de végétation les plus faibles lorsque le pourcentage de personnes à faible revenu est élevé et que la distance au centre-ville est élevée (en haut à droite à la figure 7.6). En revanche, les valeurs les plus élevées de végétation sont atteintes lorsque la distance au centre-ville est élevée et que le pourcentage de personnes à faible revenu est faible (en bas à droite). Il semble donc que léloignement au centre-ville soit associé avec une augmentation de la densité végétale, mais que cette augmentation puisse être mitigée par laugmentation parallèle du pourcentage de personnes à faible revenu. Figure 7.6: Effet marginal de linteraction entre deux variables continues Notez que dans la figure 7.6, la relation entre les deux variables indépendantes et la variable dépendante apparaît non linéaire du fait de linteraction. À titre de comparaison, si nous utilisons les prédictions du modèle 5 (sans interaction), nous obtenons les prédictions présentées à la figure 7.7. Vous pouvez constater sur cette figure sans interaction que les deux effets des variables indépendantes sont linéaires puisque toutes les lignes sont parallèles. Figure 7.7: Effets marginaux de deux variables continues en cas dabsence dinteraction 7.5.4.2 Variable dinteraction entre une variable continue et une variable dichotomique Une interaction entre une VI continue et une VI dichotomique consiste aussi à les multiplier (\\(X_1 \\times D_2\\)); le modèle sécrit alors : \\[\\begin{equation} Y = \\beta_{0} + \\beta_{1}X_{1} + \\beta_{2}D_{2} + \\beta_{3}(X_{1}\\times D_{2}) +\\ldots+ \\beta_{k}X_{k} + e\\tag{7.28} \\end{equation}\\] Pour interpréter le coefficient \\(B_3\\), il convient alors de bien connaître le nom de la modalité ayant la valeur de 1 (0 étant la modalité de référence). Dans le modèle présenté au tableau 7.12, nous avons multiplié la variable dichotomique ville de Montréal (VilleMtl) avec le pourcentage de personnes à faible revenu (Pct_FR). Les résultats de ce modèle démontrent que, toutes choses étant égales par ailleurs : à chaque augmentation dune unité du pourcentage à faible revenu (Pct_FR), le pourcentage de la couverture végétale diminue significativement de 0,444; comparativement à un îlot situé dans une autre municipalité de lîle de Montréal, un îlot de la ville de Montréal a en moyenne 9,804 de couverture végétale; à chaque augmentation dune unité de Pct_FR pour un îlot de la Ville Montréal, la couverture végétale augmente de 0,166 comparativement à une autre municipalité de lîle. En dautres termes, le Pct_FR sur le territoire de la ville de Montréal est associé à une diminution de la couverture végétale moins forte que les autres municipalités, comme illustré à la figure 7.8 (pentes en rouge et en bleu). Tableau 7.12: Modèle avec les variables dinteraction entre une VI continue et une VI dichotomique Variable Coef. Erreur type Valeur de T P Constante 59,275 1,053 56,300 0,000 *** log(HABHA) -6,160 0,168 -36,640 0,000 *** AgeMedian ordre 1 -20,719 15,354 -1,350 0,177 AgeMedian ordre 2 -278,141 13,656 -20,370 0,000 *** Pct_014 0,789 0,031 25,100 0,000 *** Pct_65P 0,278 0,018 15,200 0,000 *** Pct_MV -0,030 0,010 -3,030 0,002 ** Pct_FR -0,444 0,030 -14,550 0,000 *** VilleMtl -9,804 0,549 -17,850 0,000 *** VilleMtlX_Pct_FR 0,166 0,032 5,260 0,000 *** Linteraction entre une variable qualitative et une variable quantitative peut être représentée par un graphique des effets marginaux. La pente (coefficient) de la variable quantitative varie en fonction des deux catégories de la variable qualitative dichotomique. Figure 7.8: Graphique de leffet marginal de linteraction entre une variable quantitative et qualitative 7.5.4.3 Variable dinteraction entre deux variables dichotomiques Variable dinteraction entre deux variables dichotomiques Nous avons vu quil est possible dintroduire une variable dinteraction entre deux variables continues ou entre une variable continue et une autre dichotomique. Sachez quil est aussi possible dintroduire une interaction entre deux variables dichotomiques. Sur le sujet, vous pouvez consulter la section 8.3 de lexcellent ouvrage de Hanck et al. (2019). References "],["sect076.html", "7.6 Diagnostics de la régression", " 7.6 Diagnostics de la régression Pour illustrer comment vérifier si le modèle respecte ou non les hypothèses de la régression, nous utilisons le modèle suivant : modele3 &lt;- lm(VegPct ~ log(HABHA)+poly(AgeMedian,2)+Pct_014+Pct_65P+Pct_MV+Pct_FR, data = DataFinal) 7.6.1 Nombre dobservations Tous les auteurs ne sentendent pas sur le nombre dobservations minimal que devrait comprendre une régression linéaire multiple, tant sen faut! Parallèlement, dautres auteurs proposent aussi des méthodes de simulation pour estimer les coefficients de régression sur un jeu de données comprenant peu dobservations. Bien quaucune règle ne soit bien établie, la question du nombre dobservations mérite dêtre posée puisquun modèle basé sur trop peu dobservations risque de produire des coefficients de régression peu fiables. Par faible fiabilité des coefficients, nous entendons que la suppression dune ou de plusieurs observations pourrait drastiquement changer leffet et/ou la significativité dune ou de plusieurs variables explicatives. Dans un ouvrage classique intitulé Using Multivariate Statistics, Barbara Tabachnick et Linda Fidell (2007, 123124) proposent deux règles de pouce (à la louche) : \\(n \\geq 50 + 8k\\) avec \\(n\\) et \\(k\\) étant respectivement les nombres dobservations et de variables indépendantes, pour tester le coefficient de corrélation multiple (R2). \\(n \\geq 104 + k\\) pour tester individuellement chaque variable indépendante. Dans le modèle, nous avons 10 210 observations et variables indépendantes. Les deux conditions sont donc largement respectées. 7.6.2 Normalité des résidus Pour vérifier si les résidus sont normalement distribués, trois démarches largement décrites dans la section 2.5.4 peuvent être utilisées : le calcul des coefficients dasymétrie et daplatissement; les tests de normalité, particulièrement celui de Jarque-Bera basé sur un test multiplicateur de Lagrange; les graphiques (histogramme avec courbe normale et diagramme quantile-quantile) (figure 7.9). Les deux premières démarches étant parfois très restrictives, nous accordons habituellement une attention particulière aux graphiques. Pour notre modèle, les coefficients dasymétrie (0,263) et daplatissement (1,149) signalent que la distribution est plutôt symétrique, mais leptokurtique, cest-à-dire que les valeurs des résidus sont bien réparties autour de 0, mais avec une faible dispersion. Puisque la valeur de p associée au test de Jarque-Bera est inférieure à 0,05, nous pouvons en conclure que la distribution des résidus est anormale. La forme pointue de la distribution est dailleurs confirmée à la lecture de lhistogramme avec la courbe normale et du diagramme quantile-quantile. ## Skewness Kurtosis ## -0.161 1.193 ## ## Robust Jarque Bera Test ## ## data: residus ## X-squared = 513.15, df = 2, p-value &lt; 2.2e-16 Figure 7.9: Vérification de la normalité des résidus 7.6.3 Linéarité et homoscédasticité des résidus Un modèle est efficace si la dispersion des résidus est homogène sur tout le spectre des valeurs prédites de la variable dépendante. Dans le cas dune absence dhomoscédasticité  appelée problème dhétéroscédasticité , le nuage de points construit à partir des résidus et des valeurs prédites (figure 7.10) prend la forme dune trompette ou dun entonnoir : les résidus sont alors faibles quand les valeurs prédites sont faibles et sont de plus en plus élevés au fur et à mesure que les valeurs prédites augmentent. Figure 7.10: Distribution des résidus en fonction des valeurs prédites Le test de Breusch-Pagan est souvent utilisé pour vérifier lhomoscédasticité des résidus. Il est construit avec les hypothèses suivantes : H0 : homoscédasticité, cest-à-dire que les termes derreur ont une variance constante à travers les valeurs prédites. H1 : hétéroscédasticité. Si la valeur de p associée à ce test est inférieure à 0,05, nous réfutons lhypothèse nulle et nous concluons quil y a un problème dhétéroscédasticité, ce qui est le cas pour notre modèle. ## ## studentized Breusch-Pagan test ## ## data: modele3 ## BP = 1722, df = 8, p-value &lt; 2.2e-16 7.6.4 Absence de multicolinéarité excessive Un modèle présente un problème de multicolinéarité excessive lorsque deux variables indépendantes ou plus sont très fortement corrélées entre elles. Rappelez-vous quun coefficient de régression estime leffet dune variable dépendante (\\(X_k\\)) si toutes les autres VI restent constantes (cest-à-dire une fois les autres VI contrôlées, toutes choses étant égales par ailleurs). Prenons deux variables indépendantes (\\(X_1\\) et \\(X_2\\)) fortement corrélées avec un coefficient de Pearson très élevé (0,90 par exemple). Admettons que chacune des deux VI a un effet important et significatif sur votre VD lorsquune seule est introduite dans le modèle. Si les deux variables sont introduites dans le même modèle, vous évaluez donc leffet de \\(X_1\\) une fois contrôlé \\(X_2\\) et leffet de \\(X_2\\) une fois contrôlé \\(X_1\\). Par conséquent, leffet de lune des deux devient très faible, voire probablement non significatif. 7.6.4.1 Comment évaluer la multicolinéarité? Pour ce faire, nous utilisons habituellement le facteur dinflation de la variance (Variance Inflation Factor  VIF en anglais). Le calcul de ce facteur pour chaque VI est basé sur trois étapes. Pour chaque VI, nous construisons un modèle de régression multiple où elle est expliquée par toutes les autres variables indépendantes du modèle. Par exemple, pour la première VI (\\(X_1\\)), léquation du modèle sécrit : \\[\\begin{equation} X_1 = b_0 + b_2X_2 +\\ldots+ b_kX_k + e \\tag{7.29} \\end{equation}\\] À partir de cette équation, nous obtenons ainsi un \\(R^2\\) qui nous indique la proportion de la variance de \\(X_1\\) expliquée par les autres VI. Par convention, nous calculons la tolérance (équation (7.30)) qui indique la proportion de la variance de \\(X_k\\) nétant pas expliquée par les autres VI. En guise dexemple, une valeur de tolérance égale à 0,1 signale que 90nbsp;% de la variance de \\(X_k\\) est expliqué par les autres variables, ce qui est un problème de multicolinéarité en soit. Concrètement, plus la valeur de la tolérance est proche de zéro, plus cest problématique. \\[\\begin{equation} \\mbox{Tolérance}_k=1-R_k^2=\\frac{1}{VIF_k} \\tag{7.30} \\end{equation}\\] Puis, nous calculons le facteur dinflation de la variance (équation (7.31)). Là encore, des règles de pouce (à la louche) sont utilisées. Certains considéreront une valeur de VIF supérieur à 10 (soit une tolérance à 0,1 ou inférieure) comme problématique, dautres retiendront le seuil de 5 plus conservateur (soit une tolérance à 0,2 ou inférieure). \\[\\begin{equation} VIF_k = \\frac{1}{1-R_k^2} \\tag{7.31} \\end{equation}\\] Pour notre modèle, toutes les valeurs de VIF sont inférieures à 2, indiquant, sans lombre dun doute, labsence de multicolinéarité excessive. ## GVIF Df GVIF^(1/(2*Df)) ## VilleMtl 1.319 1 1.149 ## log(HABHA) 1.342 1 1.159 ## poly(AgeMedian, 2) 1.399 2 1.087 ## Pct_014 1.601 1 1.265 ## Pct_65P 1.317 1 1.147 ## Pct_MV 1.483 1 1.218 ## Pct_FR 1.818 1 1.348 7.6.4.2 Comment régler un problème de multicolinéarité? La prudence est de mise! Si une ou plusieurs variables présentent une valeur de VIF supérieure à 5, construisez une matrice de corrélation de Pearson (section 4.3.7) et repérez les valeurs de corrélation supérieures à 0,8 ou inférieures à 0,8. Vous repérerez ainsi les corrélations problématiques entre deux variables indépendantes du modèle. Refaites ensuite un modèle en ôtant la variable indépendante avec la plus forte valeur de VIF (7 ou 12 par exemple), et revérifiez les valeurs de VIF. Refaites cette étape si le problème de multicolinéarité excessive persiste. Une multicolinéarité excessive nest pas forcément inquiétante Nous avons vu plus haut comment introduire des variables indépendantes particulières comme des variables dinteraction (\\(X_1 \\times X_2\\)) ou des variables sous une forme polynomiale (ordre 2 : \\(X_1 + X_1^2\\); ordre 3 : \\(X_1 + X_1^2 + X_1^3\\), etc.). Bien entendu, ces termes composant les variables dinteraction ou dune forme polynomiale sont habituellement fortement corrélés entre eux. Cela nest toutefois pas problématique! Dans lexemple ci-dessous, nous obtenons deux valeurs de VIF très élevées pour la variable dinteraction Pct_014:DistCBDkm (16,713) et lun des paramètres à partir duquel elle est calculée, soit DistCBDkm (12,526). ## GVIF Df GVIF^(1/(2*Df)) ## log(HABHA) 1.426 1 1.194 ## poly(AgeMedian, 2) 1.768 2 1.153 ## Pct_014 3.326 1 1.824 ## Pct_65P 1.359 1 1.166 ## Pct_MV 1.495 1 1.223 ## Pct_FR 1.810 1 1.345 ## DistCBDkm 12.526 1 3.539 ## Pct_014:DistCBDkm 16.713 1 4.088 7.6.5 Absence dobservations aberrantes 7.6.5.1 Détection des observations très influentes du modèle Lors de lanalyse des corrélations (section 4.3), nous avons vu que des valeurs extrêmes peuvent avoir un impact important sur le coefficient de corrélation de Pearson. Le même principe sapplique à la régression multiple, pour laquelle nous nous sattendrions à ce que chaque observation joue un rôle équivalent dans la détermination de léquation du modèle. Autrement dit, il est possible que certaines observations avec des valeurs extrêmes  fortement dissemblables des autres  aient une influence importante, voire démesurée, dans lestimation du modèle. Concrètement, cela signifie que si elles étaient ôtées, les coefficients de régression et la qualité dajustement du modèle pourraient changer drastiquement. Deux mesures sont habituellement utilisées pour évaluer linfluence de chaque observation sur le modèle : La statistique de la distance de Cook qui mesure linfluence de chaque observation sur les résultats du modèle. Brièvement, la distance de Cook évalue linfluence de lobservation i en la supprimant du modèle (équation (7.32)). Plus sa valeur est élevée, plus lobservation joue un rôle important dans la détermination de léquation de régression. \\[\\begin{equation} D_i = \\frac{\\sum_{j=1}^n(\\widehat{y}_i-\\widehat{y}_{i(j)})^2}{ks^2} \\tag{7.32} \\end{equation}\\] avec \\(\\widehat{y}_{i(j)}\\) la valeur prédite quand lobservation i est ôté du modèle, k le nombre de variables indépendantes et \\(s^2\\) lerreur quadratique moyenne du modèle. La statistique de leffet levier (leverage value en anglais) qui varie de 0 (aucune influence) à 1 (explique tout le modèle). La somme de toutes les valeurs de cette statistique est égale au nombre de VI dans le modèle. Quel critère retenir pour détecter les observations avec potentiellement une trop grande influence sur le modèle? Pour les repérer, voire les supprimer, plusieurs auteur(e)s proposent les seuils suivants : \\(4/n\\) ou \\(8/n\\) ou \\(16/n\\). Avec 10210 observations dans le modèle, les seuils seraient les suivants : ## Nombre d&#39;observations = 10210 (100 %) ## 4/n = 0.00039 ## 8/n = 0.00078 ## 16/n = 0.00157 ## Observations avec une valeur supérieure ou égale aux différents seuils ## 4/n = 605 soit 5.93 % ## 8/n = 275 soit 2.69 % ## 16/n = 133 soit 1.3 % Le critère de \\(4/n\\) étant plutôt sévère, nous privilégions généralement celui de \\(8/n\\), voire \\(16/n\\). Il est aussi possible de construire un nuage de points pour les repérer (figure 7.11). Figure 7.11: Repérage graphique les valeurs influentes du modèle 7.6.5.2 Quoi faire avec les observations très influentes du modèle Trois approches sont possibles : Recourir à des régressions boostrap, ce qui permet généralement de supprimer leffet de ces observations. Brièvement, le principe général est de créer un nombre élevé déchantillons du jeu de données initial (1000 à 2000 itérations par exemple) et de construire un modèle de régression pour chacun deux. On obtiendra ainsi des intervalles de confiance pour les coefficients de régression et les mesures dajustement du modèle. Supprimer les observations trop influentes (avec lun des critères de \\(4/n\\), \\(8/n\\) et \\(16/n\\) vus plus haut). Une fois supprimées, il convient 1) de recalculer le modèle, 2) de refaire le diagnostic de la régression au complet et finalement, 3) de comparer les modèles avant et après suppression des valeurs trop influentes, notamment la qualité dajustement du modèle (R2 ajusté) et les coefficients de régression. Des changements importants indiqueront que le premier modèle est potentiellement biaisé. Utiliser un modèle linéaire généralisé (GLM) permettant dutiliser une distribution différente correspondant plus à votre jeu de données (chapitre 8). References "],["sect077.html", "7.7 Mise en uvre dans R", " 7.7 Mise en uvre dans R 7.7.1 Fonctions lm, summary() et confint() Les fonctions de base lm, summary() et confint() permettent respectivement 1) de construire un modèle, 2) dafficher ces résultats et 3) dobtenir les intervalles de confiance des coefficients de régression : monModele &lt;- lm(Y ~X1+X2+..+Xk) avec Y étant la variable dépendante et les variables indépendantes (X1 à Xk) étant séparées par le signe +. summary(monModele) confint(monModele, level=.95). Dans la syntaxe ci-dessous, vous retrouverez les différents modèles abordés dans les sections précédentes; remarquez que toutes que les lignes summary sont mises en commentaires afin de ne pas afficher les résultats des modèles. # Chargement des données load(&quot;data/lm/DataVegetation.RData&quot;) # 1er modèle de régression modele1 &lt;- lm(VegPct ~ HABHA+AgeMedian+Pct_014+Pct_65P+Pct_MV+Pct_FR, data = DataFinal) # summary(Modele1) # 2e modèle de régression : fonction polynomiale d&#39;ordre 2 (poly(AgeMedian,2)) modele2 &lt;- lm(VegPct ~ HABHA+poly(AgeMedian,2)+Pct_014+Pct_65P+Pct_MV+Pct_FR, data = DataFinal) # summary(Modele2) # 3e modèle de régression : forme logarithmique (log(HABHA)) modele3 &lt;- lm(VegPct ~ log(HABHA)+poly(AgeMedian,2)+Pct_014+Pct_65P+Pct_MV+Pct_FR, data = DataFinal) # summary(Modele3) # 4e modèle de régression : VI dichotomique # création de la variable dichotomique (VilleMtl) DataFinal$VilleMtl &lt;- ifelse(DataFinal$SDRNOM == &quot;Montréal&quot;, 1, 0) modele4 &lt;- lm(VegPct ~ log(HABHA)+poly(AgeMedian,2)+Pct_014+Pct_65P+Pct_MV+Pct_FR+ VilleMtl, # variable dichotomique data = DataFinal) # summary(Modele4) # 5e modèle de régression : VI polytomique # création de la variable polytomique (Munic) DataFinal$Munic &lt;- relevel(DataFinal$SDRNOM, ref=&quot;Montréal&quot;) modele5 &lt;- lm(VegPct ~ log(HABHA)+poly(AgeMedian,2)+Pct_014+Pct_65P+Pct_MV+Pct_FR+ Munic, data = DataFinal) # summary(Modele5) # 6e modèle de régression : interaction entre deux VI continues, # soit DistCBDkm*Pct_014 modele6 &lt;- lm(VegPct ~ log(HABHA)+poly(AgeMedian,2)+Pct_014+Pct_65P+Pct_MV+Pct_FR+ DistCBDkm+DistCBDkm*Pct_014, data = DataFinal) # summary(Modele6) # 7e modèle de régression : interaction entre une VI continue et une VI dichotomique, # soit VilleMtl*Pct_FR modele8 &lt;- lm(VegPct ~ log(HABHA)+poly(AgeMedian,2)+Pct_014+Pct_65P+Pct_MV+Pct_FR+ VilleMtl*Pct_FR, data = DataFinal) # summary(Modele7) À la figure 7.12, les résultats de la régression linéaire multiple, obtenus avec la summary(monModele), sont présentés en quatre sections distinctes : Le rappel de léquation du modèle. Quelques statistiques descriptives sur les résidus du modèle, soit la différence entre les valeurs observées et prédites. Un tableau pour les coefficients de régression comprenant plusieurs colonnes, à savoir les coefficients de régression (Estimate), lerreur type du coefficient (Std. Error), la valeur de t (t value) et la probabilité associée à la valeur de t (Pr(&gt;|t|)). La première ligne de ce tableau (Estimate) est pour la constante (Intercept en anglais) et celles qui suivent sont pour les variables indépendantes. Les mesures dajustement du modèle, dont le RMSE (Residual standard error), les R2 classique (Multiple R-squared) et ajusté (Adjusted R-squared), la statistique F avec le nombre de degrés de liberté en lignes (nombre dobservations) et en colonnes (n-k-1) ainsi que la valeur de p qui est lui associée (F-statistic: 1223 on 6 and 10203 DF, p-value: &lt; 2.2e-16). Figure 7.12: Différentes parties obtenues avec la fonction summary(Modèle) # Intervalle de confiance des coefficients à 95 % confint(modele3) ## 2.5 % 97.5 % ## (Intercept) 50.8684505 54.79255157 ## log(HABHA) -7.1847527 -6.52495353 ## poly(AgeMedian, 2)1 -18.5676034 42.53686203 ## poly(AgeMedian, 2)2 -313.4726002 -258.81630119 ## Pct_014 0.8793672 1.00190861 ## Pct_65P 0.2699504 0.34250907 ## Pct_MV -0.0557951 -0.01681481 ## Pct_FR -0.3659445 -0.32269562 7.7.2 Comparaison des modèles Tel que détaillé à la section 7.3.2, pour comparer des modèles imbriqués, il convient danalyser les valeurs du R2 ajusté et du F incrémentiel, ce qui peut être fait en trois étapes. Première étape. Il peut être judicieux dafficher léquation des différents modèles afin de se remémorer les VI introduites dans chacun deux, et ce, avec la fonction MonModèle$call$formula. # Rappel des équations des huit modèles print(modele1$call$formula) ## VegPct ~ HABHA + AgeMedian + Pct_014 + Pct_65P + Pct_MV + Pct_FR print(modele2$call$formula) ## VegPct ~ HABHA + poly(AgeMedian, 2) + Pct_014 + Pct_65P + Pct_MV + ## Pct_FR print(modele3$call$formula) ## VegPct ~ log(HABHA) + poly(AgeMedian, 2) + Pct_014 + Pct_65P + ## Pct_MV + Pct_FR print(modele4$call$formula) ## VegPct ~ log(HABHA) + poly(AgeMedian, 2) + Pct_014 + Pct_65P + ## Pct_MV + Pct_FR + VilleMtl print(modele5$call$formula) ## VegPct ~ log(HABHA) + poly(AgeMedian, 2) + Pct_014 + Pct_65P + ## Pct_MV + Pct_FR + Munic print(modele6$call$formula) ## VegPct ~ log(HABHA) + poly(AgeMedian, 2) + Pct_014 + Pct_65P + ## Pct_MV + Pct_FR + DistCBDkm + DistCBDkm * Pct_014 print(modele7$call$formula) ## VegPct ~ log(HABHA) + poly(AgeMedian, 2) + Pct_014 + Pct_65P + ## Pct_MV + Pct_FR + VilleMtl + VilleMtlX_Pct_FR Deuxième étape. La syntaxe ci-dessous vous permet de comparer les R2 ajustés des différents modèles. Nous constatons ainsi que : La valeur du R2 ajusté du modèle 2 est supérieure à celle du modèle 1 (0,4378 versus 0,4179), signalant que la forme polynomiale dordre 2 pour lâge médian des bâtiments (poly(AgeMedian, 2)) améliore la prédiction comparativement à la forme originelle de (AgeMedian). La valeur du R2 ajusté du modèle 3 est supérieure à celle du modèle 2 (0,4653 versus 0,4378), signalant que la forme logarithmique pour la densité de population (log(HABHA)) améliore la prédiction comparativement à la forme originelle (HABHA). La valeur du R2 ajusté du modèle 4 est supérieure à celle du modèle 3 (0,4863 versus 0,4653), signalant que lintroduction de la variable dichotomique (VilleMtl) pour la municipalité apporte un gain de variance expliquée non négligeable. La valeur du R2 ajusté du modèle 5 est supérieure à celle du modèle 4 (0,5064 versus 0,4863), signalant que lintroduction de la variable polytomique pour les municipalités de lîle de Montréal (Muni) améliore la prédiction du modèle comparativement à la variable dichotomique (VilleMtl). La valeur du R2 ajusté du modèle 6 est supérieure à celle du modèle 2 (0,4953 versus 0,4378), signalant que lintroduction dune variable dinteraction entre deux variables continues (DistCBDkm + DistCBDkm * Pct_014) apporte également un gain substantiel comparativement au modèle 2, ne comprenant pas cette variable dinteraction. La valeur du R2 ajusté du modèle 7 est supérieure à celle du modèle 2 (0,4877 versus 0,4378), signalant que lintroduction dune variable dinteraction entre une variable continue et la variable dichotomique (DistCBDkm + DistCBDkm * Pct_014) apporte également un gain substantiel comparativement au modèle 2, ne comprenant pas cette variable dinteraction. cat(&quot;\\nComparaison des R2 ajustés :&quot;, &quot;\\nModèle 1.&quot;, round(summary(modele1)$adj.r.squared,4), &quot;\\nModèle 2.&quot;, round(summary(modele2)$adj.r.squared,4), &quot;\\nModèle 3.&quot;, round(summary(modele3)$adj.r.squared,4), &quot;\\nModèle 4.&quot;, round(summary(modele4)$adj.r.squared,4), &quot;\\nModèle 5.&quot;, round(summary(modele5)$adj.r.squared,4), &quot;\\nModèle 6.&quot;, round(summary(modele6)$adj.r.squared,4), &quot;\\nModèle 7.&quot;, round(summary(modele7)$adj.r.squared,4) ) ## ## Comparaison des R2 ajustés : ## Modèle 1. 0.4179 ## Modèle 2. 0.4378 ## Modèle 3. 0.4653 ## Modèle 4. 0.4863 ## Modèle 5. 0.5064 ## Modèle 6. 0.4953 ## Modèle 7. 0.4877 Troisième étape. La syntaxe ci-dessous permet dobtenir le F incrémentiel pour des modèles ne comprenant pas le même nombre de variables dépendantes, et ce, en utilisant la fonction anova(modele1, modele2, ..., modelen). Par exemple, la syntaxe anova(modele1, modele2) permet de comparer les deux modèles et signale que le gain de variance expliquée entre les deux modèles (R2 de 0,4179 et de 0,4378) est significatif (F incrémentiel = 362,64; p &lt; 0,001). # Comparaison des deux modèles uniquement (modèles 1 et 2) anova(modele1, modele2) ## Analysis of Variance Table ## ## Model 1: VegPct ~ HABHA + AgeMedian + Pct_014 + Pct_65P + Pct_MV + Pct_FR ## Model 2: VegPct ~ HABHA + poly(AgeMedian, 2) + Pct_014 + Pct_65P + Pct_MV + ## Pct_FR ## Res.Df RSS Df Sum of Sq F Pr(&gt;F) ## 1 10203 2046427 ## 2 10202 1976182 1 70245 362.64 &lt; 2.2e-16 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 Il est aussi possible de comparer plusieurs modèles simultanément. Notez que dans la syntaxe ci-dessous, le troisième modèle nest pas inclus, car il comprend le même nombre de variables indépendantes que le second modèle; il en va de même pour le sixième modèle comparativement au cinquième. Ici aussi, lanalyse des valeurs de F et de p vous permettent de vérifier si les modèles, et donc leurs R2 ajustés, sont significativement différents (quand p &lt; 0,05). # Comparaison de plusieurs modèles anova(modele1, modele2, modele4, modele5, modele7) ## Analysis of Variance Table ## ## Model 1: VegPct ~ HABHA + AgeMedian + Pct_014 + Pct_65P + Pct_MV + Pct_FR ## Model 2: VegPct ~ HABHA + poly(AgeMedian, 2) + Pct_014 + Pct_65P + Pct_MV + ## Pct_FR ## Model 3: VegPct ~ log(HABHA) + poly(AgeMedian, 2) + Pct_014 + Pct_65P + ## Pct_MV + Pct_FR + VilleMtl ## Model 4: VegPct ~ log(HABHA) + poly(AgeMedian, 2) + Pct_014 + Pct_65P + ## Pct_MV + Pct_FR + Munic ## Model 5: VegPct ~ log(HABHA) + poly(AgeMedian, 2) + Pct_014 + Pct_65P + ## Pct_MV + Pct_FR + VilleMtl + VilleMtlX_Pct_FR ## Res.Df RSS Df Sum of Sq F Pr(&gt;F) ## 1 10203 2046427 ## 2 10202 1976182 1 70245 412.995 &lt; 2.2e-16 *** ## 3 10201 1805547 1 170636 1003.224 &lt; 2.2e-16 *** ## 4 10188 1732849 13 72698 32.878 &lt; 2.2e-16 *** ## 5 10200 1800664 -12 -67815 33.226 &lt; 2.2e-16 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 Quel modèle choisir? Nous avons déjà évoqué le principe de parcimonie. À titre de rappel, lajout de variables indépendantes qui savèrent significatives fait inévitablement augmenter la variance expliquée et ainsi la valeur R2 ajusté. Par contre, elle peut rendre le modèle plus complexe à analyser, voire entraîner un surajustement du modèle. Nous avons vu que lintroduction des variables ditchtomique, polytomique et dinteraction avait pour effet daugmenter la capacité de prédiction du modèle. Quoi quil en soit, le gain de variance expliquée sélève à environ 4nbsp;% entre le troisième modèle versus le cinquième et le sixième : Modèle 3 (R2=0,465). VegPct ~ log(HABHA) + poly(AgeMedian, 2) + Pct_014 + Pct_65P + Pct_MV + Pct_FR Modèle 5 (R2=0,506). VegPct ~ log(HABHA) + poly(AgeMedian, 2) + Pct_014 + Pct_65P + Muni Modèle 6 (R2=0,495). VegPct ~ log(HABHA) + poly(AgeMedian, 2) + Pct_014 + Pct_65P + Pct_MV + Pct_FR + DistCBDkm + DistCBDkm * Pct_014 Par conséquent, il est légitime de se questionner sur le bien-fondé de conserver ces variables indépendantes additionnelles : Muni pour le modèle 5 et DistCBDkm + DistCBDkm * Pct_014 pour le modèle 6. Trois options sont alors envisageables : Bien entendu, conservez lune ou lautre de ces variables additionnelles si elles sont initialement reliées à votre cadre théorique. Conservez lune ou lautre de ces variables additionnelles si elles permettent de répondre à une question spécifique (non prévue initialement) et si les associations ainsi révélées méritent, selon vous, discussion. Supprimez-les si leur apport est limité et ne fait que complexifier le modèle. 7.7.3 Diagnostic sur un modèle 7.7.3.1 Vérification le nombre dobservations La syntaxe suivante permet de vérifier si le nombre dobservations est suffisant pour tester le R2 et chacune des variables indépendantes. modele3 &lt;- lm(VegPct ~ log(HABHA)+poly(AgeMedian,2)+ Pct_014+Pct_65P+Pct_MV+Pct_FR, data = DataFinal) # Nombre d&#39;observation nobs &lt;- length(modele3$fitted.values) # Nombre de variables indépendantes (coefficients moins la constante) k &lt;- length(modele3$coefficients)-1 # Première règle de pouce if(nobs &gt;= 50+(8*k)){ cat(&quot;\\nNombre d&#39;observations suffisant pour tester le R2&quot;) }else{ cat(&quot;\\nAttention! Nombre d&#39;observations insuffisant pour tester le R2&quot;) } ## ## Nombre d&#39;observations suffisant pour tester le R2 # Deuxième règle de pouce if(nobs &gt;= 104+k){ cat(&quot;\\nNombre d&#39;observations suffisant pour tester individuellement chaque VI&quot;) }else{ cat(&quot;\\nAttention! Nombre d&#39;observations insuffisant&quot;, &quot;\\npour tester individuellement chaque VI&quot;) } ## ## Nombre d&#39;observations suffisant pour tester individuellement chaque VI 7.7.3.2 Vérification la normalité des résidus La syntaxe suivante permet de vérifier la normalité des résidus selon les trois démarches classiques : 1) coefficients dasymétrie et daplatissement, 2) test de normalité de Jarque-Bera (fonction JarqueBeraTest du package DescTools) et 3) les graphiques (histogramme avec courbe normale et diagramme quantile-quantile). library(DescTools) library(stats) library(ggplot2) library(ggpubr) # Vecteur pour les résidus du modèle residus &lt;- modele3$residuals # 1. coefficients dasymétrie et daplatissement c(Skewness= round(DescTools::Skew(residus),3), Kurtosis = round(DescTools::Kurt(residus),3)) ## Skewness Kurtosis ## -0.263 1.149 # 2. Test de normalité de Jarque-Bera JarqueBeraTest(residus) ## ## Robust Jarque Bera Test ## ## data: residus ## X-squared = 528.51, df = 2, p-value &lt; 2.2e-16 # 3. Graphiques Ghisto &lt;- ggplot() + geom_histogram(aes(x = residus, y = ..density..), bins = 30, color = &quot;#343a40&quot;, fill = &quot;#a8dadc&quot;) + stat_function(fun = dnorm, args = list(mean = mean(residus), sd = sd(residus)), color = &quot;#e63946&quot;, size = 1.2, linetype = &quot;dashed&quot;)+ labs(title=&quot;Histogramme et courbe normale&quot;, y = &quot;densité&quot;, &quot;Résidus du modèle&quot;) Gqqplot &lt;- qplot(sample = residus)+ geom_qq_line(line.p = c(0.25, 0.75), color = &quot;#e63946&quot;, size=1.2)+ labs(title=&quot;Diagramme quantile-quantile&quot;, x=&quot;Valeurs théoriques&quot;, y = &quot;Résidus&quot;) ggarrange(Ghisto, Gqqplot, ncol=2, nrow=1) Figure 7.13: Diagnostic : la normalité des résidus 7.7.3.3 Évaluation de la linéarité et lhomoscédasticité des résidus La syntaxe suivante permet de vérifier si lhypothèse dhomoscédasticité des résidus est respectée avec : 1) un nuage de points entre les valeurs prédites et des résidus, 3) les graphiques (histogramme avec courbe normale et diagramme quantile-quantile) et 2) le test de Breusch-Pagan (fonction bptest du package lmtest). # 1. Test de Breusch-Pagan pour vérifier l&#39;homoscédasticité library(lmtest) bptest(modele3) ## ## studentized Breusch-Pagan test ## ## data: modele3 ## BP = 1651.5, df = 7, p-value &lt; 2.2e-16 if(bptest(modele3)$p.value &lt; 0.05){ cat(&quot;\\nAttention : problème d&#39;hétéroscédasticité des résidus&quot;) }else{ cat(&quot;\\nParfait : homoscédasticité des résidus&quot;) } ## ## Attention : problème d&#39;hétéroscédasticité des résidus # 2. Graphique entre les valeurs prédites et les résidus residus &lt;- modele3$residuals ypredits &lt;- modele3$fitted.values ggplot() + geom_point(aes(x = ypredits, y = residus), color = &quot;#343a40&quot;, fill = &quot;#a8dadc&quot;, alpha = 0.2, size = 0.8) + geom_smooth(aes(x = ypredits, y = residus), method = lm, color = &quot;red&quot;)+ labs(x=&quot;Valeurs prédites&quot;, y = &quot;Résidus&quot;) Figure 7.14: Distribution des résidus en fonction des valeurs prédites 7.7.3.4 Vérification la multicolinéarité excessive Pour vérifier la présence ou labsence de multicolinéarité excessive, nous utilisons habituellement la fonction vif du package car. library(car) # facteur d&#39;inflation de la variance round(car::vif(modele3),3) ## GVIF Df GVIF^(1/(2*Df)) ## log(HABHA) 1.289 1 1.136 ## poly(AgeMedian, 2) 1.387 2 1.085 ## Pct_014 1.518 1 1.232 ## Pct_65P 1.304 1 1.142 ## Pct_MV 1.480 1 1.217 ## Pct_FR 1.730 1 1.315 # problème de multicolinéarité (VIF &gt; 10)? car::vif(modele3) &gt; 10 ## GVIF Df GVIF^(1/(2*Df)) ## log(HABHA) FALSE FALSE FALSE ## poly(AgeMedian, 2) FALSE FALSE FALSE ## Pct_014 FALSE FALSE FALSE ## Pct_65P FALSE FALSE FALSE ## Pct_MV FALSE FALSE FALSE ## Pct_FR FALSE FALSE FALSE # problème de multicolinéarité (VIF &gt; 5)? car::vif(modele3) &gt; 5 ## GVIF Df GVIF^(1/(2*Df)) ## log(HABHA) FALSE FALSE FALSE ## poly(AgeMedian, 2) FALSE FALSE FALSE ## Pct_014 FALSE FALSE FALSE ## Pct_65P FALSE FALSE FALSE ## Pct_MV FALSE FALSE FALSE ## Pct_FR FALSE FALSE FALSE 7.7.3.5 Répérage des valeurs très influentes du modèle La syntaxe suivante permet dévaluer le nombre de valeurs très influentes dans le modèle avec les critères de \\(\\mbox{4/n}\\), \\(\\mbox{8/n}\\) et \\(\\mbox{16/n}\\) pour la distance de Cook. nobs &lt;- length(modele3$fitted.values) DistanceCook &lt;- cooks.distance(modele3) n4 &lt;- length(DistanceCook[DistanceCook &gt; 4/nobs]) n8 &lt;- length(DistanceCook[DistanceCook &gt; 8/nobs]) n16 &lt;- length(DistanceCook[DistanceCook &gt; 16/nobs]) cat(&quot;Nombre d&#39;observations =&quot;, nobs, &quot;(100 %)&quot;, &quot;\\n 4/n =&quot;, round(4/nobs,5), &quot;\\n 8/n =&quot;, round(8/nobs,5), &quot;\\n 16/n =&quot;, round(16/nobs,5), &quot;\\nObservations avec une valeur supérieure ou égale aux différents seuils&quot;, &quot;\\n 4/n =&quot;, n4, &quot;soit&quot;, round(n4/nobs*100,2),&quot; %&quot;, &quot;\\n 8/n =&quot;, n8, &quot;soit&quot;, round(n8/nobs*100,2),&quot; %&quot;, &quot;\\n 16/n =&quot;, n16, &quot;soit&quot;, round(n16/nobs*100,2), &quot; %&quot; ) ## Nombre d&#39;observations = 10210 (100 %) ## 4/n = 0.00039 ## 8/n = 0.00078 ## 16/n = 0.00157 ## Observations avec une valeur supérieure ou égale aux différents seuils ## 4/n = 604 soit 5.92 % ## 8/n = 285 soit 2.79 % ## 16/n = 132 soit 1.29 % Vous pouvez également construire un nuage de points avec la distance de Cook et leffet de levier (leverage value) pour repérer visuellement les observations très influentes. library(car) library(ggpubr) DistanceCook &lt;- cooks.distance(modele3) LeverageValue &lt;- hatvalues(modele3) G1 &lt;- ggplot()+ geom_point(aes(x = LeverageValue, y = DistanceCook), alpha = 0.2, size = 2, col=&quot;black&quot;, fill=&quot;red&quot;)+ labs(x = &quot;Effet levier&quot;, y = &#39;Distance de Cook&#39;, title = &#39;Repérer les valeurs influentes&#39;, subtitle = &#39;(toutes les observations)&#39;) G2 &lt;- ggplot()+ geom_point(aes(x = LeverageValue, y = DistanceCook), alpha = 0.2, size = 2, col=&quot;black&quot;, fill=&quot;red&quot;)+ ylim(0,0.01)+ xlim(0,0.01)+ labs(x = &quot;Effet levier&quot;, y = &#39;Distance de Cook&#39;, title = &#39;Repérer les valeurs influentes&#39;, subtitle = &#39;(agrandissement)&#39;) ggarrange(G1,G2, nrow=1, ncol=2) Figure 7.15: Repérage graphique des valeurs influentes du modèle 7.7.3.6 Construction dun nouveau modèle en supprimant les observations très influentes du modèle Dans un premier temps, il convient de construire un nouveau modèle sans les valeurs influentes du modèle de départ. # Nombre d&#39;observation dans le modèle 3 nobs &lt;-length(modele3$fitted.values) # Distance de Cook cook &lt;- cooks.distance(modele3) # Les observations très influentes avec le critère de 16/n DataSansOutliers &lt;- cbind(DataFinal, cook) DataSansOutliers &lt;- DataSansOutliers[DataSansOutliers$cook &lt; 8/nobs, ] modele3b &lt;- lm(VegPct ~ log(HABHA)+poly(AgeMedian,2)+Pct_014+Pct_65P+Pct_MV+Pct_FR, data = DataSansOutliers) nobsb &lt;-length(modele3b$fitted.values) Comparez les valeurs du R2 ajusté des deux modèles. Habituellement, la suppression des valeurs très influentes saccompagne dune augmentation du R2 ajusté. Cest notamment le cas ici puisque sa valeur grimpe de 0,4653 à 0,5684, signalant ainsi un gain important pour la variance expliquée. # Comparaison des mesures d&#39;ajustement cat(&quot;\\nComparaison des R2 ajustés :&quot;, &quot;\\nModèle de départ (n=&quot;, nobs, &quot;), &quot;, round(summary(modele3)$adj.r.squared,4), &quot;\\nModèle sans les observations très influentes (n=&quot;, nobsb, &quot;), &quot;, round(summary(modele3b)$adj.r.squared,4), sep=&quot;&quot; ) ## ## Comparaison des R2 ajustés : ## Modèle de départ (n=10210), 0.4653 ## Modèle sans les observations très influentes (n=9925), 0.5684 Pour le modèle, il convient alors de refaire le diagnostic de la régression et de vérifier si la suppression des observations très influentes a amélioré : 1) la normalité, la linéarité et lhomoscédasticité des résidus, 2) la multicolinéarité excessive et 3) labsence de valeurs trop influentes. La normalité des résidus sest-elle ou non améliorée? Pour ce faire, comparez les valeurs dasymétrie,daplatissement et du test de Jarque-Bera et les graphiques de normalité. À la lecture des valeurs : lasymétrie est très similaire (-0,260 à -0,265); laplatissement sest amélioré (1,183 à 0,164); le test de Jarque-Bera signale toujours un problème de normalité (p &lt; 0,001), mais sa valeur a nettement diminué (548,7 à 131,24); les graphiques démontrent une nette amélioration de la normalité des résidus. # 1. coefficients dasymétrie et daplatissement resmodele3 &lt;- rstudent(modele3) resmodele3b &lt;- rstudent(modele3b) c(Skewness= round(Skew(resmodele3),3), Kurtosis = round(Kurt(resmodele3),3)) ## Skewness1 Skewness2 Skewness3 Skewness4 Kurtosis1 Kurtosis2 Kurtosis3 Kurtosis4 ## -0.260 0.024 -10.739 0.000 1.185 0.048 24.448 0.000 c(Skewness= round(Skew(resmodele3b),3), Kurtosis = round(Kurt(resmodele3b),3)) ## Skewness1 Skewness2 Skewness3 Skewness4 Kurtosis1 Kurtosis2 Kurtosis3 Kurtosis4 ## -0.265 0.025 -10.790 0.000 0.165 0.049 3.360 0.000 # 2. Test de normalité de Jarque-Bera JarqueBeraTest(resmodele3) ## ## Robust Jarque Bera Test ## ## data: resmodele3 ## X-squared = 548.7, df = 2, p-value &lt; 2.2e-16 JarqueBeraTest(resmodele3b) ## ## Robust Jarque Bera Test ## ## data: resmodele3b ## X-squared = 131.24, df = 2, p-value &lt; 2.2e-16 # 3. Graphiques Ghisto1 &lt;- ggplot() + geom_histogram(aes(x = resmodele3, y = ..density..), bins = 30, color = &quot;#343a40&quot;, fill = &quot;#a8dadc&quot;) + stat_function(fun = dnorm, args = list(mean = mean(resmodele3), sd = sd(resmodele3)), color = &quot;#e63946&quot;, size = 1.2, linetype = &quot;dashed&quot;)+ labs(title=&quot;Modèle de départ&quot;, y = &quot;densité&quot;, x=&quot;Résidus studentisés&quot;) Gqqplot1 &lt;- qplot(sample = residus)+ geom_qq_line(line.p = c(0.25, 0.75), color = &quot;#e63946&quot;, size=1.2)+ labs(title=&quot;Modèle de départ&quot;, x=&quot;Valeurs théoriques&quot;, y = &quot;Résidus studentisés&quot;) Ghisto2 &lt;- ggplot() + geom_histogram(aes(x = resmodele3b, y = ..density..), bins = 30, color = &quot;#343a40&quot;, fill = &quot;#a8dadc&quot;) + stat_function(fun = dnorm, args = list(mean = mean(resmodele3b), sd = sd(resmodele3b)), color = &quot;#e63946&quot;, size = 1.2, linetype = &quot;dashed&quot;)+ labs(title=&quot;Modèle après suppression&quot;, x=&quot;Valeurs théoriques&quot;, y=&quot;Résidus studentisés&quot;) Gqqplot2 &lt;- qplot(sample = resmodele3b)+ geom_qq_line(line.p = c(0.25, 0.75), color = &quot;#e63946&quot;, size=1.2)+ labs(title=&quot;Modèle après suppression&quot;,x=&quot;Valeurs théoriques&quot;, y = &quot;Résidus studentisés&quot;) library(ggpubr) ggarrange(Ghisto1, Ghisto2, Gqqplot1, Gqqplot2, ncol=2, nrow=2) Figure 7.16: Normalité des résidus avant et après la suppression des valeurs influentes Le problème dhétéroscédasticité est-il corrigé? la valeur du test de Breusch-Pagan est beaucoup plus faible, mais il semble persister un problème dhétéroscédasticité. # homoscédasticité des résidus améliorée ou non? library(lmtest) library(ggpubr) bptest(modele3) ## ## studentized Breusch-Pagan test ## ## data: modele3 ## BP = 1651.5, df = 7, p-value &lt; 2.2e-16 bptest(modele3b) ## ## studentized Breusch-Pagan test ## ## data: modele3b ## BP = 640.53, df = 7, p-value &lt; 2.2e-16 resmodele3 &lt;- residuals(modele3) resmodele3b &lt;- residuals(modele3b) ypredits3 &lt;- modele3$fitted.values ypredits3b &lt;- modele3b$fitted.values G1 &lt;- ggplot() + geom_point(aes(x = ypredits3, y = resmodele3), color = &quot;#343a40&quot;, fill = &quot;#a8dadc&quot;, alpha = 0.2, size = 0.8) + geom_smooth(aes(x = ypredits3, y = resmodele3), method = lm, color = &quot;red&quot;)+ labs(title=&quot;Modèle de départ&quot;,x=&quot;Valeurs prédites&quot;, y = &quot;Résidus studentisés&quot;) G2 &lt;- ggplot() + geom_point(aes(x = ypredits3b, y = resmodele3b), color = &quot;#343a40&quot;, fill = &quot;#a8dadc&quot;, alpha = 0.2, size = 0.8) + geom_smooth(aes(x = ypredits3b, y = resmodele3b), method = lm, color = &quot;red&quot;)+ labs(title=&quot;Modèle après suppression&quot;,x=&quot;Valeurs prédites&quot;, y = &quot;Résidus studentisés&quot;) ggarrange(G1, G2, ncol=2, nrow=1) Figure 7.17: Amélioration de lhomoscédasticité des résidus Finalement, il convient de comparer les coefficients de régression. # Comparaison des coefficients summary(modele3) ## ## Call: ## lm(formula = VegPct ~ log(HABHA) + poly(AgeMedian, 2) + Pct_014 + ## Pct_65P + Pct_MV + Pct_FR, data = DataFinal) ## ## Residuals: ## Min 1Q Median 3Q Max ## -66.848 -8.660 0.381 8.961 83.269 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 5.283e+01 1.001e+00 52.781 &lt; 2e-16 *** ## log(HABHA) -6.855e+00 1.683e-01 -40.730 &lt; 2e-16 *** ## poly(AgeMedian, 2)1 1.198e+01 1.559e+01 0.769 0.441958 ## poly(AgeMedian, 2)2 -2.861e+02 1.394e+01 -20.525 &lt; 2e-16 *** ## Pct_014 9.406e-01 3.126e-02 30.093 &lt; 2e-16 *** ## Pct_65P 3.062e-01 1.851e-02 16.546 &lt; 2e-16 *** ## Pct_MV -3.630e-02 9.943e-03 -3.651 0.000262 *** ## Pct_FR -3.443e-01 1.103e-02 -31.212 &lt; 2e-16 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 13.57 on 10202 degrees of freedom ## Multiple R-squared: 0.4657, Adjusted R-squared: 0.4653 ## F-statistic: 1270 on 7 and 10202 DF, p-value: &lt; 2.2e-16 summary(modele3b) ## ## Call: ## lm(formula = VegPct ~ log(HABHA) + poly(AgeMedian, 2) + Pct_014 + ## Pct_65P + Pct_MV + Pct_FR, data = DataSansOutliers) ## ## Residuals: ## Min 1Q Median 3Q Max ## -46.417 -7.734 0.456 8.290 40.085 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 6.748e+01 9.869e-01 68.370 &lt; 2e-16 *** ## log(HABHA) -1.000e+01 1.720e-01 -58.167 &lt; 2e-16 *** ## poly(AgeMedian, 2)1 4.357e+01 1.387e+01 3.142 0.00168 ** ## poly(AgeMedian, 2)2 -3.564e+02 1.250e+01 -28.510 &lt; 2e-16 *** ## Pct_014 8.351e-01 2.870e-02 29.101 &lt; 2e-16 *** ## Pct_65P 2.271e-01 1.807e-02 12.566 &lt; 2e-16 *** ## Pct_MV -8.517e-03 9.109e-03 -0.935 0.34976 ## Pct_FR -2.924e-01 1.028e-02 -28.440 &lt; 2e-16 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 11.96 on 9917 degrees of freedom ## Multiple R-squared: 0.5687, Adjusted R-squared: 0.5684 ## F-statistic: 1868 on 7 and 9917 DF, p-value: &lt; 2.2e-16 7.7.4 Graphiques pour les effets marginaux Tel que signalé ultérieurement, il est courant de représenter leffet marginal dune VI sur une VD, une fois contrôlées les autres VI. Pour ce faire, il est possible dutiliser les packages ggplot2 et ggeffects. 7.7.4.1 Effet marginal pour une variable continue La syntaxe ci-dessous illustre comment obtenir un graphique pour nos quatre variables explicatives. Bien entendu, si le coefficient de régression est positif (comme pour les pourcentages de jeunes de moins de 15 ans et les personnes âgées), la pente est alors montante, et inversement descendante pour des coefficients négatifs (comme pour les personnes ayant déclaré appartenir à une minorité visible et les personnes à faible revenu). En outre, plus la valeur absolue du coefficient est forte, plus la pente est prononcée. library(ggplot2) library(ggeffects) library(ggpubr) # Création d&#39;un DataFrame pour les valeurs prédites pour chaque VI continue fitV1 &lt;- ggpredict(modele3, terms = &quot;Pct_014&quot;) fitV2 &lt;- ggpredict(modele3, terms = &quot;Pct_65P&quot;) fitV3 &lt;- ggpredict(modele3, terms = &quot;Pct_MV&quot;) fitV4 &lt;- ggpredict(modele3, terms = &quot;Pct_FR&quot;) # Construction des graphiques G1 &lt;-ggplot(fitV1, aes(x, predicted)) + # ligne de régression geom_line(color = &#39;red&#39;, size = 1) + # intervalle de confiance à 95 % geom_ribbon(aes(ymin = conf.low, ymax = conf.high), alpha = .3)+ # Titres labs(y=&quot;valeur prédite Y&quot;, x = &quot;Moins de 15 ans (%)&quot;) G2 &lt;-ggplot(fitV2, aes(x, predicted)) + geom_line(color = &#39;red&#39;, size = 1) + geom_ribbon(aes(ymin = conf.low, ymax = conf.high), alpha = .3)+ labs(y=&quot;valeur prédite Y&quot;, x = &quot;65 ans et plus (%)&quot;) G3 &lt;-ggplot(fitV3, aes(x, predicted)) + geom_line(color = &#39;blue&#39;, size = 1) + geom_ribbon(aes(ymin = conf.low, ymax = conf.high), alpha = .3)+ labs(y=&quot;valeur prédite Y&quot;, x = &quot;Minorités visibles (%)&quot;) G4 &lt;-ggplot(fitV4, aes(x, predicted)) + geom_line(color = &#39;blue&#39;, size = 1) + geom_ribbon(aes(ymin = conf.low, ymax = conf.high), alpha = .3)+ labs(y=&quot;valeur prédite Y&quot;, x = &quot;Personne à faible revenu (%)&quot;) # Assemblage des graphiques ggarrange(G1, G2, G3, G4, ncol =2, nrow =2) Figure 7.18: Effets marginaux pour des variables continues 7.7.4.2 Effet marginal pour une variable avec une fonction polynomiale dordre 2 library(ggplot2) library(ggeffects) library(ggpubr) fitAgeMedian &lt;- ggpredict(modele3, terms = &quot;AgeMedian&quot;) ggplot(fitAgeMedian, aes(x, predicted)) + geom_line(color = &#39;green&#39;, size = 1) + geom_ribbon(aes(ymin = conf.low, ymax = conf.high), alpha = .3)+ labs(title=&quot;Variable sous forme polynomiale (ordre 2)&quot;, y=&quot;VD: valeur prédite&quot;, x = &quot;Âge médian des bâtiments&quot;) Figure 7.19: Effet marginal dune variable avec un fonction polynomiale dordre 2 7.7.4.3 Effet marginal pour une variable transformée en logarithme fitHabHa &lt;- ggpredict(modele3, terms = &quot;HABHA&quot;) ggplot(fitHabHa, aes(x, predicted)) + geom_line(color = &#39;blue&#39;, size = 1) + geom_ribbon(aes(ymin = conf.low, ymax = conf.high), alpha = .3)+ labs(y=&quot;VD: valeur prédite&quot;, x = &quot;Habitants km2&quot;) Figure 7.20: Effet du logarithme de la densité 7.7.4.4 Effet marginal pour une variable dichotomique # Valeurs prédites selon le modèle avec la variable dichotomique fitVilleMtl &lt;- ggpredict(modele4, terms = &quot;VilleMtl&quot;) # Graphique ggplot(fitVilleMtl, aes(x=x, y=predicted)) + geom_bar(stat = &quot;identity&quot;, position = position_dodge(), fill=&quot;wheat&quot;) + geom_errorbar(aes(ymin = conf.low, ymax = conf.high), alpha = .9,position = position_dodge())+ labs(title=&quot;Effet marginal de la ville de Montréal sur la végétation&quot;, x=&quot;Municipalités de la région de Montréal&quot;, y=&quot;Couverture végétation de l&#39;îlot (%)&quot;)+ scale_x_continuous(breaks=c(0,1), labels = c(&quot;Autre municipalité&quot;, &quot;Ville de Montréal&quot;)) Figure 7.21: Effet marginal dune variable dichotomique 7.7.4.5 Effet marginal pour une variable polytomique # Valeurs prédites selon le modèle avec la variable polytomique fitVilles &lt;- ggpredict(modele5, terms = &quot;Munic&quot;) # Graphique Graphique &lt;- ggplot(fitVilles, aes(x=x, y=predicted)) + geom_bar(stat = &quot;identity&quot;, position = position_dodge(), fill=&quot;wheat&quot;) + geom_errorbar(aes(ymin = conf.low, ymax = conf.high), alpha = .9,position = position_dodge())+ labs(title=&quot;Effet marginal de la ville de Montréal sur la végétation&quot;, x=&quot;Municipalités de la région de Montréal&quot;, y=&quot;Couverture végétation de l&#39;îlot (%)&quot;) # Rotation du graphique Graphique + coord_flip() Figure 7.22: Effet marginal dune variable polytomique 7.7.4.6 Effet marginal pour une variable dinteraction (deux VI continues) library(metR) # pour ajouter des labels aux contours df &lt;- expand.grid( DistCBDkm = seq(0,33,0.1), Pct_FR = seq(0,95,1), HABHA = mean(DataFinal$HABHA), AgeMedian = mean(DataFinal$AgeMedian), Pct_014 = mean(DataFinal$Pct_014), Pct_65P = mean(DataFinal$Pct_65P), Pct_MV = mean(DataFinal$Pct_MV) ) df$DistCBDkmX_Pct_FR &lt;- df$DistCBDkm * df$Pct_FR pred &lt;- predict(modele6, newdata = df, se = T) df$pred &lt;- pred$fit df$pred_se &lt;- pred$se.fit df$lower &lt;- df$pred - 1.96 * df$pred_se df$upper &lt;- df$pred + 1.96 * df$pred_se P1 &lt;- ggplot(data = df) + geom_tile(aes(x = DistCBDkm, y = Pct_FR, fill = pred)) + stat_contour(aes(x = DistCBDkm, y = Pct_FR, z = pred), color = &quot;black&quot;, linetype = &quot;dashed&quot;) + geom_text_contour(aes(x = DistCBDkm, y = Pct_FR, z = pred), )+ scale_fill_viridis(discrete=FALSE) + labs(x = &quot;Distance au centre-ville&quot;, y = &quot;Pers à faible revenu (%)&quot;, fill = &quot;&quot;, subtitle = &quot;Prédiction&quot;) P2 &lt;- ggplot(data = df) + geom_tile(aes(x = DistCBDkm, y = Pct_FR, fill = lower)) + stat_contour(aes(x = DistCBDkm, y = Pct_FR, z = lower), color = &quot;black&quot;, linetype = &quot;dashed&quot;) + geom_text_contour(aes(x = DistCBDkm, y = Pct_FR, z = lower), )+ scale_fill_viridis(discrete=FALSE)+ labs(x = &quot;Distance au centre-ville&quot;, y = &quot;Pers à faible revenu (%)&quot;, fill = &quot;&quot;, subtitle = &quot;IC 2,5 %&quot;) P3 &lt;- ggplot(data = df) + geom_tile(aes(x = DistCBDkm, y = Pct_FR, fill = upper)) + stat_contour(aes(x = DistCBDkm, y = Pct_FR, z = upper), color = &quot;black&quot;, linetype = &quot;dashed&quot;) + geom_text_contour(aes(x = DistCBDkm, y = Pct_FR, z = upper), )+ scale_fill_viridis(discrete=FALSE)+ labs(x = &quot;Distance au centre-ville&quot;, y = &quot;Pers à faible revenu (%)&quot;, fill = &quot;&quot;, subtitle = &quot;IC 97,5 %&quot;) ggarrange(P1,P2,P3,common.legend = F, ncol = 2, nrow = 2) Figure 7.23: Effet marginal de linteraction entre deux variables continues 7.7.4.7 Effet marginal pour une variable dinteraction (une VI continue et une VI dichotomique) df &lt;- expand.grid( VilleMtl = c(0,1), Pct_FR = seq(0,95,1), HABHA = mean(DataFinal$HABHA), AgeMedian = mean(DataFinal$AgeMedian), Pct_014 = mean(DataFinal$Pct_014), Pct_65P = mean(DataFinal$Pct_65P), Pct_MV = mean(DataFinal$Pct_MV) ) df$VilleMtlX_Pct_FR &lt;- df$VilleMtl * df$Pct_FR head(df, n=5) ## VilleMtl Pct_FR HABHA AgeMedian Pct_014 Pct_65P Pct_MV VilleMtlX_Pct_FR ## 1 0 0 87.7694 52.11494 15.89268 14.86761 20.96675 0 ## 2 1 0 87.7694 52.11494 15.89268 14.86761 20.96675 0 ## 3 0 1 87.7694 52.11494 15.89268 14.86761 20.96675 0 ## 4 1 1 87.7694 52.11494 15.89268 14.86761 20.96675 1 ## 5 0 2 87.7694 52.11494 15.89268 14.86761 20.96675 0 pred &lt;- predict(modele7, se = T, newdata = df) df$pred &lt;- pred$fit df$upper &lt;- df$pred + 1.96*pred$se.fit df$lower &lt;- df$pred - 1.96*pred$se.fit df$VilleMtl_str &lt;- ifelse(df$VilleMtl==0,&quot;Autre municipalité&quot;,&quot;Ville de Montréal&quot;) DataFinal$VilleMtl_str &lt;- ifelse(DataFinal$VilleMtl==0,&quot;Autre municipalité&quot;,&quot;Ville de Montréal&quot;) cols &lt;- c(&quot;Autre municipalité&quot; =&quot;#1d3557&quot; ,&quot;Ville de Montréal&quot;=&quot;#e63946&quot;) ggplot(data = df) + geom_point(data = DataFinal, mapping = aes(x = Pct_FR, y = VegPct, color = VilleMtl_str), size = 0.2, alpha = 0.2)+ geom_ribbon(aes(x = Pct_FR, ymin = lower, ymax = upper, group = VilleMtl_str), fill = rgb(0.1,0.1,0.1,0.4))+ geom_path(aes(x = Pct_FR, y = pred, color = VilleMtl_str), size = 1) + scale_colour_manual(values = cols)+ labs(x = &quot;Personnes à faible revenu (%)&quot;, y = &quot;Densité de végétation prédite (%)&quot;, color = &quot;&quot;) Figure 7.24: Graphique de leffet marginal de linteraction entre une variable quantitative et qualitative "],["sect078.html", "7.8 Quiz de révision du chapitre", " 7.8 Quiz de révision du chapitre Quels modèles sont imbriqués? Relisez au besoin la section 7.3.2. Modèle A : Y = X1 + X2 + X3 / Modèle B : Y = X1 + X2 + X3 + X4 + X5 Modèle A : Y = X1 + X4 + X5 / Modèle B : Y = X1 + X2 + X3 + X7 + X8 Quelle mesure relative à la qualité dajustement du modèle indique la proportion de la variance de la variable dépendante expliquée par les variables indépendantes du modèle? Relisez au besoin la section 7.3.1. Statistique de Fisher Coefficient de détermination (R2) Lerreur quadratique moyenne (RMSE) Le coefficient de régression standardisé Le R2 ajusté permet de comparer des modèles avec des nombres de variables indépendantes et/ou dobservations différents Relisez au besoin le début de la section 7.3.2. Vrai Faux Comment repérer les variables les plus importantes du modèle? Relisez au besoin la section 7.4.2. Coefficients de régression Coefficients de régression standardisés Erreurs types Comment évaluer la significativité des coefficients? Relisez au besoin la section 7.4.3. Valeur de t Valeur de p R2 F de Fisher Pour un nombre très élevé dobservations, quelle affirmation est vraie pour les valeurs de t et de p? Relisez au besoin la section 7.4.3. 1,96 (p &lt;= 0,05); 2,58 (p &lt;= 0,01); 3,29 (p &lt;= 0,001) 1,96 (p &lt;= 0,001); 2,58 (p &lt;= 0,01); 3,29 (p &lt;= 0,05) 2,96 (p &lt;= 0,05); 3,58 (p &lt;= 0,01); 4,29 (p &lt;= 0,001) Une variable indépendante dont lintervalle de confiance à 95 % du coefficient de régression est de [-15,06 ; 28,17] est-elle significatif au seuil de p = 0,05? Relisez au besoin la section 7.4.4. Vrai Faux Comment poser un diagnostic sur un modèle de régression linéaire? Relisez le deuxième encadré à la section 7.6. Nombre dobservations Normalité des résidus Linéarité et homoscédasticité des résidus Absence de multicolinéarité excessive Absence dobservations trop influentes Nombre de variables indépendantes Verifier Votre score "],["chap08.html", "Chapitre 8 Régressions linéaires généralisées (GLM)", " Chapitre 8 Régressions linéaires généralisées (GLM) Dans ce chapitre, nous présentons les modèles linéaires généralisés plus communément appelés GLM (generalized linear models en anglais). Il sagit dune extension directe du modèle de régression linéaire multiple (LM) basé sur la méthode des moindres carrés ordinaires, décrite dans le chapitre précédent. Pour aborder cette section sereinement, il est important davoir bien compris le concept de distribution présenté dans la section 2.4. À la fin de cette section, vous serez en mesure de : comprendre la distinction entre un modèle LM classique et un GLM; identifier les composantes dun GLM; interpréter les résultats dun GLM; effectuer les diagnostics dun GLM. Dans ce chapitre, nous utilisons principalement les packages suivants : Pour créer des graphiques : ggplot2, le seul, lunique! ggpubr pour combiner des graphiques et réaliser des diagrammes. Pour ajuster des modèles GLM : VGAM et gamlss offrent tous les deux un très large choix de distributions et de fonctions de diagnostic, mais nécessitent souvent un peu plus de code. mgcv offre moins de distributions que les deux précédents, mais est plus simple dutilisation. Pour analyser des modèles GLM : car essentiellement pour la fonction vif. DHARMa pour le diagnostic des résidus simulés. ROCR et caret pour lanalyse de la qualité dajustement de modèles pour des variables qualitatives. AER pour des tests de surdispersion. fitdistrplus pour ajuster des distributions à des données. LaplacesDemon pour manipuler certaines distributions. sandwich pour générer des erreurs standards robustes pour le modèle GLM logistique binomial. "],["sect081.html", "8.1 Quest quun modèle GLM?", " 8.1 Quest quun modèle GLM? Nous avons vu quune régression linéaire multiple (LM) ne peut être appliquée que si la variable dépendante analysée est continue et si elle est normalement distribuée, une fois les variables indépendantes contrôlées. Il sagit dune limite très importante puisquelle ne peut être utilisée pour modéliser et prédire des variables binaires, multinomiales, de comptage, ordinales ou plus simplement des données anormalement distribuées. Une seconde limite importante des LM est que linfluence des variables indépendantes sur la variable dépendante ne peut être que linéaire. Laugmentation dune unité de X conduit à une augmentation (ou diminution) de \\(\\beta\\) (coefficient de régression) unités de Y, ce qui nest pas toujours représentatif des phénomènes étudiés. Afin de dépasser ces contraintes, Nelder et Wedderburn (1972) ont proposé une extension des modèles LM, soit les modèles linéaires généralisés (GLM). 8.1.1 Formulation dun GLM Puisquun modèle GLM est une extension des modèles LM, il est possible de traduire un modèle LM sous forme dun GLM. Nous utilisons ce point de départ pour détailler la morphologie dun GLM. Nous avons vu dans la section précédente quun modèle LM est formulé de la façon suivante (notation matricielle) : \\[\\begin{equation} Y = \\beta_0 + X\\beta + \\epsilon \\tag{8.1} \\end{equation}\\] Avec \\(\\beta_0\\) la constante (intercept en anglais) et \\(\\beta\\) un vecteur de coefficients de régression pour les k variables indépendantes (X). Daprès cette formule, nous modélisons la variable Y avec une équation de régression linéaire et un terme derreur que nous estimons être normalement distribué. Nous pouvons reformuler ce simple LM sous forme dun GLM avec lécriture suivante : \\[\\begin{equation} \\begin{aligned} &amp;Y \\sim Normal(\\mu,\\sigma)\\\\ &amp;g(\\mu) = \\beta_0 + \\beta X\\\\ &amp;g(x) = x \\end{aligned} \\tag{8.2} \\end{equation}\\] Pas de panique! Cette écriture se lit comme suit : la variable Y est issue dune distribution normale \\((Y \\sim Normal)\\) avec deux paramètres : \\(\\mu\\) (sa moyenne) et \\(\\sigma\\) (son écart-type). \\(\\mu\\) varie en fonction dune équation de régression linéaire (\\(\\beta_0 + \\beta X\\)) transformée par une fonction de lien g (détaillée plus loin). Dans ce cas précis, la fonction de lien est appelée fonction identitaire puisquelle napplique aucune transformation (\\(g(x) = x\\)). Notez ici que le second paramètre de la distribution normale \\(\\sigma\\) (paramètre de dispersion) a une valeur fixe et ne dépend donc pas des variables indépendantes à la différence de \\(\\mu\\). Dans ce modèle spécifiquement, les paramètres à estimer sont \\(\\sigma\\), \\(\\beta_0\\) et \\(\\beta\\). Notez que dans la notation traditionnelle, la fonction de lien est appliquée au paramètre modélisé. Il est possible de renverser cette notation en utilisant la réciproque (\\(g&#39;\\)) de la fonction de lien (\\(g\\)) : \\[\\begin{equation} g(\\mu) = \\beta_0 + \\beta X \\Longleftrightarrow \\mu = g&#39;(\\beta_0 + \\beta X) \\text{ si : }g&#39;(g(x)) = x \\tag{8.3} \\end{equation}\\] Dans un modèle GLM, la distribution attendue de la variable Y est déclarée de façon explicite ainsi que la façon dont nos variables indépendantes conditionnent cette distribution. Ici, cest la moyenne (\\(\\mu\\)) de la distribution qui est modélisée, nous nous intéressons ainsi au changement moyen de Y provoqué par les variables X. Avec cet exemple, nous voyons les deux composantes supplémentaires dun modèle GLM : La distribution supposée de la variable Y conditionnée par les variables X (ici, la distribution normale). Une fonction de lien associant léquation de régression formée par les variables indépendantes et un paramètre de la distribution retenue (ici, la fonction identitaire et le paramètre \\(\\mu\\)). Notez également que lestimation des paramètres dun modèle GLM (ici, \\(\\beta_0\\), \\(\\beta X\\) et \\(\\sigma\\)) ne se fait plus avec la méthode des moindres carrés ordinaires utilisée pour les modèles LM. À la place, la méthode par maximum de vraisemblance (maximum likelihood) est la plus souvent utilisée, mais certains packages utilisent également la méthode des moments (method of moments). Ces deux méthodes nécessitent des échantillons plus grands que la méthode des moindres carrés. Dans le cas spécifique dun modèle GLM utilisant une distribution normale, la méthode des moindres carrés et la méthode par maximum de vraisemblance produisent les mêmes résultats. 8.1.2 Autres distributions et rôle de la fonction de lien À première vue, il est possible de se demander pourquoi ajouter ces deux éléments puisquils ne font que complexifier le modèle. Pour mieux saisir la pertinence des GLM, prenons un exemple appliqué au cas dune variable binaire. Admettons que nous souhaitons modéliser / prédire la probabilité quune personne à vélo décède lors dune collision avec un véhicule motorisé. Notre variable dépendante est donc binaire (0 = survie, 1 = décès) et nous souhaitons la prédire avec trois variables continues que sont : la vitesse de déplacement du ou de la cycliste (\\(x_1\\)), la vitesse de déplacement du véhicule (\\(x_2\\)) et la masse du véhicule (\\(x_3\\)). Puisque la variable Y nest pas continue, il serait absurde de supposer quelle est issue dune distribution normale. Il serait plus logique de penser quelle provient dune distribution de Bernoulli (pour rappel, une distribution de Bernoulli permet de modéliser un phénomène ayant deux issues possibles comme un lancer de pièce de monnaie, section 2.4). Plus spécifiquement, nous pourrions formuler lhypothèse que nos trois variables \\(x_1\\), \\(x_2\\) et \\(x_3\\) influencent le paramètre p (la probabilité doccurrence de lévènement) dune distribution de Bernoulli. À partir de ces premières hypothèses, nous pouvons écrire le modèle suivant : \\[\\begin{equation} \\begin{aligned} &amp;Y \\sim Bernoulli(p)\\\\ &amp;g(p) = \\beta_0 + \\beta X\\\\ &amp;g(x) = x \\end{aligned} \\tag{8.4} \\end{equation}\\] Toutefois, le résultat nest pas entièrement satisfaisant. En effet, p est une probabilité et, par nature, ce paramètre doit être compris entre 0 et 1 (entre 0 et 100 % de « chances de décès », ni plus ni moins). Léquation de régression que nous utilisons actuellement peut produire des résultats compris entre \\(-\\infty\\) et \\(+\\infty\\) pour p puisque rien ne contraint la somme \\(\\beta_0+ \\beta_1x_1+\\beta_2x_2+ \\beta_3x_3\\) à être comprise entre 0 et 1. Il est possible de visualiser le problème soulevé par cette situation avec les figures suivantes. Admettons que nous avons observé une variable Y binaire et que nous savons quelle est influencée par une variable X qui, plus elle augmente, plus les chances que Y soit 1 augmentent (figure 8.1). Figure 8.1: Exemple de données issues dune distribution de Bernoulli Si nous utilisons léquation de régression actuelle, cela revient à trouver la droite la mieux ajustée passant dans ce nuage de points (figure 8.2). Figure 8.2: Ajustement dune droite de régression aux données issues dune distribution de Bernoulli Ce modèle semble bien cerner linfluence positive de X sur Y, mais la droite est au final très éloignée de chaque point, indiquant un faible ajustement du modèle. De plus, la droite prédit des probabilités négatives lorsque X est inférieur à 2,5 et des probabilités supérieures à 1 quand X est supérieur à 1. Elle est donc loin de bien représenter les données. Cest ici quintervient la fonction de lien. La fonction identitaire que nous avons utilisée jusquici nest pas satisfaisante, nous devons la remplacer par une fonction qui conditionnera la somme \\(\\beta_0+ \\beta_1x_1+\\beta_2x_2+ \\beta_3x_3\\) pour donner un résultat entre 0 et 1. Une candidate toute désignée est la fonction sigmoidale, plus souvent appelée la fonction logistique! \\[\\begin{equation} \\begin{aligned} &amp;Y \\sim Bernoulli(p)\\\\ &amp;S(p) = \\beta_0 + \\beta X\\\\ &amp;S(x) = \\frac{e^{x}}{e^x+1} \\end{aligned} \\tag{8.5} \\end{equation}\\] La fonction logistique prend la forme dun S. Plus la valeur entrée dans la fonction est grande, plus le résultat produit par la fonction est proche de 1 et inversement. Si nous reprenons lexemple précédent, nous obtenons le modèle illustré à la figure 8.3. Figure 8.3: Utilisation de la fonction de lien logistique Une fois cette fonction insérée dans le modèle, nous constatons quune augmentation de la somme \\(\\beta_0+ \\beta_1x_1+\\beta_2x_2+ \\beta_3x_3\\) conduit à une augmentation de la probabilité p et inversement, et que cet effet est non linéaire. Nous avons donc maintenant un GLM permettant de prédire la probabilité dun décès lors dun accident en combinant une distribution et une fonction de lien adéquates. 8.1.3 Conditions dapplication La famille des GLM englobe de (très) nombreux modèles du fait de la diversité de distributions existantes et des fonctions de liens utilisables. Cependant, certaines combinaisons sont plus souvent utilisées que dautres. Nous présentons donc dans les prochaines sections les modèles GLM les plus communs. Les conditions dapplication varient dun modèle à lautre, il existe cependant quelques conditions dapplication communes à tous ces modèles : lindépendance des observations (et donc des erreurs); labsence de valeurs aberrantes / fortement influentes; labsence de multicolinéarité excessive entre les variables indépendantes. Ces trois conditions sont également valables pour les modèles LM tel quabordés dans le chapitre 7. La distance de Cook peut ainsi être utilisée pour détecter les potentielles valeurs aberrantes et le facteur dinflation de la variance (VIF) pour détecter la multicolinéarité. Les conditions dapplication particulières sont détaillées dans les sections dédiées à chaque modèle. 8.1.4 Résidus et déviance Dans la section sur la régression linéaire simple, nous avons présenté la notion de résidu, soit lécart entre la valeur observée (réelle) de Y et la valeur prédite par le modèle. Pour un modèle GLM, ces résidus traditionnels (aussi appelés résidus naturels) ne sont pas très informatifs si la variable à modéliser est binaire, multinomiale ou même de comptage. Lorsque lon travaille avec des GLM, nous préférons utiliser trois autres formes de résidus, soit les résidus de Pearson, les résidus de déviance et les résidus simulés. Les résidus de Pearson sont une forme ajustée des résidus classiques, obtenus par la division des résidus naturels par la racine carrée de la variance modélisée. Leur formule varie donc dun modèle à lautre puisque lexpression de la variance change en fonction de la distribution du modèle. Pour un modèle GLM gaussien, elle sécrit : \\[\\begin{equation} r_i = \\frac{y_i - \\mu_i}{\\sigma} \\tag{8.6} \\end{equation}\\] Pour un modèle GLM de Bernoulli, elle sécrit : \\[\\begin{equation} r_i = \\frac{y_i - p_i}{\\sqrt{p_i(1-p_i)}} \\tag{8.7} \\end{equation}\\] avec \\(\\mu_i\\) et \\(p_i\\) les préditions du modèle pour lobservation i. Les résidus de déviance sont basés sur le concept de likelihood présenté dans la section 2.5.4.2. Pour rappel, le likelihood, ou la vraisemblance dun modèle, correspond à la probabilité conjointe davoir observé les données Y selon le modèle étudié. Pour des raisons mathématiques (voir section 2.5.4.2), le log likelihood est plus souvent calculé. Plus cette valeur est forte, moins le modèle se trompe. Cette interprétation est donc inverse à celle des résidus classiques, cest pourquoi le log likelihood est généralement multiplié par 2 pour retrouver une interprétation intuitive. Ainsi, pour chaque observation i, nous pouvons calculer : \\[\\begin{equation} d_i = \\mbox{-2} \\times log(P(y_i|M_e)) \\tag{8.8} \\end{equation}\\] avec \\(d_i\\) le résidu de déviance et \\(P(y_i|M_e)\\) la probabilité davoir observé la valeur \\(y_i\\) selon le modèle étudié (\\(M_e\\)). La somme de tous ces résidus est appelée la déviance totale du modèle. \\[\\begin{equation} D(M_e) = \\sum_{i=1}^n \\mbox{-2} \\times log(P(y_i|M_e)) \\tag{8.9} \\end{equation}\\] Il sagit donc dune quantité représentant à quel point le modèle est erroné vis-à-vis des données. Notez quen tant que telle, la déviance na pas dinterprétation directe en revanche, elle est utilisée pour calculer des mesures dajustement des modèles GLM. Les résidus simulés sont une avancée récente dans le monde des GLM, ils fournissent une définition et une interprétation harmonisée des résidus pour lensemble des modèles GLM. Dans la section sur les LM (voir section 7.2.2), nous avons vu comment interpréter les graphiques des résidus pour détecter déventuels problèmes dans le modèle. Cependant, cette technique est bien plus compliquée à mettre en uvre pour les GLM puisque la forme attendue des résidus varie en fonction de la distribution choisie pour modéliser Y. La façon la plus efficace de procéder est dinterpréter les graphiques des résidus simulés qui ont la particularité dêtre identiquement distribués, quel que soit le modèle GLM construit. Ces résidus simulés sont compris entre 0 et 1 et sont calculés de la manière suivante : À partir du modèle GLM construit, simuler S fois (généralement 1 000) une variable Y avec autant dobservation (n) que Y. Cette variable simulée est une combinaison de la prédiction du modèle (coefficient et variables indépendantes) et de sa dispersion (variance). Ces simulations représentent des variations vraisemblables de la variable Y si le modèle est correctement spécifié. En dautres termes, si le modèle représente bien le phénomène à lorigine de la variable Y, alors les simulations Y issues du modèle devraient être proches de la variable Y originale. Pour une explication plus détaillée de ce que signifie simuler des données à partir dun modèle, référez-vous au bloc attention intitulé Distinction entre simulation et prédiction dans la section 8.1.5.2. Pour chaque observation, nous obtenons ainsi S valeurs formant une distribution \\(Ds_i\\), soit les valeurs simulées par le modèle pour cette observation. Pour chacune de ces distributions, nous calculons la probabilité cumulative dobserver la vraie valeur \\(Y_i\\) daprès la distribution \\(Ds_i\\). Cette valeur est comprise entre 0 (toutes les valeurs simulées sont plus grandes que \\(Y_i\\)) et 1 (toutes les valeurs simulées sont inférieures à \\(Y_i\\)). Si le modèle est correctement spécifié, le résultat attendu est que la distribution de ces résidus est uniforme. En effet, il y a autant de chances que les simulations produisent des résultats supérieurs ou inférieurs à \\(Y_i\\) si le modèle représente bien le phénomène (Dunn et Smyth 1996; Gelman et Hill 2006). Si la distribution des résidus ne suit pas une loi uniforme, cela signifie que le modèle échoue à reproduire le phénomène à lorigine de Y, ce qui doit nous alerter sur sa pertinence. 8.1.5 Vérification lajustement Il existe trois façons de vérifier lajustement dun modèle GLM : utiliser des mesures dajustement (AIC, pseudo-R2, déviance expliquée, etc.); comparer les distributions de la variable originale et celle des prédictions; comparer les prédictions du modèle avec les valeurs originales. Notez demblée que vérifier la qualité dajustement dun modèle (ajustement aux données originales) ne revient pas à vérifier la validité dun modèle (respect des conditions dapplication). Cependant, ces deux éléments sont généralement liés, car un modèle mal ajusté a peu de chances dêtre valide et inversement. 8.1.5.1 Mesures dajustement Les mesures dajustement sont des indicateurs plus ou moins arbitraires dont le principal intérêt est de faciliter la comparaison entre plusieurs modèles similaires. Il est nécessaire de les reporter, car dans certains cas, ils peuvent indiquer que des modèles sont très mal ajustés. 8.1.5.1.1 Déviance expliquée Rappelons que la déviance dun modèle est une quantité représentant à quel point le modèle est erroné. Lobjectif de lindicateur de la déviance expliquée est destimer le pourcentage de la déviance maximale observable dans les données que le modèle est parvenu à expliquer. La déviance maximale observable dans les données est obtenue en utilisant la déviance totale du modèle nul (notée \\(M_n\\), soit un modèle dans lequel aucune variable indépendante nest ajoutée et ne comportant quune constante). Cette déviance est maximale puisquaucune variable indépendante nest présente dans le modèle. Nous calculons ensuite le pourcentage de cette déviance totale qui a été contrôlée par le modèle étudié (\\(M_e\\)). \\[\\begin{equation} \\mbox{déviance expliquée} = \\frac{D(M_n) - D(M_e)}{D(M_n)} = 1- \\frac{D(M_e)}{D(M_n)} \\tag{8.10} \\end{equation}\\] Il sagit donc dun simple calcul de pourcentage entre la déviance maximale (\\(D(M_n)\\)) et la déviance expliquée par le modèle étudié (\\(D(M_n )-D(M_e)\\)). Cet indicateur est compris entre 0 et 1 : plus il est petit, plus la capacité de prédiction du modèle est faible. Attention, cet indicateur ne tient pas compte de la complexité du modèle. Ajouter une variable indépendante supplémentaire ne fait quaugmenter la déviance expliquée, ce qui ne signifie pas que la complexification du modèle soit justifiée (voir lencadré sur le principe de parcimonie, section 7.3.2). 8.1.5.1.2 Pseudo-R2 Le R2 est une mesure dajustement représentant la part de la variance expliquée dans un modèle linéaire classique. Cette mesure nest pas directement transposable au cas des GLM puisquils peuvent être appliqués à des variables non continues et anormalement distribuées. Toutefois, il existe des mesures semblables appelées pseudo-R2, remplissant un rôle similaire. Notez cependant quils ne peuvent pas être interprétés comme le R2 classique (dune régression linéaire multiple) : ils ne représentent pas la part de la variance expliquée. Ils sont compris dans lintervalle 0 et 1; plus leurs valeurs sapprochent de 1, plus le modèle est ajusté. Tableau 8.1: Principaux pseudo-\\(R^2\\) Nom Formule Commentaire McFadden \\(1-\\frac{loglike(M_e)}{loglike(M_n)}\\) Le rapport des loglikelihood, très proche de la déviance expliquée. McFadden ajusté \\(1-\\frac{loglike(M_e)-K}{loglike(M_n)}\\) Version ajustée du R2 de McFadden tenant compte du nombre de paramètres (k) dans le modèle. Efron \\(1-\\frac{\\sum_{i=1}^n(y_i-\\hat{y}_i)^2}{\\sum_{i=1}^n(y_i-\\bar{y}_i)^2}\\) Rapport entre la somme des résidus classiques au carré (numérateur) et de la somme des écarts au carré à la moyenne (dénominateur). Notez que pour un GLM gaussien, ce pseudo-R2 est identique au R2 classique. Cox &amp; Snell \\(1-e^{-\\frac{2}{n}({loglike(M_e) - loglike(M_n))}}\\) Transformation de la déviance afin de la mettre sur une échelle de 0 à 1 (mais ne pouvant atteindre exactement 1). Nagelkerke \\(\\frac{1-e^{-\\frac{2}{n}({loglike(M_e) - loglike(M_n))}}}{1-e^{\\frac{2*loglike(M_n)}{n}}}\\) Ajustement du R2 de Cox et Snell pour que léchelle de valeurs possibles puisse comporter 1 (attention, car les valeurs de ce R2 tendent à être toujours plus fortes que les autres). En dehors du pseudo-R2 de McFadden ajusté, aucune de ces mesures ne tient compte de la complexité du modèle. Il est cependant important de les reporter, car des valeurs très faibles indiquent vraisemblablement un modèle avec une moindre capacité informative. À linverse, des valeurs trop fortes pourraient indiquer un problème de surajustement (voir encadré sur le principe de parcimonie, section 7.3.2). 8.1.5.1.3 Critère dinformation dAkaike (AIC) Probablement lindicateur le plus répandu, sa formule est relativement simple, car il sagit seulement dun ajustement de la déviance : \\[\\begin{equation} AIC = D(M_e) + 2K \\tag{8.11} \\end{equation}\\] avec K le nombre de paramètres à estimer dans le modèle (coefficients, paramètres de distribution, etc.). LAIC na pas dinterprétation directe, mais permet de comparer deux modèles imbriqués (voir section 7.3.2). Plus lAIC est petit, mieux le modèle est ajusté. Lidée derrière cet indicateur est relativement simple. Si la déviance D est grande, alors le modèle est mal ajusté. Ajouter des paramètres (des coefficients pour de nouvelles variables X, par exemple) ne peut que réduire D, mais cette réduction nest pas forcément suffisamment grande pour justifier la complexification du modèle. LAIC pondère donc D en lui ajoutant 2 fois le nombre de paramètres du modèle. Un modèle plus simple (avec moins de paramètres) parvenant à une même déviance est préférable à un modèle complexe (principe de parcimonie ou du rasoir dOckham), ce que permet de « quantifier » lAIC. Attention, lAIC ne peut pas être utilisé pour comparer des modèles non imbriqués. Notez que dautres indicateurs similaires comme le WAIC, le BIC et le DIC sont utilisés dans un contexte dinférence bayésienne. Retenez simplement que ces indicateurs sont conceptuellement proches du AIC et sinterprètent (à peu de choses près) de la même façon. 8.1.5.2 Comparaison des distributions originales et prédites Une façon rapide de vérifier si un modèle est mal ajusté est de comparer la forme de la distribution originale et celle capturée par le modèle. Lidée est la suivante : si le modèle est bien ajusté aux données, il est possible de se servir de celui-ci pour générer de nouvelles données dont la distribution ressemble à celle des données originales. Si une différence importante est observable, alors les résultats du modèle ne sont pas fiables, car le modèle échoue à reproduire le phénomène étudié. Cette lecture graphique ne permet pas de sassurer que le modèle est valide ou bien ajusté, mais simplement décarter rapidement les mauvais candidats. Notez que cette méthode ne sapplique pas lorsque la variable modélisée est binaire, multinomiale ou ordinale. Le graphique à réaliser comprend donc la distribution de la variable dépendante Y (représentée avec un histogramme ou un graphique de densité) et plusieurs distributions simulées à partir du modèle. Cette approche est plus répandue dans la statistique bayésienne, mais elle reste pertinente dans lapproche fréquentiste. Il est rare de reporter ces figures, mais elles doivent faire partie de votre diagnostic. Distinction entre simulation et prédiction Notez ici que simuler des données à partir dun modèle et effectuer des prédictions à partir dun modèle sont deux opérations différentes. Prédire une valeur à partir dun modèle revient simplement à appliquer son équation de régression à des données. Si nous réutilisons les mêmes données, la prédiction renvoie toujours le même résultat, il sagit de la partie systématique (ou déterministe) du modèle. Pour illustrer cela, admettons que nous avons ajusté un modèle GLM de type gaussien (fonction de lien identitaire) avec trois variables continues \\(X_1\\), \\(X_2\\) et \\(X_3\\) et des coefficients respectifs de 0,5, 1,2 et 1,8 ainsi quune constante de 7. Nous pouvons utiliser ces valeurs pour prédire la valeur attendue de \\(Y\\) quand \\(X_1= 3\\), \\(X_2= 5\\) et \\(X_3 = 5\\) : \\(\\mbox{Prédiction} = \\mbox{7 + 3}\\times \\mbox{0,5 + 5}\\times \\mbox{1,2 + 5}\\times\\mbox{1,8 = 23,5}\\) En revanche, simuler des données à partir dun modèle revient à ajouter la dimension stochastique (aléatoire) du modèle. Puisque notre modèle GLM est gaussien, il comporte un paramètre \\(\\sigma\\) (son écart-type); admettons, pour cet exemple, quil est de 1,2. Ainsi, avec les données précédentes, il est possible de simuler un ensemble infini de valeurs dont la distribution est la suivante : \\(Normal(\\mu = \\mbox{23,5, } \\sigma = \\mbox{1,2})\\). 95 % du temps, ces valeurs simulées se trouveront dans lintervalle \\(\\mbox{[21,1-25,9]}\\) (\\(\\mu - 2\\sigma \\text{; } \\mu + 2\\sigma\\)), puisque cette distribution est normale. Les valeurs simulées dépendent donc de la distribution choisie pour le modèle et de lensemble des paramètres du modèle, pas seulement de léquation de régression. Si vous aviez à ne retenir quune seule phrase de ce bloc, retenez que la prédiction ne se réfère quà la partie systématique du modèle (équation de régression), alors que la simulation incorpore la partie stochastique (aléatoire) de la distribution du modèle. Deux prédictions effectuées sur des données identiques donnent nécessairement des résultats identiques, ce qui nest pas le cas pour la simulation. 8.1.5.3 Comparaison des prédictions du modèle avec les valeurs originales Les prédictions dun modèle devraient être proches des valeurs réelles observées. Si ce nest pas le cas, alors le modèle nest pas fiable et ses paramètres ne sont pas informatifs. Dépendamment de la nature de la variable modélisée (quantitative ou qualitative), plusieurs approches peuvent être utilisées pour quantifier lécart entre valeurs réelles et valeurs prédites. 8.1.5.3.1 Pour une variable quantitative La mesure la plus couramment utilisée pour une variable quantitative est lerreur moyenne quadatrique (Root Mean Square Error  RMSE en anglais). \\[\\begin{equation} RMSE = \\sqrt{\\frac{\\sum_{i=1}^n(y_i - \\hat{y_i})^2}{n}} \\tag{8.12} \\end{equation}\\] Il sagit de la racine carrée de la moyenne des écarts au carré entre valeurs réelles et prédites. Le RMSE est exprimé dans la même unité que la donnée originale et nous donne une indication sur lerreur moyenne de la prédiction du modèle. Admettons, par exemple, que nous modélisons les niveaux de bruit environnemental en ville en décibels et que notre modèle de régression ait un RMSE de 3,5. Cela signifierait quen moyenne notre modèle se trompe de 3,5 décibels (erreur pouvant être négative ou positive), ce qui serait énorme (3 décibels correspond à une multiplication par deux de lintensité sonore) et nous amènerait à reconsidérer la fiabilité du modèle. Notez que lusage dune moyenne quadratique plutôt quune moyenne arithmétique permet de donner plus dinfluence aux larges erreurs et donc de pénaliser davantage des modèles faisant parfois de grosses erreurs de prédiction. Le RMSE est donc très sensible à la présence de valeurs aberrantes. À la place de la moyenne quadratique, il est possible dutiliser la simple moyenne arithmétique des valeurs absolues des erreurs (MAE). Cette mesure est cependant moins souvent utilisée : \\[\\begin{equation} MAE = \\frac{\\sum_{i=1}^n|y_i - \\hat{y_i|}}{n} \\tag{8.13} \\end{equation}\\] Ces deux mesures peuvent être utilisées pour comparer la capacité de prédiction de deux modèles appliqués aux mêmes données, même sils ne sont pas imbriqués. Elles ne permettent cependant pas de prendre en compte la complexité du modèle. Un modèle plus complexe aura toujours des valeurs de RMSE et de MAE plus faibles. 8.1.5.3.2 Pour une variable qualitative Lorsque lon modélise une variable qualitative, une erreur revient à prédire la mauvaise catégorie pour une observation. Il est ainsi possible de compter, pour un modèle, le nombre de bonnes et de mauvaises prédictions et dorganiser cette information dans une matrice de confusion. Cette dernière prend la forme suivante pour un modèle binaire : Tableau 8.2: Exemple de matrice de confusion Valeur prédite / Valeur réelle A B Total (%) A 15 3 18 (41,9) B 5 20 25 (51,1) Total (%) 20 (46,6) 23 (53,5) 43 (81,4) En colonne du tableau 8.2, nous avons les catégories observées et en ligne, les catégories prédites. La diagonale représente les prédictions correctes. Dans le cas présent, le modèle a bien catégorisé 35 (15 + 20) observations sur 43, soit une précision totale de 81,4 %; huit sont mal classifiées (18,6 %); cinq avec la modalité A ont été catégorisées comme des B, soit 20 % des A, et seuls trois B ont été catégorisées comme des A (13 %). La matrice ci-dessus (tableau 8.2) ne comporte que deux catégories possibles puisque la variable Y modélisée est binaire. Il est facile détendre le concept de matrice de confusion au cas des variables avec plus de deux modalités (multinomiale). Le tableau 8.3 est un exemple de matrice de confusion multinomiale. Tableau 8.3: Exemple de matrice de confusion multinomiale Valeur prédite / Valeur réelle A B C D Total (%) A 15 3 1 5 24 (18,7) B 5 20 2 12 39 (30,4) C 2 10 25 8 45 (35,2) D 1 0 5 14 20 (15,6) Total (%) 23 (18,1) 33 (25,7) 33 (25,7) 39 (30,5) 128 Trois mesures pour chaque catégorie peuvent être utilisées pour déterminer la capacité de prédiction du modèle : La précision (precision en anglais), soit le nombre de fois où une catégorie a été correctement prédite, divisée par le nombre de fois où la catégorie a été prédite. Le rappel (recall en anglais), soit le nombre de fois où une catégorie a été correctement prédite divisée par le nombre de fois où elle se trouve dans les données originales. Le score F1 est la moyenne harmonique entre la précision et le rappel, soit : \\[\\begin{equation} \\text{F1} = 2 \\times \\frac{\\text{précision} \\times \\text{rappel}}{\\text{précision} + \\text{rappel}} \\tag{8.14} \\end{equation}\\] Il est possible de calculer les moyennes pondérées des différents indicateurs (macro-indicateurs) afin de disposer dune valeur densemble pour le modèle. La pondération est faite en fonction du nombre de cas observé de chaque catégorie; lidée étant quil est moins grave davoir des indicateurs plus faibles pour des catégories moins fréquentes. Cependant, il est tout à fait possible que cette pondération ne soit pas souhaitable. Cest par exemple le cas dans de nombreuses études en santé portant sur des maladies rares où lattention est concentrée sur ces catégories peu fréquentes. Le coefficient de Kappa (variant de 0 à 1) peut aussi être utilisé pour quantifier la fidélité générale de la prédiction du modèle. Il est calculé avec léquation (8.15) : \\[\\begin{equation} k = \\frac{Pr(a)-Pr(e)}{1-Pr(e)} \\tag{8.15} \\end{equation}\\] avec \\(Pr(a)\\) la proportion daccord entre les catégories observées et les catégories prédites, et \\(Pr(e)\\) la probabilité dun accord alétoire entre les catégories observées et les catégories prédites (équation (8.16)) \\[\\begin{equation} Pr(e) = \\sum^{J}_{j=1} \\frac{Cnt_{prédit}(j)}{n\\times2} \\times \\frac{Cnt_{réel}(j)}{n\\times2} \\tag{8.16} \\end{equation}\\] avec n le nombre dobservations, \\(Cnt_{prédit}(j)\\) le nombre de fois où le modèle prédit la catégorie j et \\(Cnt_{réel}(j)\\) le nombre de fois où la catégorie j a été observée. Pour linterprétation du coefficient de Kappa, référez-vous au tableau 8.4. Tableau 8.4: Inteprétation des valeurs du coefficient de Kappa K Interprétation &lt; 0 Désaccord 0 - 0,20 Accord très faible 0,21 - 0,40 Accord faible 0,41 - 0,60 Accord modéré 0,61 - 0,80 Accord fort 0,81 - 1 Accord presque parfait Enfin, un test statistique basé sur la distribution binomiale peut être utilisé pour vérifier que le modèle atteint un niveau de précision supérieur au seuil de non-information. Ce seuil correspond à la proportion de la modalité la plus présente dans le jeu de données. Dans la matrice de confusion utilisée dans le tableau 8.4, ce seuil est de 30,5 % (catégorie D), ce qui signifie quun modèle prédisant tout le temps la catégorie D aurait une précision de 30,5 % pour cette catégorie. Il est donc nécessaire que notre modèle fasse mieux que ce seuil. Dans le cas de la matrice de confusion du tableau 8.3, nous obtenons donc les valeurs affichées dans le tableau 8.5. Tableau 8.5: Indicateurs de qualité de prédiction précision rappel F1 A 65,2 31,3 42,3 B 60,6 25,6 36,0 C 75,8 27,8 40,7 D 35,9 35,0 35,4 macro 57,8 30,0 38,2 Kappa 0,44 Valeur de p (précision &gt; NIR) &lt; 0,0001 À la lecture du tableau 8.5, nous remarquons que : la catégorie D est la moins bien prédite des quatre catégories (faible précision et faible rappel); la catégorie C a une forte précision, mais un faible rappel, ce qui signifie que de nombreuses observations étant originalement des A, B ou D ont été prédites comme des C. Ce constat est également vrai pour la catégorie B; le coefficient de Kappa indique un accord modéré entre les valeurs originales et la prédiction; la probabilité que la précision du modèle ne dépasse pas le seuil de non-information est inférieure à 0,001, indiquant que le modèle à une précision supérieure à ce seuil. 8.1.6 Comparaison de deux modèles GLM Tel quabordé dans le chapitre sur les régressions linéaires classiques, il est courant de comparer plusieurs modèles imbriqués (section 7.3.2). Cette procédure permet de déterminer si lajout dune ou de plusieurs variables contribue à significativement améliorer le modèle. Il est possible dappliquer la même démarche aux GLM à laide du test de rapport de vraisemblance (likelihood ratio test). Le principe de base de ce test est de comparer le likelihood de deux modèles GLM imbriqués; la valeur de ce test se calcule avec léquation suivante : \\[\\begin{equation} LR = 2(loglik(M_2) - loglik(M_1)) \\tag{8.17} \\end{equation}\\] avec \\(M_2\\) un modèle reprenant toutes les variables du modèle \\(M_1\\), impliquant donc que \\(loglik(M_2) &gt;= loglik(M_1)\\). Avec ce test, nous supposons que le modèle \\(M_2\\), qui comporte plus de paramètres que le modèle \\(M_1\\), devrait être mieux ajusté aux données. Si cest bien le cas, la différence entre les loglikelihood de deux modèles devrait être supérieure à zéro. La valeur calculée LR suit une distribution du khi-deux avec un nombre de degrés de liberté égal au nombre de paramètres supplémentaires dans le modèle \\(M_2\\) comparativement à \\(M_1\\). Avec ces deux informations, il est possible de déterminer la valeur de p associée à ce test et de déterminer si \\(M_2\\) est significativement mieux ajusté que \\(M_1\\) aux données. Notez quil existe aussi deux autres tests (test de Wald et test de Lagrange) ayant la même fonction. Il sagit, dans les deux cas, dapproximation du test de rapport des vraisemblances dont la puissance statistique est inférieure au test de rapport de vraisemblance (Neyman, Pearson et Pearson 1933). Dans les prochaines sections, nous décrivons les modèles GLM les plus couramment utilisés. Il en existe de nombreuses variantes que nous ne pouvons pas toutes décrire ici. Lobjectif est de comprendre les rouages de ces modèles afin de pouvoir, en cas de besoin, transposer ces connaissances sur des modèles plus spécifiques. Pour faciliter la lecture de ces sections, nous vous proposons une carte didentité de chacun des modèles présentés. Elles contiennent lensemble des informations pertinentes à retenir pour chaque modèle. References "],["sect082.html", "8.2 Modèles GLM pour des variables qualitatives", " 8.2 Modèles GLM pour des variables qualitatives Nous abordons en premier les principaux GLM utilisés pour modéliser des variables binaires, multinomiales et ordinales. Prenez bien le temps de saisir le fonctionnement du modèle logistique binomial, car il sert de base pour les trois autres modèles présentés. 8.2.1 Modèle logistique binomial Le modèle logistique binomial est une généralisation du modèle de Bernoulli que nous avons présenté dans lintroduction de cette section. Le modèle logistique binomiale couvre donc deux cas de figure : La variable observée est binaire (0 ou 1). Dans ce cas, le modèle logistique binomiale devient un simple modèle de Bernoulli. La variable observée est un comptage (nombre de réussites) et nous disposons dune autre variable avec le nombre de réplications de lexpérience. Par exemple, pour chaque intersection dun réseau routier, nous pourrions avoir le nombre de décès à vélo (variable Y de comptage) et le nombre de collisions vélo / automobile (variable quantifiant le nombre dexpériences, chaque collision étant une expérience). Spécifiquement, nous tentons de prédire le paramètre p de la distribution binomiale à laide de notre équation de régression et de la fonction logistique comme fonction de lien. Notez ici que cette fonction de lien influence directement linterprétation des paramètres du modèle. Pour rappel, cette fonction est définie comme : \\[\\begin{equation} g(x) = ln(\\frac{x}{1-x}) \\end{equation}\\] avec \\(ln\\) le logarithme naturel. Au-delà de sa propriété mathématique assurant que \\(g(x) \\in \\mathopen[0,1\\mathclose]\\), cette fonction offre une interprétation intéressante. La partie \\(\\frac{x}{1-x}\\) est une cote et sinterprète en termes de chances dobserver un évènement. Par exemple, dans le cas des accidents de cyclistes, si la probabilité dobserver un décès suite à une collision est de 0,1, alors la cote de cet évènement est \\(\\frac{\\frac{1}{10}}{\\frac{9}{10}} = \\frac{1}{9}\\) soit un contre neuf. Dans un modèle GLM logistique, les coefficients ajustés pour les variables indépendantes représentent des logarithmes de rapport de cote, car ils comparent les chances dobserver lévènement (y = 1) en fonction des valeurs des variables indépendantes. Tableau 8.6: Carte didentité du modèle logistique binomial Type de variable dépendante Variable binaire (0 ou 1) ou comptage de réussite à une expérience (ex : 3 réussites sur 5 expériences) Distribution utilisée Binomiale Formulation \\(Y \\sim Binomial(p)\\) \\(g(p) = \\beta_0 + \\beta X\\) \\(g(x) = log(\\frac{x}{1-x})\\) Fonction de lien Logistique Paramètre modélisé p Paramètres à estimer \\(\\beta_0\\), \\(\\beta\\) Conditions dapplication Non-séparation complète, absence de sur-dispersion ou de sous-dispersion 8.2.1.1 Interprétation des paramètres Les seuls paramètres à estimer du modèle sont les coefficients \\(\\beta\\) et la constante \\(\\beta_0\\). La fonction de lien logistique transforme la valeur de ces coefficients, en conséquence, ils ne peuvent plus être interprétés directement. \\(\\beta_0\\) et \\(\\beta\\) sont exprimés dans une unité particulière: des logarithmes de rapports de cote (log odd ratio). Le rapport de cote est relativement facile à interpréter contrairement à son logarithme. Pour lobtenir, il suffit dutiliser la fonction exponentielle (linverse de la fonction logarithme) pour passer des log rapport de cote à de simples rapports de cote. Donc si \\(exp(\\beta)\\) est inférieur à 1, il réduit les chances dobserver lévènement et inversement si \\(exp(\\beta)\\) est supérieur à 1. Par exemple, admettons que nous ayons un coefficient \\(\\beta_1\\) de 1,2 pour une variable \\(X_1\\) dans une régression logistique. Il est nécessaire dutiliser son exponentiel pour linterpréter de façon intuitive. \\(exp\\mbox{(1,2)} = \\mbox{3,32}\\), ce qui signifie que lorsque \\(X_1\\) augmente dune unité, les chances dobserver 1 plutôt que 0 comme valeur de Y sont multipliées par 3,32. Admettons maintenant que \\(\\beta_1\\) vaille 1,2, nous calculons donc \\(exp\\mbox{(-1,2) = 0,30}\\), ce qui signifie quà chaque augmentation dune unité de \\(X_1\\), les chances dobserver 1 plutôt que 0 comme valeur de Y sont multipliées par 0,30. En dautres termes,les chances dobserver 1 plutôt que 0 sont divisées par 3,33 (\\(\\mbox{1}/\\mbox{0,30} = \\mbox{3,33}\\)), soit une diminution de 70 % (\\(\\mbox{1}-\\mbox{0,3} = \\mbox{0,7}\\)) des chances dobserver 1 plutôt que 0. Les rapports de cotes Le rapport de cote ou rapport des chances est une mesure utilisée pour exprimer leffet dun facteur sur une probabilité. Il est très utilisé dans le domaine de la santé, mais aussi des paris. Prenons un exemple concret avec le port du casque à vélo. Si sur 100 accidents impliquant des cyclistes portant un casque, nous observons seulement 3 cas de blessures graves à la tête, contre 15 dans un second groupe de 100 cyclistes ne portant pas de casque, nous pouvons calculer le rapport de cote suivant : \\[\\begin{equation} \\frac{p(1-q)}{q(1-p)} = \\frac{\\mbox{0,15} \\times (\\mbox{1}-\\mbox{0,03})}{\\mbox{0,03} \\times (\\mbox{1}-\\mbox{0,15})} = \\mbox{5,71} \\end{equation}\\] avec p la probabilité dobserver le phénomène (ici la blessure grave à la tête) dans le groupe 1 (ici les cyclistes sans casque) et q la probabilité dobserver le phénomène dans le groupe 2 (ici les cyclistes avec un casque). Ce rapport de cote indique que les cyclistes sans casques ont 5,71 fois plus de risques de se blesser gravement à la tête lors dun accident comparativement aux cyclistes portant un casque. 8.2.1.2 Conditions dapplication La non-séparation complète signifie quaucune des variables X nest, à elle seule, capable de parfaitement distinguer les deux catégories 0 et 1 de la variable Y. Dans un tel cas de figure, les algorithmes dajustement utilisés pour estimer les paramètres des modèles sont incapables de converger. Notez aussi labsurdité de créer un modèle pour prédire une variable Y si une variable X est capable à elle seule de la prédire à coup sûr. Ce problème est appelé un effet de Hauck-Donner. Il est assez facile de le repérer, car la plupart du temps les fonctions de R signalent ce problème (message derreur sur la convergence). Sinon, des valeurs extrêmement élevées ou faibles pour certains rapports de cote peuvent aussi indiquer un effet de Hauck-Donner. La sur-dispersion est un problème spécifique aux distributions nayant pas de paramètre de dispersion (binomiale, de Poisson, exponentielle, etc.), pour lesquelles la variance dépend directement de lespérance. La sur-dispersion désigne une situation dans laquelle les résidus (ou erreurs) dun modèle sont plus dispersés que ce que suppose la distribution utilisée. À linverse, il est aussi possible (mais rare) dobserver des cas de sous-dispersion (lorsque la dispersion des résidus est plus petite que ce que suppose la distribution choisie). Ce cas de figure se produit généralement lorsque le modèle parvient à réaliser une prédiction trop précise pour être crédible. Si vous rencontrez une forte sous-dispersion, cela signifie souvent que lune de vos variables indépendantes provoque une séparation complète. La meilleure option, dans ce cas, est de supprimer la variable en question du modèle. La variance attendue dune distribution binomiale est \\(nb \\times p \\times(1-p)\\), soit le produit entre le nombre de tirages, la probabilité de réussite et la probabilité déchec. À titre dexemple, si nous considérons une distribution binomiale avec un seul tirage et 50 % de chances de réussite, sa variance serait : \\(1 \\times \\mbox{0,5} \\times \\mbox{(1}-\\mbox{0,5}) = \\mbox{0,25}\\). Plusieurs raisons peuvent expliquer la présence de sur-dispersion dans une modèle: il manque des variables importantes dans le modèle, conduisant à un mauvais ajustement et donc une sur-dispersion des erreurs; les observations ne sont pas indépendantes, impliquant quune partie de la variance nest pas contrôlée et augmente les erreurs; la probabilité de succès de chaque expérience varie dune répétition à lautre (différentes distributions). La conséquence directe de la sur-dispersion est la sous-estimation de la variance des coefficients de régression. En dautres termes, la sur-dispersion conduit à sous-estimer notre incertitude quant aux coefficients obtenus et réduit les valeurs de p calculées pour ces coefficients. Les risques de trouver des résultats significatifs à cause des fluctuations déchantillonnage augmentent. Pour détecter une sur-dispersion ou une sous-dispersion dans un modèle logistique binomial, il est possible dobserver les résidus de déviance du modèle. Ces derniers sont supposés suivre une distribution du khi-deux avec nk degrés de liberté (avec n le nombre dobservations et k le nombre de coefficients dans le modèle). Par conséquent, la somme des résidus de déviance dun modèle logistique binomiale divisée par le nombre de degrés de liberté devrait être proche de 1. Une légère déviation (jusquà 0,15 au-dessus ou au-dessous de 1) nest pas alarmante; au-delà, il est nécessaire dajuster le modèle. Notez que si la variable Y modélisée est exactement binaire (chaque expérience est indépendante et nest composée que dun seul tirage) et que le modèle utilise donc une distribution de Bernoulli, le test précédent pour détecter une éventuelle sur-dispersion nest pas valide. Hilbe (2009) parle de sur-dispersion implicite pour le modèle de Bernoulli et recommande notamment de toujours ajuster les erreurs standards des modèles utilisant des distributions de Bernoulli, binomiale et de Poisson. Lidée ici est déviter dêtre trop optimiste face à lincertitude du modèle sur les coefficients et de lajuster en conséquence. Pour cela, il est possible dutiliser des quasi-distributions ou des estimateurs robustes (Zeileis 2004). Notez que si le modèle ne souffre pas de sur ou sous-dispersion, ces ajustements produisent des résultats équivalents aux résultats non ajustés. 8.2.1.3 Exemple appliqué dans R Présentation des données Pour illustrer le modèle logistique binomial, nous utilisons ici un jeu de données proposé par lUnion européenne : lenquête de déplacement sur la demande pour des systèmes de transports innovants. Pour cette enquête, un échantillon de 1 000 individus représentatifs de la population a été constitué dans chacun des 26 États membres de lUE, soit un total de 26 000 observations. Pour chaque individu, plusieurs informations ont été collectées relatives à la catégorie socioprofessionnelle, le mode de transport le plus fréquent, le temps du trajet de son déplacement le plus fréquent et son niveau de sensibilité à la cause environnementale. Nous modélisons ici la probabilité quun individu déclare utiliser le plus fréquemment le vélo comme moyen de transport. Les variables explicatives sont résumées au tableau 8.7. Il existe bien évidemment un grand nombre de facteurs individuels qui influence la prise de décision sur le mode de transport. Les résultats de ce modèle ne doivent donc pas être pris avec un grand sérieux; il est uniquement construit à des fins pédagogiques, sans cadre conceptuel solide. Tableau 8.7: Variables indépendantes utilisées pour prédire le mode de transport le plus utilisé Nom de la variable Signification Type de variable Mesure Pays Pays de résidence Variable multinomiale Le nom dun des 26 pays membres de lUE Sexe Sexe biologique Variable binaire Homme ou femme Age Âge biologique Variable continue Lâge en nombre dannées variant de 16 à 84 ans dans le jeu de données Education Niveau déducation maximum atteint Variable multinomiale Premier cycle, secondaire inférieur (classes supérieures de lécole élémentaire), secondaire, troisième cycle StatutEmploi Employé ou non Variable binaire Employé ou non Revenu Niveau de revenu autodéclaré Variable multinomiale Très faible revenu, faible revenu, revenu moyen, revenu élevé, revenu très élevé, sans reponse Residence Lieu de résidence Variable multinomiale Zone rurale, petite ou moyenne ville (moins de 250 000 habitants), grande ville (entre 250 000 et 1 million dhabitants) , aire métropolitaine (plus dun million dhabitants) Duree Durée du voyage le plus fréquent autodéclarée (en minutes) Variable continue Nombre de minutes ConsEnv Préoccupation environnementale Variable ordinale Échelle de Likert de 1 à 10 Vérification des conditions dapplication La première étape de la vérification des conditions dapplication est de calculer les valeurs du facteur dinflation de variance (VIF) pour sassurer de labsence de multicolinéarité trop forte entre les variables indépendantes. Lensemble des valeurs de VIF sont inférieures à 5, indiquant labsence de multicolinéarité excessive dans le modèle. library(car) # Chargement des données dfenquete &lt;- read.csv(&quot;data/glm/enquete_transport_UE.csv&quot;, encoding = &#39;UTF-8&#39;) dfenquete$Pays &lt;- relevel(as.factor(dfenquete$Pays), ref = &quot;Allemagne&quot;) # Vérification du VIF model1 &lt;- glm(y ~ Pays + Sexe + Age + Education + StatutEmploi + Revenu + Residence + Duree + ConsEnv, family = binomial(link=&quot;logit&quot;), data = dfenquete ) vif(model1) ## GVIF Df GVIF^(1/(2*Df)) ## Pays 1.794797 27 1.010890 ## Sexe 1.028618 1 1.014208 ## Age 1.060256 1 1.029687 ## Education 1.428872 3 1.061285 ## StatutEmploi 1.151879 1 1.073256 ## Revenu 1.220934 5 1.020162 ## Residence 1.130526 3 1.020658 ## Duree 1.042638 1 1.021096 ## ConsEnv 1.090987 1 1.044503 La seconde étape de vérification est le calcul des distances de Cook et lidentification déventuelles valeurs aberrantes (figure 8.4). # Calcul et représentation des distances de Cook cookd &lt;- data.frame( dist = cooks.distance(model1), oid = 1:nrow(dfenquete) ) ggplot(cookd) + geom_point(aes(x = oid, y = dist ), color = rgb(0.1,0.1,0.1,0.4), size = 1)+ geom_hline(yintercept = 0.002, color = &quot;red&quot;)+ labs(x = &quot;observations&quot;, y = &quot;distance de Cook&quot;) + theme(axis.text.x = element_blank(), axis.ticks.x = element_blank()) Figure 8.4: Distances de Cook pour le modèle binomial avec toutes les observations Le calcul de la distance de Cook révèle un ensemble dobservations se démarquant nettement des autres (délimitées dans la figure 8.4 par la ligne rouge). Nous les isolons dans un premier temps pour les analyser. # Isoler les observations avec de très fortes valeurs de Cook # valeur seuil choisie : 0,002 cas_etranges &lt;- subset(dfenquete, cookd$dist&gt;=0.002) cat(nrow(cas_etranges),&#39;observations se démarquant dans le modèle&#39;) ## 19 observations se démarquant dans le modèle print(cas_etranges) ## X y Pays Sexe Age Education Statut_emploi ## 7660 7660 1 Slovaquie homme 50 universite Employed ## 25150 25150 1 Malte homme 16 secondaire Not Employed ## 25227 25227 1 Malte femme 53 secondaire inferieur Not Employed ## 25309 25309 1 Malte femme 32 secondaire Employed ## 25322 25322 1 Malte homme 38 universite Employed ## 25536 25536 1 Malte homme 27 universite Employed ## 25541 25541 1 Malte homme 38 secondaire inferieur Employed ## 25549 25549 1 Malte homme 31 universite Employed ## 25690 25690 1 Luxembourg homme 32 universite Employed ## 26190 26190 1 Chypre homme 24 secondaire Not Employed ## 26201 26201 1 Chypre homme 25 secondaire Employed ## 26244 26244 1 Chypre homme 32 secondaire Employed ## 26269 26269 1 Chypre homme 60 secondaire Not Employed ## 26303 26303 1 Chypre homme 59 secondaire Not Employed ## 26393 26393 1 Chypre homme 30 premier cycle Employed ## 26444 26444 1 Chypre femme 52 universite Employed ## 26516 26516 1 Chypre homme 21 universite Not Employed ## 26549 26549 1 Chypre homme 28 universite Employed ## 26600 26600 1 Chypre homme 36 secondaire Employed ## Revenu Residence Duree mode_pref StatutEmploi ConsEnv ## 7660 moyen zone rurale 775 velo employe 7 ## 25150 moyen zone rurale 15 velo sans emploi 3 ## 25227 moyen zone rurale 45 marche sans emploi 5 ## 25309 moyen petite-moyenne ville 25 marche employe 4 ## 25322 eleve zone rurale 30 marche employe 10 ## 25536 tres eleve petite-moyenne ville 14 velo employe 10 ## 25541 moyen zone rurale 5 marche employe 8 ## 25549 sans reponse petite-moyenne ville 60 velo employe 10 ## 25690 tres eleve petite-moyenne ville 720 velo employe 6 ## 26190 moyen grande ville 20 velo sans emploi 5 ## 26201 faible zone rurale 20 velo employe 5 ## 26244 tres faible petite-moyenne ville 18 velo employe 4 ## 26269 moyen petite-moyenne ville 5 velo sans emploi 7 ## 26303 moyen zone rurale 7 velo sans emploi 8 ## 26393 tres eleve petite-moyenne ville 61 velo employe 5 ## 26444 eleve petite-moyenne ville 120 velo employe 3 ## 26516 moyen petite-moyenne ville 25 velo sans emploi 8 ## 26549 tres faible petite-moyenne ville 15 velo employe 2 ## 26600 moyen petite-moyenne ville 8 velo employe 1 À la lecture des valeurs pour ces 19 cas étranges, nous remarquons que la plupart des observations proviennent de Malte et de Chypre. Ces deux petites îles constituent des cas particuliers en Europe et devraient vraisemblablement faire lobjet dune analyse séparée. Nous décidons donc de les retirer du jeu de données. Deux autres observations étranges sont observables en Slovaquie et au Luxembourg. Dans les deux cas, les répondants ont renseigné des temps de trajet fantaisistes de respectivement 775 et 720 minutes. Nous les retirons donc également de lanalyse. # Retirer les observations aberrantes dfenquete2 &lt;- subset(dfenquete, (dfenquete$Pays %in% c(&quot;Malte&quot;, &quot;Chypre&quot;)) == F &amp; dfenquete$Duree &lt; 400) # Réajuster le modèle model2 &lt;- glm(y ~ Pays + Sexe + Age + Education + StatutEmploi + Revenu + Residence + Duree + ConsEnv, family = binomial(link=&quot;logit&quot;), data = dfenquete2) # Recalculer la distance de Cook cookd &lt;- data.frame( dist = cooks.distance(model2), oid = 1:nrow(dfenquete2) ) ggplot(cookd) + geom_point(aes(x = oid, y = dist ), color = rgb(0.1,0.1,0.1,0.4), size = 1)+ labs(x = &quot;observations&quot;, y = &quot;distance de Cook&quot;) + theme(axis.text.x = element_blank(), axis.ticks.x = element_blank()) Figure 8.5: Distances de Cook pour le modèle binomial sans les valeurs aberrantes Après avoir retiré ces valeurs aberrantes, nous nobservons plus de nouveaux cas singuliers avec les distances de Cook (figure 8.5). La prochaine étape de vérification des conditions dapplication est lanalyse des résidus simulés. Nous commençons donc par calculer ces résidus et afficher leur histogramme (figure 8.6). library(DHARMa) # Extraire les probabilités prédites par le modèle probs &lt;- predict(model2, type = &quot;response&quot;) # Calculer 1000 simulations a partir du modele ajuste sims &lt;- lapply(1:length(probs), function(i){ p &lt;- probs[[i]] vals &lt;- rbinom(n = 1000, size = 1,prob = p) }) matsim &lt;- do.call(rbind,sims) # Utiliser le package DHARMa pour calculer les résidus simulés sim_res &lt;- createDHARMa(simulatedResponse = matsim, observedResponse = dfenquete2$y, fittedPredictedResponse = probs, integerResponse = T) ggplot()+ geom_histogram(aes(x = residuals(sim_res)), bins = 30, fill = &quot;white&quot;, color = rgb(0.3,0.3,0.3))+ labs(x=&quot;résidus simulés&quot;, y=&quot;fréquence&quot;) Figure 8.6: Distribution des résidus simulés pour le modèle binomial Lhistogramme indique clairement que les résidus simulés suivent une distribution uniforme (figure 8.6). Il est possible daller plus loin dans le diagnostic en utilisant la fonction plot sur lobjet sim_res. La partie de droite de la figure ainsi obtenue (figure 8.7) est un diagramme de quantiles-quantiles (ou Q-Q plot). Les points du graphique sont supposés suivre une ligne droite matérialisée par la ligne rouge. Une déviation de cette ligne indique un éloignement des résidus de leur distribution attendue. Trois tests sont également réalisés par la fonction : Le premier (Test de Kolmogorov-Smirnov, KS test) permet de tester si les points dévient significativement de la ligne droite. Dans notre cas, la valeur de p nest pas significative, indiquant que les résidus ne dévient pas de la distribution uniforme. Le second test permet de vérifier la présence de sur ou sous-dispersion. Dans notre cas, ce test nest pas significatif, nindiquant aucun problème de sur-dispersion ou de sous-dispersion. Le dernier test permet de vérifier si des valeurs aberrantes sont présentes dans les résidus. Une valeur non significative indique une absence de valeurs aberrantes. Le second graphique permet de comparer les résidus et les valeurs prédites. Lidéal est donc dobserver une ligne droite horizontale au milieu du graphique qui indiquerait une absence de relation entre les valeurs prédites et les résidus (ce que nous observons bien ici). plot(sim_res) Figure 8.7: Diagnostic des résidus simulés par le package DHARMa Lanalyse approfondie des résidus nous permet donc de conclure que le modèle respecte les conditions dapplication et que nous pouvons passer à la vérification de la qualité dajustement du modèle. Vérification de la qualité dajustement Pour calculer les différents R2 dun modèle GLM, nous proposons la fonction suivante : rsqs &lt;- function(loglike.full, loglike.null,full.deviance, null.deviance, nb.params, n){ # Calcul de la déviance expliquée explained_dev &lt;- 1-(full.deviance / null.deviance) K &lt;- nb.params # R2 de McFadden ajusté r2_faddenadj &lt;- 1- (loglike.full - K) / loglike.null Lm &lt;- loglike.full Ln &lt;- loglike.null # R2 de Cox and Snell Rcs &lt;- 1 - exp((-2/n) * (Lm-Ln)) # R2 de Nagelkerke Rn &lt;- Rcs / (1-exp(2*Ln/n)) return( list(&quot;deviance expliquee&quot; = explained_dev, &quot;McFadden ajuste&quot; = r2_faddenadj, &quot;Cox and Snell&quot; = Rcs, &quot;Nagelkerke&quot; = Rn ) ) } Nous lutilisons pour lensemble des modèles GLM de ce chapitre. Dans le cas du modèle binomial, nous obtenons : # Ajuster un modele null avec seulement une constante model2.null &lt;- glm(y ~1, family = binomial(link=&quot;logit&quot;), data = dfenquete2) # Calculer les R2 rsqs(loglike.full = as.numeric(logLik(model2)), # loglikelihood du modèle complet loglike.null = as.numeric(logLik(model2.null)), # loglikelihood du modèle nul full.deviance = deviance(model2), # déviance du modèle complet null.deviance = deviance(model2.null), # déviance du modèle nul nb.params = model2$rank, # nombre de paramètres dans le modèle n = nrow(dfenquete2) # nombre d&#39;observations ) ## $`deviance expliquee` ## [1] 0.0876057 ## ## $`McFadden ajuste` ## [1] 0.08357379 ## ## $`Cox and Snell` ## [1] 0.0689509 ## ## $Nagelkerke ## [1] 0.1236597 La déviance expliquée par le modèle est de 8,8 %, les pseudos R2 de McFadden (ajusté), dEfron et de Nagelkerke sont respectivement 0,084, 0,069 et 0,124. Toutes ces valeurs sont relativement faibles et indiquent quune large partie de la variabilité de Y reste inexpliquée. Pour vérifier la qualité de prédiction du modèle, nous devons comparer les catégories prédites et les catégories réelles de notre variable dépendante et construire une matrice de confusion. Cependant, un modèle GLM binomial prédit la probabilité dappartenance au groupe 1 (ici les personnes utilisant le vélo pour effectuer leur déplacement le plus fréquent). Pour convertir ces probabilités prédites en catégories prédites, il faut choisir un seuil de probabilité au-delà duquel nous considérons que la valeur attendue est 1 (cycliste) plutôt que 0 (autre). Un exemple naïf serait de prendre le seuil 0,5, ce qui signifierait que si le modèle prédit quune observation a au moins 50 % de chance dêtre une personne à vélo, alors nous lattribuons à cette catégorie. Cependant, cette méthode est rarement optimale; il est donc plus judicieux de fixer le seuil de probabilité en trouvant le point déquilibre entre la sensibilité (proportion de 1 correctement identifiés) et la spécificité (proportion de 0 correctement identifiés). Ce point déquilibre est identifiable graphiquement en calculant la spécificité et la sensibilité de la prédiction selon toutes les valeurs possibles du seuil. library(ROCR) # Obtention des prédictions du modèle prob &lt;- predict(model2, type = &quot;response&quot;) # Calcul de la sensibilité et de la spécificité (package ROCR) predictions &lt;- prediction(prob, dfenquete2$y) sens &lt;- data.frame(x=unlist(performance(predictions, &quot;sens&quot;)@x.values), y=unlist(performance(predictions, &quot;sens&quot;)@y.values)) spec &lt;- data.frame(x=unlist(performance(predictions, &quot;spec&quot;)@x.values), y=unlist(performance(predictions, &quot;spec&quot;)@y.values)) # Trouver numériquement la valeur seuil (minimiser la différence absolue # entre sensibilité et spécificité) real &lt;- dfenquete2$y find_cutoff &lt;- function(seuil){ pred &lt;- ifelse(prob&gt;seuil,1,0) sensi &lt;- sum(real==1 &amp; pred==1) / sum(real==1) spec &lt;- sum(real==0 &amp; pred==0) / sum(real==0) return(abs(sensi-spec)) } prob_seuil &lt;- optimize(find_cutoff,interval = c(0,1), maximum = F)$minimum cat(&quot;Le seuil de probabilité à retenir équilibrant&quot;, &quot;la sensibilité et la spécificité est de&quot;,prob_seuil) ## Le seuil de probabilité à retenir équilibrant la sensibilité et la spécificité est de 0.14785 # Affichage du graphique ggplot() + geom_line(data = sens, mapping = aes(x = x, y = y)) + geom_line(data = spec, mapping = aes(x = x,y = y,col=&quot;red&quot;)) + scale_y_continuous(sec.axis = sec_axis(~., name = &quot;Spécificité&quot;)) + labs(x=&#39;Seuil de probabilité&#39;, y=&quot;Sensibilité&quot;) + geom_vline(xintercept = prob_seuil, color = &quot;black&quot;, linetype = &quot;dashed&quot;) + annotate(geom = &quot;text&quot;, x = prob_seuil, y = 0.01, label = round(prob_seuil,3))+ theme(axis.title.y.right = element_text(colour = &quot;red&quot;), legend.position=&quot;none&quot;) Figure 8.8: Point déquilibre entre sensibilité et spécificité Nous constatons à la figure 8.8 que si la valeur du seuil est 0 %, alors la prédiction a une sensibilité parfaite (le modèle prédit toujours 1, donc tous les 1 sont détectés); à linverse, si le seuil choisi est 100 %, alors la prédiction à une spécificité parfaite (le modèle prédit toujours 0, donc tous les 0 sont détectés). Dans notre cas, la valeur déquilibre est denviron 0,148, donc si le modèle prédit une probabilité au moins égale à 14,8 % quun individu utilise le vélo pour son déplacement le plus fréquent, nous devons lattribuer à la catégorie cycliste. Avec ce seuil, nous pouvons convertir les probabilités prédites en classes prédites et construire notre matrice de confusion. library(caret) # pour la matrice de confusion # Calcul des catégories prédites ypred &lt;- ifelse(predict(model2,type=&quot;response&quot;)&gt;0.148,1,0) info &lt;- confusionMatrix(as.factor(dfenquete2$y), as.factor(ypred)) # Affichage des valeurs brutes de la matrice de confusion print(info) ## Confusion Matrix and Statistics ## ## Reference ## Prediction 0 1 ## 0 14355 7576 ## 1 1251 2365 ## ## Accuracy : 0.6545 ## 95% CI : (0.6486, 0.6603) ## No Information Rate : 0.6109 ## P-Value [Acc &gt; NIR] : &lt; 2.2e-16 ## ## Kappa : 0.1783 ## ## Mcnemar&#39;s Test P-Value : &lt; 2.2e-16 ## ## Sensitivity : 0.9198 ## Specificity : 0.2379 ## Pos Pred Value : 0.6546 ## Neg Pred Value : 0.6540 ## Prevalence : 0.6109 ## Detection Rate : 0.5619 ## Detection Prevalence : 0.8585 ## Balanced Accuracy : 0.5789 ## ## &#39;Positive&#39; Class : 0 ## Les résultats proposés par le package caret sont exhaustifs; nous vous proposons ici une façon de les présenter dans deux tableaux : lun présente la matrice de confusion (tableau 8.8) et lautre, les indicateurs de qualité de prédiction (tableau 8.9). Tableau 8.8: Matrice de confusion pour le modèle binomial 0 (réel) 1 (réel) Total % 0 (prédit) 14355 7576 21931 85.8 1 (prédit) 1251 2365 3616 14.2 Total 15606 9941 25547 % 61.1 38.9 Daprès ces indicateurs, nous constatons que le modèle a une capacité de prédiction relativement faible, mais tout de même significativement supérieure au seuil de non-information. La valeur de rappel pour la catégorie 1 (cycliste) est faible, indiquant que le modèle a manqué un nombre important de cyclistes lors de sa prédiction. Tableau 8.9: Matrice de confusion pour le modèle binomial Précision Rappel F1 0 0.65 0.92 0.76 1 0.65 0.24 0.35 macro 0.65 0.65 0.6 Kappa 0.18 Valeur de p (précision &gt; NIR) &lt; 0,0001 Interprétation des résultats du modèle Linterprétation des résultats dun modèle binomial passe par la lecture des rapports de cotes (exponentiel des coefficients) et de leurs intervalles de confiance. Nous commençons donc par calculer la version robuste des erreurs standards des coefficients : library(sandwich) # pour calculer les erreurs standards robustes covModel2 &lt;- vcovHC(model2, type = &quot;HC0&quot;) # méthode HC0, basée sur les résidus stdErrRobuste &lt;- sqrt(diag(covModel2)) # extraire la diagonale # Extraction des coefficients coeffs &lt;- model2$coefficients # Recalcul des scores Z zvalRobuste &lt;- coeffs / stdErrRobuste # Recalcul des valeurs de P pvalRobuste &lt;- 2 * pnorm(abs(zvalRobuste), lower.tail = FALSE) # Calcul des rapports de cote oddRatio &lt;- exp(coeffs) # Calcul des intervalles de confiance à 95 % des rapports de cote lowerBound &lt;- exp(coeffs - 1.96 * stdErrRobuste) upperBound &lt;- exp(coeffs + 1.96 * stdErrRobuste) # Étoiles pour les valeurs de p starsp &lt;- case_when(pvalRobuste &lt;= 0.001 ~ &quot;***&quot;, pvalRobuste &gt; 0.001 &amp; pvalRobuste &lt;= 0.01 ~ &quot;**&quot;, pvalRobuste &gt; 0.01 &amp; pvalRobuste &lt;= 0.05 ~ &quot;*&quot;, pvalRobuste &gt; 0.05 &amp; pvalRobuste &lt;= 0.1 ~ &quot;.&quot;, TRUE ~ &quot;&quot; ) # Compilation des résultats dans un tableau tableau_binom &lt;- data.frame( coefficients = coeffs, rap.cote = oddRatio, err.std = stdErrRobuste, score.z = zvalRobuste, p.val = pvalRobuste, rap.cote.2.5 = lowerBound, rap.cote.97.5 = upperBound, sign = starsp ) Considérant que la variable Pays a 24 modalités, il est plus judicieux de présenter ses 23 rapports de cotes sous forme dun graphique. Nous avons choisi lAllemagne comme catégorie de référence puisquelle fait partie des pays avec une importante part modale pour le vélo sans pour autant constituer un cas extrême comme le Danemark. # Isoler les ligne du tableau récapitualtif pour les pays paysdf &lt;- subset(tableau_binom, grepl(&quot;Pays&quot;,row.names(tableau_binom), fixed = T)) #paysdf$Pays &lt;- gsub(&quot;Pays&quot;,&quot;&quot;,row.names(paysdf),fixed=T) paysdf$Pays &lt;- substr(row.names(paysdf), 5, nchar(row.names(paysdf))) ggplot(data = paysdf) + geom_vline(xintercept = 1, color = &quot;red&quot;)+ #afficher la valeur de référence geom_errorbarh(aes(xmin = rap.cote.2.5, xmax = rap.cote.97.5, y = reorder(Pays, rap.cote)), height = 0)+ geom_point(aes(x = rap.cote, y = reorder(Pays, rap.cote))) + geom_text(aes(x = rap.cote.97.5, y = reorder(Pays, rap.cote), label = paste(&quot;RC : &quot;,round(rap.cote,2),sep=&quot;&quot;)), size = 3, nudge_x = 0.25)+ labs(x = &quot;Rapports de cote&quot;, y = &quot;Pays (référence : Allemagne)&quot;) Figure 8.9: Rapports de cote pour les différents pays de lUE Dans la figure 8.9, la barre horizontale pour chaque pays représente lintervalle de confiance de son rapport de cotes (le point); plus cette ligne est longue, plus grande est lincertitude autour de ce paramètre. Lorsque les lignes de deux pays se chevauchent, cela signifie quil ny a pas de différence significative au seuil 0,05 entre les rapports de cotes des deux pays. La ligne rouge tracée à x = 1, représente le rapport de cotes du pays de référence (ici lAllemagne). Nous constatons ainsi que comparativement à un individu vivant en Allemagne, ceux vivant au Danemark et aux Pays-Bas ont 2,4 fois plus de chances dutiliser le vélo pour leur déplacement le plus fréquent. Les Pays de lOuest (France, Luxembourg, Royaume-Uni, Irlande) et du Sud (Grèce, Italie, Espagne, Portugal) ont en revanche des rapports de cotes plus faibles. En France, les chances quun individu utilise le vélo pour son trajet le plus fréquent sont 3,22 (1/0,31) fois plus faibles que si lindividu vivait en Allemagne. Pour le reste des coefficients et des rapports de cotes, nous les rapportons dans le tableau 8.10. Tableau 8.10: Résultats du modèle binomial Variable Coefficient Rapport de cote Err.std Val.z P RC 2,5 % RC 97,5 % Constante -2,497 0,082 0,183 -13,674 0,000 0,058 0,118 Sexe ref : femme        homme 0,372 1,451 0,038 9,803 0,000 1,347 1,562 Age -0,009 0,991 0,002 -5,361 0,000 0,988 0,994 Education ref : premier cycle        secondaire 0,193 1,213 0,105 1,836 0,066 0,987 1,490 secondaire inferieur 0,301 1,351 0,114 2,649 0,008 1,081 1,687 universite 0,146 1,157 0,108 1,349 0,177 0,936 1,432 StatutEmploi ref : employe        sans emploi 0,257 1,293 0,043 6,045 0,000 1,190 1,405 Revenu ref : eleve        faible 0,077 1,080 0,072 1,067 0,286 0,938 1,244 moyen 0,042 1,043 0,065 0,639 0,523 0,917 1,185 sans reponse 0,217 1,242 0,102 2,120 0,034 1,016 1,517 tres eleve -0,120 0,887 0,188 -0,637 0,524 0,613 1,283 tres faible 0,240 1,271 0,086 2,776 0,006 1,073 1,505 Residence ref : aire metropolitaine        grande ville 0,273 1,314 0,070 3,911 0,000 1,146 1,507 petite-moyenne ville 0,277 1,319 0,061 4,503 0,000 1,169 1,487 zone rurale -0,119 0,888 0,069 -1,713 0,087 0,775 1,017 Duree -0,001 0,999 0,001 -0,981 0,326 0,998 1,001 ConsEnv 0,102 1,108 0,010 10,502 0,000 1,087 1,130 Les chances pour un individu dutiliser le vélo pour son trajet le plus fréquent sont augmentées de 45 % sil sagit dun homme plutôt quune femme. Pour lâge, nous constatons un effet relativement faible puisque chaque année supplémentaire réduit les chances quun individu utilise le vélo comme mode de transport pour son trajet le plus fréquent de 0,9 % \\(((\\mbox{0,991}-\\mbox{1})\\times\\mbox{100})\\). Le fait dêtre sans emploi augmente les chances dutiliser le vélo de 29 % comparativement au fait davoir un emploi. Concernant le niveau déducation, seul le coefficient pour le groupe des personnes de la catégorie « secondaire inférieure » est significatif, indiquant que les personnes de ce groupe ont 35 % de chances en plus dutiliser le vélo comme mode de transport pour leur déplacement le plus fréquent comparativement aux personnes de la catégorie « premier cycle ». Pour le revenu, seul le groupe avec de très faibles revenus se distingue significativement du groupe avec un revenu élevé avec un rapport de cotes de 1,27, soit 27 % de chances en plus dutiliser le vélo. Comparativement à ceux vivant dans une aire métropolitaine, les personnes vivant dans de petites, moyennes et grandes villes ont des chances accrues dutiliser le vélo comme mode de déplacement pour leur trajet le plus fréquent. En revanche, nous nobservons aucune différence entre la probabilité dutiliser le vélo dans une métropole et en zone rurale. La figure 8.10 permet de clairement visualiser cette situation. Rappelons que la référence est la situation : vivre dans une région métropolitaine, représentée par la ligne verticale rouge. Plusieurs pistes dinterprétation peuvent être envisagées pour ce résultat : En métropole et dans les zones rurales, les distances domicile-travail tendent à être plus grandes que dans les petites, moyennes et grandes villes. En métropole, le système de transport en commun est davantage développé et entre donc en concurrence avec les modes de transport actifs. # Isoler les lignes du tableau récapitualtif pour les lieux de résidence residdf &lt;- subset(tableau_binom, grepl(&quot;Residence&quot;,row.names(tableau_binom), fixed = T)) residdf$resid &lt;- gsub(&quot;Residence&quot;,&quot;&quot;,row.names(residdf),fixed=T) ggplot(data = residdf) + geom_vline(xintercept = 1, color = &quot;red&quot;)+ #afficher la valeur de référence geom_errorbarh(aes(xmin = rap.cote.2.5, xmax = rap.cote.97.5, y = resid), height = 0)+ geom_point(aes(x = rap.cote, y = resid)) + geom_text(aes(x = rap.cote.97.5, y = resid, label = paste(&quot;RC : &quot;,round(rap.cote,2),sep=&quot;&quot;)), size = 3, nudge_x = 0.1)+ labs(x = &quot;Rapports de cotes&quot;, y = &quot;Lieu de résidence (référence : aire métropolitaine)&quot;) Figure 8.10: Rapports de cote pour les différents lieux de résidence Il est aussi intéressant de noter que la durée des trajets ne semble pas influencer la probabilité dutiliser le vélo. Enfin, une conscience environnementale plus affirmée semble être associée avec une probabilité supérieure dutiliser le vélo pour son déplacement le plus fréquent, avec une augmentation des chances de 11 % pour chaque point supplémentaire sur léchelle de Likert. Afin de simplifier la présentation de certains résultats, il est possible de calculer exactement les prédictions réalisées par le modèle. Un bon exemple ici est le cas de la variable âge. À quelle différence pouvons-nous nous attendre entre deux individus identiques ayant seulement une différence dâge de 15 ans? Prenons comme individu un homme de 30 ans, vivant dans une grande ville allemande, ayant un niveau déducation de niveau secondaire, employé, dans la tranche de revenu moyen, déclarant effectuer un trajet de 45 minutes et ayant rapporté un niveau de conscience environnementale de 5 (sur 10). Nous pouvons prédire la probabilité quil utilise le vélo pour son trajet le plus fréquent en utilisant la formule suivante : \\(logit(p) = -\\mbox{2,497} + \\mbox{1} \\times \\mbox{0,372} + \\mbox{30} \\times -\\mbox{0,009} + \\mbox{1} \\times \\mbox{0,193} + \\mbox{1} \\times \\mbox{0,042} + \\mbox{1} \\times \\mbox{0,273} + \\mbox{45} \\times -\\mbox{0,001} + \\mbox{5} \\times \\mbox{0,102}\\) \\(p = exp(-\\mbox{2,497} + \\mbox{1} \\times \\mbox{0,372} + \\mbox{30} \\times -\\mbox{0,009} + \\mbox{1} \\times \\mbox{0,193} + \\mbox{1} \\times \\mbox{0,042} + 1 \\times \\mbox{0,273} + 45 \\times -\\mbox{0,001} + \\mbox{5} \\times \\mbox{0,102})/(\\mbox{1}+exp(-\\mbox{2,497} + 1 \\times \\mbox{0,372} + \\mbox{30} \\times-\\mbox{0,009} + 1 \\times \\mbox{0,193} + 1 \\times \\mbox{0,042} + \\mbox{1} \\times \\mbox{0,273} + \\mbox{45} \\times -\\mbox{0,001} + 5 \\times \\mbox{0,102})) = \\mbox{0,194}\\) Il y aurait 19,4 % de chances pour que cette personne soit cycliste. Comme cette probabilité dépasse le seuil que nous avons sélectionné, cette personne serait classée comme cycliste. Si nous augmentons son âge de 15 ans, nous obtenons : \\(p = exp(-\\mbox{2,497} + \\mbox{1} \\times \\mbox{0,372} + \\mbox{45} \\times \\mbox{-0,009} + \\mbox{1} \\times \\mbox{0,193} + \\mbox{1} \\times \\mbox{0,042} + \\mbox{1} \\times \\mbox{0,273} + \\mbox{45} \\times -\\mbox{0,001} + \\mbox{5} \\times \\mbox{0,102}) / (\\mbox{1}+exp(-\\mbox{2,497} + \\mbox{1} \\times \\mbox{0,372} + \\mbox{45} \\times -\\mbox{0,009} + \\mbox{1} \\times \\mbox{0,193} + \\mbox{1} \\times \\mbox{0,042} + \\mbox{1} \\times \\mbox{0,273} + \\mbox{45} \\times -\\mbox{0,001} + \\mbox{5} \\times \\mbox{0,102})) = \\mbox{0,174}\\) soit une réduction de 2 points de pourcentages. Il est également possible de représenter cette évolution sur un graphique pour montrer leffet sur létendue des valeurs possibles. Sur ces graphiques des effets marginaux, il est essentiel de représenter lincertitude quant à la prédiction. En temps normal, la fonction predict calcule directement lerreur standard de la prédiction et cette dernière peut être utilisée pour calculer lintervalle de confiance de la prédiction. Cependant, nous voulons ici utiliser nos erreurs standards robustes. Nous devons donc procéder par simulation pour déterminer lintervalle de confiance à 95 % de nos prédictions. Cette opération nécessite de réaliser plusieurs opérations manuellement dans R. # Créer un jeu de données fictif pour la prédiction mat &lt;- model.matrix(model2$terms, model2$model) age2seq &lt;- seq(20,80) mat2 &lt;- matrix(mat[1,], nrow=length(age2seq), ncol=length(mat[1,]), byrow=TRUE) colnames(mat2) &lt;- colnames(mat) mat2[,&quot;Age&quot;] &lt;- age2seq mat2[,&quot;PaysBelgique&quot;] &lt;- 0 mat2[,&quot;Duree&quot;] &lt;- 45 mat2[,&quot;ConsEnv&quot;] &lt;- 5 mat2[,&quot;StatutEmploisans emploi&quot;] &lt;- 0 mat2[,&quot;Residencegrande ville&quot;] &lt;- 1 mat2[,&quot;Educationsecondaire&quot;] &lt;- 1 mat2[,&quot;Sexehomme&quot;] &lt;- 1 mat2[,&quot;Revenumoyen&quot;] &lt;- 1 mat2[,&quot;Revenufaible&quot;] &lt;- 0 # Calculer la prédiction comme un log de rapport de cote (avec les erreurs standards) # en multipliant les coefficient par les valeurs des données fictives coeffs &lt;- model2$coefficients pred &lt;- coeffs %*% t(mat2) # Simulation de prédictions (toujours en log de rapport de cote) # Étape 1 : simuler 1000 valeurs pour chaque coefficient sim_coeffs &lt;- lapply(1:length(coeffs), function(i){ coef &lt;- coeffs[[i]] std.err &lt;- stdErrRobuste[[i]] vals &lt;- rnorm(n = 1000, mean = coef, sd = std.err) return(vals) }) mat_sim_coeffs &lt;- do.call(rbind,sim_coeffs) # Étape 2 : effectuer les prédictions à partir des coefficients simulés sim_preds &lt;- lapply(1:ncol(mat_sim_coeffs),function(i){ temp_coefs &lt;- mat_sim_coeffs[,i] temp_pred &lt;- as.vector(temp_coefs %*% t(mat2)) return(temp_pred) }) mat_sim_preds &lt;- do.call(cbind,sim_preds) # Étape 3 : extraire les intervalles de confiances pour les simulations intervals &lt;- apply(mat_sim_preds,MARGIN = 1, FUN = function(vec){ return(quantile(vec,probs = c(0.025, 0.975))) }) # Étape 4 : récupérer tous ces éléments dans un DataFrame df &lt;- data.frame( Age = seq(20,80), pred = as.vector(pred), lower = as.vector(intervals[1,]), upper = as.vector(intervals[2,]) ) # Étape 5 : appliquer l&#39;inverse de la fonction de lien pour # obtenir les prédictions en termes de probabilité ilink &lt;- family(model2)$linkinv df$prob_pred &lt;- ilink(df$pred) df$prob_lower &lt;- ilink(df$lower) df$prob_upper &lt;- ilink(df$upper) # Étape 6 : représenter le tout sur un graphique ggplot(df) + geom_ribbon(aes(x = Age, ymax = prob_upper, ymin = prob_lower), fill = rgb(0.1,0.1,0.1,0.4)) + geom_path(aes(x = Age, y = prob_pred), color = &quot;blue&quot;, size = 1) + geom_hline(yintercept = 0.15, linetype = &quot;dashed&quot;, size = 0.7) + labs(x = &quot;Âge&quot;, y = &quot;Probabilité prédite (intervalle de confiance à 95 %)&quot;) Figure 8.11: Effet de lâge sur la probabilité dutiliser le vélo comme moyen de déplacement pour son trajet le plus fréquent La figure 8.11 permet de bien constater la diminution de la probabilité dutiliser le vélo pour son trajet le plus fréquent avec lâge, mais cette réduction est relativement ténue. Dans le cas utilisé en exemple, lindividu ne serait plus classé cycliste quaprès 67 ans. 8.2.2 Modèle probit binomial Le modèle GLM probit binomial est pour ainsi dire le frère du modèle logistique binomial. La seule différence entre les deux réside dans lutilisation dune autre fonction de lien: probit plutôt que logistique. La fonction de lien probit () correspond à la fonction cumulative de la distribution normale et a également une forme de S. Cette version du modèle est plus souvent utilisée par les économistes. Le principal changement réside dans linterprétation des coefficients \\(\\beta_0\\) et \\(\\beta\\). Du fait de la transformation probit, ces derniers indiquent le changement en termes de scores Z de la probabilité modélisée. Vous conviendrez quil ne sagit pas dune échelle très intuitive; la plupart du temps, seuls la significativité et le signe (positif ou négatif) des coefficients sont interprétés. Tableau 8.11: Carte didentité du modèle probit binomial Type de variable dépendante Variable binaire (0 ou 1) ou comptage de réussite à une expérience (ex : 3 réussites sur 5 expériences) Distribution utilisée Binomiale Formulation \\(Y \\sim Binomial(p)\\) \\(g(p) = \\beta_0 + \\beta X\\) \\(g(x) = \\Phi^-1(x)\\) Fonction de lien probit Paramètre modélisé p Paramètres à estimer \\(\\beta_0\\), \\(\\beta\\) Conditions dapplication Non-séparation complète, absence de sur-dispersion ou de sous-dispersion 8.2.3 Modèle logistique des cotes proportionnelles Le modèle logistique des cotes proportionnelles (aussi appelé modèle logistique cumulatif) est utilisé pour modéliser une variable qualitative ordinale. Un exemple classique de ce type de variable est une échelle de satisfaction (très insatisfait, insatisfait, mitigé, satisfait, très satisfait) qui peut être recodée avec des valeurs numériques (0, 1, 2, 3, 4; ces échelons étant notés j). Il nexiste pas à proprement parler de distribution pour représenter ces données, mais avec une petite astuce, il est possible de simplement utiliser la distribution binomiale. Cette astuce consiste à poser lhypothèse de la proportionnalité des cotes, soit que le passage de la catégorie 0 à la catégorie 1 est proportionnel au passage de la catégorie 1 à la catégorie 2 et ainsi de suite. Si cette hypothèse est respectée, alors les coefficients du modèle pourront autant décrire le passage de la catégorie satisfait à celle très satisfait que le passage de insatisfait à mitigé. Si cette hypothèse nest pas respectée, il faudrait des coefficients différents pour représenter les passages dune catégorie à lautre (ce qui est le cas pour le modèle multinomial présenté dans la section 8.2.4). Tableau 8.12: Carte didentité du modèle logistique des cotes proportionnelles Type de variable dépendante Variable qualitative ordinale avec j catégories Distribution utilisée Binomiale Formulation \\(Y \\sim Binomial(p)\\) \\(g(p \\leq j) = \\beta_{0j} + \\beta X\\) \\(g(x) = log(\\frac{x}{1-x})\\) Fonction de lien logistique Paramètre modélisé p Paramètres à estimer \\(\\beta\\) et j-1 constantes \\(\\beta_{0j}\\) Conditions dapplication Non-séparation complète, absence de sur-dispersion ou de sous-dispersion, Proportionnalité des cotes Ainsi, dans le modèle logistique binomial vu précédemment, nous modélisons la probabilité dobserver un évènement \\(P(Y = 1)\\). Dans un modèle logistique ordinal, nous modélisons la probabilité cumulative dobserver léchelon j de notre variable ordinale \\(P(Y \\leq j)\\). Lintérêt de cette reformulation est que nous conservons la facilité dinterprétation du modèle logistique binomial classique avec les rapports de cotes, à ceci prêt quils représentent maintenant la probabilité de passer à un échelon supérieur de Y. La différence pratique est que notre modèle se retrouve avec autant de constantes quil y a de catégories à prédire moins une, chacune de ces constantes contrôlant la probabilité de base de passer de la catégorie j à la catégorie j + 1. 8.2.3.1 Conditions dapplication Les conditions dapplication sont les mêmes que pour un modèle binomial, avec bien sûr lajout de lhypothèse sur la proportionnalité des cotes. Selon cette hypothèse, leffet de chaque variable indépendante est identique sur la probabilité de passer dun échelon de la variable Y au suivant. Afin de tester cette condition, deux approches sont envisageables : Utiliser lapproche de Brant (1990). Il sagit dun test statistique comparant les résultats du modèle ordinal avec ceux dune série de modèles logistiques binomiaux (1 pour chaque catégorie possible de Y). Ajuster un modèle ordinal sans lhypothèse de proportionnalité des cotes et effectuer un test de ratio des likelihood pour vérifier si le premier est significativement mieux ajusté. Si certaines variables ne respectent pas cette condition dapplication, trois options sont possibles pour y remédier : Supprimer la variable du modèle (à éviter si cette variable est importante dans votre cadre théorique). Autoriser la variable à avoir un effet différent entre chaque palier (possible avec le package VGAM). Changer de modèle et opter pour un modèle des catégories adjacentes. Il sagit du cas particulier où toutes les variables sont autorisées à changer à chaque niveau. Ne pas confondre ce dernier modèle et le modèle multinomial (section 8.2.4)), puisque le modèle des catégories adjacentes continue à prédire la probabilité de passer à une catégorie supérieure. 8.2.3.2 Exemple appliqué dans R Pour cet exemple, nous analysons un jeu de données proposé par Inside Airbnb, une organisation sans but lucratif collectant des données des annonces sur le site dAirbnb pour alimenter le débat sur leffet de cette société sur les quartiers. Plus spécifiquement, nous utilisons le jeu de données pour Montréal compilé le 30 juin 2020. Nous modélisons ici le prix par nuit des logements, ce type dexercice est appelé modélisation hédonique. Il est particulièrement utilisé en économie urbaine pour évaluer les déterminants du marché immobilier et prédire son évolution. Le cas dAirbnb a déjà été étudié dans plusieurs articles (Teubner, Hawlitschek et Dann 2017; Wang et Nicolau 2017; Zhang et al. 2017). Il en ressort notamment que le niveau de confiance inspiré par lhôte, les caractéristiques intrinsèques du logement et sa localisation sont les principales variables indépendantes de son prix. Nous construisons donc notre modèle sur cette base. Notez que nous avons décidé de retirer les logements avec des prix supérieurs à 250 $ par nuit qui constituent des cas particuliers et qui devraient faire lobjet dune analyse à part entière. Nous avons également retiré les observations pour lesquelles certaines données sont manquantes, et obtenons un nombre final de 9 051 observations. La distribution originale du prix des logements dans notre jeu de données est présentée à la figure 8.12. # Charger le jeu de données data_airbnb &lt;- read.csv(&quot;data/glm/airbnb_data.csv&quot;) # Afficher la distribution du prix ggplot(data = data_airbnb) + geom_histogram(aes(x = price), bins = 30, color = &quot;white&quot;, fill = &quot;#1d3557&quot;, size = 0.02)+ labs(x=&quot;Prix (en dollars)&quot;, y=&quot;Fréquence&quot;) Figure 8.12: Distribution des prix des logements Airbnb Nous avons ensuite découpé le prix des logements en trois catégories : inférieur à 50 $, de 50 $ à 99 $ et de 100 $ à 249 $. Ces catégories forment une variable ordinale de trois échelons que nous modélisons à partir de trois catégories de variables : les caractéristiques propres au logement; les caractéristiques environnementales autour du logement; les notes obtenues par le logement sur le site dAirbnb. # Afficher le nombre de logement par catégories table(data_airbnb$fac_price_cat) ## ## 1 2 3 ## 2212 3911 2928 Le tableau 8.13 présente lensemble des variables utilisées dans le modèle. Tableau 8.13: Variables indépendantes utilisées pour prédire la catégorie de prix de logements Airbnb Nom de la variable Description Type de variable Mesure beds Nombre de lits dans le logement Variable de comptage Nombre de lits dans le logement Garden_or_backyard Présence dun jardin ou dune arrière-cour Variable binaire Oui ou non private Le logement est entièrement à disposition du locataire ou seulement une pièce Variable binaire Privé ou partagé Free_street_parking Une place de stationnement gratuite est disponible sur la rue Variable binaire Oui ou non Host_greets_you Lhôte accueille personnellement les locataires Variable binaire Oui ou non prt_veg_500m Végétation dans les environs du logement Variable continue Pourcentage de surface végétale dans un rayon de 500 mètres autour du logement has_metro_500m Présence dune station de métro à proximité du logement Variable binaire Présence dune station de métro dans un rayon de 500 mètres autour du logement commercial_1km Commerce dans les environs du logement Variable continue Pourcentage de surface dédiée au commerce (mode doccupation du sol) dans un rayon dun kilomètre autour du logement cat_review Évaluation de la qualité du logement par les usagers Variable ordinale Note obtenue par le logement sur une échelle allant de 1 (très mauvais) à 5 (parfait) host_total_listings_count Nombre total de logements détenus par lhôte sur Airbnb Variable de comptage Nombre total de logements détenus par lhôte sur Airbnb Vérification des conditions dapplication Avant dajuster le modèle, il convient de vérifier labsence de multicolinéarité excessive entre les variables indépendantes. # Notez que la fonction vif ne s&#39;intéresse qu&#39;aux variables indépendantes. # Vous pouvez ainsi utiliser la fonction glm avec la fonction vif # pour n&#39;importe quel modèle glm vif(glm(price ~ beds + Garden_or_backyard + Host_greets_you + Free_street_parking + prt_veg_500m + has_metro_500m + commercial_1km +host_total_listings_count + private + cat_review, data = data_airbnb)) ## beds Garden_or_backyard Host_greets_you ## 1.123595 1.079324 1.046884 ## Free_street_parking prt_veg_500m has_metro_500m ## 1.142189 1.532536 1.239516 ## commercial_1km host_total_listings_count private ## 1.225301 1.058232 1.143932 ## cat_review ## 1.015778 Toutes les valeurs de VIF sont inférieures à 2, indiquant une absence de multicolinéarité excessive. Nous pouvons alors ajuster le modèle et analyser les distances de Cook afin de vérifier la présence ou non dobservations très influentes. Pour ajuster le modèle, nous utilisons le package VGAM et la fonction vglm qui nous donnent accès à la famille cumulative pour ajuster des modèles logistiques ordinaux. Notez que le fonctionnement de base de cette famille est de modéliser \\(P(Y\\leq1),P(Y\\leq2),...,P(Y\\leq J)\\) avec J le nombre de catégories. Cependant, nous voulons ici modéliser la probabilité de passer à une catégorie supérieure de prix. Pour cela, il est nécessaire de spécifier le paramètre reverse = TRUE pour la famille cumulative (voir help(cumulative) pour plus de détails). library(VGAM) modele &lt;- vglm(fac_price_cat ~ beds + Garden_or_backyard + Free_street_parking + prt_veg_500m + has_metro_500m + commercial_1km + private + cat_review + host_total_listings_count , family = cumulative(link=&quot;logitlink&quot;, # fonction de lien parallel = TRUE, # cote proportionelle reverse = TRUE), data = data_airbnb, model = T) Notez que, puisque la variable Y a trois catégories différentes et que nous modélisons la probabilité de passer à une catégorie supérieure, chaque observation a alors deux (3-1) valeurs de résidus différentes. Par conséquent, nous calculons deux distances de Cook différentes que nous devons analyser conjointement. Malheureusement, la fonction cook.distance ne fonctionne pas avec les objets vglm, nous devons donc les calculer manuellement. # Extraction des résidus res &lt;- residuals(modele, type = &quot;pearson&quot;) # Extraction de la hat matrix (nécessaire pour calculer la distance de Cook) hat &lt;- hatvaluesvlm(modele) # Calcul des distances de Cook cooks &lt;- lapply(1:ncol(res),function(i){ r &lt;- res[,i] h &lt;- hat[,i] cook &lt;- (r/(1 - h))^2 * h/(1 * modele@rank) }) # Structuration dans un DataFrame matcook &lt;- data.frame(do.call(cbind, cooks)) names(matcook) &lt;- c(&quot;dist1&quot;,&quot;dist2&quot;) matcook$oid &lt;- 1:nrow(matcook) # Afficher les distances de Cook plot1 &lt;- ggplot(data = matcook) + geom_point(aes(x = oid, y = dist1), size = 0.2, color = rgb(0.1,0.1,0.1,0.4)) + labs(x = &quot;&quot;, y = &quot;&quot;, subtitle = &quot;distance de Cook P(Y&gt;=2)&quot;)+ theme(axis.ticks.x = element_blank(), axis.text.x = element_blank()) plot2 &lt;- ggplot(data = matcook) + geom_point(aes(x = oid, y = dist2), size = 0.2, color = rgb(0.1,0.1,0.1,0.4)) + labs(x = &quot;&quot;, y = &quot;&quot;, subtitle = &quot;distance de Cook P(Y&gt;=3)&quot;)+ theme(axis.ticks.x = element_blank(), axis.text.x = element_blank()) ggarrange(plot1, plot2, ncol = 2, nrow = 1) Figure 8.13: Distances de Cook pour le modèle logistique des cotes proportionnelles Les distances de Cook (figure 8.13) nous permettent didentifier quelques observations potentiellement trop influentes, mais elles semblent être différentes dun graphique à lautre. Nous décidons donc de ne pas retirer dobservations à ce stade et de passer à lanalyse des résidus simulés. Pour effectuer des simulations à partir de ce modèle, nous nous basons sur les probabilités dappartenance prédites par le modèle. # Extraire les probabilités prédites predicted &lt;- predict(modele,type = &quot;response&quot;) round(head(predicted,n = 4),3) ## 1 2 3 ## 1 0.706 0.267 0.028 ## 2 0.073 0.461 0.466 ## 3 0.687 0.283 0.030 ## 4 0.049 0.383 0.568 Nous constatons ainsi que, pour la première observation, la probabilité prédite dappartenir au groupe 1 est de 69,4 %, de 27,7 % pour le groupe 2 et de 2,9 % pour le groupe 3. Si nous effectuons 1 000 simulations, nous pouvons nous attendre à ce quen moyenne, sur ces 1 000 simulations, 694 indiqueront 1 comme catégorie prédite, 277 indiqueront 2 et seulement 29 indiqueront 3. # Nous effectuerons 1000 simulations nsim &lt;- 1000 # Lancement des simulations pour chaque observation (lignes dans predicted) simulations &lt;- lapply(1:nrow(predicted), function(i){ probs &lt;- predicted[i,] sims &lt;- sample(c(1,2,3), size = nsim, replace = T, prob = probs) return(sims) }) # Combiner les prédictions dans un tableau matsim &lt;- do.call(rbind, simulations) # Observons si nos simulations sont proches de ce que nous attendions table(matsim[1,]) ## ## 1 2 3 ## 726 247 27 À partir de ces simulations de prédiction, nous pouvons réaliser un diagnostic des résidus simulés grâce au package DHARMa. library(DHARMa) # Extraction de la prédiction moyenne du modèle pred_cat &lt;- unique(data_airbnb$fac_price_cat)[max.col(predicted)] # Préparer les données avec le package DHARMa sim_res &lt;- createDHARMa(simulatedResponse = matsim, observedResponse = as.numeric(data_airbnb$fac_price_cat), fittedPredictedResponse = as.numeric(pred_cat), integerResponse = T) # Afficher le graphique de diagnostic général plot(sim_res) Figure 8.14: Diagnostic général des résidus simulés du modèle des cotes proportionnelles La figure 8.14 nous indique que les résidus simulés suivent bien une distribution uniforme et quaucune valeur aberrante nest observable. Pour affiner notre diagnostic, nous vérifions également si aucune relation ne semble exister entre chaque variable indépendante et les résidus. # Préparons un plot multiple par(mfrow=c(3,4)) vars &lt;- c(&quot;nombre de lits&quot; = &quot;beds&quot;, &quot;couvert végétal&quot; = &quot;prt_veg_500m&quot;, &quot;commercial&quot; = &quot;commercial_1km&quot;, &quot;nb logements hôte&quot; = &quot;host_total_listings_count&quot;, &quot;jardin&quot; = &quot;Garden_or_backyard&quot;, &quot;accueil&quot; = &quot;Host_greets_you&quot;, &quot;stationnement gratuit&quot; = &quot;Free_street_parking&quot;, &quot;métro&quot; = &quot;has_metro_500m&quot;, &quot;logement privé&quot; = &quot;private&quot;, &quot;évaluation&quot; = &quot;cat_review&quot;) for(name in names(vars)){ v &lt;- vars[[name]] plotResiduals(sim_res, data_airbnb[[v]], rank = F, quantreg = F, main = &quot;&quot;, xlab = name, ylab = &quot;résidus&quot;) } Figure 8.15: Diagnostic des variables indépendantes et des résidus simulés du modèle des cotes proportionnelles La fonction plotResiduals du package DHARMa produit des graphiques peu esthétiques, mais pratiques pour effectuer ce type de diagnostic. La figure 8.15 indique quaucune relation marquée nexiste entre nos variables indépendantes et nos résidus simulés, sauf pour la variable nombre de lits. En effet, nous pouvons constater que les résidus ont tendance à être toujours plus faibles quand le nombre de lits augmente. Cet effet est sûrement lié au fait quau-delà de cinq lits, le logement en question est vraisemblablement un dortoir. Il pourrait être judicieux de retirer ces observations de lanalyse, considérant quelles sont peu nombreuses et constituent un type de logement particulier. data_airbnb2 &lt;- subset(data_airbnb, data_airbnb$beds &lt;=5) modele2 &lt;- vglm(fac_price_cat ~ beds + Garden_or_backyard + Free_street_parking + prt_veg_500m + has_metro_500m + commercial_1km + private + cat_review + host_total_listings_count , family = cumulative(link=&quot;logitlink&quot;, # fonction de lien parallel = TRUE, # cote proportionelle reverse = TRUE), data = data_airbnb2, model = T) Nous pouvons ensuite recalculer les résidus simulés pour observer si cette tendance a été corrigée. La figure 8.16 montre quune bonne partie du problème a été corrigée; cependant, il semble tout de même que les résidus soient plus forts pour les logements avec un seul lit. # Nous effectuerons 1000 simulations nsim &lt;- 1000 predicted &lt;- predict(modele2, type = &quot;response&quot;) # Lancement des simulations pour chaque observation (lignes dans predicted) simulations &lt;- lapply(1:nrow(predicted), function(i){ probs &lt;- predicted[i,] sims &lt;- sample(c(1,2,3), size = nsim, replace = T, prob = probs) return(sims) }) # Combiner les prédictions dans un tableau matsim &lt;- do.call(rbind, simulations) # Extraction de la prédiction moyenne du modèle pred_cat &lt;- unique(data_airbnb2$fac_price_cat)[max.col(predicted)] # Préparer les donnees avec le package DHARMa sim_res &lt;- createDHARMa(simulatedResponse = matsim, observedResponse = as.numeric(data_airbnb2$fac_price_cat), fittedPredictedResponse = as.numeric(pred_cat), integerResponse = T) par(mfrow=c(3,4)) vars &lt;- c(&quot;nombre de lits&quot; = &quot;beds&quot;, &quot;couvert végétal&quot; = &quot;prt_veg_500m&quot;, &quot;commercial&quot; = &quot;commercial_1km&quot;, &quot;nb logements hôte&quot; = &quot;host_total_listings_count&quot;, &quot;jardin&quot; = &quot;Garden_or_backyard&quot;, &quot;accueil&quot; = &quot;Host_greets_you&quot;, &quot;stationnement gratuit&quot; = &quot;Free_street_parking&quot;, &quot;métro&quot; = &quot;has_metro_500m&quot;, &quot;logement privé&quot; = &quot;private&quot;, &quot;évaluation&quot; = &quot;cat_review&quot;) for(name in names(vars)){ v &lt;- vars[[name]] plotResiduals(sim_res, data_airbnb2[[v]], rank = F, quantreg = F, main = &quot;&quot;, xlab = name, ylab = &quot;résidus&quot;) } Figure 8.16: Diagnostic des variables indépendantes et des résidus simulés du modèle des cotes proportionnelles (après correction) La prochaine étape du diagnostic est de vérifier labsence de séparation parfaite provoquée par une de nos variables indépendantes. Le package VGAM propose pour cela la fonction hdeff. tests &lt;- hdeff(modele2) problem &lt;- table(tests) problem ## tests ## FALSE ## 11 La fonction nous informe quaucune de nos variables indépendantes ne provoque de séparation parfaite : toutes les valeurs renvoyées par la fonction hdeff sont égales à FALSE. Il ne nous reste donc plus quà vérifier que lhypothèse de proportionnalité des cotes est respectée, soit que leffet de chacune des variables indépendantes est bien le même pour passer de la catégorie 1 à 2 que pour passer de la catégorie 2 à 3. Pour cela, deux approches sont possibles : le test de Brant ou la réalisation dune séquence de tests de rapport de vraisemblance. Le package brant propose une implémentation du test de Brant, mais celle-ci ne peut être appliquée quà des modèles construits avec la fonction polr du package MASS. Nous avons donc récupéré le code source de la fonction brant du package brant et apporté quelques modifications pour quelle soit utilisable sur un objet vglm. Cette nouvelle fonction, appelée brant.vglm, est disponible dans le code source de ce livre. tableau_brant &lt;- round(brant.vglm(modele2),3) ## ------------------------------------------------------------ ## Test for X2 df probability ## ------------------------------------------------------------ ## Omnibus 113.72 9 0 ## beds 0.63 1 0.43 ## Garden_or_backyardYES 0.16 1 0.69 ## Free_street_parkingYES 0.84 1 0.36 ## prt_veg_500m 6.49 1 0.01 ## has_metro_500mYES 0.02 1 0.89 ## commercial_1km 0.01 1 0.92 ## privateEntier 93.56 1 0 ## cat_review 0.63 1 0.43 ## host_total_listings_count 1.51 1 0.22 ## ------------------------------------------------------------ ## ## H0: Parallel Regression Assumption holds Ce premier tableau nous indique que seule la variable indiquant si le logement est disponible en entier ou partagé contrevient à lhypothèse de proportionnalité des cotes (la seule valeur p significative). Pour confirmer cette observation, nous pouvons réaliser un ensemble de tests de rapport de vraisemblance. Pour chaque variable du modèle, nous créons un second modèle dans lequel cette variable est autorisée à varier pour chaque catégorie et nous comparons les niveaux dajustement des modèles. Nous avons implémenté cette procédure dans la fonction parallel.likelihoodtest.vglm disponible dans le code source de ce livre. tableau_likelihood &lt;- parallel.likelihoodtest.vglm(modele2, verbose = FALSE) print(tableau_likelihood) ## variable non parallele AIC loglikelihood p.val loglikelihood ratio test ## 1 beds 15304 -7640 0.271 ## 2 Garden_or_backyard 15305 -7641 0.417 ## 3 Free_street_parking 15301 -7639 0.079 ## 4 prt_veg_500m 15296 -7636 0.007 ## 5 has_metro_500m 15303 -7640 0.191 ## 6 commercial_1km 15305 -7640 0.271 ## 7 private 15215 -7595 0.000 ## 8 cat_review 15306 -7641 0.430 ## 9 host_total_listings_count 15304 -7640 0.257 Les résultats de cette seconde série de tests confirment les précédents, la variable concernant le type de logement doit être autorisée à varier en fonction de la catégorie. Ce second tableau nous indique que la variable concernant la densité de végétation pourrait aussi être amenée à varier en fonction du groupe, mais ce changement a un effet très marginal (différence entre les valeurs dAIC de seulement 8 points). Nous ajustons donc un nouveau modèle autorisant la variable private à changer en fonction de la catégorie prédite. modele3 &lt;- vglm(fac_price_cat ~ beds + Garden_or_backyard + Host_greets_you + Free_street_parking + prt_veg_500m + has_metro_500m + commercial_1km + private + cat_review + host_total_listings_count, family = cumulative(link=&quot;logitlink&quot;, parallel = FALSE ~ private , reverse = TRUE), data = data_airbnb2, model = T) Vérification lajustement du modèle Maintenant que toutes les conditions dapplication ont été passées en revue, nous pouvons passer à la vérification de lajustement du modèle. modelenull &lt;- vglm(fac_price_cat ~ 1, family = cumulative(link=&quot;logitlink&quot;, parallel = TRUE, reverse = TRUE), data = data_airbnb2, model = T) rsqs(loglike.full = logLik(modele3), loglike.null = logLik(modelenull), full.deviance = deviance(modele3), null.deviance = deviance(modelenull), nb.params = modele3@rank, n = nrow(data_airbnb2) ) ## $`deviance expliquee` ## [1] 0.2087098 ## ## $`McFadden ajuste` ## [1] 0.2073552 ## ## $`Cox and Snell` ## [1] 0.3606848 ## ## $Nagelkerke ## [1] 0.4085924 Le modèle final parvient à expliquer 21 % de la déviance originale. Il obtient un R2 ajusté de McFadden de 0,21, et des R2 de Cox et Snell et de Nagelkerke de respectivement 0,36 et 0,41. Construisons à présent la matrice de confusion de la prédiction du modèle (nous utilisons ici la fonction nice_confusion_matrix également disponible dans le code source de ce livre). preds_probs &lt;- fitted(modele3) pred_cat &lt;- c(1,2,3)[max.col(preds_probs)] library(caret) matrices &lt;- nice_confusion_matrix(data_airbnb2$fac_price_cat,pred_cat) # Afficher la matrice de confusion print(matrices$confusion_matrix) ## rowsnames 1 2 3 rs rp ## colsnames &quot;&quot; &quot;1 (reel)&quot; &quot;2 (reel)&quot; &quot;3 (reel)&quot; &quot;Total&quot; &quot;%&quot; ## 1 &quot;1 (predit)&quot; &quot;1576&quot; &quot;736&quot; &quot;168&quot; &quot;2480&quot; &quot;27.7&quot; ## 2 &quot;2 (predit)&quot; &quot;579&quot; &quot;2385&quot; &quot;1331&quot; &quot;4295&quot; &quot;48&quot; ## 3 &quot;3 (predit)&quot; &quot;49&quot; &quot;771&quot; &quot;1360&quot; &quot;2180&quot; &quot;24.3&quot; ## &quot;Total&quot; &quot;2204&quot; &quot;3892&quot; &quot;2859&quot; &quot;8955&quot; NA ## &quot;%&quot; &quot;24.6&quot; &quot;43.5&quot; &quot;31.9&quot; NA NA # Afficher les indicateurs de qualité de prédiction print(matrices$indicators) ## rnames precision rappel F1 ## 1 &quot;1&quot; &quot;0.64&quot; &quot;0.72&quot; &quot;0.67&quot; ## 2 &quot;2&quot; &quot;0.56&quot; &quot;0.61&quot; &quot;0.58&quot; ## 3 &quot;3&quot; &quot;0.62&quot; &quot;0.48&quot; &quot;0.54&quot; ## macro_scores &quot;macro&quot; &quot;0.6&quot; &quot;0.59&quot; &quot;0.59&quot; ## &quot;Kappa&quot; &quot;0.37&quot; NA NA ## &quot;Valeur de p (precision &gt; NIR)&quot; &quot;0&quot; NA NA Le modèle a une précision totale de 61 % (61 % des observations ont été correctement prédites). La catégorie 1 a de loin la meilleure précision (72 %) et la 3 a la pire (48 %), ce qui indique quil manque vraisemblablement des variables indépendantes contribuant à prédire les prix des logements les plus chers. Le coefficient de Kappa () indique un niveau daccord entre modéré et faible, mais le modèle parvient à une prédiction significativement supérieure au seuil de non-information. Si lajustement du modèle est imparfait, il est suffisamment fiable pour nous donner des renseignements pertinents sur le phénomène étudié. Interprétation des résultats Lensemble des coefficients du modèle sont accessibles via la fonction summary. À partir des coefficients et de leurs erreurs standards, il est possible de calculer les rapports de cotes ainsi que leurs intervalles de confiances. tableau &lt;- summary(modele3)@coef3 rappCote &lt;- exp(tableau[,1]) rappCote2.5 &lt;- exp(tableau[,1] - 1.96 * tableau[,2]) rappCote97.5 &lt;- exp(tableau[,1] + 1.96 * tableau[,2]) tableau &lt;- cbind(tableau, rappCote, rappCote2.5, rappCote97.5) print(round(tableau,3)) ## Estimate Std. Error z value Pr(&gt;|z|) rappCote ## (Intercept):1 -1.203 0.137 -8.768 0.000 0.300 ## (Intercept):2 -3.240 0.151 -21.516 0.000 0.039 ## beds 0.748 0.027 28.143 0.000 2.113 ## Garden_or_backyardYES 0.120 0.067 1.795 0.073 1.128 ## Host_greets_youYES 0.094 0.060 1.548 0.122 1.098 ## Free_street_parkingYES -0.015 0.046 -0.320 0.749 0.985 ## prt_veg_500m -0.026 0.003 -10.182 0.000 0.975 ## has_metro_500mYES 0.063 0.048 1.326 0.185 1.065 ## commercial_1km 0.008 0.008 0.955 0.340 1.008 ## privateEntier:1 2.445 0.062 39.241 0.000 11.533 ## privateEntier:2 1.576 0.081 19.573 0.000 4.834 ## cat_review 0.200 0.021 9.563 0.000 1.222 ## host_total_listings_count -0.002 0.001 -2.094 0.036 0.998 ## rappCote2.5 rappCote97.5 ## (Intercept):1 0.230 0.393 ## (Intercept):2 0.029 0.053 ## beds 2.006 2.226 ## Garden_or_backyardYES 0.989 1.287 ## Host_greets_youYES 0.975 1.236 ## Free_street_parkingYES 0.900 1.078 ## prt_veg_500m 0.970 0.980 ## has_metro_500mYES 0.970 1.170 ## commercial_1km 0.992 1.024 ## privateEntier:1 10.207 13.031 ## privateEntier:2 4.128 5.660 ## cat_review 1.173 1.273 ## host_total_listings_count 0.996 1.000 Pour faciliter la lecture des résultats, nous proposons le tableau 8.14. Tableau 8.14: Coefficients du modèle logistique des cotes proportionnelles Variable Coefficient RC P RC 2,5 % RC 97,5 % sign. (Intercept):1 -1,200 0,300 0,000 0,230 0,395 *** (Intercept):2 -3,240 0,039 0,000 0,029 0,052 *** beds 0,750 2,113 0,000 2,014 2,226 *** Garden_or_backyard ref : NO       YES 0,120 1,128 0,073 0,990 1,284 . Host_greets_you ref : NO       YES 0,090 1,098 0,122 0,980 1,234 Free_street_parking ref : NO       YES -0,010 0,985 0,749 0,896 1,083 prt_veg_500m -0,030 0,975 0,000 0,970 0,980 *** has_metro_500m ref : NO       YES 0,060 1,065 0,185 0,970 1,174 commercial_1km 0,010 1,008 0,340 0,990 1,020 cat_review 0,200 1,222 0,000 1,174 1,271 *** host_total_listings_count 0,000 0,998 0,036 1,000 1,000 Effets par niveau private ref : Chambre       Entier:1 2,450 11,533 0,000 10,176 13,066 *** Entier:2 1,580 4,834 0,000 4,137 5,641 *** Sans surprise, chaque lit supplémentaire contribue à augmenter les chances que le logement soit dans une catégorie de prix supérieure (multiplication par deux à chaque lit supplémentaire). En revanche, la présence dun stationnement gratuit, dun jardin et laccueil en personne par lhôte nont pas deffets significatifs. Comme lindiquent les articles mentionnés en début de section, les revues positives augmentent la probabilité dappartenir à une catégorie supérieure de prix. Pour chaque point supplémentaire sur léchelle de 1 à 5, la probabilité dappartenir à une catégorie de prix supérieure augmente de 22,2 %. Il est intéressant de noter que le fait de disposer du logement entier plutôt que dune simple chambre augmente davantage les chances de passer du groupe de prix 1 à 2 (multiplication par 2,45) que du groupe 2 à 3 (multiplication par 1,58). Il semble également que si lhôte possède plusieurs logements, la probabilité davoir une classe de prix supérieure diminue légèrement. Cependant, leffet est trop petit pour pouvoir se livrer à des interprétations. Les variables environnementales ont peu deffet : le pourcentage de surface commerciale dans un rayon dun kilomètre et la présence dune station de métro ne sont pas significatifs. En revanche, une augmentation de la surface végétale dans un rayon de 500 mètres tend à réduire la probabilité dappartenir à une classe supérieure. Notre hypothèse concernant ce résultat est que cette variable représente un effet associé à la localisation des Airbnb, les plus centraux ayant tendance à être plus dispendieux, mais avec un environnement moins vert et inversement. Pour lillustrer, prédisons les probabilités dappartenance aux différents niveaux de prix dun logement avec les caractéristiques suivantes : entièrement privé, 2 lits, un jardin, une place de stationnement gratuite, lhôte ne dispose que dun logement sur Airbnb et accueille les arrivants en personne, 10 % de surface commerciale dans un rayon dun kilomètre, noté 2 comme catégorie de revue, absence de métro dans un rayon de 500 mètres. # Créer un jeu de données pour effectuer des prédictions df &lt;- data.frame( prt_veg_500m = seq(5,90), beds = 2, Garden_or_backyard = &quot;YES&quot;, Host_greets_you = &quot;YES&quot;, Free_street_parking = &quot;YES&quot;, has_metro_500m = &quot;NO&quot;, commercial_1km = 10, private = &quot;Entier&quot;, cat_review = 2, host_total_listings_count = 1 ) # Effectuer les prédictions (dans l&#39;échelle log) preds &lt;- predict(modele3, newdata = df, type = &quot;link&quot;, se.fit=T) # Définir l&#39;inverse de la fonction de lien ilink &lt;- function(x){exp(x)/(1+exp(x))} # Calculer les probabilités et leurs intervalles de confiance df[[&quot;P[Y&gt;=2]&quot;]] &lt;- ilink(preds$fitted.values[,1]) df[[&quot;P[Y&gt;=2] 2,5&quot;]] &lt;- ilink(preds$fitted.values[,1] - 1.96 * preds$se.fit[,1]) df[[&quot;P[Y&gt;=2] 97,5&quot;]] &lt;- ilink(preds$fitted.values[,1] + 1.96 * preds$se.fit[,1]) df[[&quot;P[Y&gt;=3]&quot;]] &lt;- ilink(preds$fitted.values[,2]) df[[&quot;P[Y&gt;=3] 2,5&quot;]] &lt;- ilink(preds$fitted.values[,2] - 1.96 * preds$se.fit[,2]) df[[&quot;P[Y&gt;=3] 97,5&quot;]] &lt;- ilink(preds$fitted.values[,2] + 1.96 * preds$se.fit[,2]) df[[&quot;P[Y=1]&quot;]] = 1-df[[&quot;P[Y&gt;=2]&quot;]] df[[&quot;P[Y=1] 2,5&quot; ]] = 1-df[[&quot;P[Y&gt;=2] 2,5&quot;]] df[[&quot;P[Y=1] 97,5&quot;]] = 1-df[[&quot;P[Y&gt;=2] 97,5&quot;]] # Afficher les résultats ggplot(data = df) + geom_ribbon(aes(x = prt_veg_500m, ymin = `P[Y&gt;=2] 2,5`, ymax = `P[Y&gt;=2] 97,5`),fill =&quot;#f94144&quot;, alpha = 0.4)+ geom_path(aes(x = prt_veg_500m, y = `P[Y&gt;=2]`,color=&quot;Y2&quot;)) + geom_ribbon(aes(x = prt_veg_500m, ymin = `P[Y&gt;=3] 2,5`, ymax = `P[Y&gt;=3] 97,5`), fill =&quot;#90be6d&quot;, alpha = 0.4)+ geom_path(aes(x = prt_veg_500m, y = `P[Y&gt;=3]`, color = &quot;Y3&quot; )) + geom_ribbon(aes(x = prt_veg_500m, ymin = `P[Y=1] 2,5`, ymax = `P[Y=1] 97,5`),fill =&quot;#277da1&quot; , alpha = 0.4)+ geom_path(aes(x = prt_veg_500m, y = `P[Y=1]`, color = &quot;Y1&quot;)) + scale_color_manual(name = &quot;Probabilités prédites&quot;, breaks = c(&quot;Y1&quot;, &quot;Y2&quot;, &quot;Y3&quot;), labels = c(&quot;P[Y=1]&quot;, &quot;P[Y&gt;=2]&quot;, &quot;P[Y&gt;=3]&quot;), values = c(&quot;Y2&quot; = &quot;#f94144&quot;, &quot;Y3&quot; = &quot;#90be6d&quot;, &quot;Y1&quot; = &quot;#277da1&quot;)) + labs(x = &quot;Densité de végétation (%)&quot;, y = &quot;Probabilité&quot;, subtitle = &quot;Y1 : moins de 50 $; Y2 : 50 à 99 $; Y3 : 100 à 249 $&quot;) Figure 8.17: Prédiction de la probabilité dappartenance aux trois catégories de prix en fonction de la densité de végétation Nous constatons, à la figure 8.17, que les probabilités dappartenir aux niveaux 2 et 3 diminuent à mesure quaugmente le pourcentage de végétation. La probabilité dappartenir à la classe 2 et plus (en rouge) passe de plus de 95 % en cas dabsence de végétation et à environ 75 % avec 80 % de végétation dans un rayon de 500 mètres. Comme vous pouvez le constater, la probabilité \\(P[Y=1]\\) est la symétrie de \\(P[Y&gt;=2]\\) puisque \\(P[Y=1]+P[Y&gt;=2] = 1\\). 8.2.4 Modèle logistique multinomial La régression logistique multinomiale est utilisée pour modéliser une variable Y qualitative multinomiale, cest-à-dire une variable dont les modalités ne peuvent pas être ordonnées. Dans le modèle précédent, nous avons vu quil était possible de modéliser une variable ordinale avec une distribution binomiale en formulant lhypothèse de la proportionnalité des cotes. Avec une variable multinomiale, cette hypothèse ne tient plus, car les catégories ne sont plus ordonnées. Il faut donc formuler le modèle différemment. Lidée derrière un modèle multinomial est de choisir une catégorie de référence, puis de modéliser les probabilités dappartenir à chaque autre catégorie plutôt quà cette catégorie de référence (tableau 8.15). Si nous avons K catégories possibles dans notre variable Y, nous obtenons K-1 comparaisons. Chaque comparaison est modélisée avec sa propre équation, ce qui génère de nombreux paramètres. Par exemple, admettons que notre variable Y a cinq catégories et que nous disposons de six variables X prédictives. Nous avons ainsi 4 (5-1) équations de régression avec 7 paramètres (6 coefficients et une constante), soit 28 coefficients à analyser. Considérant cette tendance à la multiplication des coefficients, il est fréquent de recourir à une méthode appelée Analyse de type 3 pour limiter au maximum le nombre de variables indépendantes (VI) dans le modèle. Lidée de cette méthode est de recalculer plusieurs versions du modèle dans lesquelles une variable indépendante est retirée, puis de réaliser un test de rapport de vraisemblance en comparant ce nouveau modèle (complet moins une VI) au modèle complet (toutes les VI) pour vérifier si la variable en question améliore significativement le modèle. Il est alors possible de retirer toutes les variables dont lapport est négligeable si elles sont également peu intéressantes du point de vue théorique. Tableau 8.15: Carte didentité du modèle logistique multinomial Type de variable dépendante Variable qualitative multinomiale avec K catégories Distribution utilisée Binomiale Formulation \\(Y \\sim Binomial(p)\\) \\(g(p = k\\text{ avec }ref = a) = \\beta_{0k} + \\beta X_{k}\\) \\(g(x) = \\frac{log(x)}{1-x}\\) Fonction de lien Logistique Paramètre modélisé p Paramètres à estimer \\(\\beta_{0k}\\), \\(\\beta\\)k pour \\(k \\in [2,...,K]\\) Conditions dapplication Non-séparation complète, absence de sur-dispersion ou de sous-dispersion, Indépendance des alternatives non pertinentes 8.2.4.1 Conditions dapplication Les conditions dapplication sont les mêmes que pour un modèle binomial, avec lajout de lhypothèse sur lindépendance des alternatives non pertinentes. Cette dernière suppose que le choix entre deux catégories est indépendant des catégories proposées. Voici un exemple simple pour illustrer cette hypothèse: admettons que nous disposons dune trentaine de personnes et que nous leur demandons la couleur de leurs yeux. Cette variable ne serait pas affectée par la présence de nouvelles couleurs en dehors de notre échantillon. En revanche, si nous leur demandons de choisir un mode de transport parmi une liste pour se rendre à leur lieu de travail, leur réponse serait nécessairement affectée par la liste des modes de transport disponibles. Les tests développés pour vérifier cette hypothèse sont connus pour leur faible fiabilité. Il est plus pertinent de décider théoriquement si cette hypothèse est valide ou non. Dans le cas contraire, il est possible dutiliser une classe de modèle logistique plus rare: le modèle logistique imbriqué. Notez également que le grand nombre de paramètres dans ce type de modèle implique de disposer dun plus grand nombre dobservations afin davoir suffisamment dinformation dans chaque catégorie pour ajuster tous les paramètres. Pour vérifier la présence de sur-dispersion, il est possible, dans le cas du modèle multinomial, de calculer le rapport entre le khi-deux de Pearson et le nombre de degrés de liberté du modèle. Si ce rapport est supérieur à 1 (des valeurs jusquà 1,15 ne sont pas problématiques), alors le modèle souffre de sur-dispersion (SAS Institute Inc 2020a). Le khi-deux de Pearson est simplement la somme des résidus de Pearson au carré dans le cas dun modèle GLM. \\[\\begin{equation} \\chi^2 = \\sum_{i=1}^N\\sum_{c=1}^K{\\frac{(y_{ic} - p_{ic})^2}{p_{ic}}} \\tag{8.18} \\end{equation}\\] Avec \\(y_{ic}\\) 1 si lobservation i appartient à la catégorie c, 0 autrement, \\(p_{ic}\\) la probabilité prédite pour lobservation i dappartenir à la catégorie c, N le nombre dobservations et K le nombre de catégories. Le ratio est ensuite calculé comme suit: \\(\\frac{\\chi^2}{(N - p)(K-1)}\\), avec N le nombre dobservations et K le nombre de modalités dans la variable Y. Si ce ratio est égal ou supérieur à 1, alors le modèle souffre de sur-dispersion, si le ratio est inférieur à 1, le modèle souffre de sous-dispersion. Un léger écart (&gt; 0,15) nest pas considéré comme problématique. Le modèle logistique imbriqué Du fait de sa proximité avec les modèles à effets mixtes que nous abordons au chapitre 9, nous ne détaillons pas ici le modèle logistique imbriqué, mais présentons plutôt son principe général. Il sagit dune généralisation du modèle logistique multinomial basé sur lidée que certaines catégories pourraient être regroupées dans des « nids » (nest en anglais). Dans ces groupes, les erreurs peuvent être corrélées, indiquant ainsi que si une catégorie est manquante, une autre catégorie du même groupe sera préférée. Un paramètre \\(\\lambda\\) contrôle spécifiquement cette corrélation et permet de mesurer sa force une fois le modèle ajusté. Il peut être pertinent de comparer un modèle imbriqué à un modèle multinomial pour déterminer lequel des deux est le mieux ajusté aux données. 8.2.4.2 Exemple appliqué dans R Pour cet exemple, nous reproduisons une partie de lanalyse effectuée dans létude de McFadden (2016). Cet article sintéresse aux écarts entre les croyances des individus et les connaissances scientifiques sur les sujets des OGM et du réchauffement climatique. Les auteurs utilisent pour cela des données issues dune enquête auprès de 961 individus formant un échantillon représentatif de la population des États-Unis. Les données issues de cette enquête sont téléchargeables sur le site de léditeur, ce qui nous permet ici de reproduire lanalyse effectuée par les auteurs. Deux questions sont centrales dans lenquête : Dans quelle mesure êtes-vous en accord ou en désaccord avec la phrase suivante : les plantations génétiquement modifiées sont sans danger pour la consommation ? Dans quelle mesure êtes-vous en accord ou en désaccord avec la phrase suivante : la Terre se réchauffe du fait des activités humaines ? Pour ces deux questions, les répondants devaient sélectionner leur degré daccord sur une échelle de Likert allant de 1 (fortement en désaccord) à 5 (fortement en accord). Les réponses à ces deux questions ont été utilisées pour former une variable multinomiale à quatre modalités : A. Les individus sont en accord avec les deux propositions. B. Les individus sont en désaccord sur les OGM, mais en accord sur le réchauffement climatique. C. Les individus sont en accord sur les OGM, mais en désaccord sur le réchauffement climatique. D. Les individus sont en désaccord avec les deux propositions. Un modèle logistique multinomial a été utilisé pour déterminer quels facteurs contribuent à la probabilité dappartenir à ces différentes catégories. Les variables indépendantes présentes dans le modèle sont détaillées dans le tableau 8.16. Les auteurs avaient notamment conclu que : Les effets des connaissances (réelles ou perçues) sur lappartenance aux différentes catégories nétaient pas uniformes et pouvaient varier en fonction du sujet. Lorientation politique avait une influence significative sur les croyances. Les répondants avec de plus hauts résultats au test de cognition CRT avaient plus souvent des opinions divergentes de la communauté scientifique. Tableau 8.16: Variables indépendantes utilisées dans le modèle logistique multinomial Nom de la variable signification Type de variable Mesure PercepOGM La recherche scientifique supporte ma vision sur la sécurité des plantes OGM Variable ordinale Échelle de Likert de 1 (fortement en désaccord) à 5 (fortement en accord) PercepRechClim La recherche scientifique supporte ma vision sur le réchauffement climatique Variable ordinale Échelle de Likert de 1 (fortement en désaccord) à 5 (fortement en accord) ConnaisOGM Niveau de connaissance sur les OGM Variable ordinale Nombre de réponses sur trois questions portant sur les OGM ConnaisRechClim Niveau de connaissance sur le réchauffement climatique Variable ordinale Nombre de réponses sur trois questions portant sur le réchauffement climatique CRT Score obtenu au Cognitive Reflection Test, utilisé pour déterminer la propension à faire preuve desprit danalyse plutôt que choisir des réponses intuitives Variable ordinale Nombre de réponses sur trois questions pièges Parti Orientation politique du répondant Variable multinomiale Républicain, démocrate et autre Sexe Sexe du répondant Variable binaire Femme ou homme Age Âge du répondant Variable continue Âge du répondant Revenu Niveau de revenu du répondant Variable ordinale Échelle de 1 (moins de 20 000 $) à (140 000 $ et plus) Vérification des conditions dapplication Avant dajuster le modèle, nous commençons par vérifier labsence de multicolinéarité excessive entre les variables indépendantes. Toutes les valeurs de VIF sont inférieures à 2, indiquant bien une absence de multicolinéarité. data_quest &lt;- read.csv(&quot;data/glm/enquete_PublicOpinion_vs_Science.csv&quot;) # Choix des valeurs de références dans les facteurs data_quest$Parti &lt;- relevel(as.factor(data_quest$Parti), ref = &quot;Democrate&quot;) data_quest$Sexe &lt;- relevel(as.factor(data_quest$Sexe), ref = &quot;homme&quot;) vif(glm(SCIGM ~ PercepOGM + PercepRechClim + ConnaisOGM + ConnaisRechClim + CRT + Parti + AGE + Sexe + Revenu, data = data_quest)) ## GVIF Df GVIF^(1/(2*Df)) ## PercepOGM 1.092693 1 1.045320 ## PercepRechClim 1.177495 1 1.085125 ## ConnaisOGM 1.150662 1 1.072689 ## ConnaisRechClim 1.158438 1 1.076307 ## CRT 1.155371 1 1.074882 ## Parti 1.130817 2 1.031212 ## AGE 1.071655 1 1.035208 ## Sexe 1.064918 1 1.031949 ## Revenu 1.049499 1 1.024451 La seconde étape est dajuster le modèle et de vérifier labsence de sur ou sous-dispersion. Pour ajuster le modèle, nous utilisons à nouveau la fonction vglm du package VGAM, avec le paramètre family = multinomial(). Le ratio entre la statistique de Pearson et le nombre de degrés de liberté du modèle indique une absence de sur ou sous-dispersion (1,04). # Ajustement du modèle modele &lt;- vglm(Y ~ PercepOGM + PercepRechClim + ConnaisOGM + ConnaisRechClim + CRT + Parti + AGE + Sexe + Revenu, data = data_quest, family = multinomial(refLevel=&quot;A&quot;), model = T) # Calcul du Khi2 de Pearson pred &lt;- predict(modele, type= &quot;response&quot;) cat_predict &lt;- colnames(pred)[max.col(pred)] freq_real &lt;- table(data_quest$Y) freq_pred &lt;- table(cat_predict) khi2 &lt;- sum(residuals(modele, type = &quot;pearson&quot;)^2) N &lt;- nrow(data_quest) p &lt;- modele@rank r &lt;- length(freq_real) ratio &lt;- khi2 / ((N-p)*(r-1)) print(ratio) ## [1] 1.045889 La troisième étape de la vérification des conditions dapplication est lanalyse des distances de Cook. À nouveau, puisque le modèle évalue la probabilité dappartenir à \\(K-1\\) catégorie, nous pouvons calculer \\(K-1\\) résidus par observation et par extension \\(K-1\\) distances de Cook. Aucune observation ne semble se détacher nettement dans la figure 8.18. Nous décidons donc pour le moment de conserver toutes les observations. # Extraction des résidus res &lt;- residuals(modele, type = &quot;pearson&quot;) # Extraction de la hat matrix (nécessaire pour calculer la distance de Cook) hat &lt;- hatvaluesvlm(modele) # Calcul des distances de Cook vals &lt;- c(&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;) cooks &lt;- lapply(1:ncol(res),function(i){ r &lt;- res[,i] h &lt;- hat[,i] cook &lt;- (r/(1 - h))^2 * h/(1 * modele@rank) df &lt;- data.frame( oid = 1:length(cook), cook = cook ) plot &lt;- ggplot(data = df)+ geom_point(aes(x = oid, y = cook), size = 0.2, color = rgb(0.1,0.1,0.1,0.4)) + labs(x = &quot;&quot;, y = &quot;&quot;, subtitle = paste(&quot;distance de Cook P(&quot;,vals[[1]],&quot; VS &quot;,vals[[i+1]],&quot;)&quot;,sep=&quot;&quot;))+ theme(axis.ticks.x = element_blank(), axis.text.x = element_blank()) return(plot) }) ggarrange(plotlist = cooks, ncol = 2, nrow = 2) Figure 8.18: Distances de Cook pour le modèle logistique multinomial Avant de passer à lanalyse de résidus simulés, il est pertinent de réaliser une analyse de type 3 afin de retirer les variables indépendantes dont lapport au modèle est négligeable. La fonction AnalyseType3 (disponible dans le code source de ce livre) permet deffectuer cette opération automatiquement pour un objet de type vglm. tableau &lt;- AnalyseType3(modele, data_quest, verbose = FALSE) ## ************************************* ## Type 3 Analysis of Effects ## ************************************* ## AIC model complet : 1855 ## loglikelihood model complet : 1789 ## variable retiree AIC loglikelihood p.val ## 1 PercepOGM 1879 1819 0 ## 2 PercepRechClim 1941 1881 0 ## 3 ConnaisOGM 1910 1850 0 ## 4 ConnaisRechClim 1862 1802 0.0059 ## 5 CRT 1860 1800 0.0125 ## 6 Parti 1879 1825 0 ## 7 AGE 1852 1792 0.4469 ## 8 Sexe 1875 1815 0 ## 9 Revenu 1850 1790 0.7718 Lanalyse de type 3 nous permet de déterminer que lâge et le revenu sont deux variables dont la contribution au modèle est marginale. À titre de rappel, lanalyse de type 3 permet de comparer si le modèle complet (avec lensemble des variables indépendantes) est statistiquement mieux ajusté que le modèle avec lensemble des variables, sauf une. Or, dans notre cas, le modèle complet nest pas statistiquement mieux ajusté que le modèle complet sans la variable Age (p = 0,44) et que le modèle complet sans la variable Revenu (p = 0,77). Cela signifie donc que ces deux variables nont pas un apport significatif au modèle et peuvent par conséquent être ôtées par parcimonie. Nous décidons donc de les retirer afin dalléger les tableaux de coefficients que nous présentons plus loin. Nous pouvons également en conclure que ces deux variables ne jouent aucun rôle dans la propension à être en désaccord avec la recherche scientifique. Nous réajustons le modèle en conséquence. modele2 &lt;- vglm(Y ~ PercepOGM + PercepRechClim + ConnaisOGM + ConnaisRechClim + CRT + Parti + Sexe, data = data_quest, family = multinomial(refLevel=&quot;A&quot;), model = T) Nous pouvons à présent passer à lanalyse des résidus simulés. Le problème avec ce modèle est que sa variable Y est qualitative alors que la méthode danalyse des résidus du package DHARMa ne peut traiter que des variables quantitatives, binaires ou ordinales. Pour rappel, il est possible denvisager la prédiction dun modèle logistique multinomial comme la prédiction dune série de modèles logistiques binomiaux. En représentant nos prédictions de cette façon, nous pouvons à nouveau utiliser le package DHARMa pour analyser nos résidus. Veuillez noter que cette approche nest pas optimale et que cette section du livre peut être amenée à changer. La figure 8.19 indique que les résidus suivent bien une distribution uniforme et quaucune valeur aberrante nest observable. # Extraire les prédictions du modèle categories &lt;- c(&quot;B&quot;,&quot;C&quot;,&quot;D&quot;) predicted &lt;- predict(modele2, type = &quot;link&quot;) nsim &lt;- 1000 ilink &lt;- function(x){exp(x)/(1+exp(x))} # Boucler sur chacune des catégories en dehors de la référence data_sims &lt;- lapply(1:ncol(predicted),function(i){ categorie &lt;- categories[[i]] # Extraire les observation de la catégorie i et de la référence test &lt;- data_quest$Y %in% c(&quot;A&quot;,categorie) # Calculer les probabilité d&#39;appartenance à i values &lt;- predicted[test,i] probs &lt;- ilink(values) # Extraire les valeurs réelles et les convertir en 0 / 1 real &lt;- data_quest[test,]$Y real &lt;- ifelse(real==&quot;A&quot;,0,1) # Enregistrer ces différents éléments all_probs &lt;- cbind(1-probs,probs) sub_data &lt;- subset(data_quest,test) return(list(&quot;real&quot; = real, &quot;probs&quot; = all_probs, &quot;data&quot; = sub_data)) }) # Extraire les probabilités prédites all_probs &lt;- do.call(rbind, lapply(data_sims, function(i){i$probs})) # Extraire les vrais catégories all_real &lt;- unlist(lapply(data_sims, function(i){i$real})) # Effectuer les simulations simulations &lt;- lapply(1:nrow(all_probs), function(i){ probs &lt;- all_probs[i,] sims &lt;- sample(c(0,1), size = nsim, replace = T, prob = probs) return(sims) }) matsim &lt;- do.call(rbind, simulations) # Calculer les résidus simulés sim_res &lt;- createDHARMa(simulatedResponse = matsim, observedResponse = all_real, fittedPredictedResponse = all_probs[,2], integerResponse = T) # Afficher les résultats plot(sim_res) Figure 8.19: Diagnostic général des résidus simulés pour le modèle multinomial La figure 8.20 permet daffiner le diagnostic en sassurant de labsence de relation entre les variables indépendantes et les résidus. Il est possible de remarquer des irrégularités pour les variables de perception (premier et second panneaux). Dans les deux cas, la catégorie 1 (fort désaccord) se démarque nettement des autres catégories. Nous proposons donc de les recoder comme des variables binaires : en désaccord / pas en désaccord pour minimiser cet effet. # Recomposer les données pour coller au format # étendu de la prediction etend_data &lt;- do.call(rbind, lapply(data_sims, function(i){i$data})) par(mfrow=c(3,3)) vars &lt;- c(&quot;PercepOGM&quot;, &quot;PercepRechClim&quot;, &quot;ConnaisOGM&quot;, &quot;ConnaisRechClim&quot;, &quot;CRT&quot;, &quot;Parti&quot;, &quot;Sexe&quot;) for(v in vars){ plotResiduals(sim_res, etend_data[[v]], xlab= v, ylab = &quot;résidus&quot;) } Figure 8.20: Diagnostic des variables indépendantes et des résidus simulés pour le modèle multinomial Nous réajustons donc le modèle et recalculons nos résidus ajustés (masqué ici pour alléger le document). La figure 8.21 nous confirme que le problème a été corrigé. # Convertir les variables ordinales et variables binaires data_quest$PercepOGMDes &lt;- ifelse(data_quest$PercepOGM %in% c(1,2), 1,0) data_quest$PercepRechClimDes &lt;- ifelse(data_quest$PercepRechClim %in% c(1,2), 1,0) # Réajuster le modèle modele3 &lt;- vglm(Y ~ PercepOGMDes + PercepRechClimDes + ConnaisOGM + ConnaisRechClim + CRT + Parti + Sexe, data = data_quest, family = multinomial(refLevel=&quot;A&quot;), model = T) Figure 8.21: Diagnostic général des résidus simulés pour le modèle multinomial (version 3) Profitons du fait que nous utilisons le package VGAM pour vérifier labsence deffet de Hauck-Donner qui indiquerait que des variables indépendantes provoquent des séparations parfaites. test &lt;- hdeff(modele3) test[test==TRUE] ## (Intercept):2 (Intercept):3 ## TRUE TRUE La fonction nous informe que les constantes permettant de comparer le groupe C au groupe A, et le groupe D au groupe A provoquent des séparations parfaites. Cela sexplique notamment par le faible nombre dobservations tombant dans ces catégories. Considérant que comparativement à la catégorie A, être dans les catégories B, C, ou D signifie remettre en cause au moins un consensus scientifique, il peut être raisonnable de fixer la constante pour quelle soit la même pour les trois comparaisons. Ainsi, les chances de passer de A à un autre groupe ne dépenderaient pas du groupe en question, mais uniquement des variables indépendantes. Pour cela, nous pouvons forcer le modèle à najuster quune seule constante avec la syntaxe suivante : modele4 &lt;- vglm(Y ~ PercepOGMDes + PercepRechClimDes + ConnaisOGM + ConnaisRechClim + CRT + Parti + Sexe, data = data_quest, family = multinomial(refLevel=&quot;A&quot;, parallel = TRUE ~1), model = T) test &lt;- hdeff(modele4) print(table(test)) ## test ## FALSE ## 25 # Calcul du khi2 de Pearson pred &lt;- predict(modele4, type= &quot;response&quot;) cat_predict &lt;- colnames(pred)[max.col(pred)] freq_real &lt;- table(data_quest$Y) freq_pred &lt;- table(cat_predict) khi2 &lt;- sum(residuals(modele4, type = &quot;pearson&quot;)^2) N &lt;- nrow(data_quest) p &lt;- modele4@rank r &lt;- length(freq_real) ratio &lt;- khi2 / ((N)*(r-1)-p) print(ratio) ## [1] 1.010319 Nous navons donc plus de séparation complète ni de sur ou sous-dispersion et les résidus simulés de la quatrième version du modèle sont toujours acceptables (figure 8.22). Figure 8.22: Diagnostic général des résidus simulés pour le modèle multinomial (version 4) Vérification lajustement du modèle Puisque les conditions dapplication du modèle sont respectées, nous pouvons à présent vérifier sa qualité dajustement. modelenull &lt;- vglm(Y ~ 1 , data = data_quest, family = multinomial(refLevel=&quot;A&quot;, parallel = TRUE ~ 1 + CRT) , model = T) rsqs(loglike.full = logLik(modele4), loglike.null = logLik(modelenull), full.deviance = deviance(modele4), null.deviance = deviance(modelenull), nb.params = modele4@rank, n = nrow(data_quest) ) ## $`deviance expliquee` ## [1] 0.1750071 ## ## $`McFadden ajuste` ## [1] 0.1530715 ## ## $`Cox and Snell` ## [1] 0.3397248 ## ## $Nagelkerke ## [1] 0.3746843 Le modèle parvient à expliquer 17,5 % de la déviance totale. Il obtient un R2 ajusté de McFadden de 0,15, et des R2 de Cox et Snell et de Nagelkerke de respectivement 0,34 et 0,37. Passons à la construction de la matrice de confusion pour analyser la capacité de prédiction du modèle. preds &lt;- predict(modele4, type = &quot;response&quot;) pred_cats &lt;- colnames(preds)[max.col(preds)] real &lt;- data_quest$Y matrices &lt;- nice_confusion_matrix(real, pred_cats) # Afficher la matrice de confusion print(matrices$confusion_matrix) ## rowsnames A B C D rs ## colsnames &quot;&quot; &quot;A (reel)&quot; &quot;B (reel)&quot; &quot;C (reel)&quot; &quot;D (reel)&quot; &quot;Total&quot; ## A &quot;A (predit)&quot; &quot;482&quot; &quot;168&quot; &quot;75&quot; &quot;29&quot; &quot;754&quot; ## B &quot;B (predit)&quot; &quot;31&quot; &quot;88&quot; &quot;9&quot; &quot;20&quot; &quot;148&quot; ## C &quot;C (predit)&quot; &quot;10&quot; &quot;6&quot; &quot;18&quot; &quot;6&quot; &quot;40&quot; ## D &quot;D (predit)&quot; &quot;3&quot; &quot;4&quot; &quot;3&quot; &quot;9&quot; &quot;19&quot; ## &quot;Total&quot; &quot;526&quot; &quot;266&quot; &quot;105&quot; &quot;64&quot; &quot;961&quot; ## &quot;%&quot; &quot;54.7&quot; &quot;27.7&quot; &quot;10.9&quot; &quot;6.7&quot; NA ## rp ## colsnames &quot;%&quot; ## A &quot;78.5&quot; ## B &quot;15.4&quot; ## C &quot;4.2&quot; ## D &quot;2&quot; ## NA ## NA # Afficher les indicateurs de qualité de prédiction print(matrices$indicators) ## rnames precision rappel F1 ## A &quot;A&quot; &quot;0.64&quot; &quot;0.92&quot; &quot;0.75&quot; ## B &quot;B&quot; &quot;0.59&quot; &quot;0.33&quot; &quot;0.43&quot; ## C &quot;C&quot; &quot;0.45&quot; &quot;0.17&quot; &quot;0.25&quot; ## D &quot;D&quot; &quot;0.47&quot; &quot;0.14&quot; &quot;0.22&quot; ## macro_scores &quot;macro&quot; &quot;0.6&quot; &quot;0.62&quot; &quot;0.57&quot; ## &quot;Kappa&quot; &quot;0.27&quot; NA NA ## &quot;Valeur de p (precision &gt; NIR)&quot; &quot;0&quot; NA NA La précision globale (macro) du modèle est de 60 % et dépasse significativement le seuil de non-information. Lindicateur de Kappa indique un accord modéré entre la prédiction et les valeurs réelles. Les catégories C et D sont les catégories avec la plus faible précision, indiquant ainsi que le modèle a tendance à manquer les prédictions pour les individus en désaccord avec le consensus scientifique sur le réchauffement climatique. Les indices de rappel sont également très faibles pour les catégories B, C et D, indiquant que très peu dobservations appartenant originalement à ces groupes ont bien été classées dans ces groupes. La capacité de prédiction du modèle est donc relativement faible. Interprétation des résultats Puisque nous disposons de quatre catégories dans notre variable Y, nous obtenons au final trois tableaux de coefficients. Il est possible de visualiser lensemble des coefficients du modèle avec la fonction summary, nous proposons les tableaux 8.17, 8.18 et 8.19 pour présenter lensemble des résultats. Tableau 8.17: Coefficients du modèle multinomial A versus B Variable Coefficient RC val.p RC 2,5 % RC 97,5 % sign. PercepOGMDes 1,940 6,989 0,000 4,221 11,588 *** PercepRechClimDes 0,430 1,532 0,305 0,677 3,456 ConnaisOGM -0,330 0,718 0,000 0,607 0,852 *** ConnaisRechClim 0,180 1,197 0,084 0,980 1,462 . CRT 0,350 1,417 0,016 1,073 1,878 Parti ref : Democrate       autre 0,660 1,934 0,001 1,310 2,858 *** Republicain 0,650 1,910 0,003 1,259 2,915 ** Sexe ref : homme       femme 1,280 3,581 0,000 2,535 5,053 *** Le tableau 8.17 compare donc le groupe A (en accord avec la recherche scientifique sur les deux sujets) et le groupe B (en désaccord sur la question des OGM). Les résultats indiquent que le fait de se percevoir en désaccord avec le consensus scientifique sur la question des OGM multiplie par sept les chances dappartenir au groupe B comparativement au groupe A. Cependant, pour chaque bonne réponse supplémentaire sur les questions testant les connaissances sur les OGM, les chances dappartenir au groupe B comparativement au groupe A diminue de 28 %. Ainsi, un individu ayant répondu correctement aux trois questions verrait ses chances réduites de 63 % dappartenir au groupe B (\\(exp(-\\text{0,33}\\times\\text{3})\\)). Il est intéressant de noter que les variables concernant le réchauffement climatique nont pas deffet significatif ici. La variable CRT indique quà chaque bonne réponse supplémentaire au test de cognition, les chances dappartenir au groupe B augmentent de 42 %. Un individu qui aurait répondu aux trois questions du test aurait donc 2,9 fois plus de chances dappartenir au groupe B quau groupe A. Concernant le parti politique, comparativement à une personne se déclarant plus proche du parti démocrate, les personnes proches du parti républicain ou dun autre parti ont près de deux fois plus de chances dappartenir au groupe B. Enfin, une femme, comparativement à un homme, a 3,6 fois plus de chance dappartenir au groupe B. Tableau 8.18: Coefficients du modèle multinomial A versus C variable Coefficient RC val.p RC 2,5 % RC 97,5 % sign. PercepOGMDes -0,180 0,834 0,705 0,326 2,138 PercepRechClimDes 2,060 7,821 0,000 3,819 16,119 *** ConnaisOGM -0,110 0,896 0,287 0,733 1,094 ConnaisRechClim 0,280 1,323 0,024 1,041 1,682 CRT 0,240 1,275 0,149 0,914 1,768 Parti ref : Democrate       autre -0,190 0,828 0,496 0,482 1,433 Republicain 0,920 2,512 0,000 1,584 4,015 *** Sexe ref : homme       femme:1 -0,450 0,640 0,040 0,419 0,980 Le tableau 8.18 compare les groupes A et C (en désaccord sur le réchauffement climatique). Il est intéressant de noter ici que se percevoir en désaccord avec la recherche scientifique est associé avec une forte augmentation des chances dappartenir au groupe C. Cependant, un plus grand nombre de bonnes réponses aux questions sur le réchauffement climatique est également associé avec une augmentation des chances (30 % à chaque bonne réponse supplémentaire) dappartenir au groupe C. Le CRT na cette fois-ci pas deffet. Se déclarer proche du parti républicain, comparativement au parti démocrate, multiplie les chances par 2,5 dappartenir au groupe C. Comparativement au tableau précédent, le fait dêtre une femme diminue les chances de 36 % dappartenir au groupe C. Tableau 8.19: Coefficients du modèle multinomial A versus D variable Coefficient RC val.p RC 2,5 % RC 97,5 % sign. PercepOGMDes 1,500 4,488 0,000 2,270 8,935 *** PercepRechClimDes 2,440 11,501 0,000 5,312 25,028 *** ConnaisOGM -0,480 0,621 0,000 0,492 0,787 *** ConnaisRechClim 0,130 1,140 0,399 0,844 1,553 CRT 0,340 1,409 0,119 0,914 2,160 Parti ref : Democrate       autre 0,190 1,211 0,531 0,664 2,203 Republicain 0,630 1,872 0,038 1,041 3,387 Sexe ref : homme       femme:1 -0,110 0,896 0,664 0,543 1,477 Le dernier tableau 8.19 compare le groupe A au groupe D (en désaccord sur les deux sujets). Les variables les plus importantes sont une fois encore le fait de se sentir en désaccord avec la recherche scientifique et le degré de connaissance sur les OGM. La variable concernant le parti politique est significative au seuil 0,05 et exprime toujours une tendance accrue pour les individus du parti républicain à appartenir au groupe D. Nos propres conclusions corroborent celles de larticle original. Une des conclusions intéressantes est que le rejet du consensus scientifique ne semble pas nécessairement être associé à un déficit dinformation ni à une plus faible capacité analytique, mais relèverait davantage dune polarisation politique. Notez que cette littérature sur les croyances et la confiance dans la recherche est complexe, si le sujet vous intéresse, la discussion de larticle de McFadden (2016) est un bon point de départ. 8.2.5 Conclusion sur les modèles pour des variables qualitatives Nous avons vu dans cette section, les trois principales formes de modèles GLM pour modéliser une variable binaire (modèle binomial), une variable ordinale (modèle de cotes proportionnel) et une variable multinomiale (modèle multinomial). Pour ces trois modèles, nous avons vu que la distribution utilisée est toujours la distribution binomiale et la fonction de lien logistique. Les coefficients obtenus sinterprètent comme des rapports de cotes, une fois quils sont transformés avec la fonction exponentielle. References "],["sect084.html", "8.3 Modèles GLM pour des variables de comptage", " 8.3 Modèles GLM pour des variables de comptage Dans cette section, nous présentons les principaux modèles utilisés pour modéliser des variables de comptage. Il peut sagir de variables comme le nombre daccidents à une intersection, le nombre de cafés par quartier, le nombre de cas dune maladie donnée par entité géographique, etc. 8.3.1 Modèle de Poisson Le modèle GLM de base pour modéliser une variable de comptage est le modèle de Poisson. Pour rappel, la distribution de Poisson a un seul paramètre: \\(\\lambda\\). Il représente le nombre moyen dévènements observés sur lintervalle de temps dune observation, ainsi que la dispersion de la distribution. En conséquence, \\(\\lambda\\) doit être un nombre strictement positif; autrement dit, nous ne pouvons pas observer un nombre négatif dévènements. Il est donc nécessaire dutiliser une fonction de lien pour contraindre léquation de régression sur lintervalle \\([0 ,+\\infty]\\). La fonction la plus utilisée est le logarithme naturel (log) dont la réciproque est la fonction exponentielle (exp). Tableau 8.20: Carte didentité du modèle de Poisson Type de variable dépendante Variable de comptage Distribution utilisée Poisson Formulation \\(Y \\sim Poisson(\\lambda)\\) \\(g(\\lambda) = \\beta_0 + \\beta X\\) \\(g(x) =log(x)\\) Fonction de lien log Paramètre modélisé \\(\\lambda\\) Paramètres à estimer \\(\\beta_0\\), \\(\\beta\\) Conditions dapplication Absence dexcès de zéros, absence de sur-dispersion ou de sous-dispersion 8.3.1.1 Interprétation des paramètres Les coefficients du modèle expriment leffet du changement dune unité des variables X sur \\(\\lambda\\) (le nombre de cas) dans léchelle logarithmique (log-scale). Pour rappel, léchelle logarithmique est multiplicative : si nous convertissons les coefficients dans leur échelle originale avec la fonction exponentielle, leur effet nest plus additif, mais multiplicatif. Prenons un exemple concret, admettons que nous avons ajusté un modèle de Poisson à une variable de comptage Y avec deux variables \\(X_1\\) et \\(X_2\\) et que nous avons obtenus les coefficients suivants : \\(\\beta_0 = 1,8 \\text{; } \\beta_1 = 0,5 \\text{; } \\beta_2 = -1,5\\) Linterprétation basique (sur léchelle logarithmique) est la suivante : une augmentation dune unité de la variable \\(X_1\\) est associée avec une augmentation de 0,5 du logarithme du nombre de cas attendus. Une augmentation dune unité de la variable \\(X_2\\) est associée avec une réduction de 1,5 unité du logarithme du nombre de cas attendus. Avec la conversion avec la fonction exponentielle, nous obtenons alors : \\(exp\\mbox{(0,5) = 1,649}\\), soit une multiplication par 1,649 du nombre de cas attendu (aussi appelé taux dincident) à chaque augmentation dune unité de \\(X_1\\); \\(exp\\mbox{(-1,5) = 0,223}\\), soit une division par 4,54 (1/0,223) du nombre de cas attendu (aussi appelé taux dincident) à chaque augmentation dune unité de \\(X_2\\). Utilisons maintenant notre équation pour effectuer une prédiction si \\(X_1 = 1\\) et \\(X_2 = 1\\). \\(\\lambda = exp(\\mbox{1,8} + (\\mbox{0,5}\\times 1) + (\\mbox{-1,5}\\times1)) = \\mbox{2,225}\\) Si nous augmentons \\(X_1\\) dune unité, nous obtenons alors : \\(\\lambda = exp(1,8 + (\\mbox{0,5}\\times 2) + (\\mbox{-1,5}\\times1)) = \\mbox{3,670}\\) En ayant augmenté dune unité \\(X_1\\), nous avons multiplié notre résultat par 1,649 (\\(\\mbox{2,225} \\times \\mbox{1,649 = 3,670}\\)). Notez que ces effets se multiplient entre eux. Si nous augmentons à la fois \\(X_1\\) et \\(X_2\\) dune unité chacune, nous obtenons : \\(\\lambda = exp(1,8 + (\\mbox{0,5} \\times 2) + (\\mbox{-1,5} \\times 2)) = \\mbox{0,818}\\), ce qui correspond bien à \\(\\mbox{2,225} \\times \\mbox{1,649} \\text{ (effet de }X_1\\text{)} \\times \\mbox{0,223} \\text{ (effet de }X_2\\text{)} = \\mbox{0,818}\\). Il existe des fonctions dans R qui calculent ces prédictions à partir des équations des modèles. Il est cependant essentiel de bien saisir ce comportement multiplicatif induit par la fonction de lien log. 8.3.1.1.1 Conditions dapplication Puisque la distribution de Poisson na quun seul paramètre, le modèle GLM de Poisson est exposé au même problème potentiel de sur-dispersion que les modèles binomiaux de la section précédente. Référez-vous à la section 8.2.1.2 pour davantage de détails sur le problème posé par la sur-dispersion. Pour détecter une potentielle sur-dispersion dans un modèle de Poisson, il est possible, dans un premier temps, de calculer le ratio entre la déviance du modèle et son nombre de degrés de liberté (SAS Institute Inc 2020b). Ce ratio doit être proche de 1, sil est plus grand, le modèle souffre de sur-dispersion. \\[\\begin{equation} \\hat{\\phi} = \\frac{D(modele)}{N-p} \\tag{8.19} \\end{equation}\\] avec \\(N\\) et \\(p\\) étant respectivement les nombres dobservations et de paramètres. Il est également possible de tester formellement si la sur-dispersion est significative avec un test de dispersion. La question de lexcès de zéros a été abordée dans la section 2.4.3.7 du chapitre 2. Il sagit dune situation où un plus grand nombre de zéros sont présents dans les données que ce que suppose la distribution de Poisson. Dans ce cas, il convient dutiliser la distribution de Poisson avec excès de zéros. 8.3.1.2 Exemple appliqué dans R Pour cet exemple, nous reproduisons lanalyse effectuée dans larticle de Cloutier et al. (2014). Lenjeu de cette étude était de modéliser le nombre de piétons blessés autour de plus de 500 carrefours dans les quartiers centraux de Montréal. Pour cela, trois types de variables étaient utilisées : des variables décrivant lintersection, des variables décrivant les activités humaines dans un rayon dun kilomètre autour de lintersection et des variables représentant le trafic routier autour de lintersection. Un effet direct de ce type détude est bien évidemment létablissement de meilleures pratiques daménagement réduisant les risques encourus par les piétons lors de leurs déplacements en ville. Le tableau 8.21 présente lensemble des variables utilisées dans lanalyse. Tableau 8.21: Variables indépendantes utilisées dans le modèle de Poisson Nom de la variable Signification Type de variable Mesure Feux_auto Présence de feux de circulation Variable binaire 0 = absence; 1 = présence Feux_piet Présence de feux de traversée pour les piétons Variable binaire 0 = absence; 1 = présence Pass_piet Présence dun passage piéton Variable binaire 0 = absence; 1 = présence Terreplein Présence dun terre-plein central Variable binaire 0 = absence; 1 = présence Apaisement Présence de mesure dapaisement de la circulation Variable binaire 0 = absence; 1 = présence LogEmploi Logarithme du nombre demplois dans un rayon dun kilomètre Variable continue Logarithme du nombre demploi. Utilisation du logarithme, car la variable est fortement asymétrique Densite_pop Densité de population dans un rayon dun kilomètre Variable continue Habitants par hectare Entropie Diversité des occupations du sol dans un rayon dun kilomètre (indice dentropie) Variable continue Mesure de 0 à 1; 0 = spécialisation parfaite; 1 = diversité parfaite DensiteInter Densité dintersections dans un rayon dun kilomètre (connexité) Variable continue Nombre dintersection par km2 Artere Présence dune artère à lintersection Variable binaire 0 = absence; 1 = présence Long_arterePS Longueur dartère dans un rayon dun kilomètre Variable continue Exprimée en mètres NB_voies5 Présence dune cinq voies à lintersection Variable binaire 0 = absence; 1 = présence La distribution originale de la variable est décrite à la figure 8.23. Les barres grises représentent la distribution du nombre daccidents et les barres rouges une distribution de Poisson ajustée sans variable indépendante (modèle nul). Ce premier graphique peut laisser penser quun modèle de Poisson nest pas nécessairement le plus adapté considérant le grand nombre dintersections pour lesquelles nous navons aucun accident. Cependant, rappelons que la variable Y na pas besoin de suivre une distribution de Poisson. Dans un modèle GLM, lhypothèse que nous formulons est que la variable dépendante (Y) conditionnée par les variables indépendantes (X) suit une certaine distribution (ici Poisson). # Chargement des données data_accidents &lt;- read.csv(&quot;data/glm/accident_pietons.csv&quot;, sep = &quot;;&quot;) # Ajustement d&#39;une distribution de Poisson sans variable indépendante library(fitdistrplus) model_poisson &lt;- fitdist(data_accidents$Nbr_acci,distr = &quot;pois&quot;) # Création d&#39;un graphique pour comparer les deux distributions dfpoisson &lt;- data.frame(x=c(0:19), y=dpois(0:19, model_poisson$estimate) ) counts &lt;- data.frame(table(data_accidents$Nbr_acci)) names(counts) &lt;- c(&quot;nb_accident&quot;,&#39;frequence&#39;) counts$nb_accident &lt;- as.numeric(as.character(counts$nb_accident)) counts$prop &lt;- counts$frequence / sum(counts$frequence) ggplot() + geom_bar(aes(x=nb_accident, weight = prop, fill = &quot;real&quot;), width = 0.6, data = counts)+ geom_bar(aes(x=x, weight = y, fill = &quot;adj&quot;), width = 0.15, data = dfpoisson)+ scale_x_continuous(limits = c(-0.5,7), breaks = c(0:7))+ scale_fill_manual(name = &quot;&quot;, breaks = c(&quot;real&quot;,&quot;adj&quot;), labels = c(&quot;distribution originale&quot;, &quot;distribution de Poisson&quot;), values = c(&quot;real&quot; = rgb(0.4,0.4,0.4), &quot;adj&quot; = &quot;red&quot;))+ labs(subtitle = &quot;&quot;, x = &quot;nombre d&#39;accidents&quot;, y = &quot;&quot;) Figure 8.23: Distribution originale du nombre daccidents par intersection Vérification des conditions dapplication Comme précédemment, notre première étape est de vérifier labsence de multicolinéarité excessive avec la fonction vif du package car. vif(glm(Nbr_acci ~ Feux_auto + Feux_piet + Pass_piet + Terreplein + Apaisement + LogEmploi + Densite_pop + Entropie + DensiteInter + Long_arterePS + Artere + NB_voies5, family = poisson(link=&quot;log&quot;), data = data_accidents)) ## Feux_auto Feux_piet Pass_piet Terreplein Apaisement ## 2.861708 1.518668 2.321213 1.221683 1.059722 ## LogEmploi Densite_pop Entropie DensiteInter Long_arterePS ## 4.763692 1.153096 1.770904 2.040457 4.467841 ## Artere NB_voies5 ## 1.887728 1.520514 Toutes les valeurs de VIF sont inférieures à 5. Notons tout de même que le logarithme de lemploi et la longueur dartère dans un rayon dun kilomètre ont des valeurs de VIF proches de 5. La seconde étape du diagnostic consiste à calculer et à visualiser les distances de Cook. # Ajustement d&#39;une première version du modèle modele &lt;- glm(Nbr_acci ~ Feux_auto + Feux_piet + Pass_piet + Terreplein + Apaisement + LogEmploi + Densite_pop + Entropie + DensiteInter + Long_arterePS + Artere + NB_voies5, family = poisson(link=&quot;log&quot;), data = data_accidents) # Calcul des distances de Cook cooksd &lt;- cooks.distance(modele) df &lt;- data.frame( cook = cooksd, oid = 1:length(cooksd) ) ggplot(data = df)+ geom_point(aes(x = oid, y = cook), size = 0.5, alpha = 0.5)+ labs(x = &quot;&quot;, y = &quot;Distance de Cook&quot;) Figure 8.24: Distances de Cook pour le modèle de Poisson La figure 8.24 signale la présence de trois observations avec des valeurs extrêmement fortes de distance de Cook. Nous les isolons dans un premier temps pour les analyser. cas_etrange &lt;- subset(data_accidents, cooksd&gt;0.1) print(cas_etrange) ## Nbr_acci Feux_auto Feux_piet Pass_piet Terreplein Apaisement EmpTotBuffer ## 1 19 1 1 1 1 0 7208.538 ## 26 7 0 0 1 0 0 1342.625 ## 428 0 1 1 1 0 1 13122.560 ## Densite_pop Entropie DensiteInter Long_arterePS Artere NB_voies5 log_acci ## 1 5980.923 0.8073926 42.41597 6955.00 1 1 2.995732 ## 26 2751.012 0.0000000 73.35344 2849.66 0 0 2.079442 ## 428 14148.827 0.6643891 109.25066 4634.20 0 0 0.000000 ## catego_acci catego_acci2 Arret VAG sum_app LogEmploi AccOrdinal PopHa ## 1 1 1 0 1 4 8.883021 2 5.980923 ## 26 1 1 1 1 3 7.202382 2 2.751012 ## 428 0 0 0 0 3 9.482088 0 14.148827 Les deux premiers cas sont des intersections avec de nombreux accidents (respectivement 19 et 7) qui risquent de perturber les estimations du modèle. Le troisième cas ne comprend en revanche aucun accident. Puisquil ne sagit que de trois observations et que leurs distances de Cook sont très nettement supérieures aux autres, nous les retirons du modèle. data2 &lt;- subset(data_accidents, cooksd&lt;0.1) # Ajustement d&#39;une première version du modèle modele &lt;- glm(Nbr_acci ~ Feux_auto + Feux_piet + Pass_piet + Terreplein + Apaisement + LogEmploi + Densite_pop + Entropie + DensiteInter + Long_arterePS + Artere + NB_voies5, family = poisson(link=&quot;log&quot;), data = data2) # Calcul des distances de Cook cooksd &lt;- cooks.distance(modele) df &lt;- data.frame( cook = cooksd, oid = 1:length(cooksd) ) ggplot(data = df)+ geom_point(aes(x = oid, y = cook), size = 0.5, alpha = 0.5)+ labs(x = &quot;&quot;, y = &quot;distance de Cook&quot;) Figure 8.25: Distances de Cook pour le modèle de Poisson après avoir retiré les valeurs aberrantes La figure 8.25 montre que nous navons plus dobservations fortement influentes dans le modèle après avoir retiré les trois observations identifiées précédemment. Nous devons à présent vérifier labsence de sur-dispersion. # Calcul du rapport entre déviance et nombre de degrés de liberté du modèle deviance(modele)/(nrow(data2) - modele$rank) ## [1] 1.674691 Le rapport entre la déviance et le nombre de degrés de liberté du modèle est nettement supérieur à 1, indiquant une sur-dispersion excessive. Nous pouvons confirmer ce résultat avec la fonction dispersiontest du package AER. library(AER) # Test de sur-dispersion dispersiontest(modele) ## ## Overdispersion test ## ## data: modele ## z = 5.2737, p-value = 6.686e-08 ## alternative hypothesis: true dispersion is greater than 1 ## sample estimates: ## dispersion ## 1.891565 Contrairement à la forme classique dun modèle de Poisson pour laquelle la dispersion attendue est de 1, le test nous indique quune dispersion de 1,89 serait mieux ajustée aux données. Il est également possible dilluster cet écart à laide dun graphique représentant les valeurs réelles, les valeurs prédites, ainsi que la variance (sous forme de barres derreurs) attendue par le modèle (figure 8.26). Nous constatons ainsi que les valeurs réelles (en rouge) ont largement tendance à dépasser la variance attendue par le modèle, surtout pour les valeurs les plus faibles de la distribution. # Extraction des prédictions du modèle lambdas &lt;- predict(modele, type = &quot;response&quot;) # Création d&#39;un DataFrame pour contenir la prédiction et les vraies valeurs df1 &lt;- data.frame( lambdas = lambdas, reals = data2$Nbr_acci ) # Calcul de l&#39;intervalle de confiance à 95 % selon la distribution de Poisson # et stockage dans un second DataFrame seqa &lt;- seq(0,round(max(lambdas)),1) df2 &lt;- data.frame( lambdas = seqa, lower = qpois(p = 0.025, lambda = seqa), upper = qpois(p = 0.975, lambda = seqa) ) # Affichage des valeurs réelles et prédites (en rouge) # et de leur variance selon le modèle (en noir) ggplot() + geom_errorbar(data = df2, mapping = aes(x = lambdas, ymin = lower, ymax = upper), width = 0.2, color = rgb(0.4,0.4,0.4)) + geom_point(data = df1, mapping = aes(x = lambdas, y = reals), color =&quot;red&quot;, size = 0.5) + labs(x = &#39;valeurs prédites&#39;, y = &quot;valeurs réelles&quot;) Figure 8.26: Représentation de la sur-dispersion des données dans le modèle de Poisson Pour tenir compte de cette particularité des données, nous modifions légèrement le modèle pour utiliser une distribution de quasi-Poisson, intégrant spécifiquement un paramètre de dispersion. Cet ajustement ne modifie pas lestimation des coefficients du modèle, mais modifie le calcul des erreurs standards et par extension les valeurs de p pour les rendre moins sensibles au problème de sur-dispersion. Une autre approche aurait été de calculer une version robuste des erreurs standards avec le package sandwich comme nous lavons fait dans la section 8.2.1 sur le modèle binomial. Après réajustement du modèle, le nouveau paramètre de dispersion estimé est de 1,92. Les quasi-distributions Les distributions binomiale et de Poisson ne disposent chacune que dun paramètre décrivant à la fois leur dispersion et leur espérance. Elles manquent donc de flexibilité et échouent parfois à représenter fidèlement des données avec une forte variance. Il existe donc dautres distributions, respectivement les distributions quasi-binomiale et quasi-Poisson comprenant chacune un paramètre supplémentaire pour contrôler la dispersion. Bien que cette solution soit attrayante, il ne faut pas perdre de vue que la sur ou la sous dispersion peuvent être causées par labsence de certaines variables explicatives, la sur-représentation de zéros, ou encore une séparation parfaite de la variable dépendante causée par une variable indépendante. modele2 &lt;- glm(Nbr_acci ~ Feux_auto + Feux_piet + Pass_piet + Terreplein + Apaisement + LogEmploi + Densite_pop + Entropie + DensiteInter + Long_arterePS + Artere + NB_voies5, family = quasipoisson(link=&quot;log&quot;), data = data2) Nous pouvons à présent comparer la distribution originale des données et les simulations issues du modèle. Notez que contrairement à la distribution de Poisson simple, il nexiste pas dans R de fonction pour simuler des valeurs issues dune distribution de quasi-Poisson. Il est cependant possible dexploiter sa proximité théorique avec la distribution binomiale négative pour définir notre propre fonction de simulation. La figure 8.27 permet de comparer la distribution originale (en gris) et lintervalle de confiance à 95 % des simulations (en rouge). Nous remarquons que le modèle semble capturer efficacement la forme générale de la distribution originale. À titre de comparaison, nous pouvons effectuer le même exercice avec la distribution de Poisson classique (le code nest pas montré pour éviter les répétitions). La figure 8.28 montre quun simple modèle de Poisson est très éloigné de la distribution originale de Y. # Définition d&#39;une fonction pour simuler des données quasi-Poisson rqpois &lt;- function(n, lambda, disp) { rnbinom(n = n, mu = lambda, size = lambda/(disp-1)) } # Extraction des valeurs prédites par le modèle preds &lt;- predict(modele2, type=&quot;response&quot;) # Génération de 1000 simulations pour chaque prédiction disp &lt;- summary(modele2)$dispersion nsim &lt;- 1000 cols &lt;- lapply(1:length(preds),function(i){ lambda &lt;- preds[[i]] sims &lt;- round(rqpois(n = nsim, lambda = lambda, disp = disp)) return(sims) }) mat_sims &lt;- do.call(rbind, cols) # Préparation des données pour le graphique (valeurs réelles) counts &lt;- data.frame(table(data2$Nbr_acci)) names(counts) &lt;- c(&quot;nb_accident&quot;,&#39;frequence&#39;) counts$nb_accident &lt;- as.numeric(as.character(counts$nb_accident)) counts$prop &lt;- counts$frequence / sum(counts$frequence) # Préparation des données pour le graphique (valeurs simulées) df1 &lt;- data.frame(count = 0:25) count_sims &lt;- lapply(1:nsim, function(i){ sim &lt;- mat_sims[,i] cnt &lt;- data.frame(table(sim)) df2 &lt;- merge(df1,cnt, by.x=&quot;count&quot;, by.y = &quot;sim&quot;, all.x = T, all.y=F) df2$Freq &lt;- ifelse(is.na(df2$Freq),0,df2$Freq) return(df2$Freq) }) count_sims &lt;- do.call(cbind,count_sims) df_sims &lt;- data.frame( val = 0:25, med = apply(count_sims, MARGIN = 1, median), lower = apply(count_sims, MARGIN = 1, quantile, probs = 0.025), upper = apply(count_sims, MARGIN = 1, quantile, probs = 0.975) ) ggplot() + geom_bar(aes(x=nb_accident, weight = frequence), width = 0.6, data = counts)+ geom_errorbar(aes(x = val, ymin = lower, ymax = upper), data = df_sims, color = &quot;red&quot;, width = 0.6)+ geom_point(aes(x = val, y = med), color = &quot;red&quot;, size = 1.3, data = df_sims)+ scale_x_continuous(limits = c(-0.5,7), breaks = c(0:7))+ xlim(-1,12)+ labs(subtitle = &quot;&quot;, x = &quot;nombre d&#39;accidents&quot;, y = &quot;nombre d&#39;occurrences&quot;) Figure 8.27: Comparaison de la distribution originale et des simulations pour le modèle de quasi-Poisson Figure 8.28: Comparaison de la distribution originale et des simulations pour le modèle de Poisson La prochaine étape du diagnostic est lanalyse des résidus simulés. La figure 8.29 indique que les résidus du modèle suivent bien une distribution uniforme et quaucune valeur aberrante nest observable. # Génération de 1000 simulations pour chaque prédiction disp &lt;- 1.918757 # trouvable dans le summary(modele2) nsim &lt;- 1000 cols &lt;- lapply(1:length(preds),function(i){ lambda &lt;- preds[[i]] sims &lt;- rqpois(n = nsim, lambda = lambda, disp = disp) return(sims) }) mat_sims &lt;- do.call(rbind, cols) sim_res &lt;- createDHARMa(simulatedResponse = mat_sims, observedResponse = data2$Nbr_acci, fittedPredictedResponse = modele2$fitted.values, integerResponse = T) plot(sim_res) Figure 8.29: Analyse globale des résidus simulés pour le modèle de quasi-Poisson Pour affiner notre diagnostic, nous pouvons également comparer les résidus simulés et chaque variable indépendante. La figure 8.30 nindique aucune relation problématique entre nos variables indépendantes et les résidus. par(mfrow=c(3,4)) vars &lt;- c(&quot;Feux_auto&quot;, &quot;Feux_piet&quot;, &quot;Pass_piet&quot;, &quot;Terreplein&quot;, &quot;Apaisement&quot;, &quot;LogEmploi&quot;, &quot;Densite_pop&quot;, &quot;Entropie&quot;, &quot;DensiteInter&quot;, &quot;Long_arterePS&quot;, &quot;Artere&quot;, &quot;NB_voies5&quot;) for(v in vars){ plotResiduals(sim_res, data2[[v]], xlab = v, main = &quot;&quot;, ylab = &quot;résidus&quot;) } Figure 8.30: Comparaison des résidus simulés et de chaque variable indépendante Maintenant que lensemble des diagnostics a été effectué, nous pouvons passer à la vérification de la qualité dajustement. Vérification de la qualité dajustement Pour le calcul des pseudo-R2, notez quil nexiste pas à proprement parler de loglikelihood pour les quasi-distributions. Pour contourner ce problème, il est possible dutiliser le loglikelihood dun simple modèle de Poisson (puisque les coefficients ne changent pas), mais il est important de garder à lesprit que ces pseudo-R2 seront dautant plus faibles que la sur-dispersion originale était forte. modelnull &lt;- glm(Nbr_acci ~ 1, family = poisson(link=&quot;log&quot;), data = data2) rsqs(loglike.full = logLik(modele), loglike.null = logLik(modelnull), full.deviance = deviance(modele), null.deviance = deviance(modelnull), nb.params = modele$rank, n = nrow(data2)) ## $`deviance expliquee` ## [1] 0.4805998 ## ## $`McFadden ajuste` ## &#39;log Lik.&#39; 0.3258375 (df=13) ## ## $`Cox and Snell` ## &#39;log Lik.&#39; 0.7789704 (df=13) ## ## $Nagelkerke ## &#39;log Lik.&#39; 0.787958 (df=13) Le modèle parvient ainsi à expliquer 48 % de la déviance totale. Il obtient un R2 ajusté de McFadden de 0,33 et un R2 de Cox et Snell de 0,78. # Calcul du RMSE sqrt(mean((predict(modele2, type = &quot;response&quot;) - data2$Nbr_acci)**2)) ## [1] 1.838026 # Nombre moyen d&#39;accidents mean(data2$Nbr_acci) ## [1] 1.503984 Lerreur quadratique moyenne du modèle est de 1,84, ce que signifie quen moyenne le modèle se trompe denviron deux accidents pour chaque intersection. Cette valeur est relativement élevée si nous la comparons avec le nombre moyen daccidents, soit 1,5. Cela sexplique certainement par le grand nombre de zéros dans la variable Y qui tendent à tirer les prédictions vers le bas. Interprétation des résultats Lensemble des coefficients du modèle sont accessibles via la fonction summary. Puisque la fonction de lien du modèle est la fonction log, il est pertinent de convertir les coefficients avec la fonction exp afin de pouvoir les interpréter sur léchelle originale (nombre d'accidents) plutôt que léchelle logarithmique (log(nombre d'accidents)). Noubliez pas que ces effets sont multiplicatifs une fois transformés avec la fonction exp. Nous pouvons également utiliser les erreurs standards pour calculer des intervalles de confiance à 95 % des exponentiels des coefficients. Le tableau 8.22 présente lensemble des informations pertinentes pour linterprétation des résultats. # Calcul des coefficients en exponentiel et des intervalles de confiance tableau &lt;- summary(modele2)$coefficients coeffs &lt;- tableau[,1] err.std &lt;- tableau[,2] expcoeff &lt;- exp(coeffs) exp2.5 &lt;- exp(coeffs - 1.96*err.std) exp975 &lt;- exp(coeffs - 1.96*err.std) pvals &lt;- tableau[,4] tableauComplet &lt;- cbind(coeffs,err.std,expcoeff,exp2.5,exp975,pvals) # print(tableauComplet) Tableau 8.22: Résultats du modèle de quasi-Poisson Variable Coeff. exp(Coeff.) Val.p IC 2,5 % exp(Coeff.) IC 97,5 % exp(Coeff.) Sign. Constante -3,680 0,030 0,000 0,010 0,090 *** Feux_auto 1,100 3,000 0,000 1,970 4,660 *** Feux_piet 0,330 1,390 0,009 1,090 1,790 ** Pass_piet 0,340 1,400 0,149 0,880 2,200 Terreplein -0,360 0,700 0,099 0,440 1,050 . Apaisement 0,290 1,330 0,157 0,880 1,950 LogEmploi 0,230 1,260 0,017 1,040 1,520 Densite_pop 0,000 1,000 0,000 1,000 1,000 *** Entropie -0,420 0,660 0,271 0,320 1,390 DensiteInter 0,000 1,000 0,410 1,000 1,010 Long_arterePS 0,000 1,000 0,684 1,000 1,000 Artere 0,030 1,030 0,842 0,780 1,360 NB_voies5 0,640 1,890 0,000 1,460 2,440 *** Parmi les variables décrivant les aménagements de lintersection, nous constatons que les présences dun feu de circulation et dun feu de traversée pour les piétons multiplient le nombre attendu daccidents à une intersection par 3,0 et 1,39. Par contre, les présences dun passage piéton, dun terre-plein ou de mesures dapaisement nont pas deffets significatifs (valeurs de p &gt; 0,05). Concernant les variables décrivant lenvironnement à proximité des intersections, nous observons que la concentration demplois et la densité de population contribuent toutes les deux à augmenter le nombre daccidents à une intersection, bien que leurs effets soient limités. Enfin, la présence dune rue à cinq voies à lintersection augmente le nombre daccidents attendu à lintersection de 89 %. Nous ne détaillons pas plus les résultats, car nous utilisons le même jeu de données dans les prochaines sections. 8.3.2 Modèle binomial négatif Dans le cas où une variable de comptage est marquée par une sur ou sous-dispersion, la distribution de Poisson nest pas en mesure de capturer efficacement sa variance. Pour contourner ce problème, il est possible dutiliser la distribution binomiale négative plutôt que la distribution de Poisson (ou quasi-Poisson). Cette distribution peut être décrite comme une généralisation de la distribution de Poisson : elle inclut un second paramètre \\(\\theta\\) contrôlant la dispersion. Lintérêt premier de ce changement de distribution est que linterprétation des paramètres est la même pour les deux modèles, tout en contrôlant directement leffet dune potentielle sur ou sous-dispersion. Tableau 8.23: Carte didentité du modèle binomial négatif Type de variable dépendante Variable de comptage Distribution utilisée Négative binomiale Formulation \\(Y \\sim NB(\\mu,\\theta)\\) \\(g(\\mu) = \\beta_0 + \\beta X\\) \\(g(x) =log(x)\\) Fonction de lien log Paramètre modélisé \\(\\mu\\) Paramètres à estimer \\(\\beta_0\\), \\(\\beta\\) et \\(\\theta\\) Conditions dapplication Absence dexcès de zéros, respect du lien variance-moyenne 8.3.2.1 Conditions dapplication Les conditions dapplication dun modèle binomial négatif sont presque les mêmes que celles dun modèle de Poisson. La seule différence est que la condition dabsence de sur ou sous-dispersion est remplacée par une condition de respect du lien espérance-variance. En effet, dans un modèle binomial négatif, le paramètre de dispersion \\(\\theta\\) est combiné avec \\(\\mu\\) (lespérance) pour exprimer la dispersion de la distribution. Dans le package mgcv que nous utilisons dans lexemple, le lien entre \\(\\mu\\), \\(\\theta\\) et la variance est le suivant : \\[\\begin{equation} variance = \\mu + \\mu^{\\frac{2}{\\theta}} \\tag{8.20} \\end{equation}\\] Il sagit donc dun modèle hétéroscédastique : sa variance nest pas fixe, mais varie en fonction de sa propre espérance. Si celle-ci augmente, la variance augmente (comme pour un modèle de Poisson), et lintensité de cette augmentation est contrôlée par le paramètre \\(\\theta\\). Si cette condition nest pas respectée, lanalyse des résidus simulés révélera un problème de dispersion. 8.3.2.2 Exemple appliqué dans R Dans lexemple précédent avec le modèle de Poisson, nous avons observé une certaine sur-dispersion que nous avons contournée en utilisant un modèle de quasi-Poisson. Dans larticle original, les auteurs ont opté pour un modèle binomial négatif, ce que nous reproduisons ici. Les variables utilisées sont les mêmes que pour le modèle de Poisson. Nous utilisons le package mgcv et sa fonction gam pour ajuster le modèle. Vérification des conditions dapplication Nous avons vu précédemment que nos variables indépendantes ne sont pas marquées par une multicolinéarité forte. Il nest pas nécessaire de recalculer les valeurs de VIF puisque nous utilisons les mêmes données. La première étape du diagnostic est donc de calculer les distances de Cook. library(mgcv) # Chargement des données data_accidents &lt;- read.csv(&quot;data/glm/accident_pietons.csv&quot;, sep = &quot;;&quot;) # Ajustement d&#39;une première version du modèle modelnb &lt;- gam(Nbr_acci ~ Feux_auto + Feux_piet + Pass_piet + Terreplein + Apaisement + LogEmploi + Densite_pop + Entropie + DensiteInter + Long_arterePS + Artere + NB_voies5, family = nb(link=&quot;log&quot;), data = data_accidents) # Calcul et affichage des distances de Cook cooksd &lt;- cooks.distance(modelnb) df &lt;- data.frame( cook = cooksd, oid = 1:length(cooksd) ) ggplot(data = df)+ geom_point(aes(x = oid, y = cook), size = 0.5, color = rgb(0.4,0.4,0.4)) + labs(x = &quot;&quot;, y = &quot;distance de Cook&quot;)+ theme(axis.ticks.x = element_blank(), axis.text.x = element_blank()) Figure 8.31: Distances de Cook pour le modèle binomial négatif Nous observons, dans la figure 8.31, que quatre observations se distinguent très nettement des autres. cas_etrange &lt;- subset(data_accidents, cooksd &gt; 0.03) print(cas_etrange) ## Nbr_acci Feux_auto Feux_piet Pass_piet Terreplein Apaisement EmpTotBuffer ## 1 19 1 1 1 1 0 7208.538 ## 5 12 1 0 1 0 0 8585.350 ## 26 7 0 0 1 0 0 1342.625 ## 34 6 0 0 1 0 0 12516.410 ## Densite_pop Entropie DensiteInter Long_arterePS Artere NB_voies5 log_acci ## 1 5980.923 0.8073926 42.41597 6955.00 1 1 2.995732 ## 5 8655.430 0.7607852 89.11495 6412.27 0 0 2.564949 ## 26 2751.012 0.0000000 73.35344 2849.66 0 0 2.079442 ## 34 8950.942 0.4300549 74.91879 8443.01 1 0 1.945910 ## catego_acci catego_acci2 Arret VAG sum_app LogEmploi AccOrdinal PopHa ## 1 1 1 0 1 4 8.883021 2 5.980923 ## 5 1 1 0 1 4 9.057813 2 8.655430 ## 26 1 1 1 1 3 7.202382 2 2.751012 ## 34 1 1 1 0 3 9.434796 2 8.950942 Il sagit à nouveau de quatre observations avec un grand nombre daccidents. Nous décidons de les retirer du jeu de données pour ne pas fausser les résultats concernant lensemble des autres intersections. Dans une analyse plus détaillée, il serait judicieux de chercher à comprendre pourquoi ces quatre observations sont particulièrement accidentogènes. data2 &lt;- subset(data_accidents, cooksd &lt; 0.03) # Ajustement d&#39;une première version du modèle modelnb &lt;- gam(Nbr_acci ~ Feux_auto + Feux_piet + Pass_piet + Terreplein + Apaisement + LogEmploi + Densite_pop + Entropie + DensiteInter + Long_arterePS + Artere + NB_voies5, family = nb(link=&quot;log&quot;), data = data2) # Calcul et affichage des distances de Cook cooksd &lt;- cooks.distance(modelnb) df &lt;- data.frame( cook = cooksd, oid = 1:length(cooksd) ) ggplot(data = df)+ geom_point(aes(x = oid, y = cook), size = 0.5, color = rgb(0.4,0.4,0.4)) + labs(x = &quot;&quot;, y = &quot;distance de Cook&quot;)+ theme(axis.ticks.x = element_blank(), axis.text.x = element_blank()) Figure 8.32: Distances de Cook pour le modèle binomial négatif (après avoir retiré quatre observations fortement influentes) Après avoir retiré ces quatre observations, les distances de Cook (figure 8.32) ne révèlent plus dobservations fortement influentes dans le modèle. La prochaine étape du diagnostic est donc danalyser les résidus simulés. # Extraction de la valeur de theta theta &lt;- modelnb$family$getTheta(T) nsim &lt;- 1000 # Extraction des valeurs prédites par le modèle mus &lt;- predict(modelnb, type = &quot;response&quot;) # Calcul des simulations cols &lt;- lapply(1:length(mus),function(i){ mu &lt;- mus[[i]] sims &lt;- rnbinom(n = nsim, mu = mu, size = theta) return(sims) }) mat_sims &lt;- do.call(rbind, cols) # Calcul des résidus simulés sim_res &lt;- createDHARMa(simulatedResponse = mat_sims, observedResponse = data2$Nbr_acci, fittedPredictedResponse = mus, integerResponse = T) # Affichage du diagnostic plot(sim_res) Figure 8.33: Diagnostic général des résidus simulés pour le modèle binomial négatif La figure 8.33 présentant le diagnostic des résidus simulés, montre que ces derniers suivent bien une distribution uniforme et aucun problème de dispersion ni de valeurs aberrantes. La figure 8.34 permet de comparer la distribution originale de la variable Y et les simulations issues du modèle (intervalles de confiance représentés en bleu). Nous constatons que le modèle parvient bien à reproduire la distribution originale, et ce, même pour les valeurs les plus extrèmes de la distribution. # Extraction des valeurs prédites par le modèle mus &lt;- predict(modelnb, type=&quot;response&quot;) # Génération de 1000 simulations pour chaque prédiction theta &lt;- modelnb$family$getTheta(T) nsim &lt;- 1000 cols &lt;- lapply(1:length(mus),function(i){ mu &lt;- mus[[i]] sims &lt;- round(rnbinom(n = nsim, mu = mu, size = theta)) return(sims) }) mat_sims &lt;- do.call(rbind, cols) # Préparation des données pour le graphique (valeurs réelles) counts &lt;- data.frame(table(data2$Nbr_acci)) names(counts) &lt;- c(&quot;nb_accident&quot;,&#39;frequence&#39;) counts$nb_accident &lt;- as.numeric(as.character(counts$nb_accident)) counts$prop &lt;- counts$frequence / sum(counts$frequence) # Préparation des données pour le graphique (valeurs simulées) df1 &lt;- data.frame(count = 0:25) count_sims &lt;- lapply(1:nsim, function(i){ sim &lt;- mat_sims[,i] cnt &lt;- data.frame(table(sim)) df2 &lt;- merge(df1,cnt, by.x=&quot;count&quot;, by.y = &quot;sim&quot;, all.x = T, all.y=F) df2$Freq &lt;- ifelse(is.na(df2$Freq),0,df2$Freq) return(df2$Freq) }) count_sims &lt;- do.call(cbind,count_sims) df_sims &lt;- data.frame( val = 0:25, med = apply(count_sims, MARGIN = 1, median), lower = apply(count_sims, MARGIN = 1, quantile, probs = 0.025), upper = apply(count_sims, MARGIN = 1, quantile, probs = 0.975) ) # Affichage du graphique ggplot() + geom_bar(aes(x=nb_accident, weight = frequence), width = 0.6, data = counts)+ geom_errorbar(aes(x = val, ymin = lower, ymax = upper), data = df_sims, color = &quot;blue&quot;, width = 0.6)+ geom_point(aes(x = val, y = med), color = &quot;blue&quot;, size = 1.3, data = df_sims)+ scale_x_continuous(limits = c(-0.5,7), breaks = c(0:7))+ xlim(-1,12)+ labs(subtitle = &quot;&quot;, x = &quot;nombre d&#39;accidents&quot;, y = &quot;nombre d&#39;occurrences&quot;) Figure 8.34: Comparaison de la distribution originale et des simulations pour le modèle binomial négatif À titre de comparaison, nous pouvons à nouveau réaliser le graphique permettant de visualiser si la variance attendue par le modèle est proche de celle effectivement observée dans les données. Nous avons constaté avec ce graphique, lorsque nous ajustions un modèle de Poisson, que la variance des données était trop grande comparativement à celle attendue par le modèle (figure 8.26). # Extraction des prédictions du modèle mus &lt;- predict(modelnb, type = &quot;response&quot;) # Création d&#39;un DataFrame pour contenir la prédiction et les vraies valeurs df1 &lt;- data.frame( mus = mus, reals = data2$Nbr_acci ) # Calcul de l&#39;intervalle de confiance à 95 % selon la distribution de Poisson # et stockage dans un second DataFrame seqa &lt;- seq(0,round(max(mus)),1) df2 &lt;- data.frame( mus = seqa, lower = qnbinom(p = 0.025, mu = seqa, size = theta), upper = qnbinom(p = 0.975, mu = seqa, size = theta) ) # Affichage des valeurs réelles et prédites (en rouge) # et de leur variance selon le modèle (en noir) ggplot() + geom_errorbar(data = df2, mapping = aes(x = mus, ymin = lower, ymax = upper), width = 0.2, color = rgb(0.4,0.4,0.4)) + geom_point(data = df1, mapping = aes(x = mus, y = reals), color =&quot;red&quot;, size = 0.5) + labs(x = &#39;valeurs prédites&#39;, y = &quot;valeurs réelles&quot;) Figure 8.35: Représentation de la sur-dispersion des données dans le modèle de Poisson Nous pouvons ainsi constater à la figure 8.35 que le modèle binomial négatif autorise une variance bien plus large que le modèle de Poisson et est ainsi mieux ajusté aux données. Vérification de la qualité dajustement # Calcul des pseudo R2 rsqs(loglike.full = logLik(modelnb), loglike.null = logLik(modelnull), full.deviance = deviance(modelnb), null.deviance = modelnb$null.deviance, nb.params = modelnb$rank, n = nrow(data2)) ## $`deviance expliquee` ## [1] 0.458052 ## ## $`McFadden ajuste` ## &#39;log Lik.&#39; 0.384353 (df=14) ## ## $`Cox and Snell` ## &#39;log Lik.&#39; 0.8304773 (df=14) ## ## $Nagelkerke ## &#39;log Lik.&#39; 0.8399731 (df=14) # Calcul du RMSE sqrt(mean((predict(modelnb, type = &quot;response&quot;) - data2$Nbr_acci)**2)) ## [1] 1.825278 Le modèle parvient à expliquer 45 % de la déviance. Il obtient un R2 ajusté de McFadden de 0,14 et un R2 de Nagelkerke de 0,42. Lerreur moyenne quadratique de la prédiction est de 1,82, ce qui est identique au modèle de Poisson ajusté précédemment. Interprétation des résultats Il est possible daccéder à lensemble des coefficients du modèle via la fonction summary. À nouveau, les coefficients doivent être convertis avec la fonction exponentielle (du fait de la fonction de lien log) et interprétés comme des effets multiplicatifs. Le tableau 8.24 présente les coefficients estimés par le modèle. Les résultats sont très similaires à ceux du modèle de quasi-Poisson original. Nous notons cependant que la variable représentant la présence dun feu pour piéton nest plus significative au seuil de 0,05. Tableau 8.24: Résultats du modèle binomial négatif Variable Coeff. exp(Coeff.) Val.p IC 2,5 % exp(Coeff.) IC 97,5 % exp(Coeff.) Sign. Constante -3,880 0,020 0,000 0,010 0,080 *** Feux_auto 1,130 3,100 0,000 2,030 4,710 *** Feux_piet 0,350 1,420 0,016 1,060 1,900 Pass_piet 0,220 1,240 0,300 0,830 1,880 Terreplein -0,340 0,710 0,155 0,440 1,140 Apaisement 0,240 1,270 0,315 0,790 2,030 LogEmploi 0,230 1,260 0,025 1,030 1,550 Densite_pop 0,000 1,000 0,000 1,000 1,000 *** Entropie -0,170 0,840 0,669 0,380 1,860 DensiteInter 0,000 1,000 0,925 0,990 1,010 Long_arterePS 0,000 1,000 0,587 1,000 1,000 Artere 0,110 1,110 0,497 0,820 1,510 NB_voies5 0,700 2,010 0,000 1,480 2,750 *** 8.3.3 Modèle de Poisson avec excès fixe de zéros Dans le cas où la variable Y comprendrait significativement plus de zéros que ce que suppose une distribution de Poisson, il est possible dutiliser la distribution de Poisson avec excès de zéros. Pour rappel, cette distribution ajoute un paramètre p contrôlant pour la proportion de zéros dans la distribution. Du point de vue conceptuel, cela revient à formuler lhypothèse suivante : dans les données que nous avons observées, deux processus distincts sont à luvre. Le premier est issu dune distribution de Poisson et lautre produit des zéros qui sajoutent aux données. Les zéros produits par la distribution de Poisson sont appelés les vrais zéros, alors que ceux produits par le second phénomène sont appelés les faux zéros. Tableau 8.25: Carte didentité du modèle de Poisson avec excès fixe de zéros Type de variable dépendante Variable de comptage Distribution utilisée Poisson avec excès de zéros Formulation \\(Y \\sim ZIP(\\mu,\\theta)\\) \\(g(\\lambda) = \\beta_0 + \\beta X\\) \\(g(x) =log(x)\\) Fonction de lien log Paramètre modélisé \\(\\lambda\\) Paramètres à estimer \\(\\beta_0\\), \\(\\beta\\) et p Conditions dapplication Absence de sur-dispersion Dans cette formulation, p est fixé. Nous navons donc aucune information sur ce qui produit les zéros supplémentaires, mais seulement leur proportion totale dans le jeu de données. 8.3.3.1 Interprétation des paramètres Linterprétation des paramètres est identique à celle dun modèle de Poisson. Le paramètre p représente la proportion de faux zéros dans la variable Y une fois que les variables indépendantes sont contrôlées. 8.3.3.2 Exemple appliqué dans R La variable de comptage des accidents des piétons que nous avons utilisée dans les deux exemples précédents semble être une bonne candidate pour une distribution de Poisson avec excès de zéros. En effet, nous avons pu constater une sur-dispersion dans le modèle de Poisson original, ainsi quun nombre important dintersections sans accident. Tentons donc daméliorer notre modèle en ajustant un excès fixe de zéros. Nous utilisons la fonction gamlss du package gamlss. library(gamlss) modelzi &lt;- gamlss(formula = Nbr_acci ~ Feux_auto + Feux_piet + Pass_piet + Terreplein + Apaisement + LogEmploi + Densite_pop + Entropie + DensiteInter + Long_arterePS + Artere + NB_voies5, sigma.formula = ~1, family = ZIP(mu.link = &quot;log&quot;, sigma.link=&quot;logit&quot;), data = data_accidents) ## GAMLSS-RS iteration 1: Global Deviance = 1516.53 ## GAMLSS-RS iteration 2: Global Deviance = 1514.656 ## GAMLSS-RS iteration 3: Global Deviance = 1514.52 ## GAMLSS-RS iteration 4: Global Deviance = 1514.508 ## GAMLSS-RS iteration 5: Global Deviance = 1514.506 ## GAMLSS-RS iteration 6: Global Deviance = 1514.506 modelnull &lt;- glm(formula = Nbr_acci ~ 1, family = poisson(link=&quot;log&quot;), data = data_accidents) # Constante pour p coeff_p &lt;- modelzi$sigma.coefficients cat(&quot;Coefficient pour p =&quot;, round(coeff_p,4)) ## Coefficient pour p = -1.4376 # Calcul de la déviance expliquée 1 - deviance(modelzi) / deviance(modelnull) ## [1] 0.08267513 # Calcul de la probabilité de base p d&#39;être un faux 0 # en appliquant l&#39;inverse de la fonction logistique exp(-coeff_p) / (1+exp(-coeff_p)) ## (Intercept) ## 0.80809 Nous constatons immédiatement que le modèle avec excès fixe de zéros est peu ajusté aux données. Cette version du modèle ne parvient à capter que 8 % de la déviance, ce qui sexplique facilement, car nous navons donné aucune variable au modèle pour distinguer les vrais et les faux zéros. Pour cela, nous devons passer au prochain modèle : Poisson avec excès ajusté de zéros. Notons tout de même que daprès ce modèle, 81 % des observations seraient des faux zéros. 8.3.4 Modèle de Poisson avec excès ajusté de zéros Nous avons vu dans le modèle précédent, que lexcès de zéro était conceptualisé comme la combinaison de deux phénomènes, lun issu dune distribution de Poisson que nous souhaitons modéliser, et lautre générant des zéros supplémentaires. Il est possible daller plus loin que de simplement contrôler la proportion de zéros supplémentaires en modélisant explicitement ce second processus en ajoutant une deuxième équation au modèle. Cette deuxième équation a pour enjeu de modéliser p (la proportion de 0) à laide de variables indépendantes, ces dernières pouvant se retrouver dans les deux parties du modèle. Lidée étant que, pour chaque observation, le modèle évalue sa probabilité dêtre un faux zéro (partie binomiale), et le nombre attendu daccidents. Tableau 8.26: Carte didentité du modèle de Poisson avec excès ajusté de zéros Type de variable dépendante Variable de comptage Distribution utilisée Poisson avec excès de zéros Formulation \\(Y \\sim ZIP(\\mu,\\theta)\\) \\(g(\\mu) = \\beta_0 + \\beta X\\) \\(s(p) = \\alpha_0 + \\alpha_X\\) \\(g(x) =log(x)\\) \\(s(x) = log(\\frac{x}{1-x})\\) Fonction de lien log et logistique Paramètre modélisé \\(\\mu\\) et p Paramètres à estimer \\(\\beta_0\\), \\(\\beta\\), \\(\\alpha_0\\) et \\(\\alpha\\) Conditions dapplication Absence de sur-dispersion 8.3.4.1 Interprétation des paramètres Linterprétation des paramètres \\(\\beta_0\\) et \\(\\beta\\) est identique à celle dun modèle de Poisson. Les paramètres \\(\\alpha_0\\) et \\(\\alpha\\) sont identiques à ceux dun modèle binomial. Plus spécifiquement, ces derniers paramètres modélisent la probabilité dobserver des valeurs supérieures à zéro. 8.3.4.2 Exemple appliqué Nous avons vu, dans lexemple précédent, que lutilisation du modèle avec excès fixe de zéros pour les données daccident des piétons aux intersections ne donnait pas de résultats satisfaisants. Nous tentons ici daméliorer le modèle en ajoutant les variables indépendantes significatives du modèle Poisson dans la seconde équation de régression destinée à détecter les faux zéros. Vérification des conditions dapplication Pour un modèle de Poisson avec excès de zéros, il nest pas possible de calculer les distances de Cook. Nous devons donc directement passer à lanalyse des résidus simulés. # Ajuster une première version du modèle modelza &lt;- gamlss(formula = Nbr_acci ~ Feux_auto + Feux_piet + Pass_piet + Terreplein + Apaisement + LogEmploi + Densite_pop + Entropie + DensiteInter + Long_arterePS + Artere + NB_voies5, sigma.formula = ~1 + Feux_auto + Feux_piet + Densite_pop + NB_voies5, family = ZIP(mu.link = &quot;log&quot;, sigma.link=&quot;logit&quot;), data = data_accidents) ## GAMLSS-RS iteration 1: Global Deviance = 1505.155 ## GAMLSS-RS iteration 2: Global Deviance = 1488.658 ## GAMLSS-RS iteration 3: Global Deviance = 1483.304 ## GAMLSS-RS iteration 4: Global Deviance = 1482.085 ## GAMLSS-RS iteration 5: Global Deviance = 1481.868 ## GAMLSS-RS iteration 6: Global Deviance = 1481.832 ## GAMLSS-RS iteration 7: Global Deviance = 1481.827 ## GAMLSS-RS iteration 8: Global Deviance = 1481.825 ## GAMLSS-RS iteration 9: Global Deviance = 1481.825 # Extraire la prédiction des valeurs lambda lambdas &lt;- predict(modelza, type = &quot;response&quot;, what = &quot;mu&quot;) # Extraire la prédiction des valeurs p ps &lt;- predict(modelza, type = &quot;response&quot;, what = &quot;sigma&quot;) # Calculer la combinaison de ces deux éléments preds &lt;- lambdas * ps # Effectuer les 1000 simulations nsim &lt;- 1000 cols &lt;- lapply(1:length(lambdas),function(i){ lambda &lt;- lambdas[[i]] p &lt;- ps[[i]] sims &lt;- rZIP(n = nsim, mu = lambda, sigma = p) return(sims) }) mat_sims &lt;- do.call(rbind, cols) # Calculer les résidus simulés sim_res &lt;- createDHARMa(simulatedResponse = mat_sims, observedResponse = data_accidents$Nbr_acci, fittedPredictedResponse = preds, integerResponse = T) plot(sim_res) Figure 8.36: Diagnostic général des résidus simulés du modèle de Poisson avec excès de zéros ajusté La figure 8.36 indique deux problèmes importants dans le modèle : la présence de valeurs aberrantes ainsi quun potentiel problème de dispersion. Nous commençons donc par identifier ces valeurs aberrantes. # Identification des outliers isOutlier &lt;- outliers(sim_res,return = &quot;logical&quot;,lowerQuantile = 0.001, upperQuantile = 0.999) cas_etrange &lt;- subset(data_accidents, isOutlier) print(cas_etrange) ## Nbr_acci Feux_auto Feux_piet Pass_piet Terreplein Apaisement EmpTotBuffer ## 1 19 1 1 1 1 0 7208.538 ## 5 12 1 0 1 0 0 8585.350 ## 26 7 0 0 1 0 0 1342.625 ## 44 5 0 0 0 0 0 4998.519 ## 482 0 0 0 0 0 0 1813.911 ## Densite_pop Entropie DensiteInter Long_arterePS Artere NB_voies5 log_acci ## 1 5980.923 0.8073926 42.41597 6955.00 1 1 2.995732 ## 5 8655.430 0.7607852 89.11495 6412.27 0 0 2.564949 ## 26 2751.012 0.0000000 73.35344 2849.66 0 0 2.079442 ## 44 8090.478 0.7879618 66.86856 4517.65 0 0 1.791759 ## 482 8988.260 0.4486079 60.93742 3821.78 1 0 0.000000 ## catego_acci catego_acci2 Arret VAG sum_app LogEmploi AccOrdinal PopHa ## 1 1 1 0 1 4 8.883021 2 5.980923 ## 5 1 1 0 1 4 9.057813 2 8.655430 ## 26 1 1 1 1 3 7.202382 2 2.751012 ## 44 1 1 1 1 4 8.516897 2 8.090478 ## 482 0 0 0 0 3 7.503240 0 8.988260 Nous retirons des données les quelques observations pouvant avoir une trop forte influence sur le modèle. Après réajustement, la figure 8.37 nous informe que nous navons plus de valeurs aberrantes restantes ni de fort problème de dispersion. En revanche, le premier quantile des résidus tant à être plus faible que ce que nous aurions pu nous attendre dune distribution uniforme. Ce constat laisse penser que le modèle a du mal à bien identifier les faux zéros. Ce résultat nest pas étonnant, car aucune variable navait été identifiée à cette fin dans larticle original (Cloutier et al. 2014) qui utilisait un modèle binomial négatif. data2 &lt;- subset(data_accidents, isOutlier==FALSE) # Ajuster une première version du modèle modelza &lt;- gamlss(formula = Nbr_acci ~ Feux_auto + Feux_piet + Pass_piet + Terreplein + Apaisement + LogEmploi + Densite_pop + Entropie + DensiteInter + Long_arterePS + Artere + NB_voies5, sigma.formula = ~1 + Feux_auto + Feux_piet + Densite_pop + NB_voies5, family = ZIP(mu.link = &quot;log&quot;, sigma.link=&quot;logit&quot;), data = data2) ## GAMLSS-RS iteration 1: Global Deviance = 1390.884 ## GAMLSS-RS iteration 2: Global Deviance = 1381.199 ## GAMLSS-RS iteration 3: Global Deviance = 1378.319 ## GAMLSS-RS iteration 4: Global Deviance = 1377.422 ## GAMLSS-RS iteration 5: Global Deviance = 1377.118 ## GAMLSS-RS iteration 6: Global Deviance = 1377.015 ## GAMLSS-RS iteration 7: Global Deviance = 1376.982 ## GAMLSS-RS iteration 8: Global Deviance = 1376.972 ## GAMLSS-RS iteration 9: Global Deviance = 1376.968 ## GAMLSS-RS iteration 10: Global Deviance = 1376.967 ## GAMLSS-RS iteration 11: Global Deviance = 1376.966 # Extraire la prédiction des valeurs lambda lambdas &lt;- predict(modelza, type = &quot;response&quot;, what = &quot;mu&quot;) # Extraire la prédiction des valeurs p ps &lt;- predict(modelza, type = &quot;response&quot;, what = &quot;sigma&quot;) # Calculer la combinaison de ces deux éléments preds &lt;- lambdas * ps # Effectuer les 1000 simulations nsim &lt;- 1000 cols &lt;- lapply(1:length(lambdas),function(i){ lambda &lt;- lambdas[[i]] p &lt;- ps[[i]] sims &lt;- rZIP(n = nsim, mu = lambda, sigma = p) return(sims) }) mat_sims &lt;- do.call(rbind, cols) # Calculer les résidus simulés sim_res &lt;- createDHARMa(simulatedResponse = mat_sims, observedResponse = data2$Nbr_acci, fittedPredictedResponse = preds, integerResponse = T) plot(sim_res) Figure 8.37: Diagnostic général des résidus simulés du modèle de Poisson avec excès de zéros ajusté (sans valeurs aberrantes) Nous pouvons une fois encore comparer des simulations issues du modèle et de la distribution originale de la variable Y. La figure 8.38 montre clairement que les simulations du modèle (en bleu) sont très éloignées dans la distribution originale (en gris), ce qui remet directement en question la pertinence de ce modèle. # Extraire la prédiction des valeurs lambda lambdas &lt;- predict(modelza, type = &quot;response&quot;, what = &quot;mu&quot;) # Extraire la prédiction des valeurs p ps &lt;- predict(modelza, type = &quot;response&quot;, what = &quot;sigma&quot;) # Génération de 1000 simulations pour chaque prédiction nsim &lt;- 1000 cols &lt;- lapply(1:length(lambdas),function(i){ lambda &lt;- lambdas[[i]] p &lt;- ps[[1]] sims &lt;- round(rZIP(nsim,mu=lambda, sigma = p)) return(sims) }) mat_sims &lt;- do.call(rbind, cols) # Préparation des données pour le graphique (valeurs réelles) counts &lt;- data.frame(table(data2$Nbr_acci)) names(counts) &lt;- c(&quot;nb_accident&quot;,&#39;frequence&#39;) counts$nb_accident &lt;- as.numeric(as.character(counts$nb_accident)) counts$prop &lt;- counts$frequence / sum(counts$frequence) # Préparation des données pour le graphique (valeurs simulées) df1 &lt;- data.frame(count = 0:25) count_sims &lt;- lapply(1:nsim, function(i){ sim &lt;- mat_sims[,i] cnt &lt;- data.frame(table(sim)) df2 &lt;- merge(df1,cnt, by.x=&quot;count&quot;, by.y = &quot;sim&quot;, all.x = T, all.y=F) df2$Freq &lt;- ifelse(is.na(df2$Freq),0,df2$Freq) return(df2$Freq) }) count_sims &lt;- do.call(cbind,count_sims) df_sims &lt;- data.frame( val = 0:25, med = apply(count_sims, MARGIN = 1, median), lower = apply(count_sims, MARGIN = 1, quantile, probs = 0.025), upper = apply(count_sims, MARGIN = 1, quantile, probs = 0.975) ) # Affichage du graphique ggplot() + geom_bar(aes(x=nb_accident, weight = frequence), width = 0.6, data = counts)+ geom_errorbar(aes(x = val, ymin = lower, ymax = upper), data = df_sims, color = &quot;blue&quot;, width = 0.6)+ geom_point(aes(x = val, y = med), color = &quot;blue&quot;, size = 1.3, data = df_sims)+ scale_x_continuous(limits = c(-0.5,7), breaks = c(0:7))+ xlim(-1,12)+ labs(subtitle = &quot;&quot;, x = &quot;nombre d&#39;accidents&quot;, y = &quot;nombre d&#39;occurrences&quot;) Figure 8.38: Comparaison de la distribution originale et des simulations pour le modèle de Poisson avec excès de zéros ajusté Vérification la qualité dajustement modelenull &lt;- glm(Nbr_acci ~ 1, family = poisson(link=&quot;log&quot;), data = data2) # Calcul des R2 rsqs(loglike.full = logLik(modelza), loglike.null = logLik(modelenull), full.deviance = deviance(modelza), null.deviance = deviance(modelenull), nb.params = modelza$sigma.df + modelza$mu.df, n = nrow(data2) ) ## $`deviance expliquee` ## [1] 0.1073371 ## ## $`McFadden ajuste` ## &#39;log Lik.&#39; 0.3588483 (df=18) ## ## $`Cox and Snell` ## &#39;log Lik.&#39; 0.8086509 (df=18) ## ## $Nagelkerke ## &#39;log Lik.&#39; 0.8186255 (df=18) # Calcul du RMSE sqrt(mean((preds - data2$Nbr_acci)**2)) ## [1] 2.635322 Le modèle avec excès de zéro ajusté ne parvient à expliquer que 11 % de la déviance totale. Il obtient toutefois des valeurs de R2 assez hautes (McFadden ajusté : 0,36, Nagerlkerke : 0,82). Son RMSE est très élevé (2,6), comparativement à celui que nous avons obtenu avec le modèle binomial négatif (1,9). Considérant ces éléments, ce modèle est nettement moins informatif que le modèle binomial négatif et ne devrait pas être retenu. Nous montrons tout de même ici comment interpréter ces résultats. Interprétation des résultats Lensemble des coefficients du modèle sont accessibles avec la fonction summary. Les coefficients dédiés à la partie Poisson (appelée Mu dans le résumé) doivent être analysés et interprétés de la même manière que sils provenaient dun modèle de Poisson. Les coefficients appartenant à la partie logistique (appelé Sigma dans le résumé) doivent être analysés et interprétés de la même manière que sils provenaient dun modèle logistique. # Extraction des résultats base_table &lt;- summary(modelza) ## ****************************************************************** ## Family: c(&quot;ZIP&quot;, &quot;Poisson Zero Inflated&quot;) ## ## Call: gamlss(formula = Nbr_acci ~ Feux_auto + Feux_piet + ## Pass_piet + Terreplein + Apaisement + LogEmploi + ## Densite_pop + Entropie + DensiteInter + Long_arterePS + ## Artere + NB_voies5, sigma.formula = ~1 + Feux_auto + ## Feux_piet + Densite_pop + NB_voies5, family = ZIP(mu.link = &quot;log&quot;, ## sigma.link = &quot;logit&quot;), data = data2) ## ## Fitting method: RS() ## ## ------------------------------------------------------------------ ## Mu link function: log ## Mu Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) -2.609e+00 5.419e-01 -4.814 1.98e-06 *** ## Feux_auto 5.779e-01 1.903e-01 3.036 0.00253 ** ## Feux_piet 4.207e-01 1.048e-01 4.012 6.97e-05 *** ## Pass_piet 3.995e-01 1.938e-01 2.061 0.03987 * ## Terreplein -3.348e-01 1.666e-01 -2.010 0.04502 * ## Apaisement 2.246e-01 1.535e-01 1.463 0.14405 ## LogEmploi 1.663e-01 7.509e-02 2.215 0.02723 * ## Densite_pop 8.610e-05 1.501e-05 5.735 1.72e-08 *** ## Entropie -2.894e-01 2.950e-01 -0.981 0.32698 ## DensiteInter 4.035e-03 2.052e-03 1.967 0.04980 * ## Long_arterePS 1.100e-05 2.024e-05 0.544 0.58698 ## Artere 8.629e-02 1.117e-01 0.772 0.44035 ## NB_voies5 4.295e-01 1.017e-01 4.224 2.87e-05 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## ------------------------------------------------------------------ ## Sigma link function: logit ## Sigma Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 1.004e+00 5.530e-01 1.816 0.07005 . ## Feux_auto -1.716e+00 6.031e-01 -2.845 0.00463 ** ## Feux_piet 2.661e-01 7.228e-01 0.368 0.71292 ## Densite_pop -1.170e-04 5.469e-05 -2.140 0.03286 * ## NB_voies5 -1.831e+00 1.227e+00 -1.493 0.13606 ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## ------------------------------------------------------------------ ## No. of observations in the fit: 500 ## Degrees of Freedom for the fit: 18 ## Residual Deg. of Freedom: 482 ## at cycle: 11 ## ## Global Deviance: 1376.967 ## AIC: 1412.967 ## SBC: 1488.829 ## ****************************************************************** # Multiplication par 1000 des coefficients de population # (effet pour 1000 habitants) base_table[8,1] &lt;- 1000 * base_table[8,1] base_table[8,2] &lt;- 1000 * base_table[8,2] base_table[17,1] &lt;- 1000 * base_table[17,1] base_table[17,2] &lt;- 1000 * base_table[17,2] # Multiplication par 1000 des coefficients de longueur artère # (effet pour 1 km) base_table[11,1] &lt;- 1000 * base_table[11,1] base_table[11,2] &lt;- 1000 * base_table[11,2] # Calcul des exponentiels des variables indépendantes # et des intervalles de confiance expcoeff &lt;- exp(base_table[,1]) expcoeff2.5 &lt;- exp(base_table[,1] - 1.96 * base_table[,2]) expcoeff97.5 &lt;- exp(base_table[,1] + 1.96 * base_table[,2]) base_table &lt;- cbind(base_table, expcoeff, expcoeff2.5,expcoeff97.5) # Calculer une colonne indiquant le niveau de significativité sign &lt;- case_when( base_table[,4] &lt; 0.001 ~ &quot;***&quot;, base_table[,4] &gt;= 0.001 &amp; base_table[,4]&lt;0.01 ~ &quot;**&quot;, base_table[,4] &gt;= 0.01 &amp; base_table[,4]&lt;0.05 ~ &quot;*&quot;, base_table[,4] &gt;= 0.05 &amp; base_table[,4]&lt;0.1 ~ &quot;.&quot;, TRUE ~ &quot;&quot; ) # Arrondir à trois décimales base_table &lt;- round(base_table,3) # Enlever les colonnes de valeurs de t et d&#39;erreur standard base_table &lt;- base_table[,c(1,4,5,6,7)] base_table &lt;- cbind(base_table, sign) # Remplacer les 0 dans la colonne pval base_table[,2] &lt;- ifelse(base_table[,2]==&quot;0&quot;,&quot;&lt;0.001&quot;,base_table[,2]) # Séparer le tout en deux tableaux part_poiss &lt;- base_table[1:13,] part_logit &lt;- base_table[14:18,] # Mettre les bons noms de colonnes colnames(part_poiss) &lt;- c(&quot;Coeff.&quot;,&quot;Val.p&quot;,&quot;Exp(Coeff.)&quot;, &quot;IC 2,5 % exp(Coeff.)&quot;,&quot;IC 97,5 % exp(Coeff.)&quot;, &quot;Sign.&quot;) colnames(part_logit) &lt;- c(&quot;Coeff.&quot;,&quot;Val.p&quot;,&quot;RC&quot;,&quot;IC 2,5 % RC&quot;,&quot;IC 97,5 % RC&quot;, &quot;Sign.&quot;) Nous rapportons les résultats de ce modèle de Poisson avec excès de zéro ajusté dans les tableaux 8.27 et 8.28. Tableau 8.27: Résultats de la partie Poisson du modèle de Poisson avec excès de zéros ajusté Variable Coeff. Val.p Exp(Coeff.) IC 2,5 % exp(Coeff.) IC 97,5 % exp(Coeff.) Sign. (Intercept) -2.609 &lt;0.001 0.074 0.025 0.213 *** Feux_auto 0.578 0.003 1.782 1.227 2.588 ** Feux_piet 0.421 &lt;0.001 1.523 1.24 1.87 *** Pass_piet 0.399 0.04 1.491 1.02 2.18 Terreplein -0.335 0.045 0.715 0.516 0.992 Apaisement 0.225 0.144 1.252 0.927 1.691 LogEmploi 0.166 0.027 1.181 1.019 1.368 Densite_pop 0.086 &lt;0.001 1.09 1.058 1.122 *** Entropie -0.289 0.327 0.749 0.42 1.335 DensiteInter 0.004 0.05 1.004 1 1.008 Long_arterePS 0.011 0.587 1.011 0.972 1.052 Artere 0.086 0.44 1.09 0.876 1.357 NB_voies5 0.429 &lt;0.001 1.536 1.259 1.875 *** Tableau 8.28: Résultats de la partie logistique du modèle de Poisson avec excès de zéros ajusté Variable Coeff. Val.p RC IC 2,5 % RC IC 97,5 % RC Sign. (Intercept) 1.004 0.07 2.729 0.923 8.067 . Feux_auto -1.716 0.005 0.18 0.055 0.586 ** Feux_piet 0.266 0.713 1.305 0.316 5.381 Densite_pop -0.117 0.033 0.89 0.799 0.99 NB_voies5 -1.831 0.136 0.16 0.014 1.773 Nous observons ainsi que la présence dun feu de circulation divise par 5 les chances de rentrer dans la catégorie dintersection où des accidents peuvent se produire. De même, la densité de population réduit les chances de passer dans cette catégorie de 11 %. Concernant les coefficients pour la partie Poisson du modèle, nous observons que les présences dun feu de circulation et dun feu pour piéton contribuent à multiplier respectivement par 2 et 1,5 le nombre attendu daccidents à une intersection. De même, la présence dun axe de circulation à cinq voies augmente de 57 % le nombre daccidents. Enfin, la densité de population est aussi associée à une augmentation du nombre daccidents : pour 1 000 habitants supplémentaires autour de lintersection, nous augmentons le nombre daccidents attendu de 9 %. 8.3.5 Conclusion sur les modèles destinés à des variables de comptage Dans cette section, nous avons vu que modéliser une variable de comptage ne doit pas toujours être réalisé avec une simple distribution de Poisson. Il est nécessaire de tenir compte de la sur ou sous-dispersion potentielle ainsi que de lexcès de zéros. Nous navons cependant pas couvert tous les cas. Il est en effet possible dajuster des modèles avec une distribution binomiale négative avec excès de zéros (avec le package gamlss), ainsi que des modèles de Hurdle. Ces derniers ont une approche différente de celle proposée par les distributions ajustées pour tenir compte de lexcès de zéro que nous détaillons dans lencadré « pour aller plus loin » ci-dessous. Le processus de sélection du modèle peut être résumé avec la figure 8.39. Notez que même en suivant cette procédure, rien ne garantit que votre modèle final reflète bien les données que vous étudiez. Lanalyse approfondie des résidus et des prédictions du modèle est la seule façon de déterminer si oui ou non le modèle est fiable. Figure 8.39: Processus de sélection dun modèle pour une variable de comptage Modèle de Hurdle versus modèle avec excès de zéro Les modèles de Hurdle sont une autre catégorie de modèles GLM. Ils peuvent être décrits avec la formulation suivante : \\[\\begin{equation}\\left\\{\\begin{array}{c} Y \\sim \\text {Binomial}(p) \\text { si } y=0 \\\\ \\text { logit }(p)=\\beta_{a} X_{a} \\\\ Y \\sim \\text { TrPoisson}(\\lambda) \\text { si } y&gt;0 \\\\ \\log (\\lambda)=\\beta_{b} X_{b} \\end{array}\\right. \\tag{8.21} \\end{equation}\\] Nous constatons quun modèle de Hurdle utilise deux distributions, la première est une distribution binomiale dont lobjectif est de prédire si les observations sont à 0 ou au-dessus de 0. La seconde est une distribution strictement positive (supérieure à 0), il peut sagir dune distribution tronquée de Poisson, tronquée binomiale négative, Gamma, log-normale ou autre, dépendamment du phénomène modélisé. Puisque le modèle fait appel à deux distributions, deux équations de régression sont utilisées, lune pour prédire p (la probabilité dobserver une valeur au-dessus de 0) et lautre lespérance (moyenne) de la seconde distribution. En dautres termes, un modèle de Hurdle modélise les données à zéro et les données au-delà de 0 comme deux processus différents (chacun avec sa propre distribution). Cette approche se distingue des modèles avec excès de zéros qui utilisent une seule distribution pour décrire lensemble des données. Daprès un modèle avec excès de zéro, il existe de vrais et de faux zéros que lon tente de distinguer. Dans un modèle de Hurdle, lidée est que les zéros constituent une limite. Nous modélisons la probabilité de dépasser cette limite et ensuite la magnitude du dépassement de cette limite. Prenons un exemple pour rendre la distinction plus concrète. Admettons que nous utilisons un capteur capable de mesurer la concentration de particules fines dans lair. Daprès les spécifications du fabricant, le capteur est capable de mesurer des taux de concentration à partir de 0,001 µg/m3. Dans une ville avec des niveaux de concentration très faibles, il est très fréquent que le capteur enregistre des valeurs à zéro. Considérant ce phénomène, il serait judicieux de modéliser le processus avec un modèle de Hurdle Gamma puisque les 0 représentent une limite qui na pas été franchie : le seuil de détection du capteur. Nous traitons donc différemment les secteurs au-dessous et au-dessus de ce seuil. Si nous reprenons notre exemple sur les accidents des piétons à des intersections, il est plus judicieux, dans ce cas, de modéliser le phénomène avec un modèle avec excès de zéro puisque nous pouvons observer zéro accident à une intersection dangereuse (vrai zéro) et zéro accident à une intersection sur laquelle aucun piéton ne traverse jamais (faux zéro). References "],["sect085.html", "8.4 Modèles GLM pour des variables continues", " 8.4 Modèles GLM pour des variables continues Comme nous lavons vu dans la section 2.4, il existe un grand nombre de distributions permettant de décrire une grande diversité de variables continues. Il serait fastidieux de toutes les présenter, nous revenons donc seulement sur les plus fréquentes. 8.4.1 Modèle GLM gaussien Comme nous lavons vu en introduction, le modèle GLM gaussien est le plus simple puisquil correspond à la transposition de la régression linéaire classique (des moindres carrés) dans la forme des modèles généralisés. Tableau 8.29: Carte didentité du modèle gaussien Type de variable dépendante Variable continue dans lintervalle \\(]-\\infty ; + \\infty[\\) Distribution utilisée Normale Formulation \\(Y \\sim Normal(\\mu,\\sigma)\\) \\(g(\\mu) = \\beta_0 + \\beta X\\) \\(g(x) = x\\) Fonction de lien Identitaire Paramètre modélisé \\(\\mu\\) Paramètres à estimer \\(\\beta_0\\), \\(\\beta\\) et \\(\\sigma\\) Conditions dapplication Homoscédasticité 8.4.1.1 Conditions dapplication Les conditions dapplication sont les mêmes que celles dune régression linéaire classique. La condition de lhomoscédasticité (homogénéité de la variance) est due au fait que la variance du modèle est contrôlée par un seul paramètre fixe \\(var(y) = \\sigma\\) (lécart-type de la distribution normale). À titre de comparaison, rappelons que dans un modèle de Poisson, la variance est égale à la moyenne (\\(var(y) = E(y)\\)) alors que dans un modèle binomial négatif, la variance est fonction de la moyenne et dun paramètre \\(\\theta\\) (\\(var(y) = E(y) + E(y)^{\\frac{2}{\\theta}}\\)). Pour ces deux exemples, la variance augmente au fur et à mesure que la moyenne augmente. 8.4.1.2 Interprétation des paramètres Linterprétation des paramètres est la même que pour une régression linéaire classique : \\(\\beta_0\\) : la constante, soit la moyenne attendue de la variable Y lorsque les valeurs de toutes les variables X sont 0. \\(\\beta\\) : les coefficients de régression qui quantifient leffet dune augmentation dune unité des variables X sur la moyenne de la variable Y. \\(\\sigma\\) : lécart-type de Y après avoir contrôlé les variables X. Il peut sinterpréter comme lincertitude restante après modélisation de la moyenne de Y. Concrètement, si vous utilisez votre équation de régression pour prédire une nouvelle valeur de Y : \\(\\hat{Y}\\), lintervalle de confiance à 95 % de cette prédiction est (\\(\\hat{Y} - 3\\sigma\\text{ ; }\\hat{Y} + 3\\sigma\\)). Vous noterez donc que plus \\(\\sigma\\) est grand, plus grande est lincertitude de la prédiction. 8.4.1.3 Exemple appliqué dans R Pour cet exemple, nous reprenons le modèle LM que nous avons présenté dans la section 7.7. À titre de rappel, lobjectif est de modéliser la densité végétale dans les secteurs de recensement de Montréal. Pour cela, nous utilisons des variables relatives aux populations vulnérables physiologiquement ou socioéconomiquement, tout en contrôlant leffet de la forme urbaine. Parmi ces dernières, lâge médian des bâtiments est ajouté au modèle avec une polynomiale dordre deux, et la densité dhabitants est transformée avec la fonction logarithmique. Vérification des conditions dapplication La première étape de la vérification des conditions dapplication est bien sûr de sassurer de labsence de multicolinéarité excessive. # Chargement des données load(&quot;data/lm/DataVegetation.RData&quot;) # Calcul du VIF library(car) vif(glm(VegPct ~ log(HABHA)+poly(AgeMedian,2)+ Pct_014+Pct_65P+Pct_MV+Pct_FR, data = DataFinal)) ## GVIF Df GVIF^(1/(2*Df)) ## log(HABHA) 1.289495 1 1.135559 ## poly(AgeMedian, 2) 1.387429 2 1.085307 ## Pct_014 1.517957 1 1.232054 ## Pct_65P 1.304094 1 1.141969 ## Pct_MV 1.480275 1 1.216666 ## Pct_FR 1.729646 1 1.315160 Puisque lensemble des valeurs de VIF sont inférieures à deux, nos données ne sont pas marquées par une multicolinéarité problématique. La seconde étape du diagnostic consiste à calculer et à afficher les distances de Cook. Figure 8.40: Distances de Cook pour le modèle gaussien La figure 8.40 indique clairement que quatre observations sont très influentes dans le modèle. # Sélection des cas étranges cas_etranges &lt;- subset(DataFinal, cooksd &gt; 0.03) print(cas_etranges) ## VegPct ArbPct V250Pct V500Pct A250Pct A500Pct HABHA AgeMedian Pct_014 ## 3374 10.481 5.478 18.987 13.744 2.908 2.704 74.835867 226 4.76 ## 3378 0.000 0.000 12.709 12.505 2.116 2.324 88.006946 206 6.25 ## 4446 23.162 5.209 31.437 31.535 8.672 9.108 313.142733 206 14.40 ## 9088 85.767 27.583 78.195 83.492 42.999 51.074 2.070472 207 12.00 ## Pct_65P Pct_MV Pct_FR DistCBDkm SDRNOM ## 3374 14.29 23.81 14.29 0.748 Montréal ## 3378 12.50 25.00 12.50 0.706 Montréal ## 4446 16.87 53.50 42.39 8.678 Montréal ## 9088 24.00 12.00 16.00 28.440 Montréal Il sagit de quatre îlots dans Montréal avec des logements très anciens : plus de 200 ans, alors que la moyenne est de 52 ans pour le reste de la zone détude. Le fait que nous ayons dans le modèle une polynomiale dordre 2 pour cette variable intensifie linfluence de ces valeurs extrêmes. Par conséquent, nous décidons de simplement les supprimer. Nous verrons plus tard quune alternative envisageable est de changer la distribution du modèle pour une distribution de Student (plus robuste aux valeurs extrêmes). Figure 8.41: Distances de Cook pour le modèle gaussien après suppression des observations influentes Une fois ces observations retirées, les nouvelles distances de Cook (figure 8.41) ne révèlent plus dobservations fortement influentes. Nous pouvons passer à lanalyse des résidus simulés. La figure 8.42 démontre que la distribution des résidus est significativement différente dune distribution uniforme, que des valeurs aberrantes sont encore présentes et quil existe un lien entre résidus et prédiction dans le modèle. # Extraction des prédictions du modèle mus &lt;- predict(modele, type = &#39;response&#39;) modsigma &lt;- sigma(modele) # Extraction de l&#39;écart type du modèle # Génération de 1000 simulations pour chaque prédiction nsim &lt;- 1000 cols &lt;- lapply(1:length(mus),function(i){ mu &lt;- mus[[i]] sims &lt;- rnorm(nsim, mean=mu, sd = modsigma) return(sims) }) mat_sims &lt;- do.call(rbind, cols) # Calculer les résidus simulés sim_res &lt;- createDHARMa(simulatedResponse = mat_sims, observedResponse = DataFinal2$VegPct, fittedPredictedResponse = mus, integerResponse = F) plot(sim_res) Figure 8.42: Diagnostic général des résidus simulés pour le modèle gaussien Pour mieux cerner ce problème, nous pouvons, dans un premier temps, comparer la distribution originale des données et les simulations issues du modèle. La figure 8.43 montre clairement que la distribution normale est mal ajustée aux données. Ces dernières sont légèrement asymétriques et ne peuvent pas être inférieures à zéro, ce que la distribution normale ne parvient pas à reproduire. df &lt;- reshape2::melt(mat_sims[,1:30]) ggplot() + geom_histogram(data = DataFinal2, mapping = aes(x = VegPct, y = ..density..), color = &quot;black&quot;, fill = &quot;white&quot;, bins = 50)+ geom_density(data = df, aes(x = value, group = Var2), color = rgb(0.4,0.4,0.4,0.4), fill = rgb(0,0,0,0))+ labs(x = &quot;Pourcentage de végétation dans l&#39;îlot (%)&quot;, y = &quot;Densité&quot;) Figure 8.43: Comparaison de la distribution originale de la variable et des simulations issues du modèle Il est également possible de vérifier si la condition dhomogénéité de la variance sapplique bien aux données. # Extraction des prédictions du modèle mus &lt;- predict(modele, type = &quot;response&quot;) sigma_model &lt;- sigma(modele) # Création d&#39;un DataFrame pour contenir les prédictions et les vraies valeurs df1 &lt;- data.frame( mus = mus, reals = DataFinal2$VegPct ) # Calcul de l&#39;intervalle de confiance à 95 % selon la distribution normale # et stockage dans un second DataFrame seqa &lt;- seq(0,100,10) df2 &lt;- data.frame( mus = seqa, lower = qnorm(p = 0.025, mean = seqa, sd = sigma_model), upper = qnorm(p = 0.975, mean = seqa, sd = sigma_model) ) # Affichage des valeurs réelles et prédites (en rouge) # et de leur variance selon le modèle (en noir) ggplot() + geom_point(data = df1, mapping = aes(x = mus, y = reals), color =&quot;red&quot;, size = 0.5) + geom_errorbar(data = df2, mapping = aes(x = mus, ymin = lower, ymax = upper), width = 0.2, color = rgb(0.4,0.4,0.4)) + labs(x = &#39;valeurs prédites&#39;, y = &quot;valeurs réelles&quot;) Figure 8.44: Comparaison de la distribution originale de la variable et des simulations issues du modèle À nouveau, nous constatons à la figure 8.44 que le modèle sattend à trouver des valeurs négatives pour la concentration de végétation, ce qui nest pas possible dans notre cas. En revanche, il semble que la variance soit bien homogène puisque la dispersion des observations semble suivre à peu près la dispersion attendue par le modèle (en noir). Malgré ces différents constats indiquant clairement quun modèle gaussien est un choix sous-optimal pour ces données, nous poursuivons lanalyse de ce modèle. Vérification de la qualité dajustement # Ajustement d&#39;un modèle nul modelenull &lt;- glm(VegPct ~ 1, data = DataFinal2, family = gaussian()) # Calcul des pseudo R2 rsqs(loglike.full = logLik(modele), loglike.null = logLik(modelenull), full.deviance = deviance(modele), null.deviance = deviance(modelenull), nb.params = modele$rank, n = nrow(DataFinal2) ) ## $`deviance expliquee` ## [1] 0.4706321 ## ## $`McFadden ajuste` ## &#39;log Lik.&#39; 0.07310662 (df=9) ## ## $`Cox and Snell` ## &#39;log Lik.&#39; 0.4706321 (df=9) ## ## $Nagelkerke ## &#39;log Lik.&#39; 0.4707122 (df=9) Le modèle parvient à expliquer 47 % de la déviance totale, mais obtient un R2 ajusté de McFadden de seulement 0,07. # Calcul du RMSE sqrt(mean((predict(modele, type = &quot;response&quot;) - DataFinal2$VegPct)**2)) ## [1] 13.49885 Lerreur quadratique moyenne et de 13,5 points de pourcentage, ce qui indique que le modèle a une assez faible capacité prédictive. Interprétation des résultats Lensemble des coefficients du modèle sont accessibles via la fonction summary; le tableau 8.30 présente les résultats pour les coefficients du modèle. Tableau 8.30: Résultats du modèle gaussien Variable Coeff. Err.std Val.z val.p IC coeff 2,5 % IC coeff 97,5 % Sign. Constante 53,606 1,000 53,640 0,000 51,647 55,565 *** AgeMedian ordre 1 2,732 15,560 0,180 0,861 -27,772 33,237 AgeMedian ordre 2 -320,869 14,000 -22,910 0,000 -348,318 -293,420 *** Pct_014 0,915 0,030 29,310 0,000 0,853 0,976 *** Pct_65P 0,280 0,020 15,050 0,000 0,243 0,316 *** Pct_MV -0,042 0,010 -4,190 0,000 -0,061 -0,022 *** Pct_FR -0,340 0,010 -30,940 0,000 -0,362 -0,318 *** Les résultats de la régression linéaire multiple ont déjà été interprétés dans la section 7.7.1, nous ne commenterons pas ici les résultats du modèle GLM gaussien qui sont identiques. 8.4.2 Modèle GLM avec une distribution de Student Pour rappel, la distribution de Student ressemble à une distribution normale (section 2.4.3.11). Elle est symétrique autour de sa moyenne et a également une forme de cloche. Cependant, elle dispose de queues lourdes, ce qui signifie quelle permet de représenter des phénomènes présentant davantage de valeurs extrêmes quune distribution normale. Pour contrôler le poids des queues, la distribution de Student intègre un troisième paramètre : \\(\\nu\\) (nu). Lorsque \\(\\nu\\) tends vers linfini, la distribution de Student tend vers une distribution normale (figure 8.45). Figure 8.45: Effet du paramètre nu sur une distribution de Student Comme vous pouvez le constater dans la carte didentité au tableau 8.31, le modèle GLM de Student est très proche du modèle GLM gaussien. Nous modélisons explicitement la moyenne de la distribution et son paramètre de dispersion (variance) est laissé fixe. Ce GLM est même souvent utilisé comme une version « robuste » du modèle gaussien du fait de sa capacité à intégrer explicitement leffet des observations extrêmes. En effet, dans un modèle gaussien, les observations extrêmes (aussi appelées observations aberrantes) vont davantage influencer les paramètres du modèle que pour un modèle utilisant une distribution de Student. Tableau 8.31: Carte didentité du modèle de Student Type de variable dépendante Variable continue dans lintervalle \\(]-\\infty ; + \\infty[\\) Distribution utilisée Student Formulation \\(Y \\sim Student(\\mu,\\sigma,\\nu)\\) \\(g(\\mu) = \\beta_0 + \\beta X\\) \\(g(x) = x\\) Fonction de lien Identitaire Paramètre modélisé \\(\\mu\\) Paramètres à estimer \\(\\beta_0\\), \\(\\beta\\), \\(\\sigma\\) et \\(\\nu\\) Conditions dapplication Homoscédasticité 8.4.2.1 Conditions dapplication Les conditions dapplication sont les mêmes que pour un modèle GLM gaussien, à ceci prêt que le modèle utilisant la distribution de Student est moins sensible aux observations extrêmes. 8.4.2.2 Interprétation des paramètres Linterprétation des paramètres est la même que pour un modèle gaussien puisque nous modélisons la moyenne de la distribution et que la fonction de lien est la fonction identitaire. Le seul paramètre supplémentaire est \\(\\nu\\), qui na en soit aucune interprétation pratique. Notez simplement que si \\(\\nu\\) est supérieur à 30, un simple modèle GLM gaussien serait sûrement suffisant. 8.4.2.3 Exemple appliqué dans R Nous proposons ici de simplement réajuster le modèle gaussien présenté dans la section précédente en utilisant une distribution de Student. Nous utilisons pour cela la fonction gam du package mgcv avec le paramètre family=scat pour utiliser une distribution de Student. Les valeurs de VIF ont déjà été calculées dans lexemple précédent, nous pouvons donc passer directement au calcul des distances de Cook. # Chargement des données load(&quot;data/lm/DataVegetation.RData&quot;) # Ajustement du modèle modele &lt;- gam(VegPct ~ log(HABHA)+poly(AgeMedian,2)+ Pct_014+Pct_65P+Pct_MV+Pct_FR, data = DataFinal, family = scat) # Calcul des distances de Cook cooksd &lt;- cooks.distance(modele) # Affichage des valeurs df &lt;- data.frame( cook = cooksd, oid = 1:length(cooksd) ) ggplot(data = df) + geom_point(aes(x = oid, y = cook), color = rgb(0.4,0.4,0.4,0.7), size = 1) + labs(x=&quot;&quot;, y = &quot;distance de Cook&quot;) Figure 8.46: Distances de Cook pour un modèle GLM avec une distribution de Student Nous retrouvons les quatre observations avec des distances de Cook très fortes que nous avons identifiées dans le modèle gaussien. Nous décidons donc de les enlever pour les mêmes raisons que précédemment. # Chargement des données DataFinal2 &lt;- subset(DataFinal, cooksd&lt;0.1) # Ajustement du modèle modele &lt;- gam(VegPct ~ log(HABHA)+poly(AgeMedian,2)+ Pct_014+Pct_65P+Pct_MV+Pct_FR, data = DataFinal2, family = scat) # Calcul des distances de Cook cooksd &lt;- cooks.distance(modele) # Affichage des valeurs df &lt;- data.frame( cook = cooksd, oid = 1:length(cooksd) ) ggplot(data = df) + geom_point(aes(x = oid, y = cook), color = rgb(0.4,0.4,0.4,0.7), size = 1) + labs(x=&quot;&quot;, y = &quot;distance de Cook&quot;) Figure 8.47: Distances de Cook pour un modèle GLM avec une distribution de Student après suppression des valeurs fortement influentes Nous pouvons à présent vérifier si les résidus simulés se comportent tel quattendu. # Extraction des prédictions du modèle mus &lt;- predict(modele, type = &#39;response&#39;) # Affichage des paramètres nu et sigma modele$family$family ## [1] &quot;Scaled t(6.333,11.281)&quot; sigma_model &lt;- 11.281 nu_model &lt;- 6.333 library(LaplacesDemon) # pour simuler des données d&#39;une distribution de Student # Génération de 1000 simulations pour chaque prédiction nsim &lt;- 1000 cols &lt;- lapply(1:length(mus),function(i){ mu &lt;- mus[[i]] sims &lt;- rst(nsim, mu=mu, sigma = sigma_model, nu = nu_model) return(sims) }) mat_sims &lt;- do.call(rbind, cols) # Calculer les résidus simulés sim_res &lt;- createDHARMa(simulatedResponse = mat_sims, observedResponse = DataFinal2$VegPct, fittedPredictedResponse = mus, integerResponse = F) plot(sim_res) Figure 8.48: Diagnostic général des résidus simulés pour le GLM avec distribution de Student Il semble que nous obtenons des résultats similaires à ceux du modèle gaussien: les résidus divergent significativement dune distribution uniforme (figure 8.48). Le graphique quantile-quantile nest parfois pas très adapté pour discerner une déviation de la distribution uniforme, nous pouvons dans ce cas afficher un histogramme des résidus pour en avoir le coeur net (figure 8.49). ggplot()+ geom_histogram(aes(x = residuals(sim_res)), bins = 50, color = &quot;white&quot;) + labs(x = &quot;effectifs&quot;, y = &quot;résidus simulés&quot;) Figure 8.49: Distribution des résidus simulés du modèle GLM avec distribution de Student Pour cet exercice, il est intéressant de comparer les formes des simulations issues du modèle gaussien et du modèle de Student pour bien distinguer la différence entre les deux. Figure 8.50: Simulations issues des modèles gaussien et de Student, comparées aux données originales Nous constatons ainsi que la différence entre les deux modèles est ici très mince, voire inexistante. Le seul élément que nous pouvons noter est que le modèle de Student à une courbe (une queue de distribution) moins aplatie vers la droite. Cela lui permettrait de mieux tenir compte de cas extrêmes avec de fortes densités de végétation (ce qui concerne donc très peu dobservations puisque cette variable a un maximum de 100). Pour déterminer si le modèle de Student est plus pertinent à retenir que le modèle gaussien, nous pouvons ajuster un second modèle de Student pour lequel nous forçons artificiellement \\(\\nu\\) à être très élevé. Pour rappel, quand \\(\\nu\\) tend vers linfini, la distribution de Student tend vers une distribution normale. Nous forçons ici \\(\\nu\\) à être supérieur à 100 pour créer un second modèle de Student se comportant quasiment comme un modèle gaussien et calculons les AIC des deux modèles. # Calcul d&#39;un modèle de Student identitique à un modèle gaussien modele2 &lt;- gam(VegPct ~ log(HABHA)+poly(AgeMedian,2)+ Pct_014+Pct_65P+Pct_MV+Pct_FR, data = DataFinal2, family = scat(min.df = 100)) # Calcul des deux AIC AIC(modele) ## [1] 81771.92 AIC(modele2) ## [1] 82057.79 Le second AIC (modèle gaussien) est plus élevé, indiquant que le modèle est moins bien ajusté aux données. Dans le cas présent, il est plus pertinent de retenir le modèle de Student même si les écarts entre ces deux modèles sont minimes. Ce résultat nest pas surprenant puisque la variable Y (pourcentage de végétation dans les îlots de lîle de Montréal) est relativement compacte et comporte peu / pas de valeurs pouvant être qualifiées de valeurs extrêmes. Nous ne détaillons pas ici linterprétation des coefficients du modèle (présentés au tableau 8.32) puisquils sinterprètent de la même façon quun modèle GLM et quun modèle de régression linéaire multiple. Tableau 8.32: Résultats du modèle Student Variable Coeff. Err.std Val.z val.p IC coeff 2,5 % IC coeff 97,5 % Sign. Constante 65,096 0,940 69,110 0,000 63,250 66,943 *** log(HABHA) -9,502 0,160 -60,160 0,000 -9,811 -9,192 *** Pct_014 0,866 0,030 29,450 0,000 0,808 0,924 *** Pct_65P 0,237 0,020 13,540 0,000 0,203 0,272 *** Pct_MV -0,015 0,010 -1,650 0,099 -0,034 0,003 . Pct_FR -0,301 0,010 -29,040 0,000 -0,321 -0,280 *** 8.4.3 Modèle GLM avec distribution Gamma Pour rappel, la distribution Gamma est strictement positive (\\([0;+\\infty[\\)), asymétrique, et a une variance proportionnelle à sa moyenne (hétéroscedastique). Dans la section sur les distributions, nous avons vu que la distribution Gamma (section 2.4.3.15) est formulée avec deux paramètres : sa forme (\\(\\alpha\\) ou shape) et son échelle (\\(b\\) ou scale). Ces deux paramètres nont pas une interprétation intuitive, mais il est possible avec un peu de jonglage mathématique darriver à une reparamétrisation intéressante. Cela est détaillé dans lencadré ci-dessous; notez toutefois quil nest pas nécessaire de maîtriser le contenu de cet encadré pour lire la suite de cette section sur les modèles GLM avec une distribution Gamma. Reparamétrisation dune distribution Gamma pour un GLM Si nous disposons dune variable Y, suivant une distribution Gamma telle que \\(Y \\sim Gamma(\\alpha,b)\\) avec \\(\\alpha\\) le paramètre de forme et \\(b\\) le paramètre déchelle, alors, lespérance et la variance de Y peuvent être définies comme suit : \\[\\begin{equation} \\begin{aligned} &amp;E(Y) = \\alpha \\times b \\\\ &amp;Var(Y) = \\alpha \\times b^2\\\\ \\end{aligned} \\tag{8.22} \\end{equation}\\] En dautres termes, lespérance (léquivalent de la moyenne pour une distribution normale) de notre variable Y est égale au produit des paramètres de forme et déchelle. Avec ces propriétés, il est possible de redéfinir la fonction de densité de la distribution Gamma et darriver à une nouvelle formulation : \\(Y \\sim Gamma(\\mu,\\alpha)\\). \\(\\mu\\) est donc lespérance de Y (interprétable comme sa moyenne, soit sa valeur attendue) et \\(\\alpha\\) permet de capturer la dispersion de la distribution Gamma. Par extension des relations présentées ci-dessus, il est possible de reformuler la variance en fonction de \\(\\mu\\) et de \\(\\alpha\\). \\[\\begin{equation} \\begin{aligned} &amp;Var(Y) = \\alpha \\times b^2\\\\ &amp;\\mu = \\alpha \\times b \\text{ soit }b = \\frac{\\mu}{a}\\\\ &amp;Var(Y) = \\alpha \\times (\\frac{\\mu}{\\alpha})^2 \\text{ soit } Var(Y) = \\frac{\\mu^2}{\\alpha}\\\\ \\end{aligned} \\tag{8.23} \\end{equation}\\] Nous observons donc que la variance dans un modèle Gamma augmente de façon quadratique avec la moyenne, mais est tempérée par le paramètre de forme. Nous en concluons quun paramètre de forme plus grand produit une distribution moins étalée. Dans ce contexte, \\(\\mu\\) doit être strictement positif : la valeur attendue moyenne dune distribution Gamma doit être positive par définition puisquune distribution Gamma ne peut pas produire de valeurs négatives. Il est donc logique dutiliser la fonction logarithmique comme fonction de lien, puisque sa contrepartie (la fonction exponentielle) ne produit que des résultats positifs. Pour résumer, nous nous retrouvons donc avec un modèle qui prédit, sur une échelle logarithmique, lespérance (~moyenne) dune distribution Gamma. Notez quil existe dautres façons de spécifier un modèle GLM avec une distribution Gamma, mais celle-ci est la plus intuitive. Tableau 8.33: Carte didentité du modèle Gamma Type de variable dépendante Variable continue dans lintervalle \\(]0 ; + \\infty[\\) Distribution utilisée Gamma Formulation \\(Y \\sim Gamma(\\mu,\\alpha)\\) \\(g(\\mu) = \\beta_0 + \\beta X\\) \\(g(x) = log(x)\\) Fonction de lien log Paramètre modélisé \\(\\mu\\) Paramètres à estimer \\(\\beta_0\\), \\(\\beta\\), et \\(\\alpha\\) Conditions dapplication \\(Variance = \\frac{\\mu^2}{\\alpha}\\) 8.4.3.1 Interprétation des paramètres Puisque le modèle utilise la fonction de lien log, alors les coefficients \\(\\beta\\) expriment laugmentation de lespérance (la valeur attendue de Y, ce qui est proche de lidée de moyenne) de la variable Y sur une échelle logarithmique (comme dans un modèle de Poisson). Il est possible de convertir les coefficients dans léchelle originale de la variable Y en utilisant la fonction exponentielle (linverse de la fonction log), mais ces coefficients représentent alors des effets multiplicatifs et non des effets additifs. Prenons un exemple, admettons que le coefficient \\(\\beta_1\\), associé à la variable \\(X_1\\) soit de 1,5. Cela signifie quune augmentation dune unité de \\(X_1\\), augmente le log de lespérance de Y de 1,5 unité. Lexponentielle du coefficient est 4,48, ce qui signifie quune augmentation dune unité entraîne une multiplication par 4,48 de la valeur attendue de Y (lespérance de Y). Le paramètre de forme (\\(\\alpha\\)) na pas dinterprétation pratique, bien quil soit utilisé dans les différents tests des conditions dapplication du modèle et dans le calcul de sa déviance. 8.4.3.2 Conditions dapplication Dans un modèle GLM gaussien, la variance est capturée par un paramètre \\(\\sigma\\) et est constante, produisant la condition dhomoscédasticité des résidus. Dans un modèle Gamma, la variance varie en fonction de lespérance et du paramètre de forme selon la relation : \\(Var(Y) = \\frac{E(Y)^2}{\\alpha}\\). Les résidus sont donc par nature hétéroscédastiques dans un modèle Gamma et doivent suivre cette relation. 8.4.3.3 Exemple appliqué dans R Pour cet exemple, nous nous intéressons à la durée de déplacement en milieu urbain. Ce type danalyse permet notamment de mieux comprendre les habitudes de déplacement de la population et dorienter les politiques de transport. Plusieurs travaux concluent que les durées de déplacement en milieu urbain varient en fonction du motif du déplacement, du mode de transport utilisé, des caractéristiques socio-économiques de lindividu et des caractéristiques du trajet lui-même (Anastasopoulos et al. 2012; Frank et al. 2008). Nous modélisons ici la durée en minute dun ensemble de déplacements effectués par des Montréalais en 2017 et enregistrés avec lapplication MTL Trajet proposée par la Ville de Montréal. Ces données sont disponibles sur le site web des données ouvertes de Montréal et son anonymisées. Nous ne disposons donc daucune information individuelle. Compte tenu du très grand nombre dobservations (plus de 185 000), nous avons dû effectuer quelques opérations de tri et nous avons ainsi supprimé: les trajets utilisant de multiples modes de transport (sauf en combinaison avec la marche à pied, par exemple, un trajet effectué à pied et en transport en commun a été recatégorisé comme un trajet en transport en commun uniquement). Les déplacements multimodaux se distinguent largement des déplacements unimodaux dans la littérature scientifique; les trajets de nuit (seuls les trajets démarrant dans lintervalle de 7 h à 21 h ont été conservés); les trajets dont le point de départ est un arrondissement / municipalité pour lequel moins de 150 trajets ont été enregistrés (trop peu dobservations); les trajets de plus de deux heures (cas rares, considérés comme des données aberrantes); les trajets dont le point de départ est à moins de 100 mètres du point darrivée (formant des boucles plutôt que des déplacements). Nous arrivons ainsi à un total de 24 969 observations. Pour modéliser ces durées de déplacement, nous utilisons les variables indépendantes présentées dans le tableau 8.34. Tableau 8.34: Variables indépendantes utilisées dans le modèle Gamma Nom de la variable Signification Type de variable Mesure Mode Mode de déplacement Variable catégorielle Transport collectif; piéton; vélo et véhicule individuel Motif Motif du déplacement Variable catégorielle Travail; loisir; magasinage et éducation HeureDep Heure de départ Variable catégorielle De 7 h à 21 h ArrondDep Arrondissement de départ Variable catégorielle Nom de larrondissement dont part le trajet LogDist Logarithme de la distance à vol doiseau en km Variable continue Logarithme de la distance à vol doiseau en km entre le point de départ et darrivée MemeArrond Larrivée du trajet se situe-t-elle dans le même arrondissement que celui du départ? Variable binaire Oui ou non Semaine Le trajet a-t-il été effectué en semaine ou en fin de semaine? Variable binaire Semaine ou fin de semaine Les temps de trajet forment une variable strictement positive et très vraisemblablement asymétrique. En effet, nous nous attendons à observer une certaine concentration de valeurs autour dune moyenne, et davantage de trajets avec de courtes durées que de trajets avec de longues durées. Pour nous en assurer, réalisons un histogramme de la distribution de notre variable Y et comparons la avec des distributions normale et Gamma. # Chargement des données dataset &lt;- read.csv(&quot;data/glm/DureeTrajets.csv&quot;, stringsAsFactors = F) arrondMTL &lt;- c(&quot;Mercier-Hochelaga-Maisonneuve&quot;, &quot;Villeray-Saint-Michel-Parc-Extension&quot;, &quot;Ville-Marie&quot;, &quot;Verdun&quot;, &quot;Saint-Leonard&quot;, &quot;Saint-Laurent&quot;, &quot;Rosemont-La Petite-Patrie&quot;, &quot;Riviere-des-Prairies-Pointe-aux-Trembles&quot;, &quot;Pierrefonds-Roxboro&quot;, &quot;Outremont&quot;, &quot;Montreal-Nord&quot;, &quot;Le Sud-Ouest&quot;, &quot;Le Plateau-Mont-Royal&quot;, &quot;Lachine&quot; , &quot;Ahuntsic-Cartierville&quot;, &quot;Anjou&quot; ,&quot;Cote-des-Neiges-Notre-Dame-de-Grace&quot;, &quot;LaSalle&quot; ) dataset &lt;- subset(dataset,dataset$ArrondDep %in% arrondMTL) # Définissons 7 h du matin comme la référence pour la variable Heure de départ dataset$HeureDep &lt;- relevel( factor(dataset$HeureDep, levels = as.character(7:21)), ref = &quot;7&quot;) # Comparaison de la distribution originale avec une distribution # normale et une distribution Gamma library(fitdistrplus) model_gamma &lt;- fitdist(dataset$Duree, distr = &quot;gamma&quot;) ggplot(data = dataset) + geom_histogram(aes(x=Duree, y = ..density..), bins = 40, color = &quot;white&quot;)+ stat_function(fun = dgamma, color = &#39;red&#39;, size = 0.8, args = as.list(model_gamma$estimate))+ stat_function(fun = dnorm, color = &#39;blue&#39;, size = 0.8, args = list(mean = mean(dataset$Duree), sd = sd(dataset$Duree)))+ labs(x = &#39;Temps de déplacement (minutes)&#39;, y = &#39;&#39;, subtitle = &quot;modèles Gamma et gaussien&quot;) Figure 8.51: Distribution des temps de trajet diurne à Montréal La figure 8.51 permet de constater lasymétrie de la distribution des temps de trajet et quun modèle Gamma (ligne rouge) a plus de chance dêtre adapté aux données quun modèle gaussien (ligne bleue). Vérification des conditions dapplication Comme pour les modèles précédents, nous commençons par la vérification de labsence de multicolinéarité. ## Calcul du VIF vif(glm(Duree ~ Mode + Motif + HeureDep + LogDist + ArrondDep + MemeArrond + Jour, data = dataset, family = Gamma(link=&quot;log&quot;))) ## GVIF Df GVIF^(1/(2*Df)) ## Mode 2.103392 3 1.131931 ## Motif 1.934997 3 1.116298 ## HeureDep 1.791009 14 1.021032 ## LogDist 2.665998 1 1.632789 ## ArrondDep 1.439499 17 1.010772 ## MemeArrond 2.151113 1 1.466667 ## Jour 1.330091 6 1.024055 Lensemble des valeurs de VIF sont inférieures à trois, indiquant donc labsence de multicolinéarité excessive. Nous pouvons donc ajuster une première version du modèle (ici avec le package VGAM et la fonction vglm) et calculer les distances de Cook. # Calcul du modèle avec VGAM modele &lt;- vglm(Duree ~ Mode + Motif + HeureDep + LogDist + ArrondDep+ MemeArrond + Semaine, data = dataset, family=gamma2(lmu = &quot;loglink&quot;)) # Calcul des distances de Cook hats &lt;- hatvaluesvlm(modele)[,1] res &lt;- residuals(modele,type = &quot;pearson&quot;)[,1] disp &lt;- modele@coefficients[[2]]**-1 nbparams &lt;- modele@rank cooksd &lt;- (res/(1 - hats))^2 * hats/(disp * nbparams) df &lt;- data.frame( cook = cooksd, oid = 1:length(cooksd) ) # Représentation des distances de Cook ggplot(data = df)+ geom_point(aes(x = oid, y = cook), size = 0.5, color = rgb(0.4,0.4,0.4,0.4)) + geom_hline(yintercept = 0.003, color = &quot;red&quot;) + labs(x = &quot;&quot;, y = &quot;distance de Cook&quot;) Figure 8.52: Distances de Cook pour le modèle Gamma Puisque nous disposons dun (très) grand nombre dobservations, nous pouvons nous permettre de retirer les quelques observations fortement influentes (distance de Cook &gt; 0,003 dans notre cas) qui apparaissent dans la figure 8.52. Nous retirons ainsi 28 observations et réajustons le modèle. # Retirer les valeurs influentes dataset2 &lt;- subset(dataset, cooksd&lt;0.003) # Calcul du modèle avec VGAM modele &lt;- vglm(Duree ~ Mode + Motif + HeureDep + LogDist + ArrondDep+ MemeArrond + Semaine, data = dataset2, family=gamma2(lmu = &quot;loglink&quot;)) Nous constatons ainsi que dans la nouvelle version du modèle (figure 8.53), aucune valeur particulièrement influente ne semble être présente. # Calcul des distances de Cook hats &lt;- hatvaluesvlm(modele)[,1] res &lt;- residuals(modele,type = &quot;pearson&quot;)[,1] disp &lt;- modele@coefficients[[2]]**-1 nbparams &lt;- modele@rank cooksd &lt;- (res/(1 - hats))^2 * hats/(disp * nbparams) df &lt;- data.frame( cook = cooksd, oid = 1:length(cooksd) ) # Représentation des distances de Cook ggplot(data = df)+ geom_point(aes(x = oid, y = cook), size = 0.5, color = rgb(0.4,0.4,0.4,0.4)) + labs(x = &quot;&quot;, y = &quot;distance de Cook&quot;) Figure 8.53: Distances de Cook pour le modèle Gamma (sans les observations fortement influentes) # Extraction des prédictions du modèle (mu) mus &lt;- modele@fitted.values # Extration du paramètre de forme shape &lt;- exp(modele@coefficients[[2]]) # Calcul des simulations nsim &lt;- 1000 cols &lt;- lapply(1:length(mus),function(i){ mu &lt;- mus[[i]] sims &lt;- rgamma(n = nsim,shape = shape, scale = mu/shape) return(sims) }) mat_sims &lt;- do.call(rbind, cols) # Représentation graphique de 20 simulations df2 &lt;- reshape2::melt(mat_sims[,0:20]) ggplot() + geom_histogram(aes(x = Duree, y = ..density..), data = dataset, bins = 100, color = &quot;black&quot;, fill = &quot;white&quot;) + geom_density(aes(x = value, y=..density.., group = Var2), data = df2, fill = rgb(0,0,0,0), color = rgb(0.9,0.22,0.27,0.4), size = 1)+ xlim(0,200)+ labs(X=&quot;durée (minutes)&quot;, y=&quot;densité&quot;) Figure 8.54: Comparaison de la distribution originale et de simulations issues du modèle Gamma Avant de calculer les résidus simulés, nous comparons la distribution originale des données et des simulations issues du modèle. La figure 8.54 permet de constater que le modèle semble bien capturer lessentiel de la forme de la variable Y originale. Nous notons un léger décalage entre la pointe des deux distributions, laissant penser que les valeurs prédites par le modèle tendent à être légèrement plus grandes que les valeurs réelles. Pour mieux appréhender ce constat, nous passons à lanalyse des résidus simulés. # DHarma tests sim_res &lt;- createDHARMa(simulatedResponse = mat_sims, observedResponse = dataset2$Duree, fittedPredictedResponse = modele@fitted.values[,1], integerResponse = F) ggplot() + geom_histogram(aes(x = residuals(sim_res)), bins = 100, color = &quot;white&quot;) + labs(x = &quot;résidus simulés&quot;, y = &quot;effectifs&quot;) Figure 8.55: Distribution des résidus simulés du modèle Gamma Nul besoin dun test statistique pour constater que ces résidus (figure 8.55) ne suivent pas une distribution uniforme. Nous observons une nette surreprésentation de résidus à 1 et une nette sous-représentation de résidus à 0. Il y a donc de nombreuses observations dans notre modèle pour lesquelles les simulations sont systématiquement trop fortes et il ny en a pas assez pour lesquelles les simulations seraient systématiquement trop faibles. plot(sim_res) Figure 8.56: Diagnostic général des résidus simulés du modèle Gamma La figure 8.56 indique que le modèle souffre à la fois dun problème de dispersion (la relation espérance-variance nest donc pas respectée) et est affecté par des valeurs aberrantes. Considérant que nous avons encore un très grand nombre dobservations, nous faisons le choix de retirer celles pour lesquelles la méthode des résidus simulés estime quelles sont des valeurs aberrantes dans au moins 1 % des simulations, soit environ 620 observations. # Sélection des valeurs aberrantes au seuil 0.01 sim_outliers &lt;- outliers(sim_res, lowerQuantile = 0.01, upperQuantile = 0.99, return = &quot;logical&quot;) table(sim_outliers) ## sim_outliers ## FALSE TRUE ## 22936 610 # Retirer ces observations des données dataset3 &lt;- subset(dataset2, sim_outliers==FALSE) # Réajuster le modèle modele &lt;- vglm(Duree ~ Mode + Motif + HeureDep + LogDist + ArrondDep + MemeArrond + Semaine, data = dataset3, model = T, family=gamma2) modele2 &lt;- vglm(Duree ~ Mode + Motif + HeureDep + ArrondDep + MemeArrond + Semaine, data = dataset3, model = T, family=gamma2) # Extraction des prédictions du modèle (mu) mus &lt;- modele@fitted.values # Extration du paramètre de forme shape &lt;- exp(modele@coefficients[[2]]) # Calcul des simulations nsim &lt;- 1000 cols &lt;- lapply(1:length(mus),function(i){ mu &lt;- mus[[i]] sims &lt;- rgamma(n = nsim,shape = shape, scale = mu/shape) return(sims) }) mat_sims &lt;- do.call(rbind, cols) # Calcul des résidus simulés sim_res &lt;- createDHARMa(simulatedResponse = mat_sims, observedResponse = dataset3$Duree, fittedPredictedResponse = modele@fitted.values[,1], integerResponse = F) plot(sim_res) Figure 8.57: Diagnostic général des résidus simulés du modèle Gamma (après suppression denviron 620 valeurs aberrantes) La figure 8.57 indique que les résidus simulés ne suivent toujours pas une distribution uniforme et quil existe une relation prononcée (panneau de droite) entre les résidus et les valeurs prédites. Cette dernière laisse penser que des variables indépendantes importantes ont été omises dans le modèle, ce qui nest pas surprenant compte tenu du fait que nous ne disposons daucune donnée socioéconomique sur les individus ayant réalisé les trajets. Nos données sont également potentiellement affectées par la présence de dépendance spatiale. Nous pouvons comparer graphiquement la variance observée dans les données et la variance attendue par le modèle. La figure 8.58 montre clairement que la variance des données tend à être plus grande quattendue quand les temps de trajet sont courts, mais diminue trop vite quand les temps de trajet augmentent. Dautres distributions pourraient être envisagées pour ajuster notre modèle : Lognormal, Weibull, etc. # Extraction des prédictions du modèle mus &lt;- predict(modele, type = &quot;response&quot;)[,1] # Création d&#39;un DataFrame pour contenir la prédiction et les vraies valeurs df1 &lt;- data.frame( mus = mus, reals = dataset3$Duree ) # Calcul de l&#39;intervalle de confiance à 95 % selon la distribution Gamma # et stockage dans un second DataFrame seqa &lt;- seq(10,120,10) shape &lt;- exp(modele@coefficients[[2]]) df2 &lt;- data.frame( mus = seqa, lower = qgamma(p = 0.025, shape = shape, scale = seqa/shape), upper = qgamma(p = 0.975, shape = shape, scale = seqa/shape) ) # Affichage des valeurs réelles et prédites (en rouge) # et de leur variance selon le modèle (en noir) ggplot() + geom_point(data = df1, mapping = aes(x = mus, y = reals), color =rgb(0.9,0.22,0.27,0.4), size = 0.5) + geom_errorbar(data = df2, mapping = aes(x = mus, ymin = lower, ymax = upper), width = 0.2, color = rgb(0.4,0.4,0.4)) + labs(x = &#39;valeurs prédites&#39;, y = &quot;valeurs réelles&quot;) Figure 8.58: Comparaison de la variance attendue par le modèle et la variance observée dans les données pour le modèle Gamma À ce stade, nous disposons de suffisamment déléments pour douter des résultats du modèle. Nous poursuivons tout de même notre analyse afin dillustrer lestimation de la qualité dajustement dun tel modèle et son interprétation. Analyse de la qualité dajustement # Ajustement d&#39;un modele nul modele.null &lt;- vglm(Duree ~1, data = dataset3, model = T, family=gamma2) # Calcul des pseudos R2 rsqs(loglike.full = logLik(modele), loglike.null = logLik(modele.null), full.deviance = logLik(modele) * -2, null.deviance = logLik(modele.null) * -2, nb.params = modele2@rank, n = nrow(dataset3) ) ## $`deviance expliquee` ## [1] 0.05061803 ## ## $`McFadden ajuste` ## [1] 0.05017065 ## ## $`Cox and Snell` ## [1] 0.3326894 ## ## $Nagelkerke ## [1] 0.3328021 # Calcul du RMSE preds &lt;- predict(modele, type=&quot;response&quot;)[,1] sqrt(mean((preds - dataset3$Duree)**2)) ## [1] 13.39254 Le modèle nexplique que 5 % de la déviance et obtient des valeurs de R2 ajusté de McFadden, de Cox et Snell et de Nagelkerke de respectivement 0,05, 0,33 et 0,33. La moyenne de lerreur quadratique est de seulement 13,4 indiquant que le modèle se trompe en moyenne de seulement 13,4 minutes. La capacité de prédiction du modèle est donc limitée sans être catastrophique. Interprétation des résultats Pour rappel, la fonction de lien dans notre modèle est la fonction log. Chaque coefficient représente donc leffet de laugmentation dune unité des variables indépendantes sur le logarithme de lespérance de notre variable dépendante. Si nous transformons nos coefficients avec la fonction exponentielle (exp), nous obtenons, pour chaque augmentation dune unité des variables indépendantes, la multiplication de lespérance de notre variable dépendante. Puisque nos trajets peuvent provenir de nombreux arrondissements, nous proposons de représenter lexponentiel de leurs coefficients avec un graphique. Nous pouvons dailleurs comparer les exponentiels des coefficients et les effets marginaux pour simplifier linterprétation. # Extraction des coefficient du modèle coeffs &lt;- modele@coefficients # Calcul des interval de confiance des coefficients conf &lt;- confint(modele) # Passage en exponentiel df &lt;- exp(cbind(coeffs, conf)) # Extraction des coefficients pour les arrondissements dfArrond &lt;- data.frame(df[grepl(&quot;ArrondDep&quot;,row.names(df), fixed = T),]) names(dfArrond) &lt;- c(&quot;coeff&quot;, &quot;lower&quot;,&quot;upper&quot;) dfArrond$Arrondissement &lt;- gsub(&quot;ArrondDep&quot;,&quot;&quot;,rownames(dfArrond),fixed = T) # Graphique des exponentiels des coefficients P1 &lt;- ggplot(data = dfArrond) + geom_vline(xintercept = 1, color = &quot;red&quot;)+ geom_errorbarh(aes(y = reorder(Arrondissement, coeff), xmin = upper, xmax = lower), height = 0)+ geom_point(aes(y = reorder(Arrondissement, coeff), x = coeff)) + geom_text(aes(x = upper, y = reorder(Arrondissement, coeff), label = paste(&quot;coeff. : &quot;,round(coeff,2),sep=&quot;&quot;)), size = 3, nudge_x = 0.07)+ labs(x = &quot;Coefficient multiplicateur (ref : Ahuntsic-Cartierville)&quot;, y = &quot;&quot;, subtitle = &quot;Exponentiels des coefficients du modèle&quot;)+ xlim(c(0.75,1.46)) # Création d&#39;un DataFrame fictif pour les effets marginaux dfpred &lt;- expand.grid( LogDist = mean(dataset3$LogDist), Motif = &#39;education&#39;, HeureDep = &#39;7&#39;, MemeArrond = &#39;Different&#39;, ArrondDep = unique(dataset3$ArrondDep), Mode = &#39;pieton&#39;,&#39;velo&#39;,&#39;transport collectif&#39;, Semaine = &#39;lundi au vendredi&#39; ) # Utiliser le modèle pour effectuer des prédictions (échelle log) lin_pred &lt;- predict(modele,dfpred, se = T) mu_lin_pred &lt;- lin_pred$fitted.values[,1] se_lin_pred &lt;- lin_pred$se.fit[,1] dfpred2 &lt;- data.frame( pred = exp(mu_lin_pred), lower = exp(mu_lin_pred- 1.96*se_lin_pred), upper = exp(mu_lin_pred+ 1.96*se_lin_pred) ) dfpred2 &lt;- cbind(dfpred2, dfpred) # Réaliser le graphique des effets marginaux P2 &lt;- ggplot(data = dfpred2) + geom_col(aes(x = pred, y = ArrondDep)) + geom_errorbarh(aes(xmin = lower, xmax = upper, y = ArrondDep)) + labs(x = &quot;Temps de déplacement prédit&quot;, y=&quot;&quot;, subtitle = &quot;Prédiction du modèle&quot;) ggarrange(P1,P2, ncol = 1, nrow = 2) Figure 8.59: Effet de larrondissement de départ sur les temps de trajet à Montréal La figure 8.59 permet de constater que les arrondissements Ville-Marie et Plateau-Mont-Royal se distinguent avec des trajets plus courts (environ 20 % plus courts en moyenne que les trajets partant dAhuntsic-Cartierville). À linverse, Lachine est de loin larrondissement avec les trajets les plus longs (25 % plus longs en moyenne que les trajets partant dAhuntsic-Cartierville). Nous appliquons la même méthode de visualisation à la variable Heure de départ des trajets. # Extraction des valeurs pour les heures de départ dfHeures &lt;- data.frame(df[grepl(&quot;HeureDep&quot;,row.names(df), fixed = T),]) names(dfHeures) &lt;- c(&quot;coeff&quot;, &quot;lower&quot;,&quot;upper&quot;) dfHeures$Heure &lt;- gsub(&quot;HeureDep&quot;,&quot;&quot;,rownames(dfHeures),fixed = T) # Rajouter des 0 et des h pour de jolies légendes dfHeures$Heure &lt;- paste(dfHeures$Heure,&quot;h&quot;,sep=&quot; &quot;) # Afficher le graphique ggplot(data = dfHeures) + geom_hline(yintercept = 1, color = &quot;red&quot;)+ geom_errorbar(aes(x = Heure, ymin = upper, ymax = lower), width = 0)+ geom_point(aes(x = Heure, y = coeff)) + geom_text(aes(y = upper, x = Heure, label = round(coeff,2)), size = 3, nudge_y = 0.07)+ labs(x = &quot;Coefficient multiplicateur (ref : 7 h)&quot;, y = &quot;&quot;) Figure 8.60: Effet de lheure de départ sur les temps de trajet à Montréal Nous pouvons ainsi observer, à la figure 8.60, que les trajets effectués à 10 h, 11 h et 12 h sont les plus longs de la journée, entre 30 et 40 % plus longs que ceux effectués à 7 h et 8 h qui constituent les trajets les plus courts. Le reste des coefficients (ainsi que le paramètre de forme) sont affichés dans le tableau 8.35. Comparativement à un trajet effectué à pied, un trajet en transport en commun dure en moyenne 52 % plus longtemps (1,53 fois plus long), alors que les déplacements en véhicule individuel et en vélo sont respectivement 28 % et 23 % moins longs. Aucune différence nest observable entre les déplacements effectués en semaine ou pendant la fin de semaine. Tableau 8.35: Résultats pour le modèle GLM Gamma Variable Coeff. Exp(Coeff.) Val.p IC 2,5 % exp(Coeff.) IC 97,5 % exp(Coeff.) Sign. Constante 2,927 18,665 0,000 14,939 23,313 *** Mode ref : pieton       transport collectif 0,421 1,523 0,000 1,484 1,562 *** vehicule individuel -0,321 0,725 0,000 0,707 0,744 *** velo -0,258 0,772 0,000 0,753 0,792 *** Motif ref : education       loisir -0,010 0,990 0,569 0,957 1,024 magasinage -0,107 0,899 0,000 0,868 0,931 *** travail -0,060 0,941 0,000 0,913 0,970 *** LogDist 0,334 1,397 0,000 1,383 1,412 *** MemeArrond ref : Different       Meme -0,037 0,964 0,001 0,944 0,985 *** Semaine ref : lundi au vendredi       samedi et dimanche 0,003 1,003 0,755 0,983 1,024 shape 1,144 3,140 0,000 3,086 3,196 *** Les déplacements ayant comme motif le magasinage et le travail ont tendance à être en moyenne plus courts de 11 % et 6 % respectivement, comparativement aux déplacements effectués pour léducation ou le loisir (différence non significative entre loisir et éducation). Sans surprise, la distance entre le point de départ et darrivée du trajet (LogDist) affecte sa durée de façon positive. Considérant quil est difficile dinterpréter des log de kilomètre (dû à une transformation de la variable originale), nous représentons leffet de cette variable avec la prédiction du modèle à la figure. Nous utilisons pour cela le cas suivant: déplacement à pied à 7 h en semaine, ayant pour motif éducation, dont le point de départ se situe dans larrondissement Ahuntsic et donc le point darrivée est dans un autre arrondissement. Seule la distance du trajet varie de 1 à 40 km. À titre de comparaison, nous représentons aussi, pour les mêmes conditions, le cas dune personne à vélo (en vert) et dune personne utilisant le transport en commun (en bleu). Les lignes en pointillés représentent les intervalles de confiance à 95 % des prédictions (figure 8.61). # Création d&#39;un DataFrame fictif pour la prédiction dfpred &lt;- expand.grid( Dist = seq(1,40, 0.5), Motif = &#39;education&#39;, HeureDep = &#39;7&#39;, MemeArrond = &#39;Different&#39;, ArrondDep = &#39;Ahuntsic-Cartierville&#39;, Mode = c(&#39;pieton&#39;,&#39;velo&#39;,&#39;transport collectif&#39;), Semaine = &#39;lundi au vendredi&#39; ) # Mise en log de la variable de distance dfpred$LogDist &lt;- log(dfpred$Dist) # Calcul des prédictions et de leur erreur standard (échelle log) lin_pred &lt;- predict(modele,dfpred, se = T) # Calcul des intervalles de confiance et mise en exponentielle des prédictions dfpred$pred &lt;- exp(lin_pred$fitted.values[,1]) dfpred$lower &lt;- exp(lin_pred$fitted.values[,1] -1.96*lin_pred$se.fit[,1]) dfpred$upper &lt;- exp(lin_pred$fitted.values[,1] +1.96*lin_pred$se.fit[,1]) # Ajoutons les accents pour le graphiques dfpred$Mode &lt;- as.character(dfpred$Mode) dfpred$Mode2 &lt;- case_when(dfpred$Mode == &quot;pieton&quot; ~ &quot;piéton&quot;, dfpred$Mode == &quot;velo&quot; ~ &quot;vélo&quot;, TRUE ~ dfpred$Mode) # Affichage des résultats ggplot(data = dfpred) + geom_path(aes(x = Dist, y = lower, color = Mode2), linetype = &quot;dashed&quot;)+ geom_path(aes(x = Dist, y = upper, color = Mode2), linetype = &quot;dashed&quot;)+ geom_path(aes(x = Dist, y = pred, color = Mode2), size = 1) + labs(y = &quot;temps de trajet prédit (minutes)&quot;, x = &quot;distance à vol d&#39;oiseau (km)&quot;) Figure 8.61: Effet de la distance à vol doiseau sur les temps de trajet à Montréal 8.4.4 Modèle GLM avec une distribution bêta Pour rappel, la distribution bêta est une distribution définie sur lintervalle \\([0,1]\\), elle est donc particulièrement utile pour décrire des proportions, des pourcentages ou des probabilités. Dans la section 2.4.3.16 sur les distributions, nous avons présenté la paramétrisation classique de la distribution avec les paramètres \\(a\\) et \\(b\\) étant tous les deux des paramètres de forme. Ces deux paramètres nont pas dinterprétation pratique, mais il est possible (comme pour la distribution Gamma) de reparamétrer la distribution bêta avec un paramètre de centralité (espérance) et de dispersion. Notez également que si la distribution bêta autorise la présence de 0 et de 1, le modèle GLM utilisant cette distribution doit les exclure des valeurs possibles sil utilise la fonction de lien logistique. En effet, cette fonction à la forme suivante : \\[\\begin{equation} logit(x) = log(\\frac{x}{1-x})\\\\ \\tag{8.24} \\end{equation}\\] Nous pouvons constater que si \\(x = 1\\), alors le dénominateur de la fraction est 0, or il est impossible de diviser par 0. Si \\(x = 0\\), alors nous obtenons \\(log(0)\\) ce qui est également impossible au plan mathématique. Dans le cas de figure où des 0 et/ou des 1 sont présents dans les données, quatre options sont possibles pour contourner le problème : Si les observations à 0 ou 1 sont très peu nombreuses, il est envisageable de les retirer des données. Si la variable mesurée le permet, il est possible de remplacer les 0 et les 1 par des valeurs très proches (0,0001 et 0,9999 par exemple) sans dénaturer excessivement les données initiales. Plutôt que dutiliser une valeur arbitraire, Smithson et Verkuilen (2006) recommande de recalculer la variable \\(Y \\in [0;1]\\) avec la formule (8.25); Employer un modèle Hurdle à trois équations, la première prédisant la probabilité dobserver \\(Y &gt; 0\\), la seconde, la probabilité dobserver \\(Y = 1\\) et la dernière prédisant les valeurs de Y pour \\(0&gt;Y&gt;1\\). \\[\\begin{equation} Y&#39; = \\frac{Y(N-1)+s}{N} \\tag{8.25} \\end{equation}\\] Avec N le nombre dobservations, Y la variable Y transformée et s une constante. Plus cette dernière est élevée, plus la variable Y a des valeurs éloignée de 0 et 1. la valeur de 0,5 est recommandée par les auteurs. Reparamétrisation de la distribution bêta Pour une distribution bêta telle que définie par \\(Y \\sim Beta(a,b)\\), lespérance de cette distribution et sa variance sont données par : \\[\\begin{equation} \\begin{aligned} &amp;E(Y) = \\frac{a}{a+b} \\\\ &amp;Var(Y) = \\frac{a \\times b}{(a+b)^2(a+b+1)}\\\\ \\end{aligned} \\tag{8.26} \\end{equation}\\] Pour reparamétrer cette distribution, nous définissons un nouveau paramètre \\(\\phi\\) (phi) tel que: \\[\\begin{equation} \\begin{aligned} &amp;a = \\phi * E(Y) \\\\ &amp;b = \\phi - a \\\\ &amp;Var(Y) = \\frac{E(Y) \\times (1-E(Y))}{1+\\phi} \\end{aligned} \\tag{8.27} \\end{equation}\\] De cette manière, il est possible dexprimer la distribution bêta en fonction de son espérance (sa valeur attendue, ce qui sinterprète approximativement comme une moyenne) et dun paramètre \\(\\phi\\) intervenant dans le calcul de sa variance. Vous noterez dailleurs que la variance de cette distribution dépend de sa moyenne, impliquant à nouveau une hétéroscédasticité intrinsèque. Pour résumer, nous nous retrouvons donc avec un modèle qui prédit lespérance dune distribution bêta avec une fonction de lien logistique. La variance de cette distribution est fonction de cette moyenne et dun second paramètre \\(\\phi\\). Ces informations sont résumées dans la fiche didentité du modèle (tableau 8.36). Tableau 8.36: Carte didentité du modèle bêta Type de variable dépendante Variable continue dans lintervalle \\(]0,1[\\) Distribution utilisée Student Formulation \\(Y \\sim Beta(\\mu,\\phi)\\) \\(g(\\mu) = \\beta_0 + \\beta X\\) \\(g(x) = log(\\frac{x}{1-x})\\) Fonction de lien log Paramètre modélisé \\(\\mu\\) Paramètres à estimer \\(\\beta_0\\), \\(\\beta\\), et \\(\\phi\\) Conditions dapplication \\(Variance = \\frac{\\mu \\times (1-\\mu)}{1+\\phi}\\) 8.4.4.1 Conditions dapplication Comme pour un modèle Gamma, la seule condition dapplication spécifique à un modèle avec distribution bêta est que la variance des résidus suit la forme attendue par la distribution bêta. 8.4.4.2 Interprétation des coefficients Puisque le modèle utilise la fonction de lien logistique, les exponentiels des coefficients \\(\\beta\\) du modèle peuvent être interprétés comme des rapports de cotes (voir la section 8.2.1 sur le modèle GLM binomial). Admettons ainsi que nous avons obtenu pour une variable indépendante \\(X_1\\) le coefficient \\(\\beta_1\\) de 0,12. Puisque le coefficient est positif, cela signifie quune augmentation de \\(X_1\\) conduit à une augmentation de lespérance de Y. Lexponentiel de 0,12 est 1,13, ce qui signifie quune augmentation dune unité de \\(X_1\\) multiplie par 1,13 (augmente de 13 %) les chances dune augmentation de Y. Pour ce type de modèle, il est particulièrement important de calculer ses prédictions afin den faciliter linterprétation. 8.4.4.3 Exemple appliqué dans R Afin de présenter le modèle GLM avec une distribution bêta, nous utilisons un jeu de données que nous avons construit pour lîle de Montréal. Nous nous intéressons à la question des îlots de chaleur urbains au niveau des aires de diffusion (AD  entités spatiales du recensement canadien comprenant entre 400 et 700 habitants). Pour cela, nous avons calculé dans chaque AD le pourcentage de sa surface classifiée comme îlot de chaleur dans la carte des îlots de chaleur/fraicheur réalisée par lINSPQ et le CERFO. La question que nous nous posons est la suivante : les populations vulnérables socioéconomiquement et/ou physiologiquement sont-elles systématiquement plus exposées à la nuisance que représentent les îlots de chaleur? Cette question se rattache donc au champ de la recherche sur la justice environnementale et plus spécifiquement sur sa dimension spatiale (à savoir léquité environnementale, à distinguer des dimensions procédurale et de reconnaissance). Plusieurs études se sont dailleurs déjà penchées sur la question des îlots de chaleur abordée sous langle de léquité environnementale (Harlan et al. 2007; Sanchez et Reames 2019; Huang, Zhou et Cadenasso 2011). Nous modélisons donc pour chaque AD (n = 3 158) de lîle de Montréal la proportion de sa surface couverte par des îlots de chaleur. Nos variables indépendantes sont divisées en deux catégories : variables environnementales et variables socio-économiques. Les premières sont des variables de contrôle, il sagit de la densité de végétation dans lAD (ajoutée avec une polynomiale dordre deux) et de larrondissement dans lequel elle se situe. Ces deux paramètres affectent directement les chances dobserver des îlots de chaleur, mais nous souhaitons isoler leurs effets (toutes choses étant égales par ailleurs) de ceux des variables socio-économiques. Ces dernières ont pour objectif de cibler les populations vulnérables sur le plan physiologique (personnes âgées et enfants de moins de 14 ans) ou socio-économique (minorités visibles et faible revenu). Lensemble de ces variables sont présentées dans le tableau 8.37. Notez que, puisque le modèle avec distribution bêta ne peut pas prendre en compte des valeurs exactes de 1 ou 0, nous les avons remplacées respectivement par 0,99 et 0,01. Cette légère modification naltère que marginalement les données, surtout si nous considérons quelles sont agrégées au niveau des AD et proviennent originalement dimagerie satellitaire. Tableau 8.37: Variables indépendantes utilisées dans le modèle bêta Nom de la variable Signification Type de variable Mesure A65PlusPct Population de 65 ans et plus Variable continue Pourcentage de la population ayant 65 ans et plus A014Pct Population de 14 ans et moins Variable continue Pourcentage de la population ayant 14 ans et moins PopFRPct Population à faible revenu Variable continue Pourcentage de la population à faible revenu PopMVPct Minorités visibles Variable continue Pourcentage de la population faisant partie des minorités visibles VegPct Végétation Variable continue Pourcentage de la surface de lAD couverte par de la végétation Arrond Arrondissements Variable continue Arrondissement de lÎle de Montréal Vérification des conditions dapplication Sans surprise, nous commençons par charger nos données et nous nous assurons de labsence de multicolinéarité excessive entre nos variables indépendantes. ## Chargement des données dataset &lt;- read.csv(&quot;data/glm/data_chaleur.csv&quot;,fileEncoding = &quot;utf8&quot;) ## Calcul des valeurs de vif vif(glm(hot ~ A65Pct + A014Pct + PopFRPct + PopMVPct + poly(prt_veg, degree = 2) + Arrond, data = dataset)) ## GVIF Df GVIF^(1/(2*Df)) ## A65Pct 1.609917 1 1.268825 ## A014Pct 2.206072 1 1.485285 ## PopFRPct 2.162036 1 1.470386 ## PopMVPct 2.370269 1 1.539568 ## poly(prt_veg, degree = 2) 2.619552 2 1.272204 ## Arrond 7.899208 32 1.032820 La seule variable semblant poser un problème de multicolinéarité est la variable Arrond. Cependant, du fait de sa nature multinomiale, elle regroupe en réalité 32 coefficients (voir la colonne Df). Il faut donc utiliser la règle habituelle de 5 sur le carré de la troisième colonne (GVIF^(1/(2*Df))) du tableau (Fox et Monette 1992), soit 1,032820^2 = 1,066717, ce qui est bien inférieur à la limite de 5. Nous navons donc pas de problème de multicolinéarité excessive. Nous pouvons passer au calcul des distances de Cook. Pour ajuster notre modèle, nous utilisons le package mgcv et la fonction gam avec le paramètre family = betar(link = \"logit\"). # Ajustement d&#39;une première version du modèle modele &lt;- gam(hot ~ A65Pct + A014Pct + PopFRPct + PopMVPct + poly(prt_veg, degree=2) + Arrond, data = dataset, family = betar(link = &quot;logit&quot;)) # Calcul des distances de Cook df &lt;- data.frame( cooksd = cooks.distance(modele), oid = 1:nrow(dataset) ) # Affichage des distances de Cook ggplot(data = df)+ geom_point(aes(x = oid, y = cooksd), color = rgb(0.4,0.4,0.4,0.4), size = 0.5)+ labs(x = &quot;&quot;, y = &quot;Distance de Cook&quot;) Figure 8.62: Distances de Cook pour le modèle GLM bêta Nous pouvons observer à la figure 8.62 que seulement deux observations se distinguent très nettement des autres. Nous les isolons donc dans un premier temps. cas_etranges &lt;- subset(dataset, df$cooksd &gt;= 0.01) print(cas_etranges[,23:ncol(cas_etranges)]) ## A014Pct A65Pct PopFRPct PopMVPct Km2 HabKm2 Shape_Leng Shape_Area ## 1666 11.78 26.77 6.38 11.65 6.458460 72.3083 21153.055 6458456.6 ## 2803 15.54 31.07 24.17 52.17 0.134013 5283.0879 1651.471 134012.5 ## prt_hot prt_veg dist_cntr Arrond hot ## 1666 1.824483 90.11691 29.181345 Senneville 0.02 ## 2803 40.117994 60.15745 4.178823 Westmount 0.40 Ces deux observations nont pas de points communs marqués, et ne semblent pas avoir de valeurs particulièrement fortes sur les différentes variables indépendantes ou la variable dépendante. Nous décidons donc de les supprimer et de recalculer les distances de Cook. # Suppression des deux observations très influentes dataset2 &lt;- subset(dataset, df$cooksd &lt; 0.01) modele2 &lt;- gam(hot ~ A65Pct + A014Pct + PopFRPct + PopMVPct + I(prt_veg**2) + prt_veg + Arrond, data = dataset2, family = betar(link = &quot;logit&quot;), methode = &quot;REML&quot;) # Calcul des distances de Cook df2 &lt;- data.frame( cooksd = cooks.distance(modele2), oid = 1:nrow(dataset2) ) # Affichage des distances de Cook ggplot(data = df2)+ geom_point(aes(x = oid, y = cooksd), color = rgb(0.4,0.4,0.4,0.4), size = 0.5)+ labs(x = &quot;&quot;, y = &quot;Distance de Cook&quot;) Figure 8.63: Distances de Cook pour le modèle GLM bêta (suppression de deux observations influentes) Après réajustement (figure 8.63) nous constatons à nouveau quune observation est extrêmement éloignée des autres. Nous la retirons également, car cette différence est si forte quelle risque de polluer le modèle. # Suppression de l&#39;observation très étonnante dataset3 &lt;- subset(dataset2, df2$cooksd&lt;max(df2$cooksd)) # Réajustement du modèle modele3 &lt;- gam(hot ~ A65Pct + A014Pct + PopFRPct + PopMVPct + I(prt_veg**2) + prt_veg + Arrond, data = dataset3, family = betar(link = &quot;logit&quot;), methode = &quot;REML&quot;) # Calcul des distances de Cook df3 &lt;- data.frame( cooksd = cooks.distance(modele3), oid = 1:nrow(dataset3) ) # Affichage des distances de Cook ggplot(data = df3)+ geom_point(aes(x = oid, y = cooksd), color = rgb(0.4,0.4,0.4,0.4), size = 0.5)+ labs(x = &quot;&quot;, y = &quot;Distance de Cook&quot;) Figure 8.64: Distances de Cook pour le modèle GLM bêta (suppression de trois observations influentes) Tout semble aller pour le mieux après ce second passage (figure 8.64). Si nous avions continué à observer des valeurs aussi influentes, nous aurions dû commencer à sérieusement questionner nos données ou notre modèle. La prochaine étape du diagnostic est donc lanalyse des résidus simulés. # Extraction de phi modele3$family$family ## [1] &quot;Beta regression(14.612)&quot; phi &lt;- 14.612 # Réalisation des simulations nsim &lt;- 1000 mus &lt;- modele3$fitted.values cols &lt;- lapply(1:length(mus),function(i){ mu &lt;- mus[[i]] p &lt;- mu * phi q &lt;- (1-mu)*phi sims &lt;- rbeta(n = nsim,shape1 = p, shape2 = q) return(sims) }) mat_sims &lt;- do.call(rbind, cols) # Calcul des résidus simulés sim_res &lt;- createDHARMa(simulatedResponse = mat_sims, observedResponse = dataset3$hot, fittedPredictedResponse = modele3$fitted.values, integerResponse = F) plot(sim_res) Figure 8.65: Diagnostic général des résidus simulés du modèle bêta La figure 8.65 indique que les résidus suivent bien une distribution uniforme. Le test des valeurs aberrantes nest pas significatif au seuil de 0,01 (nous retenons ce seuil considérant le grand nombre de simulations et dobservations de notre jeu de données), nous décidons donc de ne pas supprimer davantage dobservations. Le panneau de droite indique une relation non linéaire instable, mais essentiellement centrée sur la ligne droite attendue. Pour plus de détails, nous calculons ces résidus simulés avec chacune des variables indépendantes. # Préparons un plot multiple par(mfrow=c(2,3)) vars &lt;- c(&quot;A65Pct&quot;, &quot;A014Pct&quot;, &quot;PopFRPct&quot;, &quot;PopMVPct&quot;, &quot;prt_veg&quot;) for(v in vars){ plotResiduals(sim_res, dataset3[[v]], main = &quot;&quot;, xlab = v) } plotResiduals(sim_res, dataset3[[&quot;prt_veg&quot;]]**2, xlab = &quot;prt_veg^2&quot;, main = &quot;&quot;) Figure 8.66: Relation entre chaque variable indépendante et les résidus simulés du modèle bêta La figure 8.66 indique des relations marginales et négligeables entre nos variables indépendantes et nos résidus simulés. Concernant la variable Arrond (figure 8.67), nous observons une situation plus particulière. Pour quelques arrondissements, les résidus simulés sont nettement plus forts ou plus faibles. Notre hypothèse est que cet effet est provoqué par lintroduction de cette variable dans notre modèle comme un effet fixe alors que sa nature devrait nous inciter à lintroduire comme un effet aléatoire. Nous navons pas encore présenté ces concepts ici, mais nous le ferons dans le chapitre 9. En attendant, nous conservons le modèle tel quel et passons à lanalyse de sa qualité dajustement. df &lt;- data.frame( resid = residuals(sim_res), Arrond = dataset3$Arrond ) ggplot(data = df) + geom_boxplot(aes(x = Arrond, y = resid))+ theme(axis.text.x = element_blank(), axis.ticks.x = element_blank() )+ labs(x = &quot;Arrondissements&quot;, y = &quot;Résidus simulés&quot;) Figure 8.67: Relation entre la variable Arrondissement et les résidus simulés du modèle bêta Analyse de la qualité dajustement Dans un premier temps, nous comparons la distribution originale des données à des simulations issues du modèle. # Extraction de 20 simulations df2 &lt;- data.frame(mat_sims[,1:20]) df3 &lt;- reshape2::melt(df2) ggplot() + geom_histogram(aes(x = hot, y = ..density..), data = dataset3, bins = 100, color = &quot;black&quot;, fill = &quot;white&quot;) + geom_density(aes(x = value, y=..density.., group = variable), data = df3, fill = rgb(0,0,0,0), color = rgb(0.2,0.2,0.2,0.3), size = 1) + labs(x = &quot;résidus simulés&quot;, y = &quot;densité&quot;) Figure 8.68: Comparaison entre la distribution originale et les simulations issues du modèle Nous constatons à la figure 8.68 que le modèle est parvenu à reproduire la forme générale de la distribution originale : un plus grand nombre de valeurs proches de zéro, suivies dune répartition presque homogène dans les valeurs comprises entre 0,15 et 0,8, suivies par un plus faible nombre de valeurs quand Y est supérieur à 0,8. Il semble en revanche manquer un certain nombre de valeurs extrêmes proches de 0 (absence dîlot de chaleur) et proches de 1 (couverture à 100 % par des îlots de chaleur). # Calcul des pseudo R2 rsqs(loglike.full = modele3$deviance/-2, loglike.null = modele3$null.deviance/-2, full.deviance = modele3$deviance, null.deviance = modele3$null.deviance, nb.params = modele3$rank, n = nrow(dataset3)) ## $`deviance expliquee` ## [1] 0.9017396 ## ## $`McFadden ajuste` ## [1] 0.8992329 ## ## $`Cox and Snell` ## [1] 0.999828 ## ## $Nagelkerke ## [1] 0.9998949 # Calcul du RMSE sqrt(mean((modele3$fitted.values - modele3$y)**2)) ## [1] 0.1025719 Le modèle parvient à expliquer 90 % de la déviance totale et obtient des pseudo-R2 très élevés. Il obtient cependant un RMSE de 0,10 soit une erreur quadratique moyenne de 10 % dans la prédiction, ce qui est tout de même important. Le modèle ne semble pas souffrir particulièrement de sur-ajustement comme les pseudo-R2 auraient pu nous le laisser penser. Lensemble des coefficients du modèle sont accessibles via la fonction summary. Pour rappel, il est nécessaire de les convertir avec la fonction exponentielle pour pouvoir les interpréter en termes de rapport de cotes. À nouveau, nous proposons de construire dans un premier temps une figure pour observer leffet des arrondissements. # Identifier les coefficients pour les arrondissements test &lt;- grepl(&quot;Arrond&quot;,names(modele3$coefficients), fixed = T) # Extraire les coefficients et les erreurs standards coeffs &lt;- modele3$coefficients[test] err.std &lt;- summary(modele3)$se[test] # Créer un DataFrame avec les rapports de cote et les intervalles de confiance df &lt;- data.frame( Arrond = gsub(&quot;Arrond&quot;,&quot;&quot;,names(coeffs), fixed = T), coeffs = coeffs, err.std = err.std, RC = exp(coeffs), lowerRC = exp(coeffs-1.96*err.std), upperRC = exp(coeffs+1.96*err.std) ) # Retrouver l&#39;arrondissement de référence allArrond &lt;- unique(dataset3$Arrond) refArrond &lt;- setdiff(allArrond, df$Arrond) # Créer le graphique ggplot(data = df) + geom_errorbarh(aes(xmin = lowerRC, xmax = upperRC, y = reorder(Arrond,RC)))+ geom_point(aes(x = RC, y = reorder(Arrond,RC)))+ geom_vline(xintercept = 1, color = &quot;red&quot;)+ geom_text(aes(x = upperRC, y = reorder(Arrond, RC), label = paste(&quot;RC : &quot;,round(RC,2),sep=&quot;&quot;)), size = 3, nudge_x = 0.3)+ labs(x = paste(&quot;Rapport de cote (rouge : &quot;,refArrond,&#39;)&#39;,sep=&#39;&#39;), y = &#39;Arrondissement&#39;) Figure 8.69: Rapports de cote pour les arrondissements dans le modèle bêta Nous constatons ainsi que seuls quelques arrondissements ont une différence dexposition aux îlots de chaleur significative au seuil de 0,05 comparativement à Ahuntsic-Cartierville (figure 8.69). Pour lessentiel, il sagit darrondissements pour lesquels nous observons des rapports de cotes supérieurs à 1. Verdun, Lasalle et le Plateau-Mont-Royal sont les arrondissements les plus touchés avec des chances dobserver des niveaux supérieurs de densité dîlots de chaleur multipliés par 3,19, 2,89 et 2,74. Le reste des coefficients sont affichés dans le tableau 8.38. Nous notons ainsi que le seul groupe associé avec une augmentation significative des chances dobserver une augmentation de la densité dîlot de chaleur est le groupe des personnes à faible revenu (1,4 % de chance supplémentaire à chaque augmentation dun point de pourcentage de la variable indépendante). Pour mieux cerner la taille de cet effet, nous représentons leffet marginal de ce coefficient en maintenant toutes les autres variables à leur moyenne. Nous calculons également ces effets marginaux pour trois arrondissements différents : Verdun (RC le plus fort), Ahuntsic-Cartierville (la référence) et Dollard-des-Ormeaux (RC le plus faible). Nous réalisons également un second graphique pour visualiser leffet non linéaire de la variable pourcentage de végétation. La figure 8.70 nous indique ainsi que le rôle de larrondissement est plus important que celui du pourcentage de personnes à faible revenu. Cependant, nous constatons que passer de 0 % de personnes à faible revenu dans une AD à 75 % est associé avec une multiplication de la surface couverte par des îlots de chaleur par environ 1,5 (toutes choses égales par ailleurs). Le rôle de la végétation dans la réduction de la surface des îlots de chaleur est très net et non linéaire. Lessentiel de la réduction est observé entre 0 et 50 % de végétation dans une AD, au-delà de ce seuil, la réduction des îlots de chaleur par la végétation est moins flagrante. Il semblerait donc exister à Montréal une forme diniquité systématique pour les populations à faible revenu, qui seraient davantage exposées aux îlots de chaleur. Cependant, compte tenu de la dépendance spatiale et de lhétéroscésadicité observées plus haut, des ajustements devraient être apportés au modèle pour confirmer ou infirmer ce résultat. Tableau 8.38: Résultats pour le modèle GLM bêta Variable Coeff. RC Val.p IC 2,5 % RC IC 97,5 % RC Sign. Constante 3,468 32,059 0,000 25,636 40,085 *** A65Pct -0,002 0,998 0,243 0,996 1,001 A014Pct -0,006 0,994 0,035 0,988 1,000 PopFRPct 0,013 1,014 0,000 1,011 1,016 *** PopMVPct -0,003 0,997 0,000 0,995 0,998 *** prt_veg -0,137 0,872 0,000 0,865 0,879 *** # Créer un DataFrame pour la prédiction df &lt;- expand.grid( A65Pct = mean(dataset3$A65Pct), A014Pct = mean(dataset3$A014Pct), PopFRPct = seq(0,75, 1), PopMVPct = mean(dataset3$PopMVPct), prt_veg = mean(dataset3$prt_veg), Arrond = c(&quot;Verdun&quot;,&#39;Ahuntsic-Cartierville&#39;,&#39;Dollard-des-Ormeaux&#39;) ) # Effectuer les prédiction sur l&#39;échelle log pred &lt;- predict(modele3, df, se=T, type = &quot;link&quot;) # Calculer les prédictions et leurs intervalles de confiance ilink &lt;- modele3$family$linkinv df$pred &lt;- ilink(pred$fit) df$lower &lt;- ilink(pred$fit - 1.96* pred$se.fit) df$upper &lt;- ilink(pred$fit + 1.96* pred$se.fit) # Afficher le résultat P1 &lt;- ggplot(data = df)+ geom_path(aes(x = PopFRPct, y = pred, color = Arrond), size =1) + geom_path(aes(x = PopFRPct, y = lower, color = Arrond), linetype=&quot;dashed&quot;) + geom_path(aes(x = PopFRPct, y = upper, color = Arrond), linetype=&quot;dashed&quot;)+ labs(x = &quot;Personnes à faible revenu (%)&quot;, y = &quot;Surface de l&#39;AD couverte par des îlots de chaleur (%)&quot;, color = &#39;Arrondissement&#39;)+ ylim(0,1) # Pour la végétation df2 &lt;- expand.grid( A65Pct = mean(dataset3$A65Pct), A014Pct = mean(dataset3$A014Pct), PopFRPct = mean(dataset3$PopFRPct), PopMVPct = mean(dataset3$PopMVPct), prt_veg = seq(0,95,1), Arrond = c(&quot;Verdun&quot;,&#39;Ahuntsic-Cartierville&#39;,&#39;Dollard-des-Ormeaux&#39;) ) # Effectuer les prédiction sur l&#39;échelle log pred2 &lt;- predict(modele3, df2, se=T, type = &quot;link&quot;) # Calculer les prédictions et leurs intervalles de confiance df2$pred &lt;- ilink(pred2$fit) df2$lower &lt;- ilink(pred2$fit - 1.96* pred2$se.fit) df2$upper &lt;- ilink(pred2$fit + 1.96* pred2$se.fit) # Afficher le résultat P2 &lt;- ggplot(data = df2)+ geom_path(aes(x = prt_veg, y = pred, color = Arrond), size =1) + geom_path(aes(x = prt_veg, y = lower, color = Arrond), linetype=&quot;dashed&quot;) + geom_path(aes(x = prt_veg, y = upper, color = Arrond), linetype=&quot;dashed&quot;)+ labs(x = &quot;Couverture végétale (%)&quot;, y = &#39;&#39;, color = &#39;Arrondissement&#39;)+ ylim(0,1) ggarrange(P1,P2, common.legend = T) Figure 8.70: Effets marginaux des variables pourcentage de personnes à faible revenu et densité de végétation References "],["sect086.html", "8.5 Conclusion sur les modèles linéaires généralisés", " 8.5 Conclusion sur les modèles linéaires généralisés Comme vous avez dû le remarquer, les modèles linéaires généralisés constituent un monde à part entière et tout un livre pourrait être rédigé à leur sujet. Leur grande flexibilité les rend extrêmement utiles dans de nombreux contextes, mais complique leur mise en uvre, chaque modèle ayant ses propres spécificités théoriques. Ils partagent cependant tous une base commune : le choix dune distribution et dune fonction de lien. Lensemble de leurs spécificités découle directement de ces deux choix. La figure 8.71 résume les choix de modèles présentés au cours de ce chapitre pour des variables qualitatives, de comptage et continues. Notez bien quil ne sagit que de la partie émergée de liceberg, car il existe de nombreuses autres distributions plus ou moins complexes (skew-normale, log-normal, beta-binomiale, Box-Cox, Gumbel etc.). Dautres pistes pourraient aussi être explorées pour aller plus loin avec les GLM, notamment les modèles Hurdle (combinant un modèle binomial et un modèle avec une distribution continue), les modèles tronqués ou censurés (tenant compte dune limite nette dans la variable dépendante) ou encore les modèles distributionnels ajustant une équation de régression pour chaque paramètre de la distribution utilisée. Figure 8.71: Résumé graphique des principaux GLM abordés "],["sect087.html", "8.6 Quiz de révision du chapitre", " 8.6 Quiz de révision du chapitre Contrairement à un modèle LM, un GLM permet de choisir : Relisez au besoin la section 8.1. la distribution conditionnelle de la variable Y une fonction de lien appliquée aux coefficients du modèle une fonction de lien appliquée à léquation de régression du modèle la distribution à priori de la variable Y la distribution des résidus du modèle La fonction de lien est utilisée pour transformer : Relisez au besoin la section 8.1.2 les paramètres dun modèle et les rendre plus interprétables le résultat de léquation dun modèle pour le contraindre à un intervalle de valeurs cohérent avec le paramètre de la distribution modélisée le résultat de léquation dun modèle pour obtenir un effet multiplicatif plutôt quadditif des coefficients la variable Y pour quelle suive une distribution normale Un modèle GLM est ajusté par la méthode des moindres carrés. Relisez au besoin la section 8.1.1. Vrai Faux Dans un modèle GLM la vraisemblance (likelihood) est : Relisez au besoin la section 11.3. le produit des probabilités dobserver chacune des observations selon le modèle la somme des résidus du modèle un test de significativité du modèle impossible à calculer en pratique, nous lui préférons le log-likelihood Idéalement, les résidus simulés dun modèle GLM devraient : Relisez au besoin la section 8.1.4. suivre une distribution normale ne suivre aucune distribution particulière suivre une distribution uniforme être corrélés avec la variable Y LAIC Relisez au besoin la section 8.1.5. mesure la qualité dajustement dun modèle tient compte du nombre de paramètres dans un modèle mesure le niveau de significativité des coefficients dun modèle pénalise les modèles avec un plus petit nombre de paramètres tient compte du nombre dobservations dans le modèle Pour un modèle utilisant une distribution binomiale, le paramètre modélisé par léquation de régression est : Relisez au besoin la section 8.2.1. mu, la moyenne de y lambda, le nombre doccurrence attendu pour y sigma, la variance de y p, la probabilité dobserver y = 1 Si la fonction de lien logistique est utilisée dans un modèle binomial, comment peuvent être interprétés les coefficients? Relisez au besoin la section 8.2.1. En appliquant la fonction log aux coefficients, nous obtenons leffet linéaire de ceux-ci sur la probabilité p En appliquant la fonction exp aux coefficients, nous obtenons leffet linéaire de ceux-ci sur la probabilité p En appliquant la fonction exp aux coefficients, nous obtenons leur effet sous forme de rapport de côte sur la probabilité p En appliquant la fonction 1/exp aux coefficients, nous obtenons leur effet sous forme de rapport de côte sur la probabilité p Pour choisir la distribution la mieux adaptée pour un modèle GLM, il est possible de : Relisez au besoin la section 8.5. consulter la littérature et retenir les distributions utilisées habituellement comparer plusieurs distributions et conserver le modèle le mieux ajusté selon les AIC utiliser systématiquement la distribution normale demander à un service de voyance Verifier Votre score "],["chap09.html", "Chapitre 9 Régressions à effets mixtes (GLMM)", " Chapitre 9 Régressions à effets mixtes (GLMM) Dans les deux chapitres précédents, nous avons consécutivement présenté la méthode de la régression linéaire multiple (LM) ainsi quune de ses extensions, soit les modèles linéaires généralisés (GLM). Dans ce chapitre, nous poursuivons sur cette voie avec une nouvelle extension : les modèles généralisés à effet mixtes (GLMM). À la fin de cette section, vous serez en mesure de : comprendre la distinction entre un modèle GLM et un modèle GLMM; distinguer un effet fixe dun effet aléatoire; formuler des modèles GLMM avec des constantes et/ou des pentes aléatoires; effectuer les diagnostics dun GLMM. Dans ce chapitre, nous utilisons principalement les packages suivants : Pour créer des graphiques : ggplot2, le seul, lunique! ggpubr pour combiner des graphiques et réaliser des diagrammes. ellipse pour représenter des ellipses sur certains graphiques. Pour ajuster des modèles GLMM : lme4, offrant une interface simple pour ajuster des GLMM. Pour analyser des modèles GLM : car, essentiellement pour la fonction vif. DHARMa pour le diagnostic des résidus simulés. merTools pour explorer les résultats dun GLMM. lmerTest pour obtenir des tests de significativité pour les coefficients dun GLMM. MuMin pour calculer les R2 conditionnel et marginal. performance pour calculer lICC et dautres mesures dajustement. "],["sect091.html", "9.1 Introduction", " 9.1 Introduction 9.1.1 Indépendance des observations et effets de groupes Nous avons vu dans les précédents chapitres que lindépendance des observations est une condition dapplication commune à lensemble des modèles de régression. Cette condition implique ainsi que chaque unité dobservation de notre jeu de données est indépendante des autres; en dautres termes, quelle ne soit associée à aucune autre observation par un lien de dépendance. Prenons un exemple concret pour illustrer cette notion. Admettons que nous nous intéressons à la performance scolaire délèves du secondaire à Montréal. Pour cela, nous collectons la moyenne des résultats aux examens du Ministère de tous les élèves des différentes commissions scolaires de lîle de Montréal. Chaque élève appartient à une classe spécifique, et chaque classe se situe dans une école spécifique. Les classes constituent des environnements particuliers, la performance des élèves y est influencée par un ensemble de facteurs comme la personne qui enseigne et les relations entre les élèves dune même classe. Deux élèves provenant dune même classe sont donc lié(e)s par une forme de structure propre à leur classe et ne peuvent pas être considéré(e)s comme indépendant(e)s. De même, lécole constitue un environnement particulier pouvant influencer la performance des élèves du fait de moyens financiers plus importants, de la mise en place de programmes spéciaux, de la qualité des infrastructures (bâtiment, gymnase, cour décole) ou dune localisation minimisant certaines nuisances à lapprentissage comme le bruit. À nouveau, deux élèves provenant dune même école partagent une forme de structure qui, cette fois-ci, est propre à leur école. Si nous collectons des données pour lensemble du Canada, nous pourrions étendre ce raisonnement aux villes dans lesquelles les écoles se situent et aux provinces. Dans cet exemple, la dépendance entre les données est provoquée par un effet de groupe : il est possible de rassembler les observations dans des ensembles (classes et écoles) influençant vraisemblablement la variable étudiée (performance scolaire). Les effets des classes et des écoles ne sont cependant pas intrinsèques aux élèves. En effet, il est possible de changer un ou une élève de classe ou décole, mais pas de changer son âge ou sa situation familiale. Il est ainsi possible de distinguer la population des élèves, la population des classes, et la population des écoles (figure 9.1). Ces effets de groupes sont plus la règle que lexception dans lanalyse de données en sciences sociales, ce qui met à mal lhypothèse dindépendance des observations. Notez que les effets de groupes ne sont pas les seules formes de structures remettant en cause lindépendance des observations. Il existe également des structures temporelles (deux observations proches dans le temps ont plus de chances de se ressembler) et spatiales (deux observations proches dans lespace ont plus de chances de se ressembler); cependant, les cas de la dépendance temporelle et spatiale ne sont pas couverts dans ce livre, car ils sont complexes et méritent un ouvrage dédié. Figure 9.1: Structure hiérarchique entre élèves, classes et écoles La notion de pseudo-réplication Les effets de dépendance causés par des structures de groupe, temporelles ou spatiales, sont regroupés sous le terme de pseudo-réplication. Il est intéressant de se pencher sur la signification de ce mot pour comprendre le problème intrinsèque causé par la dépendance entre les observations et son influence sur linférence. Reprenons lexemple des élèves et de la performance scolaire et admettons que nous souhaitons estimer la moyenne générale de lensemble des élèves sur lîle de Montréal, mais que nous ne disposons pas du jeu de données complet. Nous devons donc collecter un échantillon suffisamment grand pour estimer la moyenne pour lensemble de cette population. Raisonnons en termes de quantité dinformations. Si nous ne disposons daucune observation (nous navons pas encore interrogé délèves), cette quantité est de 0. Si nous interrogeons un premier ou une première élève, nous obtenons une donnée supplémentaire, et donc un point dinformation supplémentaire (+1). Admettons maintenant que nous collectons 30 observations dans une école, 10 dans une seconde et 5 dans une troisième. A priori, nous pourrions dire que nous avons ajouté 45 points dinformation à notre total de connaissance. Ce serait le cas si les observations étaient indépendantes les unes des autres. Dans un tel contexte, chaque observation ajoute la même quantité dinformation. Cependant, puisque les personnes étudiant dans la même école ont plus de chance de se ressembler, interroger les élèves dune même école apporte moins dinformation. Notez que plus la ressemblance entre les élèves dune même école est forte, plus la quantité dinformation est réduite. Nous sommes donc loin de disposer dune quantité dinformation égale à 45. Chaque réplication de lexpérience (demander à un ou une élève sa moyenne annuelle) napporte pas autant dinformation quattendu si les observations étaient indépendantes, cest pourquoi on parle de pseudo-réplication. La pseudo-réplication influence directement linférence statistique puisque le calcul des différents tests statistiques assume que chaque observation apporte autant dinformation que les autres. En cas de présence de pseudo-réplication, la quantité dinformation présente dans léchantillon est plus petite quattendu. Il est possible de voir cela comme une forme de surestimation de la taille de léchantillon. En cas de pseudo-réplication, nous disposons en réalité de moins de données que ce que lon attendrait dun échantillon de cette taille, si les observations étaient indépendantes. La conséquence est la sous-estimation de la variabilité réelle des données et laugmentation des risques de trouver des effets significatifs dans léchantillon alors quils ne le sont pas pour lensemble de la population. 9.1.2 Terminologie: effets fixes et effets aléatoires Puisque les effets des classes et des écoles ne sont pas propres aux élèves, il convient de les introduire différemment dans les modèles de régression. Nous appelons un effet fixe, un effet qui est propre aux observations que nous étudions et un effet aléatoire, un effet provoqué par une structure externe (effet de groupe, effet temporel et/ou effet spatial). Un modèle combinant à la fois des effets fixes et des effets aléatoires est appelé un modèle à effets mixtes, ou GLMM pour Generalized Linear Mixed Model. Tous les modèles que nous avons ajustés dans les sections précédentes ne comprenaient que des effets fixes alors quà plusieurs reprises, des effets aléatoires induits par lexistence de structure de groupe auraient pu (dû) être utilisés. Prenons pour exemple le modèle logistique binomial visant à prédire la probabilité dutiliser le vélo comme mode de transport pour son trajet le plus fréquent. La variable multinomiale Pays, représentant le pays dans lequel les personnes interrogées résident, a été introduite comme un effet fixe. Cependant, leffet du pays ne constitue pas une caractéristique propre aux individus; il sagit plutôt dun agrégat complexe mêlant culture, météorologie, politiques publiques et formes urbaines. À linverse, le sexe ou lâge sont bien des caractéristiques intrinsèques des individus et peuvent être considérés comme des effets fixes. Notez que lutilisation du terme effet aléatoire peut porter à confusion, car il est utilisé différemment en fonction du champ détudes. Parmi les différentes définitions relevées par Gelman (2005) dun effet aléatoire, citons les suivantes : Les effets fixes sont identiques pour tous les individus, alors que les effets aléatoires varient (définition 1). Les effets sont fixes sils sont intéressants en eux-mêmes, et les effets sont aléatoires si nous nous intéressons à la population dont ils sont issus (définition 2). Lorsquun échantillon couvre une grande part de la population, la variable correspondante est un effet fixe. Si léchantillon couvre une faible part de la population, leffet est aléatoire (définition 3). Si leffet est censé provenir dune variable aléatoire, alors il sagit dun effet aléatoire (définition 4). Les effets fixes sont estimés par la méthode des moindres carrés ou par le maximum de vraisemblance, alors que les effets aléatoires sont estimés avec régularisation (shrinkage) (définition 5). Il est ainsi possible de se retrouver dans des cas où un effet serait classé comme fixe selon une définition et aléatoire selon une autre. La deuxième définition suppose même quun effet peut être aléatoire ou fixe selon lobjectif de létude. La dernière définition a lavantage dêtre mathématique, mais ne permet pas de décider si un effet doit être traité comme aléatoire ou fixe. Nous ne proposons pas ici de clore le débat, mais plutôt de donner quelques pistes de réflexion pour décider si un effet doit être modélisé comme fixe ou aléatoire: Est-ce que leffet en question est propre aux individus étudiés ou est externe aux individus? Sil est propre aux individus, il sagit plus certainement dun effet fixe. À titre dexemple, il nest pas possible de changer lâge dune personne, mais il est certainement possible changer sa ville de résidence. Existe-t-il un nombre bien arrêté de catégories possibles pour leffet en question? Si oui, il sagit plus certainement dun effet fixe. Il y a un nombre bien arrêté de catégories pour la variable sexe, mais pour la variable pays, de nombreuses autres valeurs peuvent être ajoutées. Il est également possible de se demander sil semble cohérent deffectuer un échantillonnage sur les catégories en question. Dans le cas des pays, nous pourrions mener une étude à léchelle des pays et collecter des données sur un échantillon de lensemble des pays. Il existe donc une population de pays, ce que nous ne pouvons pas affirmer pour la variable sexe. Leffet en question est direct ou indirect? Dans le second cas, leffet en question est un agglomérat complexe découlant de plusieurs processus nayant pas été mesurés directement, ce qui correspond davantage à un effet aléatoire. Ainsi, leffet du pays de résidence des individus sur leur probabilité dutiliser le vélo est bien une agglomération complexe deffets (culture, météorologie, orientation des politiques publiques, formes urbaines, etc.) nayant pas tous été mesurés. À linverse, lâge dun individu a bien un effet direct sur sa probabilité dutiliser le vélo. Leffet est-il le même pour tous les individus, ou doit-il varier selon le groupe dans lequel lindividu se situe? Si un effet doit varier en fonction dun groupe, il sapparente davantage à un effet aléatoire. Pour reprendre lexemple de lâge, nous pourrions décider que cette caractéristique des individus na peut-être pas le même effet en fonction du pays dans lequel vit lindividu et lajouter au modèle comme un effet aléatoire. Vous comprendrez donc quune partie non négligeable du choix entre effet fixe ou un effet aléatoire réside dans le cadre théorique à lorigine du modèle. Maintenant que cette distinction conceptuelle a été détaillée, nous pouvons passer à la présentation statistique des modèles GLMM. References "],["sect092.html", "9.2 Principes de base des GLMM", " 9.2 Principes de base des GLMM Un GLMM est donc un modèle GLM introduisant à la fois des effets fixes et des effets aléatoires. Si nous ne considérons que les effets de groupes, un GLMM peut avoir trois formes : constantes aléatoires, pentes aléatoires et constantes et pentes aléatoires. Nous présentons ici ces trois formes en reprenant lexemple ci-dessus avec des élèves intégré(e)s dans des classes et pour lesquel(le)s le niveau de performance à lexamen ministériel de mathématique nous intéresse. 9.2.1 GLMM avec constantes aléatoires Il sagit de la forme la plus simple dun GLMM. Plus spécifiquement, elle autorise le modèle à avoir une constante différente pour chaque catégorie dune variable multinomiale. En dautres termes, si nous reprenons lexemple des élèves dans leurs classes, nous tentons dajouter dans le modèle lidée que chaque classe a une moyenne différente en termes de performance à lexamen de mathématique. Il est assez facile de visualiser ce que cela signifie à laide dun graphique. Admettons que nous modélisons la note obtenue par des élèves du secondaire à lexamen ministériel de mathématique à partir dune autre variable continue représentant le temps de travail moyen par semaine en dehors des heures de classe et dune variable catégorielle représentant dans quelle classe se trouve chaque élève. Notez quil ne sagit pas ici de vraies données, mais de simples simulations utilisées à titre dillustration. Si nous ne tenons pas compte des classes, nous pouvons ajuster une régression linéaire simple entre nos deux variables continues comme le propose la figure 9.2. Figure 9.2: Influence du temps de travail sur la performance scolaire délèves Nous constatons que notre modèle semble bien identifier la relation positive entre le temps de travail et le niveau de performance, mais la droite de régression est très éloignée de chaque point; nous avons ainsi énormément derreurs de prédiction, et donc des résidus importants. Jusquici, nous avons vu que nous pouvons ajouter un prédicteur et intégrer leffet des classes comme un effet fixe (figure 9.3). Figure 9.3: Influence du temps de travail sur la performance scolaire délèves en tenant compte de leffet de leur classe (effet fixe) Cet ajustement constitue une nette amélioration du modèle. Prenons un instant pour reformuler clairement notre modèle à effets fixes : \\[\\begin{equation} \\begin{aligned} &amp;Y \\sim Normal(\\mu,\\sigma)\\\\ &amp;g(\\mu) = \\beta_0 + \\beta_1 x_1 + \\sum^k_{j=1}{\\beta_j x_{2j}}\\\\ &amp;g(x) = x \\end{aligned} \\tag{9.1} \\end{equation}\\] avec \\(x_1\\) le temps de travail et \\(x_2\\) la classe ayant k-1 modalités (puisquune modalité est la référence). Nous ajustons ainsi un coefficient pour chaque classe, ce qui a pour effet de tirer vers le haut ou vers le bas la prédiction du modèle en fonction de la classe. Cet effet est pour linstant fixe, mais nous avons déterminé dans les sections précédentes quil serait conceptuellement plus approprié de le traiter comme un effet aléatoire. Passons à présent à la reformulation de ce modèle en transformant leffet fixe de la classe en effet aléatoire. \\[\\begin{equation} \\begin{aligned} &amp;Y \\sim Normal(\\mu,\\sigma_e)\\\\ &amp;g(\\mu) = \\beta_0 + \\beta_1 x_1 + \\upsilon \\\\ &amp;\\upsilon \\sim Normal(0, \\sigma_{\\upsilon}) \\\\ &amp;g(x) = x \\end{aligned} \\tag{9.2} \\end{equation}\\] Remarquez que leffet fixe de la classe \\(\\sum^k_{j=1}{\\beta_j x_{2j}}\\) a été remplacé par \\(\\upsilon\\) qui est un terme aléatoire propre aux classes et qui suit une distribution normale centrée sur 0 (\\(\\upsilon \\sim Normal(0, \\sigma_{\\upsilon})\\)). En dautres termes, cela signifie que leffet des classes sur la performance des élèves suit une distribution normale et que si nous moyennons leffet de toutes les classes, cet effet serait de 0. Nous ne modélisons donc plus leffet moyen de chaque classe comme dans le modèle à effets fixes, mais la variabilité de leffet des classes, soit \\(\\sigma_{\\upsilon}\\). Notre modèle a donc deux variances, une au niveau des élèves (\\(\\sigma_e\\)) et une au niveau des classes (\\(\\sigma_{\\upsilon}\\)). Cette particularité explique souvent pourquoi ce type de modèle est appelé un modèle hiérarchique ou un modèle de partition de la variance. Cette information est particulièrement intéressante, car elle permet de calculer la part de la variance présente au niveau des élèves et celle au niveau des classes. Selon cette formulation, les constantes propres à chaque classe sont issues dune distribution normale (nous reviendrons dailleurs sur ce choix plus tard), mais elles napparaissent pas directement dans le modèle. Ces paramètres ne sont plus estimés directement dans le modèle, mais a posteriori à partir des prédictions du modèle, et sont appelés Best Linear Unbiased Predictor (BLUP). Ces dernières précisions devraient dailleurs mieux vous aider à comprendre lorigine des définitions 1, 2 et 4 que nous avons mentionnées précédemment. Figure 9.4: Influence du temps de travail sur la performance scolaire délèves en tenant compte de leffet de leur classe (effet aléatoire) En comparant les figures 9.3 et 9.4, la différence ne saute pas aux yeux; vous pourriez alors légitimement vous demander pourquoi tous ces efforts et cette complexité théorique pour une différence dajustement minime? Trois arguments permettent de justifier lutilisation de constantes aléatoires plutôt que deffets fixes dans notre cas. 9.2.1.1 Resserrement (shrinkage) et mutualisation (partial pooling) Le premier intérêt dutiliser un effet aléatoire réside dans sa méthode destimation qui diffère largement dun effet fixe. Il est assez facile de se représenter intuitivement la différence entre les deux. Dans le cas de nos élèves et de nos classes, lorsque leffet des classes est estimé avec un effet fixe, leffet de chaque classe est déterminé de façon totalement indépendante des autres classes. En dautres termes, il nest possible den apprendre plus sur une classe quen collectant des données dans cette classe (separate pooling). Si leffet des classes est estimé comme un effet aléatoire, alors linformation entre les classes est mutualisée (partial pooling). Lidée étant que linformation que nous apprenons sur des élèves dans une classe est au moins en partie valide dans les autres classes. Cette méthode destimation est particulièrement intéressante si nous ne disposons que de peu dobservations dans certaines classes, puisque nous pouvons apprendre au moins une partie de leffet de cette classe à partir des données des autres classes. Cela nest pas possible dans le cas dun effet fixe où lon traite chaque classe en silo. McElreath (2020) écrit à ce sujet quun effet fixe « na pas de mémoire » et quil oublie tout ce quil a appris sur les classes lorsquil passe à une nouvelle classe. La conséquence de cette mutualisation de linformation est un resserrement (shrinkage) des effets des classes autour de leur moyenne. Cela signifie que les tailles des effets de chaque classe sont plus petites dans le cas dun effet aléatoire que dun effet fixe. Utiliser des effets aléatoires conduit donc à une estimation plus conservatrice de leffet des classes. Nous pouvons le visualiser en comparant les effets de classes dans le modèle à effets mixtes et le modèle à effets fixes. La figure 9.5 montre clairement que les effets aléatoires tendent à se rapprocher (resserrement) de leur moyenne (ligne noire), et donc à identifier des effets moins extrêmes pour chaque classe. Cette explication est directement en lien avec la définition 5 dun effet aléatoire vu précédemment. Figure 9.5: Comparaison des effets des classes pour le modèle à effets fixes versus le modèle à effets aléatoires 9.2.1.2 Prédiction pour de nouveaux groupes Une autre retombée directe de la mutualisation de linformation est la capacité du modèle à envisager les effets plausibles pour de nouvelles classes. En effet, puisque nous avons approximé leffet des classes sous forme dune distribution normale dont nous connaissons la moyenne (0) et lécart-type (\\(\\sigma_{\\upsilon}\\)), nous pouvons simuler des données pour de nouvelles classes, ce que ne permet pas un effet fixe. Ce constat est dailleurs directement lié à la définition 3 des effets aléatoires vue précédemment. Dans notre cas, \\(\\sigma_{\\upsilon}\\) = 3,542, ce qui nous permet daffirmer que dans 95 % des classes, leffet de la classe sur la performance scolaire doit se trouver entre -1,96 \\(\\times\\) 3,542 et +1,96 \\(\\times\\) 3,542, soit lintervalle [-6,942, 6,942]. 9.2.1.3 Partition de la variance Un autre avantage net de leffet aléatoire est lestimation du paramètre \\(\\sigma_{\\upsilon}\\), soit la variance au niveau des écoles. Ce dernier permet de calculer un indicateur très intéressant, soit le coefficient de corrélation intraclasse (ICC) : \\[\\begin{equation} ICC = \\frac{\\sigma_{\\upsilon}}{\\sigma_{\\upsilon} + \\sigma_{e}} \\tag{9.3} \\end{equation}\\] Il sagit donc du pourcentage de la variance présente au niveau des classes, qui peut être interprétée comme le niveau de corrélation (de ressemblance) entre les élèves dune même classe. Dans notre cas, lécart-type est de 3,542 au niveau des classes et de 7,734 au niveau des élèves. Nous pouvons donc calculer lICC au niveau des classes avec la formule précédente : 3,542 / (3,542 + 7,734) = 0,314. Cela signifie que le niveau de corrélation entre deux élèves dune même classe est de 0,314 ou encore que 31,4 % de la variance de Y se situe au niveau des classes, ce qui est conséquent. Une telle information ne peut être extraite dun modèle avec uniquement des effets fixes. Notez ici que lICC peut être calculé pour chaque niveau dun modèle à effet mixte. Dans notre exemple, nous navons quun seul niveau au-dessus des élèves, soit les classes, mais nous pourrions étendre cette logique à des écoles, par exemple. Notez également que cette formule de lICC nest valide que pour un modèle pour lequel la distribution de la variable Y est normale. Des développements apparaissent pour proposer dautres formulations adaptées à dautres distributions, mais il est également possible destimer lICC à partir des simulations issues du modèle (Nakagawa, Johnson et Schielzeth 2017; Aly et al. 2014; Stryhn et al. 2006; Wu, Crespi et Wong 2012). Lidée générale reste dexpliquer la partition de la variance dans le modèle. En plus de lICC, il est également possible de calculer les R2 marginal et conditionnel du modèle. Le premier représente la variance expliquée par le modèle si seulement les effets fixes sont pris en compte, et le second si les effets fixes et aléatoires sont pris en compte. Distinguer les deux sources dinformation permet de mieux cerner limportance du rôle des écoles dans la performance des élèves. Dans notre cas, nous obtenons un R2 marginal de 0,115 et un R2 conditionnel de 0,269, ce qui nous confirme à nouveau que le rôle joué par la classe dans le niveau de performance est loin dêtre négligeable. 9.2.2 GLMM avec pentes aléatoires Dans cette seconde version du GLMM, nous nenvisageons plus de faire varier une constante en fonction des classes, mais un coefficient en fonction des classes. Admettons que nous voulons tester ici si leffet du temps de travail (\\(x_1\\)) sur la performance scolaire (Y) nest pas constant partout. En dautres termes, nous supposons que, dans certaines classes, le temps de travail hebdomadaire en dehors de lécole est plus ou moins efficace que dautres classes. Lidée sous-jacente est que nous nobservons pas de différence en termes de moyenne entre deux classes, mais en termes deffet pour notre variable \\(x_1\\). À nouveau, nous pouvons nous contenter dun effet fixe pour intégrer cette idée dans notre modèle. Pour cela, nous avons simplement à ajouter une interaction entre notre variable quantitative temps de travail et notre variable qualitative classe. Nous obtenons le résultat décrit par la figure 9.6. Notez ici que la constante est bien la même pour chaque classe (les lignes sintersectent à 0 sur laxe des x), et que seule la pente change. Figure 9.6: Influence du temps de travail sur la performance scolaire délèves en interraction avec la classe (effet fixe) La formulation de ce modèle à effets fixes seulement est la suivante : \\[\\begin{equation} \\begin{aligned} &amp;Y \\sim Normal(\\mu,\\sigma)\\\\ &amp;g(\\mu) = \\beta_0 + \\beta_1 x_1 + \\sum^k_{j=1}{\\beta_j x_{2j} x_1}\\\\ &amp;g(x) = x \\end{aligned} \\tag{9.4} \\end{equation}\\] Nous constatons donc que nous avons un effet principal \\(\\beta_1\\) décrivant le lien entre le temps de travail et la note obtenue à lexamen pour lensemble des élèves, ainsi quun bonus ou un malus sur cet effet \\(\\beta_j\\) sappliquant en fonction de la classe. Nous pouvons reformuler ce modèle pour inclure cet effet spécifique par classe comme un effet aléatoire : \\[\\begin{equation} \\begin{aligned} &amp;Y \\sim Normal(\\mu,\\sigma_e)\\\\ &amp;g(\\mu) = \\beta_0 + \\beta_1 x_1 + \\upsilon x_1 \\\\ &amp;\\upsilon \\sim Normal(0,\\sigma_{\\upsilon})\\\\ &amp;g(x) = x \\end{aligned} \\tag{9.5} \\end{equation}\\] Nous formulons ici un modèle dans lequel la classe modifie leffet de la variable temps détude sur la variable note à lexamen. Leffet moyen de \\(x_1\\) (propre aux individus) est capté par le coefficient \\(\\beta_1\\), les bonus ou malus ajoutés à cet effet par la classe sont issus dune distribution normale centrée sur 0 avec un écart-type, soit \\(\\sigma_{\\upsilon}\\). À nouveau, lidée est que si nous moyennons leffet de toutes les classes, nous obtenons 0. Aussi, le fait de modéliser cet effet comme un effet aléatoire nous permet de partitionner la variance, de mutualiser linformation entre les classes et de resserrer lestimation des effets des classes. Les résultats pour ce second modèle sont présentés à la figure 9.7, et une comparaison entre les estimations des effets fixes et des effets aléatoires est présentée à la figure 9.8. Nous pouvons ainsi constater à nouveau leffet de resserrement provoqué par leffet aléatoire. Figure 9.7: Influence du temps de travail sur la réussite scolaire délèves en interraction avec la classe (effet aléatoire) Figure 9.8: Influence du temps de travail sur la réussite scolaire délèves en interraction avec la classe (effet aléatoire) Lorsque nous intègrons des pentes aléatoires dans un modèle, nous faisons face au problème suivant : la variance associée aux pentes aléatoires nest pas fixe, mais proportionnelle à la variable X autorisée à varier. Si nous comparons la figure 9.4 (constantes aléatoires) et la figure 9.7 (pentes aléatoires), nous constatons bien que la dispersion des prédictions du modèle (représentées par les lignes) augmente dans le cas de pentes aléatoires et reste identique dans le cas des constantes aléatoires. La conséquence pratique est quil existe un nombre infini de valeurs possibles pour lICC. Dans ce contexte, il est préférable de laisser de côté cet indicateur et de ne reporter que les R2 marginal et conditionnel. Dans notre cas, nous obtenons les valeurs 0,109 et 0,258, ce qui confirme une fois encore que le rôle joué par la classe est loin dêtre négligeable. 9.2.3 GLMM avec constantes et pentes aléatoires Vous laurez certainement deviné en lisant le titre de cette section : il est tout à fait possible de combiner à la fois des constantes et des pentes aléatoires dans un modèle. Cela augmente bien sûr la complexité du modèle et introduit quelques subtilités comme la notion de distribution normale multivariée, mais chaque chose en son temps. Si nous reprenons notre exemple avec nos élèves et nos classes, combiner à la fois des constantes et des pentes aléatoires revient à formuler lhypothèse que chaque classe a un effet sur la moyenne de la performance de ses élèves, mais également un effet sur lefficacité du temps de travail. Il est possible de créer un modèle avec uniquement des effets fixes tenant compte de ces deux aspects en ajoutant dans le modèle la variable multinomiale classe ainsi que son interaction avec la variable temps de travail. La formulation de ce modèle à effets fixes est la suivante : \\[\\begin{equation} \\begin{aligned} &amp;Y \\sim Normal(\\mu,\\sigma)\\\\ &amp;g(\\mu) = \\beta_0 + \\beta_1 x_1 + \\sum^k_{j=1}{\\beta_{2j} x_{2j} + \\beta_{3j} x_{2j} x_1}\\\\ &amp;g(x) = x \\end{aligned} \\tag{9.6} \\end{equation}\\] Nous pouvons représenter les résultats de ce modèle avec la figure 9.9. Figure 9.9: Influence du temps de travail sur la performance scolaire délèves en tenant compte de leffet de leur classe et de leffet de la classe sur lefficacité du temps de travail (effet fixe) Nous reformulons à présent ce modèle pour intégrer leffet moyen de chaque classe (constante) et leffet des classes sur lefficacité du temps de travail (pente) comme deux effets aléatoires : \\[\\begin{equation} \\begin{aligned} &amp;Y \\sim Normal(\\mu,\\sigma)\\\\ &amp;g(\\mu) = \\beta_0 + \\upsilon_1 + (\\beta_1 + \\upsilon_2) x_1\\\\ &amp;\\left(\\begin{array}{l} \\upsilon_{1} \\\\ \\upsilon_{2} \\end{array}\\right) \\sim \\mathcal{N}\\left(\\left(\\begin{array}{l} 0 \\\\ 0 \\end{array}\\right),\\left(\\begin{array}{cc} \\sigma_{\\upsilon_1} &amp; \\sigma_{\\upsilon_1\\upsilon_2} \\\\ \\sigma_{\\upsilon_1\\upsilon_2} &amp; \\sigma_{\\upsilon_1} \\end{array}\\right)\\right) \\\\ &amp;g(x) = x \\end{aligned} \\tag{9.7} \\end{equation}\\] Pas de panique! Cette écriture peut être interprétée de la façon suivante : Le modèle a deux effets aléatoires, lun faisant varier la constante en fonction de la classe (\\(\\upsilon_1\\)) et lautre leffet de la classe sur lefficacité du temps de travail (\\(\\upsilon_2\\)). Ces deux effets sont issus dune distribution normale bivariée (une dimension par effet aléatoire). Cette distribution normale bivariée a donc deux moyennes et ces deux moyennes sont à 0 (les effets sannulent si nous considérons toutes les classes ensemble). Elle dispose également dune variance par effet aléatoire (\\(\\sigma_{\\upsilon_1}\\) et \\(\\sigma_{\\upsilon_2}\\)) et dune covariance entre les deux effets aléatoires (\\(\\sigma_{\\upsilon_1\\upsilon_2}\\)). Cette covariance permet de tenir compte du fait que, potentiellement, les classes avec une constante plus élevée pourraient systématiquement avoir une efficacité du temps de travail plus faible ou plus élevée. Cette formulation implique donc dajuster trois paramètres de variance : \\(\\sigma_{\\upsilon_1}\\), \\(\\sigma_{\\upsilon_2}\\) et \\(\\sigma_{\\upsilon_1\\upsilon_2}\\). Il peut arriver que nous nayons pas assez de données pour estimer ces trois paramètres, ou que nous décidions, pour des raisons théoriques, quaucune corrélation ne soit attendue entre \\(\\sigma_{\\upsilon_1}\\) et \\(\\sigma_{\\upsilon_2}\\). Dans ce cas, il est possible de fixer \\(\\sigma_{\\upsilon_1\\upsilon_2}\\) à 0, ce qui revient à indiquer au modèle que \\(\\upsilon_1\\) et \\(\\upsilon_2\\) proviennent de deux distributions normales distinctes, nous pouvons donc écrire : \\[\\begin{equation} \\begin{aligned} &amp;Y \\sim Normal(\\mu,\\sigma)\\\\ &amp;g(\\mu) = \\beta_0 + \\upsilon_1 + (\\beta_1 + \\upsilon_2) x_1\\\\ &amp;\\left(\\begin{array}{l} \\upsilon_{1} \\\\ \\upsilon_{2} \\end{array}\\right) \\sim \\mathcal{N}\\left(\\left(\\begin{array}{l} 0 \\\\ 0 \\end{array}\\right),\\left(\\begin{array}{cc} \\sigma_{\\upsilon_1} &amp; 0 \\\\ 0 &amp; \\sigma_{\\upsilon_1} \\end{array}\\right)\\right) \\\\ &amp;g(x) = x \\end{aligned} \\tag{9.8} \\end{equation}\\] Ce qui est identique à : \\[\\begin{equation} \\begin{aligned} &amp;Y \\sim Normal(\\mu,\\sigma)\\\\ &amp;g(\\mu) = \\beta_0 + \\upsilon_1 + (\\beta_1 + \\upsilon_2) x_1\\\\ &amp;\\upsilon_{1} \\sim Normal(0,\\sigma_{\\upsilon_1}) \\\\ &amp;\\upsilon_{2} \\sim Normal(0,\\sigma_{\\upsilon_2}) \\\\ &amp;g(x) = x \\end{aligned} \\tag{9.9} \\end{equation}\\] Nous avons déjà abordé la notion de covariance dans la section 4.2. Pour rappel, la covariance dépend de lunité de base des deux variables sur laquelle elle est calculée. Ici, il sagit dun coefficient et dune constante. Il est donc préférable de la standardiser pour obtenir la corrélation entre les deux effets : \\[\\begin{equation} corr(\\upsilon_1;\\upsilon_2) = \\frac{\\sigma_{\\upsilon_1\\upsilon_2}}{\\sqrt{\\sigma_{\\upsilon_1}}\\sqrt{\\sigma_{\\upsilon_2}}} \\tag{9.10} \\end{equation}\\] Si cette corrélation est positive, cela signifie que les classes ayant tendance à avoir un effet positif sur la performance scolaire ont également tendance à influencer positivement lefficacité du temps de travail. À linverse, une corrélation négative signifie que lefficacité du temps de travail a tendance à être plus faible dans les classes où la performance scolaire moyenne est élevée. Si la corrélation nest pas significative, cest que les deux effets sont indépendants lun de lautre. Pour cet exemple, nous conservons la première formulation afin de montrer comment interpréter \\(\\sigma_{\\upsilon_1\\upsilon_2}\\), mais nous ne disposons probablement pas de suffisamment de classes différentes pour estimer correctement ces trois paramètres. Les résultats de ce modèle sont représentés à la figure 9.10. Figure 9.10: Influence du temps de travail sur la performance scolaire délèves en tenant compte de leffet de leur classe et de leffet de la classe sur lefficacité du temps de travail (effet aléatoire) Nous pouvons ainsi constater que pour ce troisième modèle, leffet de resserrement est bien plus prononcé que pour les modèles précédents (figure 9.11). Si nous nous fions au modèle à effets fixes (figure 9.9), alors leffet de lécole sur lefficacité du temps de travail est très important. En revanche, le modèle à effet aléatoire identifie que la différence de moyenne entre les écoles est importante, mais la différence en termes defficacité du temps de travail est beaucoup plus anecdotique. Figure 9.11: Comparaison des effets fixes et aléatoires pour le modèle intégrant leffet des classes et linteraction entre les classes et le temps de travail Notre modèle estime les valeurs de \\(\\sigma_{\\upsilon_1}\\) à 8,563, de \\(\\sigma_{\\upsilon_2}\\) à 0,042 et de \\(\\sigma_{\\upsilon_1\\upsilon_2}\\) à 0,073. La corrélation entre les deux effets est donc de 0,122, ce qui est relativement faible (pour lanecdote, notez que la valeur originale de corrélation entre ces deux effets était de 0,1 lorsque nous avons simulé ces données, notre modèle a donc bien été capable de retrouver le paramètre original). À nouveau, puisque nous avons des pentes aléatoires dans ce modèle, nous ne pouvons pas calculer lICC; nous pouvons cependant rapporter les R2 marginal et conditionnel. Leurs valeurs respectives sont 0,115 et 0,269, ce qui nous confirme une nouvelle fois que lajout deffets aléatoires contribue à expliquer une partie importante de la variance de la performance scolaire. Pour terminer cette section, comparons brièvement les trois modèles (constantes aléatoires, pentes aléatoires, constantes et pentes aléatoires) pour déterminer lequel est le mieux ajusté à nos données. Nous ajoutons également un quatrième modèle dans lequel les deux effets aléatoires sont présents, mais non corrélés (\\(\\sigma_{\\upsilon_1\\upsilon_2}=0\\)). Le tableau 9.1 nous permet de constater que lajout des constantes aléatoires joue un rôle essentiel dans le premier modèle : le R2 conditionnel est plus que deux fois supérieur au R2 marginal. Cependant, lajout des pentes aléatoires dans les trois autres modèles apporte finalement très peu dinformation, nous laissant penser que leffet de la classe sur le temps de travail est faible, voire inexistant. Tableau 9.1: Comparaison des trois modèles à effets aléatoires modèle AIC R2 marginal R2 conditionnel Constantes aléatoires 2 100,9 0,12 0,27 Pentes aléatoires 2 101,6 0,11 0,26 Pentes et constantes aléatoires corrélées 2 104,7 0,11 0,27 Pentes et constantes aléatoires non-corrélées 2 102,7 0,11 0,27 Modèles à effets mixtes avec des structures croisées Jusquà présent, nous avons abordé des modèles GLMM comprenant des structures imbriquées (nested en anglais), cest-à-dire quune observation dun niveau 1 est incluse dans un et un seul groupe du niveau 2. Comme structure imbriquée à trois niveaux, nous avons vu comme exemple des élèves intégrés dans des classes elles-mêmes intégrées dans des écoles (figure 9.1) : un ou une élève appartient à une et une seule classe qui est elle-même localisée dans une et une seule école (élève / classe / école). Notez quil est aussi possible davoir des structures des données croisées (crossed). Admettons à présent que nous ne nous intéressons pas à la classe dans laquelle se situe lélève, mais plutôt à la personne qui enseigne. Admettons également que ces personnes peuvent donner des cours dans plusieurs écoles. Nous nous retrouvons dans un cas de figure où une personne qui enseigne peut se situer dans plusieurs écoles, ce qui diffère du cas précédent où chaque classe appartient à une seule école. Dans ce second cas, on parle dune structure croisée plutôt quimbriquée. Si les personnes enseignent dans toutes les écoles, il est possible de dire que le design détude est croisé complet ou croisé partiel si elles nenseignent que dans certaines écoles. La figure 9.12 résume ces trois situations. Figure 9.12: Différentes structures de données hiérarchiques (imbriquée versus croisée) Il est important de bien saisir la structure de son jeu de données, car lestimation dun modèle avec effets imbriqués ou croisés peut donner des résultats parfois significativement différents. De plus, un modèle imbriqué est généralement moins difficile à ajuster quun modèle croisé. En effet, dans un modèle imbriqué, deux personnes étudiant dans deux écoles différentes sont jugées indépendantes. Dans un modèle croisé, deux élèves provenant de deux écoles différentes peuvent tout de même partager une dépendance du fait quils ou elles ont pu avoir le même professeur ou la même professeure. La structure de dépendance (et donc de la matrice de covariance des effets aléatoires) est ainsi plus complexe pour un modèle croisé. References "],["sect093.html", "9.3 Conditions dapplication des GLMM", " 9.3 Conditions dapplication des GLMM Puisque les GLMM sont une extension des GLM, ils partagent lessentiel des conditions dapplication de ces derniers. Pour simplifier, si vous ajustez un modèle GLMM avec une distribution Gamma, vous devez réaliser les mêmes tests que ceux pour un simple GLM avec une distribution Gamma. Une question importante se pose souvent lorsque nous ajustons des modèles GLMM : combien de groupes faut-il au minimum aux différents niveaux? En effet, pour estimer les différentes variances, nous devons disposer de suffisamment de groupes différents. Dans le cas dun modèle avec uniquement une constante aléatoire, il est fréquent de lire que nous devons disposer au minimum de cinq groupes différents (Gelman et Hill 2006), en dessous de ce minimum, traiter leffet comme aléatoire plutôt que fixe apporte très peu dinformation. De plus, lestimation des variances pour chaque niveau est très imprécise, donnant potentiellement des valeurs inexactes pour lICC et polluant linterprétation. Avec cinq groupes ou moins, il est certainement plus judicieux dajuster seulement un effet fixe. Dans un modèle avec plusieurs effets aléatoires et plusieurs variances / covariances à estimer, ce nombre doit être augmenté proportionnellement, à moins que les effets aléatoires ne soient estimés indépendamment les uns des autres. Notez ici que, si lenjeu du modèle était destimer avec une grande précision les paramètres de variances, il faudrait compter au minimum une centaine de groupes. Il nest pas nécessaire davoir le même nombre dobservations par groupe, car les modèles GLMM partagent linformation entre les groupes. Cependant, dans les groupes avec peu dobservations (inférieur à 15), lestimation de leur effet propre (BLUP) est très incertaine. Puisque les GLMM font intervenir la distribution normale aux niveaux supérieurs du modèle, il est nécessaire de vérifier si les hypothèses quelle implique sont respectées. Il sagit essentiellement de deux hypothèses : les effets aléatoires suivent bien une distribution normale (univariée ou multivariée), et la variance au sein des groupes est bien homogène. 9.3.1 Vérification de la distribution des effets aléatoires Reprenons la formulation dun modèle simple avec seulement deux niveaux et seulement une constante aléatoire: \\[\\begin{equation} \\begin{aligned} &amp;Y \\sim Normal(\\mu,\\sigma_e)\\\\ &amp;g(\\mu) = \\beta_0 + \\beta_1 x_1 + \\upsilon \\\\ &amp;\\upsilon \\sim Normal(0, \\sigma_{\\upsilon}) \\\\ &amp;g(x) = x \\end{aligned} \\end{equation}\\] Ce modèle formule lhypothèse que les constantes aléatoires \\(\\upsilon\\) proviennent dune distribution normale avec une moyenne de 0 et un écart-type \\(\\sigma_{\\upsilon}\\). La première étape du diagnostic est donc de vérifier si les constantes aléatoires suivent bien une distribution normale, ce que nous pouvons faire habituellement avec un diagramme quantile-quantile. Si nous reprenons notre exemple avec nos données de performance scolaire des sections précédentes, nous obtenons la figure 9.13. Puisque les points tombent bien approximativement sur la ligne rouge, nous pouvons conclure que cette condition dapplication est bien respectée. Notez quil est également possible dutiliser ici un des tests vus dans le chapitre 2 pour tester formellement la distribution des constantes aléatoires, mais nous disposons rarement de suffisamment de valeurs différentes pour quun tel test soit pertinent. Figure 9.13: Distribution normale univariée des constantes aléatoires Cette vérification est bien sûr à appliquer à chacun des niveaux (en dehors du niveau de base) du modèle étudié. Si nous nous intéressons maintenant au modèle avec constantes et pentes aléatoires, nous avons deux cas de figure: notre modèle inclut une covariance entre les constantes et les pentes; elles proviennent donc dune distribution normale bivariée. notre modèle considère les pentes et les constantes comme indépendantes; elles proviennent donc de deux distributions normales distinctes. Le second cas est de loin le plus simple puisquil nous suffit de réaliser un graphique de type quantile-quantile pour les deux effets aléatoires séparément. Dans le premier cas, il nous faut adapter notre stratégie pour vérifier si les deux effets aléatoires suivent conjointement une distribution normale multivariée. Pour cela, nous devons, dans un premier temps, observer séparément la distribution des pentes et des constantes, puisque chaque variable provenant dune distribution normale multivariée suit elle-même une distribution normale univariée (Burdenski 2000). Nous pouvons, dans un second temps, construire un graphique nous permettant de juger si nos pentes et nos constantes suivent bien la distribution normale bivariée attendue par le modèle. Pour lillustrer, nous reprenons le modèle sur la performance scolaire intégrant des pentes et des constantes aléatoires avec une covariance estimée entre les deux. La figure 9.14 représente donc les deux graphiques quantile-quantile univariés. Les deux semblent indiquer que nos effets aléatoires suivent bien chacun une distribution normale. La figure 9.15 montre la distribution normale bivariée attendue par le modèle avec des ellipses représentant différents pourcentiles de cette distribution. Les valeurs des effets aléatoires sont représentées par des points noirs. Seulement 5 % des points noirs devraient se trouver dans la première ellipse et 95 % des points devraient se trouver dans la quatrième ellipse. En revanche, seulement 20 % des points devraient se trouver dans le dernier anneau et seulement 5 % des points en dehors de cet anneau. Il faut donc évaluer si les points sont plus ou moins centrés que ce que nous attendons. Pour simplifier la lecture, il est possible de rajouter des points grisés en arrière-plan représentant des réalisations possibles de cette distribution normale bivariée. Les vrais points noirs devraient avoir une dispersion similaire à celle des points grisés. Dans notre cas, ils semblent suivre un patron cohérent avec notre distribution normale bivariée. Dans le cas contraire, cela signifierait que le modèle doit être révisé. Figure 9.14: Multiples distributions normales univariées des constantes et pentes aléatoires Figure 9.15: Distribution normale bivariée des constantes et des pentes aléatoires 9.3.2 Homogénéité des variances au sein des groupes Dans le chapitre 8 sur les GLM, nous avons vu que chaque distribution a sa propre définition de la variance. Pour rappel, un modèle gaussien assume une variance constante, un modèle de Poisson assume une variance égale à son espérance, alors quun modèle Gamma assume une variance proportionnelle au carré de son espérance divisée par un paramètre de forme, etc. Nous devions donc, pour chaque GLM, vérifier graphiquement si la variance présente dans les données originales était proche de la variance attendue par le modèle. Dans un modèle GLMM, le même exercice doit être fait pour chaque groupe aux différents niveaux du modèle. Dans notre exemple sur la performance scolaire, notre variable Y a été modélisée avec une distribution normale. Le modèle assume donc une uniformité de sa variance (homoscédasticité). La figure 9.16 nous montre ainsi que, quelle que soit la classe, la dispersion des points (notes des élèves) semble bien respecter la variance attendue par le modèle (représentée par les lignes noires). Figure 9.16: Homogénéité de la variance pour les différents groupes dun modèle GLMM gaussien References "],["sect094.html", "9.4 Inférence dans les modèles GLMM", " 9.4 Inférence dans les modèles GLMM Une des questions importantes à se poser lorsque nous construisons un modèle est toujours : est-ce que les différents effets présents dans le modèle ont un effet significativement différent de zéro sur la variable dépendante? Cette étape dinférence est plus compliquée pour les modèles GLMM que dans les modèles GLM à cause de la présence deffets aléatoires. Ces derniers brouillent le comptage du nombre de paramètres et, par extension, du nombre de degrés de liberté des modèles. Pour un effet aléatoire, il est possible de déterminer que le nombre de degrés de liberté est de 1 puisque nous ajustons un seul paramètre supplémentaire (la variance de cet effet aléatoire). Selon un autre point de vue, il serait possible daffirmer que le nombre de degrés de liberté est de \\(k - 1\\) (avec k le nombre de groupes dans cet effet aléatoire), ce que nous utilisons habituellement pour un effet fixe. La vraie valeur du nombre de degrés de liberté se situe quelque part entre ces deux extrêmes. Lenjeu du nombre de degrés de liberté est crucial, car il influence directement lestimation des valeurs de p pour lensemble des coefficients du modèle. Avec un nombre de degrés de liberté plus petit, les valeurs de p sont plus faibles et les effets plus significatifs. Le sujet est dailleurs lobjet dune telle controverse que les auteurs de certains packages comme lme4 (un des packages les plus utilisés pour ajuster des GLMM) ont fait le choix de ne renvoyer aucune valeur de p dans les résultats des modèles. Larticle de Bolker et al. (2009) propose une explication détaillée et relativement accessible du problème (en plus dune excellente introduction aux GLMM) : en se basant sur leurs recommandations, il est possible de séparer le problème de linférence dans les GLMM en trois sous problèmes : Quel est le degré de significativité des effets fixes? Quel est le degré de significativité de leffet aléatoire dans le modèle? Quels sont les degrés de significativité de chaque constante / pente aléatoire? 9.4.1 Inférence pour les effets fixes Trois approches peuvent être envisagées pour déterminer si un effet fixe est significatif ou non. Elles font appel à trois approches théoriques différentes (test classique, comparaison de modèles et bootstrapping) et peuvent donc donner des résultats différents. À titre exploratoire, il peut être intéressant de toutes les tester, mais certaines peuvent être préférées en fonction de votre champ de recherche. 9.4.1.1 Test classique Nous avons vu, pour les modèles LM et GLM, que les valeurs de p sont calculées à partir de scores obtenus en divisant les coefficients par leurs erreurs standards. Une approche similaire peut être utilisée pour les modèles GLMM. Cependant, la question du nombre de degrés de liberté à utiliser reste un problème. Lapproche la plus flexible est certainement lapproximation par la méthode Satterthwaite proposant une estimation de ce nombre de degrés de liberté et, par extension, des valeurs de p. 9.4.1.2 Rapports de vraisemblance Si le modèle comprend suffisamment dobservations (par suffisamment, comprenez au moins une centaine dobservations par paramètre), il est également possible dutiliser une série de tests de rapports de vraisemblance pour vérifier si lapport de chaque variable indépendante contribue à améliorer significativement le modèle. Cette approche correspond à une analyse de type 3, comme nous lavons mentionné dans la section 8.2.4 pour le modèle logistique multinomial. 9.4.1.3 Bootstrapping Lapproche par bootstrapping (parametric-bootstrap ou semi-parametric-bootstrap) permet de calculer, pour les différents paramètres dun modèle, un intervalle de confiance. Lidée étant de réajuster un grand nombre de fois le modèle sur des sous-échantillons de données pour saisir la variabilité des différents paramètres du modèle. Si les intervalles de confiance ainsi construits ne comprennent pas de zéro, il est possible de dire que cet effet est significatif. À nouveau, cette méthode nest valide que si le jeu de données comporte suffisamment dobservations. Lintérêt de cette approche est quelle ne postule pas dhypothèse sur la distribution des paramètres qui ont la fâcheuse tendance à ne pas suivre une distribution normale dans le cas des GLMM. Elle est dailleurs considérée comme la plus robuste bien que coûteuse en termes de temps de calcul. 9.4.2 Inférence pour les effets aléatoires, effet global Pour déterminer si un effet aléatoire est significatif dans un modèle, il est recommandé dutiliser un test de rapport de vraisemblance entre un modèle sans leffet aléatoire et un modèle avec leffet aléatoire. Lanalyse des différences entre les valeurs de déviance, lAIC et le BIC peut également aider à déterminer si lajout de leffet aléatoire est justifié. Il est également possible de considérer les valeurs de lICC et du R2 conditionnel. Notez ici que si vous avez une très bonne raison théorique dajouter leffet aléatoire dans votre modèle et suffisamment dobservations / groupes pour lajuster, il peut être pertinent de laisser leffet aléatoire dans le modèle même si tous les indicateurs mentionnés précédemment indiquent quil contribue faiblement au modèle. Le retirer risquerait en effet de donner limpression que les autres paramètres du modèle sont plus significatifs quils ne le sont en réalité. Notez que lapproche par bootstrapping décrite pour les effets fixes peut aussi être utilisée ici pour obtenir un intervalle de confiance pour lICC, le R2 conditionnel et les différents paramètres de variance et covariance. 9.4.3 Inférence pour les effets aléatoires, des constantes et des pentes Pour rappel, dans lapproche fréquentiste présentée ici, les valeurs des constantes et des pentes aléatoires ne sont pas à proprement parler des paramètres du modèle : elles sont estimées à posteriori (BLUP). Pour déterminer si ces constantes et des pentes sont significativement différentes de zéro et significativement différentes les unes des autres, il est possible de calculer les intervalles de confiance de chacune dentre elles par bootstrap, par profilage ou par simulation à partir du modèle. Si la constante du groupe j a zéro dans son intervalle de confiance, nous pouvons alors déclarer que le groupe j en question ne semble pas varier du reste de la population en termes de moyenne. Si la pente l du groupe j a zéro dans son intervalle de confiance, nous pouvons alors déclarer que le groupe j en question ne semble pas varier du reste de la population pour leffet l. Notez que la méthode par simulation est bien plus rapide que les deux autres, mais que lapproche par bootstrapping reste la plus fiable. References "],["sect095.html", "9.5 Conclusion sur les GLMM", " 9.5 Conclusion sur les GLMM Les GLMM sont donc une extension des GLM offrant une grande flexibilité de modélisation (variabilité des pentes et des constantes en fonction de groupes) et nous permettant danalyser la partition de la variance entre plusieurs niveaux de nos données. Cependant, cette flexibilité implique des modèles plus complexes avec un travail de diagnostic et dinterprétation plus long et potentiellement plus ardu. "],["sect096.html", "9.6 Mise en uvre des GLMM dans R", " 9.6 Mise en uvre des GLMM dans R Pour cet exemple de GLMM, nous proposons danalyser à nouveau les données présentées dans la section 6.2.1.1 sur le modèle logistique binomial. Pour rappel, nous modélisions la probabilité quun individu utilise le vélo comme mode de transport pour son trajet le plus fréquent en utilisant une enquête réalisée auprès denviron 26 000 Européens. Initialement, nous avons intégré les pays comme un effet fixe. Or, nous savons à présent quil serait plus judicieux de les traiter comme un effet aléatoire. Nous comparons deux modèles, un pour lequel seulement la constante varie par pays et un second dans lequel la pente pour lâge varie également par pays. Lhypothèse étant que leffet de lâge sur lutilisation du vélo pourrait être réduit dans certains pays où la culture du vélo est plus présente. Cette hypothèse implique également la présence potentielle dune corrélation inverse entre la constante et la pente de chaque pays : dans un pays où la probabilité de base dutiliser le vélo est plus élevée, leffet de leffet de lâge est probablement réduit. Pour ajuster ces modèles, nous utilisons le package lme4, permettant dajuster des modèles GLMM avec des distributions gaussienne, Gamma, de Poisson et binomial. Lorsque dautres distributions sont nécessaires, il est possible de se tourner vers le package gamlss. Notez cependant que les effets aléatoires de gamlss sont estimés avec une méthode appelée PQL très flexible, mais qui peut produire des résultats erronés dans certains cas (Bolker et al. 2009). Afin de limiter les répétitions, nous ne recalculons pas ici le VIF et nous excluons demblée les observations aberrantes (provenant de Malte ou de Chypre ou avec des temps de trajets supérieurs à 400 minutes). 9.6.1 Ajustement du modèle avec uniquement une constante aléatoire Nous commençons donc par ajuster un premier modèle avec une constante aléatoire en fonction du pays. Dans la plupart des packages intégrant des effets aléatoires, la syntaxe suivante est utilisée pour stipuler une constante aléatoire : + (1|Pays). Concrètement, nous tentons dajuster le modèle décrit par léquation (9.11). \\[\\begin{equation} \\begin{aligned} &amp;Y \\sim Binomial(p)\\\\ &amp;g(p) = \\beta_0 + \\beta_1 x_1 + \\upsilon \\\\ &amp;\\upsilon \\sim Normal(0, \\sigma_{\\upsilon}) \\\\ &amp;g(x) = log(\\frac{x}{1-x}) \\end{aligned} \\tag{9.11} \\end{equation}\\] Il sagit simplement dun modèle logistique binomial dans lequel nous avons ajouté une constante aléatoire : \\(\\upsilon\\). Dans notre cas, elle varie avec la variable Pays. La syntaxe dans R pour produire ce modèle est la suivante. # Chargement des données dfenquete &lt;- read.csv(&quot;data/glm/enquete_transport_UE.csv&quot;, encoding = &quot;UTF-8&quot;) dfenquete$Pays &lt;- relevel(as.factor(dfenquete$Pays), ref = &quot;Allemagne&quot;) # Retirer les observations aberrantes dfenquete2 &lt;- subset(dfenquete, (dfenquete$Pays %in% c(&quot;Malte&quot;, &quot;Chypre&quot;)) == F &amp; dfenquete$Duree &lt; 400) # Ajustement du modèle library(lme4) # Nécessité ici de centrer et réduire ces variables pour permettre au modèle de converger dfenquete2$Age2 &lt;- scale(dfenquete2$Age,center = T, scale = T) dfenquete2$Duree2 &lt;- scale(dfenquete2$Duree,center = T, scale = T) modele1 &lt;- glmer(y ~Sexe + Age2 + Education + StatutEmploi + Revenu + Residence + Duree2 + ConsEnv + (1|Pays), family = binomial(link=&quot;logit&quot;), control = glmerControl(optimizer = &quot;bobyqa&quot;), data = dfenquete2) Nous nous concentrons ici sur linterprétation des résultats du modèle et nous réalisons lensemble des diagnostics dans une section dédiée en fin de chapitre. Notez cependant que le diagnostic devrait précéder linterprétation comme nous lavons vu dans le chapitre sur les modèles GLM. Vous constaterez que nous avons centré-réduit les variables Age et Duree. Il est souvent nécessaire de réaliser cette étape en amont pour sassurer que le modèle converge sans trop de difficulté. Dans notre cas, si ces deux variables sont laissées dans leur échelle dorigine, la fonction glmer ne parvient pas à ajuster le modèle. Notez que cette transformation nous permet dobtenir les coefficients standardisés, sexprimant alors en écarts-types. La fonction summary nous donne accès à un premier ensemble dinformations. summary(modele1) ## Generalized linear mixed model fit by maximum likelihood (Laplace ## Approximation) [glmerMod] ## Family: binomial ( logit ) ## Formula: y ~ Sexe + Age2 + Education + StatutEmploi + Revenu + Residence + ## Duree2 + ConsEnv + (1 | Pays) ## Data: dfenquete2 ## Control: glmerControl(optimizer = &quot;bobyqa&quot;) ## ## AIC BIC logLik deviance df.resid ## 19176.1 19322.8 -9570.1 19140.1 25529 ## ## Scaled residuals: ## Min 1Q Median 3Q Max ## -1.1989 -0.4418 -0.3212 -0.2134 7.2461 ## ## Random effects: ## Groups Name Variance Std.Dev. ## Pays (Intercept) 0.5949 0.7713 ## Number of obs: 25547, groups: Pays, 26 ## ## Fixed effects: ## Estimate Std. Error z value Pr(&gt;|z|) ## (Intercept) -3.368942 0.212577 -15.848 &lt; 2e-16 *** ## Sexehomme 0.370864 0.037921 9.780 &lt; 2e-16 *** ## Age2 -0.102388 0.018777 -5.453 4.95e-08 *** ## Educationsecondaire 0.188096 0.103204 1.823 0.06837 . ## Educationsecondaire inferieur 0.297591 0.111352 2.673 0.00753 ** ## Educationuniversite 0.138670 0.106518 1.302 0.19297 ## StatutEmploisans emploi 0.256476 0.042284 6.066 1.31e-09 *** ## Revenufaible 0.073836 0.071653 1.030 0.30279 ## Revenumoyen 0.039404 0.065243 0.604 0.54587 ## Revenusans reponse 0.215706 0.102308 2.108 0.03500 * ## Revenutres eleve -0.121285 0.185352 -0.654 0.51288 ## Revenutres faible 0.237388 0.085712 2.770 0.00561 ** ## Residencegrande ville 0.272277 0.069280 3.930 8.49e-05 *** ## Residencepetite-moyenne ville 0.276282 0.061496 4.493 7.03e-06 *** ## Residencezone rurale -0.118967 0.069096 -1.722 0.08511 . ## Duree2 -0.018718 0.019241 -0.973 0.33065 ## ConsEnv 0.101757 0.009277 10.969 &lt; 2e-16 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 La première partie de ce résumé nous rappelle la formule utilisée pour le modèle et nous indique différents indicateurs de qualité dajustement comme lAIC, le BIC et la déviance. Nous avons ensuite une partie dédiée aux effets aléatoires (Random Effects) et une partie dédiée aux effets fixes (Fixed effects). Cette dernière sinterprète de la même manière que pour un modèle à effets fixes, noubliez cependant pas dutiliser la fonction exponentielle pour obtenir les rapports de cotes (fonction de lien logistique). 9.6.1.1 Rôle joué par leffet aléatoire Comme vous pouvez le constater, la section Random Effects ne comprend quun seul paramètre : la variance de leffet pays. Nous pouvons ainsi écrire que leffet du pays suit une distribution normale avec une moyenne de 0 et une variance \\(\\sigma^2\\) de 0,595. Pour aller plus loin dans cette analyse, nous pouvons calculer le coefficient de corrélation intraclasse (ICC). Cependant, puisque notre modèle est binomial et non gaussien, nous ne disposons pas dun paramètre de variance au niveau des individus, il est donc possible, à la place, dutiliser la variance théorique du modèle : \\(\\frac{\\pi^2}{3}\\). Nous calculons ainsi notre ICC : # Extraction de la variance des Pays var_pays &lt;- VarCorr(modele1)[[1]][[1]] # Calcul de l&#39;ICC var_pays / (((pi**2)/3) + var_pays) ## [1] 0.153141 Nous pouvons parvenir au même résultat en utilisant la fonction icc du package performance. library(performance) # Calcul de l&#39;ICC icc(modele1) ## # Intraclass Correlation Coefficient ## ## Adjusted ICC: 0.153 ## Conditional ICC: 0.148 Notez que cette fonction distingue un ICC ajusté et un ICC conditionnel. Le premier correspond à lICC que nous avons présenté jusquici et que nous avons calculé à la main. LICC conditionnel inclut dans son estimation la variance présente dans les effets fixes. Un fort écart entre ces deux ICC indique que les effets fixes sont capables de capturer une très forte variance dans les données, ce qui pourrait remettre en cause la pertinence de leffet aléatoire. Dans notre cas, la différence entre les deux est très faible. En plus du ICC, nous pouvons calculer les R2 marginal et conditionnel. Pour cela, nous utilisons la fonction r.squaredGLMM du package MuMIn. library(MuMIn) r.squaredGLMM(modele1) ## R2m R2c ## theoretical 0.03492136 0.18271447 ## delta 0.01554518 0.08133502 Cette fonction nous renvoie à la fois les R2 obtenus en utilisant la variance théorique du modèle (\\(\\frac{\\pi^2}{3}\\) dans notre cas) et la variance estimée par la méthode delta. La seconde est plus conservative, mais les deux résultats indiquent que les effets aléatoires expliquent une part importante de la variance comparativement aux effets fixes. Notez également que la fonction r2 du package performance peut calculer ces deux R2, mais seulement en utilisant la variance théorique. 9.6.1.2 Significativité de leffet aléatoire Nous souhaitons déterminer ici si notre effet aléatoire contribue à significativement améliorer le modèle. Pour cela, nous effectuons un test de rapport de vraisemblance entre le modèle sans leffet aléatoire (un simple GLM ici) et le modèle complet. Nous utilisons pour cela la fonction anova : # Ajustement d&#39;un modèle sans l&#39;effet aléatoire model_simple &lt;- glm(y ~Sexe + Age2 + Education + StatutEmploi + Revenu + Residence + Duree2 + ConsEnv, family = binomial(link=&quot;logit&quot;), data = dfenquete2) # Comparaison des deux modèles anova(modele1,model_simple) ## Data: dfenquete2 ## Models: ## model_simple: y ~ Sexe + Age2 + Education + StatutEmploi + Revenu + Residence + ## model_simple: Duree2 + ConsEnv ## modele1: y ~ Sexe + Age2 + Education + StatutEmploi + Revenu + Residence + ## modele1: Duree2 + ConsEnv + (1 | Pays) ## npar AIC BIC logLik deviance Chisq Df Pr(&gt;Chisq) ## model_simple 17 20521 20660 -10243.6 20487 ## modele1 18 19176 19323 -9570.1 19140 1347 1 &lt; 2.2e-16 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 Le test indique clairement que le modèle complet est mieux ajusté : les valeurs de lAIC, du BIC et de la déviance sont toutes grandement réduites et le test est largement significatif. Pour aller plus loin, nous pouvons utiliser une approche par bootstrap pour calculer un intervalle de confiance pour la variance de leffet aléatoire, lICC et le R2 conditionnel. Nous utilisons pour cela la fonction bootMer. Si vous essayez de lancer cette syntaxe, vous constaterez quelle prend énormément de temps, ce qui sexplique par le grand nombre de fois où le modèle doit être réajusté. Nous vous recommandons donc de bien enregistrer vos résultats après lexécution de la fonction avec la fonction save. Notez que pour réduire significativement le temps de calcul, il est possible dutiliser simultanément plusieurs curs de votre processeur, ce que nous faisons ici avec le package snow. # Définition d&#39;une fonction pour extraire les valeurs qui nous intéressent extractor &lt;- function(mod){ vari &lt;- VarCorr(mod)[[1]][[1]] ICC &lt;- vari / (vari + (pi**2/3)) r2cond &lt;- performance::r2(mod)[[1]] return(c(&quot;vari&quot;=vari,&quot;icc&quot;=ICC,&quot;r2cond&quot;=r2cond)) } # Préparation d&#39;un environnement multitraitement pour accélérer le calcul library(snow) # Préparation de huit coeurs (attention si votre machine en a moins!) cl &lt;- makeCluster(8) clusterEvalQ(cl,library(&quot;lme4&quot;)) valeurs &lt;- bootMer(modele1,FUN = extractor,nsim = 1000, use.u = F, type=&quot;parametric&quot;, ncpus = 8, parallel=&quot;snow&quot;, cl = cl) # Sauvegarde des résultats save(valeurs,file = &#39;data/glmm/boot_binom.rda&#39;) Nous pouvons à présent analyser lincertitude de ces différents paramètres. Pour cela, nous devons commencer par observer graphiquement leurs distributions obtenues par bootstrap avec la figure 9.17. # Chargement de nos valeurs préalablement enregistrées load(&#39;data/glmm/boot_binom.rda&#39;) # Construction de trois graphiques de distribution df &lt;- data.frame(valeurs$t) names(df) &lt;- c(&quot;variance&quot;,&quot;icc&quot;,&quot;R2cond&quot;) breaks1 &lt;- as.vector(quantile(df$variance, probs = c(0.001,0.15,0.5,0.85, 0.999))) labs1 &lt;- round(breaks1,2) p1 &lt;- ggplot(df) + geom_histogram(aes(x = variance), bins = 50, fill = &quot;#e63946&quot;, color = &quot;black&quot;)+ geom_vline(xintercept = median(df$variance), color = &quot;black&quot;, linetype=&quot;dashed&quot;, size = 1)+ scale_x_continuous(breaks = breaks1, labels = labs1)+ theme(axis.ticks.y = element_blank(), axis.text.y = element_blank(), axis.title.y = element_blank()) breaks2 &lt;- as.vector(quantile(df$icc, probs = c(0.001,0.15,0.5,0.85, 0.999))) labs2 &lt;- round(breaks2,2) p2 &lt;- ggplot(df) + geom_histogram(aes(x = icc), bins = 50, fill = &quot;#a8dadc&quot;, color = &quot;black&quot;)+ geom_vline(xintercept = median(df$icc), color = &quot;black&quot;, linetype=&quot;dashed&quot;, size = 1)+ scale_x_continuous(breaks = breaks2, labels = labs2)+ theme(axis.ticks.y = element_blank(), axis.text.y = element_blank(), axis.title.y = element_blank()) breaks3 &lt;- as.vector(quantile(df$R2cond, probs = c(0.001,0.15,0.5,0.85, 0.999))) labs3 &lt;- round(breaks3,3) p3 &lt;- ggplot(df) + geom_histogram(aes(x = R2cond), bins = 50, fill = &quot;#1d3557&quot;, color = &quot;black&quot;)+ geom_vline(xintercept = median(df$R2cond), color = &quot;black&quot;, linetype=&quot;dashed&quot;, size = 1)+ scale_x_continuous(breaks = breaks3, labels = labs3)+ theme(axis.ticks.y = element_blank(), axis.text.y = element_blank(), axis.title.y = element_blank()) ggarrange(p1,p2,p3, nrow = 2, ncol = 2) Figure 9.17: Distributions obtenues par bootstrap de la variance de leffet aléatoire, de lICC et du R carré conditionnel Les trois distributions sont toutes suffisamment éloignées de zéro pour que nous puissions en conclure que ces différentes valeurs sont toutes différentes de zéro. Notez également que les distributions sont relativement symétriques, indiquant que nous disposons de probablement suffisamment dinformation dans nos données pour inclure notre effet aléatoire. Des distributions fortement asymétriques indiqueraient, au contraire, une forte difficulté du modèle à estimer le paramètre de variance à partir des données. Dans un article, il nest pas nécessaire de reporter ces graphiques, mais plus simplement les intervalles de confiance à 95 % et les médianes. # Intervalle de confiance pour la variance quantile(df$variance,probs = c(0.0275,0.5,0.975)) ## 2.75% 50% 97.5% ## 0.3059400 0.5578986 0.9200472 # Intervalle de confiance pour l&#39;ICC quantile(df$icc,probs = c(0.0275,0.5,0.975)) ## 2.75% 50% 97.5% ## 0.0850824 0.1449928 0.2185428 # Intervalle de confiance pour le R2 conditionnel quantile(df$R2cond,probs = c(0.0275,0.5,0.975)) ## 2.75% 50% 97.5% ## 0.1208577 0.1772778 0.2462622 9.6.1.3 Significativité des différentes constantes Puisque nous avons conclu que leffet aléatoire contribue significativement au modèle, nous pouvons à présent vérifier si les constantes ajustées pour chaque pays varient significativement les unes des autres. Pour rappel, les pentes et les constantes aléatoires ne sont pas directement estimées par le modèle, mais à posteriori. Il en résulte quil ny a pas de moyen direct de mesurer lincertitude de ces paramètres, et donc de construire des intervalles de confiance. Une première option pour contourner ce problème est deffectuer des simulations à partir de la distribution postérieure du modèle. Notez que cette approche sinspire largement de lapproche statistique bayésienne. Nous utilisons ici le package merTools pour effectuer 1000 simulations et obtenir une erreur standard pour chaque constante aléatoire de chaque pays. # Simulations et extraction des effets aléatoires library(merTools) simsRE &lt;- REsim(modele1,n.sims = 1000, oddsRatio = F) # Calcul des intervalles de confiance simsRE$lower &lt;- simsRE$mean - 1.96 * simsRE$sd simsRE$upper &lt;- simsRE$mean + 1.96 * simsRE$sd # Variable binaire pour la significativité simsRE$sign &lt;- case_when( simsRE$lower&lt;0 &amp; simsRE$upper&lt;0 ~ &quot;inf&quot;, simsRE$lower&gt;0 &amp; simsRE$upper&gt;0 ~ &quot;sup&quot;, TRUE ~ &quot;not&quot; ) # Représentation des intervalles de confiance ggplot(simsRE) + geom_errorbarh(aes(xmin = lower, xmax = upper, y = reorder(groupID,mean)), size = 0.5, height = 0.5) + geom_point(aes(x = mean, y = reorder(groupID,mean), color = sign)) + scale_color_manual(values = c(&quot;inf&quot; = &quot;#0077b6&quot;, &quot;sup&quot; = &quot;#e63946&quot;, &quot;not&quot;=&quot;#000000&quot;), labels = c(&quot;sign. &lt; 0&quot;, &quot;sign. &gt; 0&quot;, &quot;non sign.&quot;)) + labs(x = &quot;Constante aléatoire&quot;, y = &quot;Pays&quot;) Figure 9.18: Constantes aléatoires estimées par Pays (IC par simulations) La figure 9.18 permet de repérer en un coup doeil les pays pour lesquels la probabilité dutiliser le vélo comme moyen de transport pour le trajet le plus fréquent est la plus élevée ou la plus faible. Notez cependant que les valeurs représentées sont pour linstant des logarithmes de rapport de cotes. Nous devons donc les convertir en rapports de cotes avec la fonction exponentielle pour faciliter leur interprétation. # Conversion en rapports de cote (et arrondissement à trois décimales) mat &lt;- round(exp(simsRE[c(&quot;mean&quot;,&quot;lower&quot;,&quot;upper&quot;)]),3) rownames(mat) &lt;- simsRE$groupID names(mat) &lt;- c(&quot;RC&quot;,&quot;RC.025&quot;,&quot;RC.975&quot;) print(mat) ## RC RC.025 RC.975 ## Allemagne 1.667 1.191 2.333 ## Autriche 1.311 0.927 1.853 ## Belgique 1.428 1.022 1.997 ## Bulgarie 0.541 0.374 0.784 ## Croatie 1.880 1.354 2.610 ## Danemark 4.043 2.926 5.587 ## Espagne 0.292 0.194 0.439 ## Estonie 1.121 0.787 1.598 ## Finlande 2.242 1.621 3.102 ## France 0.523 0.357 0.766 ## Grande Bretagne 0.396 0.269 0.583 ## Grèce 0.615 0.422 0.897 ## Hongrie 2.359 1.700 3.273 ## Ireland 0.377 0.254 0.558 ## Italie 0.805 0.575 1.126 ## Lettonie 1.270 0.901 1.790 ## Lituanie 0.902 0.632 1.287 ## Luxembourg 0.419 0.262 0.670 ## Pays-Bas 3.939 2.873 5.400 ## Pologne 1.658 1.189 2.311 ## Portugal 0.218 0.139 0.340 ## Roumanie 0.542 0.376 0.781 ## Slovaquie 1.029 0.727 1.455 ## Slovénie 1.362 0.969 1.916 ## Suède 2.166 1.555 3.018 ## Tchéquie 1.172 0.837 1.641 Nous observons ainsi quune personne vivant en Finlande voit ses chances multipliées par 2,25 dutiliser le vélo comme mode de transport pour son trajet le plus fréquent comparativement à la moyenne des pays européens. À linverse, une personne résidant en France a 47 % de chances de moins dutiliser le vélo. Notez cependant que cette approche basée sur des simulations peut poser des problèmes, car elle ne renvoie quune erreur standard pour mesurer lincertitude de nos constantes. Dans les cas où nous ne disposons pas de beaucoup dobservations par groupe, la distribution à posteriori des constantes peut être asymétrique, rendant lestimation des intervalles de confiance par les erreurs standards inutiles. Il est possible de détecter ce cas de figure quand les médianes et les moyennes renvoyées par la fonction simsRE diffèrent nettement. Une alternative plus robuste est à nouveau destimer la variabilité des effets aléatoires par bootstrap. Cette méthode requiert bien plus de temps de calcul que la précédente, nous vous recommandons donc de commencer par la méthode par simulations pour disposer dun premier aperçu des résultats et dutiliser ensuite la méthode bootstrap quand votre modèle est dans sa forme finale. # Création de la fonction d&#39;extraction extractor2 &lt;- function(mod){ elements &lt;- ranef(mod)$Pays vec &lt;- elements[,1] names(vec) &lt;- rownames(elements) return(vec) } # Préparation de l&#39;opération en multitraitement cl &lt;- makeCluster(8) clusterEvalQ(cl,library(&quot;lme4&quot;)) # Calcul des effets aléatoires en bootstrap valeurs &lt;- bootMer(modele1,FUN = extractor2,nsim = 1000, use.u = T, type=&quot;parametric&quot;, ncpus = 8, parallel=&quot;snow&quot;, cl = cl) # Sauvegarder des résultats! save(valeurs,file = &#39;data/glmm/boot_binom2.rda&#39;) Puisque nous disposons des distributions bootstrapées des différents effets aléatoires, nous pouvons directement les représenter dans un graphique (figure 9.19). Les résultats sont très similaires à ceux de la figure 9.18, ce qui sexplique par le grand nombre dobservations et de groupes. Avec moins dobservations, il est recommandé de privilégier lapproche par bootstrap. # Chargement de nos valeurs bootstrapées load(&#39;data/glmm/boot_binom2.rda&#39;) # Conversion des bootstraps en intervalle de confiance q025 &lt;- function(x){return(quantile(x,probs = 0.025))} q975 &lt;- function(x){return(quantile(x,probs = 0.975))} df &lt;- reshape2::melt(valeurs$t) df_med &lt;- df %&gt;% group_by(Var2) %&gt;% summarise( med = median(value), lower = q025(value), upper = q975(value)) # Ajout d&#39;une variable pour la couleur si significatif df_med$sign &lt;- case_when( df_med$lower&lt;0 &amp; df_med$upper&lt;0 ~ &quot;inf&quot;, df_med$lower&gt;0 &amp; df_med$upper&gt;0 ~ &quot;sup&quot;, TRUE ~ &quot;not&quot; ) # Affichage des résultats ggplot(df_med) + geom_errorbar(aes(xmin = lower, xmax = upper, y = reorder(Var2,med)), width = 0.5) + geom_point(aes(x = med, y = reorder(Var2,med), color = sign)) + scale_color_manual(values = c(&quot;inf&quot; = &quot;#0077b6&quot;, &quot;sup&quot; = &quot;#e63946&quot;, &quot;not&quot;=&quot;#000000&quot;), labels = c(&quot;sign. &lt; 0&quot;, &quot;sign. &gt; 0&quot;, &quot;non sign.&quot;)) + labs(x = &quot;Constante aléatoire&quot;, y = &quot;Pays&quot;) Figure 9.19: Constantes aléatoires estimées par Pays (IC par bootstrap) 9.6.2 Ajustement du modèle avec constantes et pentes aléatoires Dans le modèle précédent, nous avons ajusté, pour chaque pays, une constante aléatoire afin de vérifier si la probabilité dutiliser le vélo comme mode de transport principal changeait dun pays dEurope à lautre. Nous souhaitons à présent tester lhypothèse que leffet de lâge sur la probabilité dutiliser le vélo varie dun pays à lautre. Pour cela, nous ajustons des constantes aléatoires par pays. Nous comparons trois modèles, triés ici selon leur niveau de complexité (nombre de paramètres) : le modèle avec uniquement des constantes aléatoires; le modèle avec des constantes et des pentes aléatoires indépendantes; le modèle avec des constantes et des pentes aléatoires corrélées. Dans le package lme4, les syntaxes pour ajuster ces trois modèles sont les suivantes : constantes aléatoires : +(1|Pays); constantes et pentes aléatoires indépendantes : +(1 + Age||Pays); constantes et pentes aléatoires corrélées : +(1 + Age|Pays). Notez quil est aussi possible dajuster un modèle avec uniquement des pentes aléatoires avec la syntaxe : +(-1 + Age|Pays). Le paramètre -1 sert à retirer explicitement la constante aléatoire du modèle. Ajustons donc nos deux modèles avec pentes et constantes aléatoires. # Constantes et pentes aléatoires indépendantes modele2 &lt;- glmer(y ~ Sexe + Age2 + Education + StatutEmploi + Revenu + Residence + Duree2 + ConsEnv + (1 + Age2||Pays), family = binomial(link=&quot;logit&quot;), control = glmerControl(optimizer = &quot;bobyqa&quot;), data = dfenquete2) # Constantes et pentes aléatoires corrélées modele3 &lt;- glmer(y ~ Sexe + Age2 + Education + StatutEmploi + Revenu + Residence + Duree2 + ConsEnv + (1 + Age2|Pays), family = binomial(link=&quot;logit&quot;), control = glmerControl(optimizer = &quot;bobyqa&quot;), data = dfenquete2) 9.6.2.1 Significativité de leffet aléatoire Puisque les trois modèles sont imbriqués, la première étape est de vérifier si les ajouts successifs au modèle de base sont significatifs, ce que nous pouvons tester avec un rapport de vraisemblance. anova(modele1,modele2,modele3) ## Data: dfenquete2 ## Models: ## modele1: y ~ Sexe + Age2 + Education + StatutEmploi + Revenu + Residence + ## modele1: Duree2 + ConsEnv + (1 | Pays) ## modele2: y ~ Sexe + Age2 + Education + StatutEmploi + Revenu + Residence + ## modele2: Duree2 + ConsEnv + (1 + Age2 || Pays) ## modele3: y ~ Sexe + Age2 + Education + StatutEmploi + Revenu + Residence + ## modele3: Duree2 + ConsEnv + (1 + Age2 | Pays) ## npar AIC BIC logLik deviance Chisq Df Pr(&gt;Chisq) ## modele1 18 19176 19323 -9570.1 19140 ## modele2 19 19171 19325 -9566.3 19133 7.5754 1 0.005917 ** ## modele3 20 19172 19335 -9566.1 19132 0.4033 1 0.525385 ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 Nous constatons ainsi que lajout des pentes aléatoires permet daméliorer significativement le modèle, mais que lajout de la corrélation entre les pentes et les constantes aléatoires a un apport très marginal. Nous décidons tout de même de le garder dans un premier temps, car ce paramètre a un intérêt théorique. Affichons le résumé du modèle 3. summary(modele3) ## Generalized linear mixed model fit by maximum likelihood (Laplace ## Approximation) [glmerMod] ## Family: binomial ( logit ) ## Formula: y ~ Sexe + Age2 + Education + StatutEmploi + Revenu + Residence + ## Duree2 + ConsEnv + (1 + Age2 | Pays) ## Data: dfenquete2 ## Control: glmerControl(optimizer = &quot;bobyqa&quot;) ## ## AIC BIC logLik deviance df.resid ## 19172.2 19335.1 -9566.1 19132.2 25527 ## ## Scaled residuals: ## Min 1Q Median 3Q Max ## -1.2087 -0.4392 -0.3218 -0.2137 7.1677 ## ## Random effects: ## Groups Name Variance Std.Dev. Corr ## Pays (Intercept) 0.594976 0.77135 ## Age2 0.007326 0.08559 -0.22 ## Number of obs: 25547, groups: Pays, 26 ## ## Fixed effects: ## Estimate Std. Error z value Pr(&gt;|z|) ## (Intercept) -3.357922 0.213122 -15.756 &lt; 2e-16 *** ## Sexehomme 0.372886 0.037961 9.823 &lt; 2e-16 *** ## Age2 -0.087748 0.027796 -3.157 0.001595 ** ## Educationsecondaire 0.179620 0.103838 1.730 0.083664 . ## Educationsecondaire inferieur 0.286993 0.111904 2.565 0.010329 * ## Educationuniversite 0.130114 0.107149 1.214 0.224622 ## StatutEmploisans emploi 0.256253 0.042508 6.028 1.66e-09 *** ## Revenufaible 0.070578 0.071820 0.983 0.325754 ## Revenumoyen 0.038414 0.065347 0.588 0.556630 ## Revenusans reponse 0.203615 0.102658 1.983 0.047319 * ## Revenutres eleve -0.124202 0.185684 -0.669 0.503564 ## Revenutres faible 0.235617 0.085949 2.741 0.006118 ** ## Residencegrande ville 0.269577 0.069366 3.886 0.000102 *** ## Residencepetite-moyenne ville 0.275698 0.061575 4.477 7.56e-06 *** ## Residencezone rurale -0.118979 0.069177 -1.720 0.085446 . ## Duree2 -0.018889 0.019274 -0.980 0.327067 ## ConsEnv 0.101888 0.009291 10.967 &lt; 2e-16 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 À nouveau, nous nous intéressons ici principalement à la section Random Effect, puisque les effets fixes sinterprètent exactement comme dans les modèles présentés dans le chapitre 6. Les constantes ont une variance de 0,595 et les pentes de 0,007. La corrélation entre les deux effets est de -0,22. Cette corrélation est négative et relativement faible, ce qui signifie que les pays dans lesquels la constante est forte tendent à avoir un coefficient plus petit pour lâge, et donc une réduction accrue de la probabilité dutiliser le vélo avec lâge. Nous devons cependant encore nous assurer quelle est significativement différente de 0. Pour cela, nous devons calculer lintervalle de confiance des trois paramètres de variance du modèle. Nous utilisons à nouveau une approche par bootstrap et nous enregistrons les résultats. # Fonction d&#39;extraction des trois paramètres de variance extractor3 &lt;- function(mod){ vari1 &lt;- VarCorr(mod)[[1]][[1]] vari2 &lt;- VarCorr(mod)[[1]][[4]] covari &lt;- VarCorr(mod)[[1]][[2]] return(c(&quot;vari1&quot;=vari1,&quot;vari2&quot;=vari2,&quot;covari&quot;=covari)) } # Lancement du bootstrap valeurs &lt;- bootMer(modele3,FUN = extractor3,nsim = 1000, use.u = F, type=&quot;parametric&quot;, ncpus = 8, parallel=&quot;snow&quot;, cl = cl, .progress=&quot;txt&quot;,PBarg=list(style=3)) # Enregistrement des résultats save(valeurs,file = &#39;data/glmm/boot_binom3.rda&#39;) À partir des valeurs bootstrapées, nous pouvons représenter les distributions de ces trois paramètres (variance des constantes, variance des pentes et corrélation entre les deux). # Chargement des résultats load(&#39;data/glmm/boot_binom3.rda&#39;) # Conversion des valeurs de covariance en corrélation df &lt;- data.frame( corr_values = valeurs$t[,3] / (sqrt(valeurs$t[,1]) * sqrt(valeurs$t[,2])), vari_const = valeurs$t[,1], vari_pente = valeurs$t[,2] ) # Histogramme pour la variance des constantes breaks1 &lt;- quantile(df$vari_const,probs=c(0.025,0.5,0.975,0.999)) label1 &lt;- round(breaks1,3) p1 &lt;- ggplot(df) + geom_histogram(aes(x = vari_const), color = &quot;black&quot;, fill = &quot;white&quot;, bins = 30) + geom_vline(xintercept = median(df$vari_const), color = &quot;red&quot;, size = 1, linetype=&quot;dashed&quot;) + geom_vline(xintercept = quantile(df$vari_const, probs = 0.025), color = &quot;blue&quot;, size = 0.5, linetype=&quot;dashed&quot;) + geom_vline(xintercept = quantile(df$vari_const, probs = 0.975), color = &quot;blue&quot;, size = 0.5, linetype=&quot;dashed&quot;) + labs(x = &quot;Variance des constantes&quot;, y=&quot;&quot;)+ scale_x_continuous(breaks = breaks1, labels = label1) # Histogramme pour la variance des pentes breaks2 &lt;- quantile(df$vari_pente,probs=c(0.025,0.5,0.975,0.999)) label2 &lt;- round(breaks2,3) p2 &lt;- ggplot(df) + geom_histogram(aes(x = vari_pente), color = &quot;black&quot;, fill = &quot;white&quot;, bins = 30) + geom_vline(xintercept = median(df$vari_pente), color = &quot;red&quot;, size = 1, linetype=&quot;dashed&quot;) + geom_vline(xintercept = quantile(df$vari_pente, probs = 0.025), color = &quot;blue&quot;, size = 0.5, linetype=&quot;dashed&quot;) + geom_vline(xintercept = quantile(df$vari_pente, probs = 0.975), color = &quot;blue&quot;, size = 0.5, linetype=&quot;dashed&quot;) + labs(x = &quot;Variance des pentes&quot;, y=&quot;&quot;)+ scale_x_continuous(breaks = breaks2, labels = label2) # Histogramme pour la corrélation breaks3 &lt;- c(-1,-0.5,0,0.5,1,median(df$corr_values)) label3 &lt;- round(breaks3,3) p3 &lt;- ggplot(df) + geom_histogram(aes(x = corr_values), color = &quot;black&quot;, fill = &quot;white&quot;, bins = 30) + geom_vline(xintercept = median(df$corr_values), color = &quot;red&quot;, size = 1, linetype=&quot;dashed&quot;) + geom_vline(xintercept = quantile(df$corr_values, probs = 0.025), color = &quot;blue&quot;, size = 0.5, linetype=&quot;dashed&quot;) + geom_vline(xintercept = quantile(df$corr_values, probs = 0.975), color = &quot;blue&quot;, size = 0.5, linetype=&quot;dashed&quot;) + labs(x = &quot;Corrélation pentes/constantes&quot;, y=&quot;&quot;) + scale_x_continuous(breaks = breaks3, labels = label3) ggarrange(p1,p2, p3, ncol = 2, nrow = 2) Figure 9.20: Incertitude autour des paramètres de variance obtenue par bootstrap Nous constatons ainsi, à la figure 9.20, que la variance des constantes aléatoires est significativement différente de zéro (cette valeur nest pas dans lintervalle de confiance à 95 % représenté par les lignes verticales bleues) et une médiane de 0,56 (ligne verticale rouge). Pour les pentes, zéro est également à la limite de lintervalle de confiance, et la distribution asymétrique et étalée nous indique que ce paramètre est fortement incertain dans le modèle. Enfin, la corrélation entre les pentes et les constantes est de loin le paramètre le plus incertain et son intervalle de confiance est franchement à cheval sur zéro, ce qui devrait nous amener à privilégier un modèle sans ce paramètre. Pour terminer, nous pouvons calculer les R2 marginal et conditionnel du modèle afin de mieux cerner le rôle joué par les effets fixes et les effets aléatoires. r.squaredGLMM(modele3) ## R2m R2c ## theoretical 0.03413720 0.18360159 ## delta 0.01419945 0.07636951 Les valeurs des R2 marginal et conditionnel du modèle sont similaires à celles que nous avons obtenus avec seulement des constantes aléatoires dans la section précédente, signalant lapport relativement faible des pentes aléatoires. 9.6.2.2 Analyse des effets aléatoires Pour analyser facilement les constantes et les pentes aléatoires de chaque pays, nous pouvons représenter graphiquement leurs intervalles de confiance construits à partir des simulations tirées de la distribution a posteriori du modèle. # Simulations et extraction des effets aléatoires library(merTools) simsRE &lt;- REsim(modele3,n.sims = 1000, oddsRatio = F) # Calcul des intervalles de confiance simsRE$lower &lt;- simsRE$mean - 1.96 * simsRE$sd simsRE$upper &lt;- simsRE$mean + 1.96 * simsRE$sd # Variable binaire pour la significativité simsRE$sign &lt;- case_when( simsRE$lower&lt;0 &amp; simsRE$upper&lt;0 ~ &quot;inf&quot;, simsRE$lower&gt;0 &amp; simsRE$upper&gt;0 ~ &quot;sup&quot;, TRUE ~ &quot;not&quot; ) df1 &lt;- subset(simsRE, grepl(&quot;Intercept&quot;,simsRE$term,fixed = T)) df2 &lt;- subset(simsRE, grepl(&quot;Age2&quot;,simsRE$term,fixed = T)) # Représentation des intervalles de confiance p1 &lt;- ggplot(df1) + geom_errorbarh(aes(xmin = lower, xmax = upper, y = reorder(groupID,mean)), size = 0.5, height = 0.5) + geom_point(aes(x = mean, y = reorder(groupID,mean), color = sign)) + scale_color_manual(values = c(&quot;inf&quot; = &quot;#0077b6&quot;, &quot;sup&quot; = &quot;#e63946&quot;, &quot;not&quot;=&quot;#000000&quot;), labels = c(&quot;sign. &lt; 0&quot;, &quot;non sign.&quot;, &quot;sign. &gt; 0&quot;)) + labs(x = &quot;Constante aléatoire&quot;, y = &quot;Pays&quot;) p2 &lt;- ggplot(df2) + geom_errorbarh(aes(xmin = lower, xmax = upper, y = reorder(groupID,mean)), size = 0.5, height = 0.5) + geom_point(aes(x = mean, y = reorder(groupID,mean), color = sign)) + scale_color_manual(values = c(&quot;inf&quot; = &quot;#0077b6&quot;, &quot;sup&quot; = &quot;#e63946&quot;, &quot;not&quot;=&quot;#000000&quot;), labels = c(&quot;sign. &lt; 0&quot;, &quot;non sign.&quot;, &quot;sign. &gt; 0&quot;)) + labs(x = &quot;Pente aléatoire (âge)&quot;, y = &quot;Pays&quot;) ggarrange(p1,p2, common.legend = T, nrow = 1, ncol = 2) Figure 9.21: Constantes aléatoires estimées par pays (intervalles de confiance obtenus par simulations) La figure 9.21 nous permet ainsi de constater que leffet des pays sur les pentes est presque toujours non significatif, sauf pour le Danemark. Son effet négatif (-0,136) indique un renforcement de leffet général, lui-même négatif (-0,088). Une interprétation possible est quau Danemark, lutilisation du vélo est proportionnellement plus courante par les jeunes que dans le reste des pays de lEurope. Pour linterprétation finale, il est nécessaire dafficher les valeurs exactes de ces différents paramètres et, dans notre cas, de les convertir en rapports de cotes avec la fonction exponentielle. Pour les pentes aléatoires, il peut être plus facile dinterpréter la somme de leffet fixe et de leffet aléatoire. # Extraction des effets aléatoires obtenus par simulation mat &lt;- simsRE[c(&quot;mean&quot;,&quot;lower&quot;,&quot;upper&quot;)] mat$Pays &lt;- simsRE$groupID mat$effet &lt;- simsRE$term # Séparation des pentes et des constantes df1 &lt;- subset(mat, grepl(&quot;Intercept&quot;,mat$effet, fixed = TRUE)) df2 &lt;- subset(mat, grepl(&quot;Age2&quot;,mat$effet, fixed = TRUE)) # Conversion en rapports de cotes pour les pentes (+ effet fixe) df2$RC &lt;- round(exp(df2$mean + fixef(modele3)[[3]]),3) df2$RC025 &lt;- round(exp(df2$lower + fixef(modele3)[[3]]),3) df2$RC975 &lt;- round(exp(df2$upper + fixef(modele3)[[3]]),3) print(head(df2[c(&quot;Pays&quot;,&quot;RC&quot;,&quot;RC025&quot;,&quot;RC975&quot;)],10)) ## Pays RC RC025 RC975 ## 27 Allemagne 0.835 0.744 0.937 ## 28 Autriche 0.986 0.875 1.112 ## 29 Belgique 0.895 0.797 1.005 ## 30 Bulgarie 0.946 0.824 1.086 ## 31 Croatie 0.905 0.802 1.020 ## 32 Danemark 0.799 0.720 0.886 ## 33 Espagne 0.920 0.796 1.063 ## 34 Estonie 0.950 0.835 1.080 ## 35 Finlande 0.865 0.774 0.967 ## 36 France 0.897 0.783 1.029 Nous constatons ainsi quau Danemark, les chances pour un individu dutiliser le vélo sont réduites de 20 % à chaque augmentation de lâge dun écart-type, contre seulement 1,5 % en Autriche (non significatif pour ce dernier). Notons ici que lécart-type de la variable Age est de 11 ans. Nous pouvons à présent analyser les constantes. # Conversion en rapports de cotes pour les constantes df1$RC &lt;- round(exp(df1$mean),3) df1$RC025 &lt;- round(exp(df1$lower),3) df1$RC975 &lt;- round(exp(df1$upper),3) print(head(df1[c(&quot;Pays&quot;,&quot;RC&quot;,&quot;RC025&quot;,&quot;RC975&quot;)],10)) ## Pays RC RC025 RC975 ## 1 Allemagne 1.691 1.207 2.369 ## 2 Autriche 1.312 0.925 1.860 ## 3 Belgique 1.435 1.015 2.029 ## 4 Bulgarie 0.547 0.375 0.799 ## 5 Croatie 1.885 1.350 2.630 ## 6 Danemark 4.087 2.937 5.686 ## 7 Espagne 0.291 0.192 0.440 ## 8 Estonie 1.131 0.798 1.602 ## 9 Finlande 2.243 1.609 3.125 ## 10 France 0.527 0.359 0.774 En revanche, les chances pour un individu dutiliser le vélo comme mode de transport pour son trajet le plus fréquent sont 4 fois supérieures à la moyenne européenne, contre seulement 1,3 fois en Autriche. Notez à nouveau que les intervalles de confiance pour ces pentes et ces constantes pourraient être estimés plus fiablement par bootstrap. 9.6.2.3 Diagnostic des effets aléatoires Pour rappel, dans un modèle GLMM, les effets aléatoires sont modélisés comme provenant de distributions normales. Nous devons donc vérifier quils respectent cette condition dapplication. La figure 9.22 (graphique quantile-quantile) nous permet de constater que les constantes suivent bien une distribution normale, ce qui ne semble pas vraiment être le cas pour les pentes. Considérant que leurs effets sont petits, il serait plus pertinent ici de les retirer du modèle. Figure 9.22: Distribution normale univariée des constantes et des pentes aléatoires Considérant que ce modèle inclut une corrélation entre les constantes et les pentes aléatoires, il est également nécessaire de vérifier si elles suivent conjointement une distribution normale bivariée. La figure 9.23 semble indiquer que cest le cas. cor_mat &lt;- VarCorr(modele3)[[1]] re_effects &lt;- data.frame(ranef(modele3)$Pays) names(re_effects) &lt;- c(&quot;constante&quot;,&quot;pente&quot;) library(ellipse) levels &lt;- c(0.05,0.25,0.75,0.95) els &lt;- lapply(levels, function(i){ el &lt;- data.frame(ellipse(cor_mat,center = c(0,0), level = i)) names(el) &lt;- c(&quot;x&quot;,&quot;y&quot;) return(el) }) ref_points &lt;- data.frame(data.frame(MASS::mvrnorm(n = 1000, mu = c(0,0), Sigma = cor_mat))) names(ref_points) &lt;- c(&quot;x&quot;,&quot;y&quot;) ggplot() + geom_point(aes(x = x, y = y), data = ref_points, alpha = 0.3, size = 0.4) + geom_path(data = els[[1]], aes(x = x, y = y, color = &quot;a&quot;)) + geom_path(data = els[[2]], aes(x = x, y = y, color = &quot;b&quot;)) + geom_path(data = els[[3]], aes(x = x, y = y, color = &quot;c&quot;)) + geom_path(data = els[[4]], aes(x = x, y = y, color = &quot;d&quot;)) + geom_point(data = re_effects, aes(x = constante, y = pente))+ scale_color_manual(values = c(&quot;a&quot;=&quot;#90e0ef&quot;, &quot;b&quot;=&quot;#00b4d8&quot;, &quot;c&quot;=&quot;#0077b6&quot;, &quot;d&quot;=&quot;#03045e&quot;), labels = c(&quot;5 %&quot;,&quot;25 %&quot;,&quot;75 %&quot;,&quot;95 %&quot;))+ labs(x = &quot;Constantes&quot;, y = &quot;Pentes&quot;, color = &quot;quantiles&quot;) Figure 9.23: Distribution normale bivariée des constantes et des pentes aléatoires 9.6.2.4 Inférence pour les effets fixes Nous avons mentionné, dans les sections précédentes, que le calcul de valeurs de p pour les effets fixes fait lobjet de controverses pour les modèles GLMM. La méthode offrant le meilleur compromis entre rapidité de calcul et fiabilité est la méthode Satterthwaite implémentée dans le package lmerTest. Pour lutiliser, il suffit de charger le package lmerTest après lme4, ce qui modifie la fonction summary pour quelle utilise directement cette approche. library(lmerTest) round(summary(modele3)$coefficients,3) ## Estimate Std. Error z value Pr(&gt;|z|) ## (Intercept) -3.358 0.213 -15.756 0.000 ## Sexehomme 0.373 0.038 9.823 0.000 ## Age2 -0.088 0.028 -3.157 0.002 ## Educationsecondaire 0.180 0.104 1.730 0.084 ## Educationsecondaire inferieur 0.287 0.112 2.565 0.010 ## Educationuniversite 0.130 0.107 1.214 0.225 ## StatutEmploisans emploi 0.256 0.043 6.028 0.000 ## Revenufaible 0.071 0.072 0.983 0.326 ## Revenumoyen 0.038 0.065 0.588 0.557 ## Revenusans reponse 0.204 0.103 1.983 0.047 ## Revenutres eleve -0.124 0.186 -0.669 0.504 ## Revenutres faible 0.236 0.086 2.741 0.006 ## Residencegrande ville 0.270 0.069 3.886 0.000 ## Residencepetite-moyenne ville 0.276 0.062 4.477 0.000 ## Residencezone rurale -0.119 0.069 -1.720 0.085 ## Duree2 -0.019 0.019 -0.980 0.327 ## ConsEnv 0.102 0.009 10.967 0.000 Les deux autres options envisageables sont : effectuer une analyse de type 3 ou calculer les intervalles de confiance par bootstrap. Cependant, elles requièrent beaucoup plus de temps de calcul. Par conséquent, elles ne sont pas présentées ici. References "],["sect097.html", "9.7 Quiz de révision du chapitre", " 9.7 Quiz de révision du chapitre GLMM est un acronyme signifiant : Relisez au besoin la section 9.1.2 modèles Linéaires Généralisés à effets Mixtes modèles Linéaires Gaussiens à effets Mixtes modèles Linéaire Généralisé Multinomial modèles Linéaire Généralisés Multiniveau Les modèles GLMM, comparativement aux GLM, permettent de tenir compte de : Relisez au besoin la section 9.1.1. la distribution spécifique de la variable Y les distributions spécifiques des variables X lhétéroscédasticité des résidus la non-indépendance des observations Un effet aléatoire se distingue dun effet fixe, car : Relisez au besoin la section 9.1.2. Un effet aléatoire nest pas propre aux individus (unités dobservations), mais provient de facteurs externes. Un effet aléatoire induit une forme de hiérarchie, de regroupement dindividus dans des groupes au seins desquels les observations ont plus tendance à se ressembler. Un effet aléatoire provient dune autre population que les unités dobservations et peut donc être également échantillonné. Un effet aléatoire implique un partage de linformation dans son estimation. Comparativement à un effet fixe, la conséquence est notamment la réduction des tailles deffet (shrinkage). Quels sont les principaux types deffets que nous pouvons modéliser avec des effets aléatoires? Relisez au besoin la section 9.2. Des constantes aléatoires, suggérant des écarts absolus entre les groupes Des pentes aléatoires, suggérant des écarts en termes deffets pour certains prédicteurs en fonction des groupes Des pentes et des constantes aléatoires Quels indicateurs peuvent être utilisés pour analyser la part de la variance / déviance expliquée aux différents niveaux dun GLMM? Relisez au besoin la section 9.2.1.3. LICC, soit le coefficient de corrélation intraclasse Le BIC, soit le critère dinformation Bayésien LAIC La déviance expliquée Les R2 marginal et conditionnel Toutes les variables catégorielles devraient être incluses dans un modèle comme des effets aléatoires. Relisez au besoin la section 9.1.2. Vrai Faux Lors de lestimation dun effet aléatoire, le modèle estime exactement : Relisez au besoin la section 9.2.1. k + 1 paramètres, soit le nombre de catégories plus un paramètre pour la variance de leffet aléatoire en question un seul paramètre, la variance de la distribution normale associée à leffet aléatoire en question k paramètres, soit le nombre de catégories pour leffet aléatoire en question k - 1 paramètres, soit le nombre de catégories moins un pour la catégorie de référence Verifier Votre score "],["chap10.html", "Chapitre 10 Régressions multiniveaux", " Chapitre 10 Régressions multiniveaux Dans le précédent chapitre, nous avons abordé les modèles à effets mixtes qui permettent dintroduire à la fois des effets fixes et aléatoires (GLMM). Dans ce chapitre, nous poursuivons sur cette voie avec une nouvelle extension des modèles GLM : les modèles multiniveaux. Ces modèles sont simplement une extension des modèles à effets mixtes et permettent de modéliser un phénomène avec une structure hiérarchique des données, tel que décrit dans le chapitre précédent. Rappel de la structure hiérarchique des données Exemple à deux niveaux : il sagit de modéliser un phénomène \\(y_{ij}\\), soit une variable dépendante Y pour un individu i (niveau 1) niché dans un groupe j (niveau 2). Par exemple, modéliser lindice de masse corporelle (IMC) de 5000 individus résidant dans 100 quartiers différents. Exemple à trois niveaux : il sagit de modéliser un phénomène \\(y_{ijk}\\), soit une variable dépendante Y pour un individu i (niveau 1), niché dans un groupe j (niveau 2) appartenant à un groupe k (niveau 3). Par exemple, modéliser les notes à un examen de mathématiques délèves (niveau 1) nichés dans des classes (niveau 2) nichées dans des écoles (niveau 3). Nous avons largement décrit précédemment trois principaux types de modèles deffets mixtes (GLMM) : Les GLMM avec constantes aléatoires qui permettent davoir une constante différente pour chacun des groupes (niveau 2). Les GLMM avec pentes aléatoires qui permettent de faire varier une variable indépendante au niveau 1 (coefficient) en fonction des groupes au niveau 2. Les GLMM avec constantes et pentes aléatoires. Les modèles multiniveaux se différencient des modèles à effets mixtes puisquils permettent dintroduire des variables indépendantes mesurées aux niveaux supérieurs (2 et 3). Dans ce chapitre, nous utilisons les packages suivants : lme4 pour en uvre des modèles multiniveaux avec une variable dépendante continue. performance pour obtenir le coefficient intraclasse (ICC). MuMIn pour obtenir les pseudo R2. "],["sect101.html", "10.1 Modèles multiniveaux : deux intérêts majeurs", " 10.1 Modèles multiniveaux : deux intérêts majeurs Les modèles multiniveaux ont deux principaux avantages : analyser la répartition de la variance entre les différents niveaux et introduire des variables explicatives aux différents niveaux du modèle. 10.1.1 Répartition de la variance entre les différents niveaux Les modèles multiniveaux permettent destimer comment se répartit la variance entre les différents niveaux du jeu de données. Dans les deux exemples de lencadré précédent, ils permettraient de répondre aux questions suivantes : Quel niveau explique le plus lIMC, le niveau individuel (niveau 1) ou le niveau contextuel (niveau 2)? Comment se répartit la variance des notes à lexamen de mathématiques entre les trois niveaux? A-t-on plus de variance pour les individus (niveau 1) ou au sein des classes (niveau 2) ou entre les différentes écoles (niveau 3)? 10.1.2 Estimation des coefficients aux différents niveaux Les modèles multiniveaux permettent destimer simultanément les coefficients de plusieurs variables indépendantes introduites à chacun des niveaux du modèle. Autrement dit, de voir comment les variables indépendantes introduites aux différents niveaux influencent la variable dépendante (Y) mesurée au niveau 1. Si nous reprenons lexemple à trois niveaux (élèves/classes/écoles), plusieurs facteurs peuvent influencer la réussite ou la performance scolaire des élèves aux différents niveaux : Variables indépendantes au niveau 1 (élève) : âge, sexe, statut socioéconomique, langue maternelle autre que la langue denseignement Variables indépendantes au niveau 2 (classe) : nombre délèves par classe, programme spécialisé ou pas Variables indépendantes au niveau 3 (école) : indice de défavorisation de lécole, école publique ou privée, qualité des infrastructures de lécole (bâtiment, gymnase, cour décole) Dans la même veine, afin dillustrer lapport des modèles multiniveaux dans le champ de la géographie de la santé, Philibert et Apparicio (2007, 129) signalent que « pour un modèle à deux niveaux, il sagit de modéliser \\(y_{ij}\\), par exemple lIMC dun individu i (niveau 1) résidant dans un quartier j (niveau 2). Il est alors possible de mettre des variables explicatives tant au niveau 1 (âge, sexe, revenu, niveau déducation, etc.) quau niveau 2 (niveau de défavorisation sociale du quartier, offre de services et déquipements sportifs et récréatifs, caractéristiques de lenvironnement urbain, etc.). Dans cet exemple, nous pouvons voir comment la modélisation multiniveaux permet destimer simultanément les effets environnementaux et individuels de manière à distinguer la contribution de chacun des niveaux (ex. : leffet du revenu des individus et celui de la défavorisation du quartier) dans lexplication des variations géographiques observées ». Évaluer les effets de milieu avec des analyses multiniveaux En santé des populations et en études urbaines, les modèles multiniveaux sont largement mobilisés pour évaluer les effets de milieu (neighbourhoods effects ou area effects en anglais). Atkinson et Kintrea (2001, 2278) définissent les « effets de milieu comme le changement net dans les potentialités de lexistence (life chances) attribuable au fait de vivre dans un quartier (ou une zone) plutôt quun autre » [traduction libre]. Les effets de milieu peuvent être positifs ou négatifs et concerner aussi bien les enfants que les adultes. Les analyses multiniveaux sont particulièrement adaptées à lévaluation des effets de milieu. En effet, plusieurs phénomènes  état de santé, comportement ou choix individuels  peuvent être influencés à la fois par des caractéristiques individuelles (âge, sexe, niveau de revenu, niveau déducation, etc.) et par des caractéristiques contextuelles (caractéristiques du quartier). Avec un modèle multiniveau, une fois contrôlées les caractéristiques individuelles (variables indépendantes mesurées au niveau 1), il est alors possible dévaluer leffet des caractéristiques du quartier (variables indépendantes mesurées au niveau 2) sur un phénomène \\(y_{ij}\\) mesuré pour un individu i résidant dans un quartier j. References "],["sect102.html", "10.2 Différents types de modèles multiniveaux", " 10.2 Différents types de modèles multiniveaux 10.2.1 Description du jeu de données utilisé Dans le cadre de cette section, nous présentons uniquement les modèles à deux niveaux, soit celui pour modéliser un phénomène \\(y_{ij}\\). Pour ce faire, nous utilisons des données tirées dune étude de Pham et al. (2017). Dans cet article, les auteurs souhaitent évaluer les effets des caractéristiques de la forme urbaine et des caractéristiques socioéconomiques sur la couverture des arbres de rue, et ce, à partir dun modèle multiniveau. Ils disposent ainsi dune structure hiérarchique de données avec deux niveaux : les tronçons de rue (niveau 1, n = 10 814) inclus dans un et un seul secteur de recensement (niveau 2, n = 312). La variable dépendante (\\(y_{ij}\\)) est le pourcentage de la superficie du tronçon de rue qui est couverte par des arbres, calculé à partir dimages satellites à haute résolution (Quickbird, 60 cm, septembre 2008). Lensemble des variables utilisées pour les modèles sont reportées au tableau 10.1. Sept variables indépendantes relatives à la forme urbaine sont mesurées pour les tronçons de rue, soit la largeur et la longueur de la rue, lâge médian des bâtiments (introduit également au carré pour vérifier lexistence dun effet curvilinéaire; voir la section 7.5.1.1), les pourcentages de bâtiments résidentiels, de duplex et de triplex, le nombre de bâtiments et finalement la distance moyenne entre le bâtiment et la rue. Les variables indépendantes pour les 312 secteurs de recensement (niveau 2) sont extraites du recensement canadien de 2006 (tableau 10.1). Tableau 10.1: Statistiques descriptives pour les variables des modèles multiniveaux Nom Intitulé Type Niveau Moy. Écart type PCTArb Arbres sur le tronçon de rue (%) VD 1 7,2 10,7 Width Largeur des rues VI 1 16,0 7,3 Length Longueur de rues VI 1 136,0 87,8 AgeMed Age médian des bâtiments VI 1 1 952,7 28,3 ResiPCT Bâtiments résidentiels (%) VI 1 83,5 28,0 DuTriPct Duplex ou triplex (%) VI 1 41,8 39,3 NoLog Nombre de bâtiments VI 1 14,0 14,4 Setback Distance entre le bâtiment et la rue VI 1 7,2 4,3 ValLog Valeur moyenne des logements (milliers de dollars) VI 2 267,6 80,0 UDipPCT Diplômés universitaires (%) VI 2 16,9 9,6 PCTFRAVI Personnes à faible revenu (%) VI 2 30,3 11,5 PCTIMGRE Immigrants récents (%) VI 2 10,0 7,3 AvecEnf Ménages avec enfants (%) VI 2 34,8 12,6 FranPCT Langue maternelle française (%) VI 2 66,9 24,1 10.2.2 Démarche classique pour les modèles multiniveaux La démarche habituelle en analyse multiniveau est de réaliser plusieurs modèles, allant du plus simple au plus complexe. Cette stratégie permet habituellement de bien cerner la répartition de la variance entre les différents niveaux et lapport des variables explicatives introduites aux différents niveaux. De la sorte, cinq types de modèles peuvent être construits : Le modèle vide (appelé aussi modèle inconditionnel) qui comprend des constantes aléatoires au niveau 2, mais aucune variable explicative. Le modèle avec uniquement les variables indépendantes au niveau 1 et des constantes aléatoires au niveau 2. Le modèle complet avec les variables indépendantes aux deux niveaux et des constantes aléatoires. Le modèle complet avec les variables indépendantes aux deux niveaux, incluant une interaction entre une variable indépendante mesurée au niveau 1 et une autre mesurée au niveau 2. Le modèle avec les variables indépendantes aux deux niveaux et des constantes et pentes aléatoires. Dans les sous-sections suivantes, nous détaillons chacun de ces cinq modèles en prenant soin de montrer les similitudes quils partagent avec les modèles à effets mixtes vus précédemment. Notez demblée que les trois premiers modèles sont les plus fréquemment utilisés. 10.2.2.1 Modèle vide Comme son nom lindique, le modèle vide ne comprend aucune variable explicative. Il consiste simplement à faire varier la constante du niveau 1 avec des effets aléatoires au niveau 2, ce qui explique quil est souvent comparé à une ANOVA avec des effets aléatoires. En dautres termes, ce modèle correspond à un GLMM avec constantes aléatoires dans lequel aucune variable indépendante nest incluse au niveau 1. Dailleurs, si vous comparez léquation (10.1) avec léquation (9.2) au chapitre précédent, vous constaterez que seul le paramètre \\(\\beta_1 x_1\\) a été ôté et quil comprend aussi deux variances : lune fixe au niveau 1 (\\(\\sigma_e\\)) et lautre aléatoire (stochastique) au niveau 2 (\\(\\sigma_{\\upsilon}\\)). \\[\\begin{equation} \\begin{aligned} &amp;Y \\sim Normal(\\mu,\\sigma_e)\\\\ &amp;g(\\mu) = \\beta_0 + \\upsilon \\\\ &amp;\\upsilon \\sim Normal(0, \\sigma_{\\upsilon}) \\\\ &amp;g(x) = x \\end{aligned} \\tag{10.1} \\end{equation}\\] Quel est alors lintérêt de réaliser un modèle si simple? À partir des deux variances, il est possible de calculer le coefficient de corrélation intraclasse (intraclass-correlation (ICC) en anglais) qui est le rapport entre la variance aléatoire et la somme des variances des deux niveaux, soit fixe et aléatoire (équation (10.2)). Ce coefficient varie ainsi de 0 à 1 et indique la proportion de la variance de la variable dépendante qui est imputable au niveau 2. Tous(tes) les auteur(e)s sentendent sur le fait quil est impératif de commencer une analyse de multiniveau en calculant ce modèle vide qui nous informe de la répartition de la variance entre les deux niveaux (Raudenbush et Bryk 2002; Gelman et Hill 2006; Tabachnick, Fidell et Ullman 2007; Bressoux 2010). Nous pourrons ensuite analyser lévolution de ce coefficient dans les modèles subséquents. \\[\\begin{equation} \\rho = \\frac{\\sigma_{\\upsilon}}{\\sigma_{\\upsilon} + \\sigma_{e}} \\tag{10.2} \\end{equation}\\] Les résultats du modèle vide (inconditionnel) à partir des données de Pham et al. (2017) sont présentés au tableau 10.2. La variance du niveau 1 est de 92,93 contre 19,82 au niveau 2. Le coefficient de corrélation intraclasse vaut alors : \\(\\mbox{19,82} / \\mbox{(19,82} + \\mbox{92,93}) = \\mbox{0,1758}\\). Cela signifie que 18 % de la variance de la variable dépendante sont imputables au niveau 2 (des secteurs de recensement) et 82 % au niveau 1 (des tronçons). Nous verrons comment évolue ce coefficient dans les modèles subséquents. Tableau 10.2: Résultats du modèle vide (modèle 1) Paramètre Coefficient Erreur type Valeur de T Effets fixes (niveau 1) Constante 7,337 0,277 314,918 Répartition de la variance Variance (niveau 1) 19,818 Variance (niveau 2) 92,925 Coefficient de corrélation intraclasse 0,176 Qualité dajustement du modèle AIC 80 305,219 R2 marginal 0,000 R2 conditionnel 0,176 10.2.2.2 Modèle avec les variables indépendantes du niveau 1 Dans ce second modèle, nous introduisons uniquement les variables explicatives au niveau 1. Par conséquent, ce modèle est tout simplement un modèle à effets mixtes (GLMM) avec des constantes aléatoires largement décrit à la section 9.2.1). Si vous comparez léquation du modèle vide (équation (10.2)) avec léquation de ce modèle (équation (10.3)), vous constaterez que le paramètre \\(\\beta_1 x_1\\) a été ajouté. Il correspond au coefficient pour la variable indépendante \\(X_1\\) mesurée au niveau 1 (effet fixe). Nous pourrions alors ajouter dautres paramètres pour les autres variables indépendantes du modèle, soit \\(\\beta_1 x_1 + \\beta_2 x_2+ \\ldots + \\beta_k x_k\\) (\\(k\\) étant le nombre de variables explicatives mesurées au niveau 1, effets fixes). \\[\\begin{equation} \\begin{aligned} &amp;Y \\sim Normal(\\mu,\\sigma_e)\\\\ &amp;g(\\mu) = \\beta_0 + \\beta_1 x_1 + \\upsilon \\\\ &amp;\\upsilon \\sim Normal(0, \\sigma_{\\upsilon})) \\\\ &amp;g(x) = x \\end{aligned} \\tag{10.3} \\end{equation}\\] Les résultats du second modèle sont présentés au tableau 10.3. La répartition de la variance entre les deux niveaux. La variance du niveau 1 est désormais de 15,263 contre 80,317 au niveau 2, ce qui permet dobtenir un coefficient de corrélation intraclasse de 0,1597. Cela signifie que de 16 % de la variance de la variable dépendante sont imputables au niveau 2 (des secteurs de recensement), une fois contrôlées les caractéristiques des tronçons. La qualité dajustement du modèle. Dans le chapitre précédent sur les GLMM, nous avons largement décrit plusieurs mesures de la qualité dajustement du modèle, notamment lAIC et les R2 marginal et conditionnel. À titre de rappel, voici comment interpréter ces mesures : Plus la valeur de lAIC est faible, mieux le modèle est ajusté. En comparant les valeurs dAIC du modèle vide et du modèle avec les variables explicatives du niveau 1 (80 305 versus 78 785), nous constatons, sans surprise, que ce dernier modèle est plus performant. Le R2 marginal indique la proportion de la variance expliquée uniquement si les effets fixes sont pris en compte (ici, 0,129). Quant au R2 conditionnel, il indique la proportion de la variance expliquée à la fois par les effets fixes et aléatoires (ici, 0,268). Lécart important entre les deux R2 signale que les secteurs de recensement (effets aléatoires, niveau 2) jouent un rôle important dans le modèle. Quelles informations peut-on tirer des coefficients de régression? Les variables indépendantes relatives à la forme urbaine les plus importantes sont : le pourcentage de bâtiments résidentiels (ResiPCT), la largeur de la rue (Width) et le nombre de bâtiments (NoLog). Aussi, la distance entre le bâtiment et la rue (Setback) est associée positivement avec la variable dépendante. En effet, à chaque ajout dun mètre de la distance moyenne entre les bâtiments et le tronçon de rue, la couverture des arbres sur le tronçon augmente de 0,202 point de pourcentage, toutes choses étant égales par ailleurs. Tableau 10.3: Résultats du modèle avec les variables indépendantes au niveau 1 (modèle 2) Paramètre Coefficient Erreur type Valeur de T Effets fixes (niveau 1) Constante -1 028,618 179,736 10 799,64 Width -0,129 0,013 10 754,96 Length 0,011 0,002 10 733,36 AgeMed 1,103 0,186 10 799,74 AgeMed2 0,000 0,000 10 799,55 ResiPCT 0,047 0,003 10 804,92 DuTriPct -0,013 0,003 10 703,70 NoLog 0,147 0,011 10 797,85 Setback 0,202 0,023 10 797,86 Répartition de la variance Variance (niveau 1) 15,263 Variance (niveau 2) 80,317 Coefficient de corrélation intraclasse 0,160 Qualité dajustement du modèle AIC 78 785,827 R2 marginal 0,129 R2 conditionnel 0,268 Remarquez la valeur de la constante : 1028,618. À titre de rappel, la constante est la valeur que prend la variable dépendante quand toutes les variables indépendantes sont égales à 0. Or, il est impossible quelles soient toutes égales à zéro. Centrage des variables quantitatives mesurées au niveau 1 En analyse multiniveau, il est très courant et souvent recommandé de centrer les variables explicatives quantitatives au niveau 1. Deux options sont alors possibles : Pour une variable indépendante donnée, les observations sont centrées sur leur moyenne générale, cest-à-dire la moyenne de lensemble des observations du jeu de données, soit \\(X_{ij} - \\bar{X}\\). Dans ce cas, la constante est donc la valeur que prend la variable \\(Y\\) quand toutes les variables indépendantes sont égales à leur moyenne respective. Chaque observation est centrée sur la moyenne de son groupe respectif, soit \\(X_{ij} - \\bar{X}_{.j}\\). Tel que signalé par Bressoux (2010, 328), « dans le premier cas, la variance des pentes sera estimée pour lindividu moyen dans la distribution générale, tandis que dans le second elle est estimée pour lindividu moyen de chaque groupe ». Autrement dit, comparativement à un modèle sans centrage, les valeurs des coefficients pour les variables indépendantes sont les mêmes dans le premier cas (seule la valeur de la constante va changer) tandis quelles sont différentes dans le second cas. Attention, il ne faut pas appliquer de centrage sur une variable qualitative, quelle soit dichotomique, nominale ou ordinale. Pourquoi la pratique du centrage en analyse multiniveau est si courante? Dans la plupart des livres sur les régressions multiniveaux, le centrage est recommandé, notamment dans louvrage classique de Raudenbush et Bryk (2002). Rappelons que ces modèles sont largement utilisés en éducation avec une structure hiérarchique classique élève/école/classe. Nous nous intéressons alors à lindividu moyen (lélève), ce qui explique que le centrage est habituellement appliqué. Par exemple, ne pas centrer lâge des élèves fait que la constante qui est obtenue est peu interprétable : difficile dévaluer la note moyenne à un examen quand la variable âge de lélève a la valeur de 0, tout comme les autres variables explicatives quantitatives relatives à lélève. Centrage et réduction de lensemble des variables du modèle Il est à noter que certains auteurs centrent et réduisent lensemble des variables du modèle. À titre de rappel, le centrage consiste à soustraire à chaque valeur la moyenne de la variable; la réduction, à la diviser par lécart-type de la variable (section 2.5.5.2). Pour chaque variable, la moyenne est alors égale à 0 et lécart-type à 1. Les coefficients sinterprètent alors en termes daugmentation dune unité décart-type tant pour la VI que la VD. Ils correspondent alors à des coefficients de régression standardisés (abordés dans la section 7.4.2). Ce processus de centrage et de réduction des variables peut être motivé par des problèmes de convergence du modèle (lorsque lalgorithme doptimisation narrive pas à trouver une solution pour produire les coefficients). Par conséquent, nous vous proposons de centrer les variables du niveau 1 de notre jeu de données. Si vous comparez les tableaux 10.3 et 10.4, vous constaterez que les valeurs relatives aux coefficients, aux mesures de la répartition de la variance et à la qualité dajustement du modèle sont les mêmes. Seule la valeur de la constante change : elle passe de 1028,618 à 7,228. Elle sinterprète désormais de la façon suivante : si toutes les variables explicatives sont égales à leurs moyennes respectives, alors le pourcentage de la superficie du tronçon couverte par des arbres est égal à 7,228 %. Tableau 10.4: Résultats du modèle avec les variables indépendantes centrées au niveau 1 (modèle 2) Paramètre Coefficient Erreur type Valeur de T Effets fixes (niveau 1) Constante 7,228 0,248 318,313 Width.c -0,129 0,013 10 754,961 Length.c 0,011 0,002 10 733,361 AgeMed.c 1,103 0,186 10 801,399 AgeMed2.c 0,000 0,000 10 801,243 ResiPCT.c 0,047 0,003 10 804,923 DuTriPct.c -0,013 0,003 10 703,746 NoLog.c 0,147 0,011 10 797,848 Setback.c 0,202 0,023 10 797,856 Répartition de la variance Variance (niveau 1) 15,263 Variance (niveau 2) 80,317 Coefficient de corrélation intraclasse 0,160 Qualité dajustement du modèle AIC 78 785,827 R2 marginal 0,129 R2 conditionnel 0,268 10.2.2.3 Modèle complet avec les variables indépendantes aux niveaux 1 et 2 Le troisième type de modèle consiste à introduire à la fois les variables explicatives mesurées au niveau 1 et au niveau 2 (équation (10.4)). Il est communément appelé le modèle complet. Les variables explicatives du niveau 2 sont aussi considérées comme des effets fixes. \\[\\begin{equation} \\begin{aligned} &amp;Y \\sim Normal(\\mu,\\sigma_e)\\\\ &amp;g(\\mu) = \\underbrace{\\beta_0 + \\beta_1 x_1}_{\\mbox{effets fixes (niveau 1)}}+ \\underbrace{\\beta_2 z_2}_{\\mbox{effets fixes (niveau 2)}}+\\epsilon \\\\ &amp;\\upsilon \\sim Normal(0, \\sigma_{\\upsilon}) \\\\ &amp;g(x) = x \\end{aligned} \\tag{10.4} \\end{equation}\\] Les résultats du troisième modèle sont présentés au tableau 10.5. Ce modèle permet dévaluer les effets des caractéristiques socioéconomiques (mesurés au niveau des secteurs de recensement) sur la couverture des arbres des îlots, une fois contrôlées les caractéristiques de la forme urbaine des tronçons. Rappelons, que dans ce modèle, les constantes sont aléatoires et les variables indépendantes au niveau 1 sont centrées. Quelles informations peut-on tirer des coefficients de régression du niveau 2? Demblée, deux caractéristiques nont pas deffet significatif sur la variable dépendante, soit les pourcentages de diplômés universitaires et de ménages avec enfants. Par contre, toutes choses étant égales par ailleurs, la valeur moyenne des logements et le pourcentage dimmigrants récents sont associés à une augmentation de la couverture végétale. À linverse, le pourcentage de personnes à faible revenu est associé à une diminution de la couverture végétale. Tableau 10.5: Résultats du modèle avec les variables indépendantes aux niveaux 1 et 2 (modèle 3) Paramètre Coefficient Erreur type Valeur de T Effets fixes (niveau 1 : tronçons) Constante -0,518 3,227 313,586 Width.c -0,132 0,013 10 762,184 Length.c 0,011 0,002 10 728,713 AgeMed.c 1,097 0,185 10 783,965 AgeMed2.c 0,000 0,000 10 782,352 ResiPCT.c 0,046 0,003 10 778,050 DuTriPct.c -0,013 0,003 10 608,724 NoLog.c 0,148 0,011 10 793,143 Setback.c 0,194 0,023 10 793,303 Effets fixes (niveau 2 : secteurs de recensement) ValLog 0,016 0,004 312,695 UDipPCT 0,014 0,035 329,191 PCTFRAVI -0,088 0,030 328,151 PCTIMGRE 0,237 0,049 321,723 AvecEnf 0,001 0,032 314,079 FranPCT 0,052 0,016 316,295 Répartition de la variance Variance (niveau 1) 12,121 Variance (niveau 2) 80,347 Coefficient de corrélation intraclasse 0,131 Qualité dajustement du modèle AIC 78 776,845 R2 marginal 0,160 R2 conditionnel 0,270 10.2.2.4 Modèle avec une interaction entre deux niveaux Dans la section 7.5.4, nous avons vu comment introduire des variables dinteraction dans une régression linéaire multiple, soit entre deux variables continues (section 7.5.4.1), soit entre une variable continue et une variable dichotomique (section 7.5.4.2), soit entre deux variables dichotomiques (section 7.5.4.3). En analyse multiniveau, il peut être pertinent dintroduire une interaction entre une variable mesurée au niveau 1 et une autre mesurée au niveau 2 (équation (10.5)). \\[\\begin{equation} \\begin{aligned} &amp;Y \\sim Normal(\\mu,\\sigma_e)\\\\ &amp;g(\\mu) = \\underbrace{\\beta_0 + \\beta_1 x_1}_{\\mbox{effets fixes (niv. 1)}}+ \\underbrace{\\beta_2 z_2}_{\\mbox{effets fixes (niv. 2)}}+ \\underbrace{\\beta_3 (x_1 \\times z_2)}_{\\mbox{interaction (niv. 1 et 2)}}+ \\epsilon \\\\ &amp;\\upsilon \\sim Normal(0, \\sigma_{\\upsilon})) \\\\ &amp;g(x) = x \\end{aligned} \\tag{10.5} \\end{equation}\\] Dans le tableau 10.6, nous introduisons une variable dinteraction entre la distance entre le bâtiment et la rue (Setback.c) et le pourcentage de personnes à faible revenu (PCTFRAVI). On constate alors que PCTFRAVI est associé négativement avec la variable dépendante (\\(\\beta =\\) 0,079, t = 2,684). Toutefois, lorsquelle est mise en interaction avec la variable Setback.c, cette variable est significative et positive (\\(\\beta =\\) 0,008, t = 4,591). Tableau 10.6: Résultats du modèle avec une variable dinteraction entre les deux niveaux 1 et 2 (modèle 4) Paramètre Coefficient Erreur type Valeur de T Effets fixes (niveau 1 : tronçons) Constante -0,009 3,198 313,170 Width.c -0,136 0,013 10 763,142 Length.c 0,011 0,002 10 730,154 AgeMed.c 1,092 0,185 10 781,041 AgeMed2.c 0,000 0,000 10 779,196 ResiPCT.c 0,046 0,003 10 778,148 DuTriPct.c -0,013 0,003 10 592,140 NoLog.c 0,145 0,011 10 793,158 Setback.c 0,003 0,048 10 757,245 Effets fixes (niveau 2 : secteurs de recensement) ValLog 0,016 0,004 311,944 UDipPCT 0,009 0,035 328,840 PCTFRAVI -0,079 0,029 332,194 PCTIMGRE 0,219 0,048 326,135 AvecEnf -0,007 0,032 313,551 FranPCT 0,050 0,016 316,142 Variable dinteraction (niv. 1 et 2) Setback X PCTFRAVI 0,008 0,002 10 470,185 Répartition de la variance Variance (niveau 1) 11,829 Variance (niveau 2) 80,239 Coefficient de corrélation intraclasse 0,128 Qualité dajustement du modèle AIC 78 768,659 R2 marginal 0,163 R2 conditionnel 0,270 References "],["sect103.html", "10.3 Conditions dapplication des régressions multiniveaux", " 10.3 Conditions dapplication des régressions multiniveaux Puisque les modèles multiniveaux sont une extension des modèles à effets mixtes (GLMM), nous retrouvons globalement les mêmes conditions dapplication (voir la section 9.3), dont les principales sont : labsence de multicolinéarité excessive, la normalité des résidus, labsence dobservations trop influentes dans le modèle. Combien de groupes au niveau 2? Dans la section 9.3, nous avons vu que dans un modèle GLMM, plusieurs auteur(e)s, notamment Gelman et Hill (2006), préconisent un minimum de cinq groupes dans un modèle à effets mixtes. Toutefois, dans un modèle complet dune régression multiniveau, nous introduisons aussi des variables indépendantes au niveau 2. Par conséquent, le nombre de groupes doit être augmenté significativement, et ce, idéalement proportionnellement au nombre des variables indépendantes ajoutées au niveau 2. En ce sens, Bressoux (2010, 325) conseille davoir au moins 10 groupes pour chaque variable indépendante mesurée au niveau 2. Toujours selon Bressoux (2010, 325), certains auteurs recommandent même 20 groupes par variable indépendante au niveau 2. En conséquence, bien quaucune règle de pouce soit clairement admise, il est clair quun modèle complet multiniveau nécessite un nombre de groupes conséquent. References "],["sect104.html", "10.4 Mise en uvre dans R", " 10.4 Mise en uvre dans R Pour mettre en uvre des modèles multiniveaux avec une variable dépendante continue, nous utilisons la fonction lmer du package lme4. Pour dautres distributions, nous pouvons utiliser la fonction glmer implémentant différentes familles de modèles GLM, notamment binomiale (modèle multiniveau logistique), gaussien, Gamma, inverse gaussien, Poisson, Quasi-poisson, etc. Comme pour les modèles GLMM, lorsque dautres distributions sont nécessaires, il est possible dutiliser le package gamlss. 10.4.1 Le modèle vide Dans le code R ci-dessous, la syntaxe lmer(PCTArb ~ 1 + (1| SRNOM), data = Multiniveau) permet de construire le modèle vide avec la variable indépendante PCTArb et SRNOM comme variable définissant les groupes au niveau 2, soit les 312 secteurs de recensement. À titre de rappel, le modèle vide ne comprend aucune variable indépendante. library(&quot;lme4&quot;) library(&quot;MuMIn&quot;) # chargement du jeu de données load(&quot;data/multiniveau/dataArbres.RData&quot;) # MODÈLE 1 : modèle vide (sans prédicteurs) #------------------------------------------------------ # Écrire Y ~ 1 signifie que le modèle est vide # 1| SRNOM : signifie que l&#39;on fait varier la constante avec la variable SRNOM Modele1 &lt;- lmer(PCTArb ~ 1 + (1| SRNOM), data = Multiniveau) # Nombre de groupes cat(&quot;nombre de groupes =&quot;, length(unique(Multiniveau$SRNOM))) ## nombre de groupes = 312 La fonction summary(Modele1) permet dafficher les résultats du modèle. Dans la section intitulée Random effects, la variance pour le niveau 2 (SRNOM (Intercept)) est de 19,82 contre 92,93 pour le niveau 1 (Residual). Le coefficient de corrélation intraclasse (ICC) est donc égal à \\(\\mbox{19,82 / (19,82+92,93)} \\times \\mbox{100 = 17,58}\\)%. # Résultats du modèle summary(Modele1) ## Linear mixed model fit by REML. t-tests use Satterthwaite&#39;s method [ ## lmerModLmerTest] ## Formula: PCTArb ~ 1 + (1 | SRNOM) ## Data: Multiniveau ## ## REML criterion at convergence: 80299.2 ## ## Scaled residuals: ## Min 1Q Median 3Q Max ## -1.9413 -0.5295 -0.2235 0.2175 8.4695 ## ## Random effects: ## Groups Name Variance Std.Dev. ## SRNOM (Intercept) 19.82 4.452 ## Residual 92.93 9.640 ## Number of obs: 10814, groups: SRNOM, 312 ## ## Fixed effects: ## Estimate Std. Error df t value Pr(&gt;|t|) ## (Intercept) 7.3373 0.2772 314.9183 26.47 &lt;2e-16 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 Notez quil est possible dobtenir directement la valeur de lICC avec la fonction icc(Modele1) du package performance et les statistiques dajustement du modèle avec les fonctions logLik, AIC et BIC. # Calcul de l&#39;ICC (coefficient intraclasse) performance::icc(Modele1) ## # Intraclass Correlation Coefficient ## ## Adjusted ICC: 0.176 ## Conditional ICC: 0.176 ICC1 &lt;- performance::icc(Modele1) cat(&quot;Part de la variance de la variable dépendante imputable au niveau 2 : &quot;, round(ICC1$ICC_adjusted*100,2), &quot;%&quot;, sep=&quot;&quot;) ## Part de la variance de la variable dépendante imputable au niveau 2 : 17.58% # Qualité d&#39;ajustement du modèle cat(&quot;Statistiques d&#39;ajustement du modèle :&quot;, &quot;\\n-2 Log V = &quot;, -2*logLik(Modele1), &quot;\\nAIC =&quot;, AIC(Modele1), &quot;\\nBIC =&quot;, BIC(Modele1)) ## Statistiques d&#39;ajustement du modèle : ## -2 Log V = 80299.22 ## AIC = 80305.22 ## BIC = 80327.08 10.4.2 Modèle avec les variables indépendantes du niveau 1 Le second modèle consiste à introduire les variables indépendantes mesurées pour les tronçons de rue (niveau 1). Notez comment sont centrées préalablement les variables explicatives. # Centrage des variables indépendantes VINiv1 &lt;- c(&quot;Width&quot;,&quot;Length&quot;,&quot;AgeMed&quot;,&quot;AgeMed2&quot;,&quot;ResiPCT&quot;,&quot;DuTriPct&quot;,&quot;NoLog&quot;,&quot;Setback&quot;) for (e in VINiv1){ e.c &lt;- paste(e, &quot;.c&quot;, sep=&quot;&quot;) Multiniveau[[e.c]] &lt;- Multiniveau[[e]] - mean(Multiniveau[[e]]) } # MODÈLE 2 : modèle avec les prédicteurs au niveau 1 (rues) # ------------------------------------------------------ Modele2 &lt;- lmer(PCTArb ~ # Variables indépendantes au niveau 1 Width.c+Length.c+AgeMed.c+AgeMed2.c+ResiPCT.c+DuTriPct.c+NoLog.c+Setback.c+ (1| SRNOM), data = Multiniveau) # Résultats du modèle summary(Modele2) ## Linear mixed model fit by REML. t-tests use Satterthwaite&#39;s method [ ## lmerModLmerTest] ## Formula: PCTArb ~ Width.c + Length.c + AgeMed.c + AgeMed2.c + ResiPCT.c + ## DuTriPct.c + NoLog.c + Setback.c + (1 | SRNOM) ## Data: Multiniveau ## ## REML criterion at convergence: 78763.8 ## ## Scaled residuals: ## Min 1Q Median 3Q Max ## -2.9065 -0.5536 -0.1941 0.2569 9.4205 ## ## Random effects: ## Groups Name Variance Std.Dev. ## SRNOM (Intercept) 15.26 3.907 ## Residual 80.32 8.962 ## Number of obs: 10814, groups: SRNOM, 312 ## ## Fixed effects: ## Estimate Std. Error df t value Pr(&gt;|t|) ## (Intercept) 7.228e+00 2.479e-01 3.183e+02 29.151 &lt; 2e-16 *** ## Width.c -1.292e-01 1.272e-02 1.075e+04 -10.160 &lt; 2e-16 *** ## Length.c 1.085e-02 1.717e-03 1.073e+04 6.322 2.69e-10 *** ## AgeMed.c 1.103e+00 1.856e-01 1.080e+04 5.946 2.83e-09 *** ## AgeMed2.c -2.950e-04 4.791e-05 1.080e+04 -6.158 7.62e-10 *** ## ResiPCT.c 4.699e-02 3.466e-03 1.080e+04 13.558 &lt; 2e-16 *** ## DuTriPct.c -1.299e-02 2.683e-03 1.070e+04 -4.842 1.30e-06 *** ## NoLog.c 1.473e-01 1.057e-02 1.080e+04 13.938 &lt; 2e-16 *** ## Setback.c 2.018e-01 2.295e-02 1.080e+04 8.792 &lt; 2e-16 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Correlation of Fixed Effects: ## (Intr) Wdth.c Lngth. AgMd.c AgMd2. RsPCT. DTrPc. NoLg.c ## Width.c -0.003 ## Length.c 0.011 -0.216 ## AgeMed.c 0.000 0.010 -0.014 ## AgeMed2.c 0.002 -0.011 0.013 -1.000 ## ResiPCT.c 0.056 0.095 0.208 0.023 -0.024 ## DuTriPct.c -0.010 0.022 0.086 -0.074 0.077 0.025 ## NoLog.c -0.030 0.156 -0.785 -0.008 0.009 -0.269 -0.127 ## Setback.c 0.048 -0.018 -0.146 0.007 -0.008 -0.014 0.035 0.038 ## fit warnings: ## Some predictor variables are on very different scales: consider rescaling # Calcul de l&#39;ICC (coefficient intraclasse) performance::icc(Modele2) ## # Intraclass Correlation Coefficient ## ## Adjusted ICC: 0.160 ## Conditional ICC: 0.139 ICC2 &lt;- performance::icc(Modele2) cat(&quot;Part de la variance de la variable dépendante &quot;, &quot;\\nimputable au niveau 2 : &quot;, round(ICC2$ICC_adjusted*100,2), &quot;%&quot;, sep=&quot;&quot;) ## Part de la variance de la variable dépendante ## imputable au niveau 2 : 15.97% # Calcul des R2 conditionnel et marginal avec les fonctions # r.squaredGLMM ou r2_nakagawa du package performance r.squaredGLMM(Modele2) ## R2m R2c ## [1,] 0.1292872 0.2683329 r2_nakagawa(Modele2) ## # R2 for Mixed Models ## ## Conditional R2: 0.268 ## Marginal R2: 0.129 # Qualité d&#39;ajustement du modèle cat(&quot;Statistiques d&#39;ajustement du modèle&quot;, &quot;\\n-2 Log L = &quot;, -2*logLik(Modele2), &quot;\\nAIC =&quot;, AIC(Modele2), &quot;\\nBIC =&quot;, BIC(Modele2)) ## Statistiques d&#39;ajustement du modèle ## -2 Log L = 78763.83 ## AIC = 78785.83 ## BIC = 78866 10.4.3 Modèle avec les variables indépendantes aux niveaux 1 et 2 Le troisième modèle comprend à la fois les variables indépendantes mesurées aux deux niveaux (tronçons et secteurs de recensement). # MODÈLE 3 : modèle complet avec les prédicteurs aux niveaux 1 et 2 # ------------------------------------------------------ Modele3 &lt;- lmer(PCTArb ~ # Variables indépendantes au niveau 1 Width.c+Length.c+AgeMed.c+AgeMed2.c+ResiPCT.c+DuTriPct.c+NoLog.c+Setback.c+ # Variables indépendantes au niveau 2 ValLog+UDipPCT+PCTFRAVI+PCTIMGRE+AvecEnf+FranPCT+ (1| SRNOM), data = Multiniveau) # Résultats du modèle summary(Modele3) ## Linear mixed model fit by REML. t-tests use Satterthwaite&#39;s method [ ## lmerModLmerTest] ## Formula: PCTArb ~ Width.c + Length.c + AgeMed.c + AgeMed2.c + ResiPCT.c + ## DuTriPct.c + NoLog.c + Setback.c + ValLog + UDipPCT + PCTFRAVI + ## PCTIMGRE + AvecEnf + FranPCT + (1 | SRNOM) ## Data: Multiniveau ## ## REML criterion at convergence: 78742.8 ## ## Scaled residuals: ## Min 1Q Median 3Q Max ## -3.0461 -0.5558 -0.1939 0.2622 9.4190 ## ## Random effects: ## Groups Name Variance Std.Dev. ## SRNOM (Intercept) 12.12 3.482 ## Residual 80.35 8.964 ## Number of obs: 10814, groups: SRNOM, 312 ## ## Fixed effects: ## Estimate Std. Error df t value Pr(&gt;|t|) ## (Intercept) -5.175e-01 3.227e+00 3.136e+02 -0.160 0.87271 ## Width.c -1.319e-01 1.271e-02 1.076e+04 -10.375 &lt; 2e-16 *** ## Length.c 1.076e-02 1.717e-03 1.073e+04 6.265 3.87e-10 *** ## AgeMed.c 1.097e+00 1.854e-01 1.078e+04 5.920 3.31e-09 *** ## AgeMed2.c -2.936e-04 4.785e-05 1.078e+04 -6.136 8.75e-10 *** ## ResiPCT.c 4.649e-02 3.482e-03 1.078e+04 13.352 &lt; 2e-16 *** ## DuTriPct.c -1.268e-02 2.677e-03 1.061e+04 -4.737 2.20e-06 *** ## NoLog.c 1.478e-01 1.057e-02 1.079e+04 13.985 &lt; 2e-16 *** ## Setback.c 1.944e-01 2.307e-02 1.079e+04 8.428 &lt; 2e-16 *** ## ValLog 1.591e-02 3.856e-03 3.127e+02 4.126 4.75e-05 *** ## UDipPCT 1.405e-02 3.546e-02 3.292e+02 0.396 0.69221 ## PCTFRAVI -8.837e-02 2.958e-02 3.282e+02 -2.988 0.00302 ** ## PCTIMGRE 2.367e-01 4.860e-02 3.217e+02 4.870 1.76e-06 *** ## AvecEnf 5.778e-04 3.226e-02 3.141e+02 0.018 0.98572 ## FranPCT 5.213e-02 1.638e-02 3.163e+02 3.183 0.00160 ** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## fit warnings: ## Some predictor variables are on very different scales: consider rescaling # Qualité d&#39;ajustement du modèle cat(&quot;Statistiques d&#39;ajustement du modèle&quot;, &quot;\\n-2 Log L = &quot;, -2*logLik(Modele3), &quot;\\nAIC =&quot;, AIC(Modele3), &quot;\\nBIC =&quot;, BIC(Modele3)) ## Statistiques d&#39;ajustement du modèle ## -2 Log L = 78742.85 ## AIC = 78776.85 ## BIC = 78900.75 # Calcul de l&#39;ICC (coefficient intraclasse) performance::icc(Modele3) ## # Intraclass Correlation Coefficient ## ## Adjusted ICC: 0.131 ## Conditional ICC: 0.110 ICC3 &lt;- performance::icc(Modele3) cat(&quot;Part de la variance de la variable dépendante &quot;, &quot;\\nimputable au niveau 2 : &quot;, round(ICC3$ICC_adjusted*100,2), &quot;%&quot;, sep=&quot;&quot;) ## Part de la variance de la variable dépendante ## imputable au niveau 2 : 13.11% # Calcul des R2 conditionnel et marginal avec les fonctions # r.squaredGLMM ou r2_nakagawa du package performance r.squaredGLMM(Modele3) ## R2m R2c ## [1,] 0.1598477 0.269979 r2_nakagawa(Modele3) ## # R2 for Mixed Models ## ## Conditional R2: 0.270 ## Marginal R2: 0.160 10.4.4 Modèle complet avec une interaction Le quatrième modèle consiste à ajouter au modèle complet une interaction entre deux variables des deux niveaux. # Variance d&#39;interaction Multiniveau$PCTFRAVI_Setback &lt;- Multiniveau$PCTFRAVI * Multiniveau$Setback.c # MODÈLE 4 : interaction aux deux niveaux # ------------------------------------------------------ Modele4 &lt;- lmer(PCTArb ~ # Variables indépendantes au niveau 1 Width.c+Length.c+AgeMed.c+AgeMed2.c+ResiPCT.c+DuTriPct.c+NoLog.c+Setback.c+ # Variables indépendantes au niveau 2 ValLog+UDipPCT+PCTFRAVI+PCTIMGRE+AvecEnf+FranPCT+ # Variable d&#39;interaction PCTFRAVI_Setback+ (1| SRNOM), data = Multiniveau) # Résultats du modèle summary(Modele4) ## Linear mixed model fit by REML. t-tests use Satterthwaite&#39;s method [ ## lmerModLmerTest] ## Formula: PCTArb ~ Width.c + Length.c + AgeMed.c + AgeMed2.c + ResiPCT.c + ## DuTriPct.c + NoLog.c + Setback.c + ValLog + UDipPCT + PCTFRAVI + ## PCTIMGRE + AvecEnf + FranPCT + PCTFRAVI_Setback + (1 | SRNOM) ## Data: Multiniveau ## ## REML criterion at convergence: 78732.7 ## ## Scaled residuals: ## Min 1Q Median 3Q Max ## -3.0148 -0.5568 -0.1922 0.2598 9.4261 ## ## Random effects: ## Groups Name Variance Std.Dev. ## SRNOM (Intercept) 11.83 3.439 ## Residual 80.24 8.958 ## Number of obs: 10814, groups: SRNOM, 312 ## ## Fixed effects: ## Estimate Std. Error df t value Pr(&gt;|t|) ## (Intercept) -9.484e-03 3.198e+00 3.132e+02 -0.003 0.99764 ## Width.c -1.357e-01 1.273e-02 1.076e+04 -10.660 &lt; 2e-16 *** ## Length.c 1.079e-02 1.716e-03 1.073e+04 6.289 3.32e-10 *** ## AgeMed.c 1.092e+00 1.852e-01 1.078e+04 5.894 3.88e-09 *** ## AgeMed2.c -2.923e-04 4.780e-05 1.078e+04 -6.114 1.00e-09 *** ## ResiPCT.c 4.608e-02 3.480e-03 1.078e+04 13.239 &lt; 2e-16 *** ## DuTriPct.c -1.268e-02 2.674e-03 1.059e+04 -4.742 2.14e-06 *** ## NoLog.c 1.454e-01 1.057e-02 1.079e+04 13.747 &lt; 2e-16 *** ## Setback.c 3.443e-03 4.759e-02 1.076e+04 0.072 0.94233 ## ValLog 1.582e-02 3.820e-03 3.119e+02 4.141 4.46e-05 *** ## UDipPCT 9.404e-03 3.515e-02 3.288e+02 0.268 0.78920 ## PCTFRAVI -7.883e-02 2.937e-02 3.322e+02 -2.684 0.00764 ** ## PCTIMGRE 2.194e-01 4.829e-02 3.261e+02 4.543 7.82e-06 *** ## AvecEnf -7.063e-03 3.199e-02 3.136e+02 -0.221 0.82542 ## FranPCT 4.987e-02 1.623e-02 3.161e+02 3.072 0.00231 ** ## PCTFRAVI_Setback 8.169e-03 1.779e-03 1.047e+04 4.591 4.46e-06 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## fit warnings: ## Some predictor variables are on very different scales: consider rescaling # Qualité d&#39;ajustement du modèle cat(&quot;Statistiques d&#39;ajustement du modèle&quot;, &quot;\\n-2 Log L = &quot;, -2*logLik(Modele4), &quot;\\nAIC =&quot;, AIC(Modele3), &quot;\\nBIC =&quot;, BIC(Modele4)) ## Statistiques d&#39;ajustement du modèle ## -2 Log L = 78732.66 ## AIC = 78776.85 ## BIC = 78899.85 # Calcul de l&#39;ICC (coefficient intraclasse) performance::icc(Modele4) ## # Intraclass Correlation Coefficient ## ## Adjusted ICC: 0.128 ## Conditional ICC: 0.108 ICC4 &lt;- performance::icc(Modele4) cat(&quot;Part de la variance de la variable dépendante &quot;, &quot;\\nimputable au niveau 2 : &quot;, round(ICC4$ICC_adjusted*100,2), &quot;%&quot;, sep=&quot;&quot;) ## Part de la variance de la variable dépendante ## imputable au niveau 2 : 12.85% # Calcul des R2 conditionnel et marginal avec les fonctions # r.squaredGLMM ou r2_nakagawa du package performance r.squaredGLMM(Modele4) ## R2m R2c ## [1,] 0.1628372 0.270394 r2_nakagawa(Modele4) ## # R2 for Mixed Models ## ## Conditional R2: 0.270 ## Marginal R2: 0.163 10.4.5 Comparaison des quatre modèles Pour comparer les modèles, nous utilisons habituellement les statistiques dajustement du modèle vues plus haut, soit le maximum de vraisemblance (2 Log-likelihood), lAIC, lICC et les R2 marginal et conditionnel. c_logLik &lt;- c(logLik(Modele1),logLik(Modele2),logLik(Modele3),logLik(Modele4)) ICC &lt;- c(performance::icc(Modele1)$ICC_adjusted, performance::icc(Modele2)$ICC_adjusted, performance::icc(Modele3)$ICC_adjusted, performance::icc(Modele4)$ICC_adjusted) R2m &lt;- c(r.squaredGLMM(Modele1)[1], r.squaredGLMM(Modele2)[1], r.squaredGLMM(Modele3)[1], r.squaredGLMM(Modele4)[1]) R2c &lt;- c(r.squaredGLMM(Modele1)[2], r.squaredGLMM(Modele2)[2], r.squaredGLMM(Modele3)[2], r.squaredGLMM(Modele4)[2]) print(data.frame( Modele = c(&quot;Modèle 1 (vide)&quot;, &quot;Modèle 2 (VI : niv. 1)&quot;, &quot;Modèle 3 (VI : niv. 1 et 2)&quot;, &quot;Modèle 4 (interaction niv. 1 et 2&quot;), dl = AIC(Modele1, Modele2, Modele3, Modele4)$df, Moins2LogLik = round(-2*c_logLik,0), AIC = round(AIC(Modele1, Modele2, Modele3, Modele4)$AIC,0), ICC = round(ICC,4), R2marg = round(R2m,3), R2cond = round(R2c,3) )) ## Modele dl Moins2LogLik AIC ICC R2marg R2cond ## 1 Modèle 1 (vide) 3 80299 80305 0.1758 0.000 0.176 ## 2 Modèle 2 (VI : niv. 1) 11 78764 78786 0.1597 0.129 0.268 ## 3 Modèle 3 (VI : niv. 1 et 2) 17 78743 78777 0.1311 0.160 0.270 ## 4 Modèle 4 (interaction niv. 1 et 2 18 78733 78769 0.1285 0.163 0.270 Vous constaterez ci-dessus que les valeurs dAIC et de -2 log de vraisemblance diminuent des modèles 1 à 4, signalant une amélioration progressive des modèles. Cela se traduit aussi par une augmentation du R2 conditionnel incluant à la fois les effets fixes et aléatoires. Sans surprise, la valeur du coefficient de corrélation intraclasse diminue du modèle vide au modèle complet : plus nous ajoutons de variables dépendantes, plus la capacité explicative du niveau 2 diminue. Il est également judicieux de vérifier si un modèle est significativement différent du modèle précédent avec la fonction anova qui compare les différences de leurs déviances. En guise dexemple, la différence de déviance de 59 (\\(\\mbox{78 625}-\\mbox{78 684}=\\mbox{59}\\)) entre les modèles 3 et 2 (modèle complet versus modèle GLMM) avec six degrés de liberté  puisque le modèle 3 inclut six variables indépendantes de plus que le précédent (\\(\\mbox{17}-\\mbox{11}=\\mbox{6}\\))  est significative (p &lt; 0,001). Cela indique que le modèle 3 est plus performant que le précédent. anova(Modele1, Modele2, Modele3, Modele4) ## Data: Multiniveau ## Models: ## Modele1: PCTArb ~ 1 + (1 | SRNOM) ## Modele2: PCTArb ~ Width.c + Length.c + AgeMed.c + AgeMed2.c + ResiPCT.c + ## Modele2: DuTriPct.c + NoLog.c + Setback.c + (1 | SRNOM) ## Modele3: PCTArb ~ Width.c + Length.c + AgeMed.c + AgeMed2.c + ResiPCT.c + ## Modele3: DuTriPct.c + NoLog.c + Setback.c + ValLog + UDipPCT + PCTFRAVI + ## Modele3: PCTIMGRE + AvecEnf + FranPCT + (1 | SRNOM) ## Modele4: PCTArb ~ Width.c + Length.c + AgeMed.c + AgeMed2.c + ResiPCT.c + ## Modele4: DuTriPct.c + NoLog.c + Setback.c + ValLog + UDipPCT + PCTFRAVI + ## Modele4: PCTIMGRE + AvecEnf + FranPCT + PCTFRAVI_Setback + (1 | SRNOM) ## npar AIC BIC logLik deviance Chisq Df Pr(&gt;Chisq) ## Modele1 3 80304 80326 -40149 80298 ## Modele2 11 78706 78786 -39342 78684 1614.351 8 &lt; 2.2e-16 *** ## Modele3 17 78659 78783 -39313 78625 59.131 6 6.758e-11 *** ## Modele4 18 78640 78771 -39302 78604 21.166 1 4.213e-06 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 "],["sect105.html", "10.5 Quiz de révision du chapitre", " 10.5 Quiz de révision du chapitre Quels sont les deux intérêts majeurs des modèles multiniveaux? Relisez au besoin la section 10.1. Analyser la répartition de la variance entre les différents niveaux Introduire des variables explicatives aux différents niveaux du modèle construire des splines Le modèle vide comprend : Relisez au besoin la section 10.2.2.1. aucune variable explicative plusieurs variables explicatives aux niveaux 1 et 2 Un modèle avec uniquement les variables indépendantes du niveau 1 est un modèle à effets mixtes (GLMM). Relisez au besoin la section 10.2.2.2. Vrai Faux Quelle mesure permet danalyser la répartition de la variance entre les deux niveaux? Relisez au besoin la section 10.2.2.1. Coefficients de régression Coefficient de corrélation intraclasse AIC Un modèle complet comprend des variables explicatives aux deux niveaux. Relisez au besoin la section 10.2.2.3. Vrai Faux Est-ce possible dintroduire une interaction entre une variable mesurée au niveau 1 et une autre mesurée au niveau 2? Relisez au besoin la section 10.2.2.4. Vrai Faux Verifier Votre score "],["chap11.html", "Chapitre 11 Modèles généralisés additifs", " Chapitre 11 Modèles généralisés additifs Dans les précédents chapitres, nous avons eu loccasion dexplorer toute une panoplie de modèles : régressions linéaires, modèles généralisés, modèles généralisés à effets mixtes et modèles multiniveaux. Dans ce chapitre, nous abordons une nouvelle extension dans le monde des régressions : les modèles généralisés additifs (Generalized additive model en anglais  GAM). Cette extension a pour but de permettre de modéliser des relations non linéaires entre les variables indépendantes et la variable dépendante. Dans ce chapitre, nous utilisons principalement les packages suivants : Pour créer des graphiques : ggplot2 le seul, lunique! ggpubr pour combiner des graphiques et réaliser des diagrammes. metR pour placer des étiquettes sur des isolignes. Pour jouer avec des splines : splines2 pour construire les fonctions de base de nombreuses splines. segmented pour ajuster des modèles avec des coefficients variant par segment. Pour ajuster des modèles GAM : mgcv, le package de référence pour ajuster des GAM dans R! gamlss, un second package très flexible pour ajuster des GAM. gamlss.add, une extension de gamlss ajoutant des distributions supplémentaires. Pour analyser des modèles GAM : itsadug pour notamment extraire certains résultats dun GAM. mixedup pour notamment extraire les effets aléatoires dun GAM. DHARMa pour le diagnostic des résidus simulés. "],["sect111.html", "11.1 Introduction", " 11.1 Introduction Puisque les modèles GAM sont une extension des modèles GLM, ils peuvent sappliquer à des modèles pour des variables indépendantes qualitatives, de comptage ou continues. Nous lappliquons ici, à titre dillustration, à une variable indépendante continue. Pour rappel, la formule décrivant un modèle linéaire généralisé (GLM) utilisant une distribution normale et une fonction de lien identitaire est la suivante : \\[\\begin{equation} \\begin{aligned} &amp;Y \\sim Normal(\\mu,\\sigma)\\\\ &amp;g(\\mu) = \\beta_0 + \\beta X\\\\ &amp;g(x) = x \\end{aligned} \\tag{11.1} \\end{equation}\\] Les coefficients \\(\\beta\\) permettent de quantifier leffet des variables indépendantes (X) sur la moyenne (lespérance) (\\(\\mu\\)) de la variable dépendante (Y). Un coefficient \\(\\beta_k\\) négatif indique que, si la variable \\(X_k\\) augmente, alors la variable Y tend à diminuer et inversement, si le coefficient est positif. Linconvénient de cette formulation est que le modèle est capable de capter uniquement des relations linéaires entre ces variables. Or, il existe de nombreuses situations dans lesquelles une variable indépendante a un lien non linéaire avec une variable dépendante; voici quelques exemples : Si nous mesurons le niveau de bruit émis par une source sonore (variable dépendante) à plusieurs endroits et que nous tentons de prédire lintensité sonore en fonction de la distance à la source (variable indépendante), nous pouvons nous attendre à observer une relation non linéaire entre les deux. En effet, le son étant une énergie se dispersant selon une sphère dans lespace, son intensité est inversement proportionnelle au carré de la distance avec la source sonore. La concentration de la pollution atmosphérique en ville suit généralement des patrons temporels et spatiaux influencés directement par la météorologie et les activités humaines. Autrement dit, il serait absurde dintroduire lespace de façon linéaire (avec un gradient nord-sud ou est-ouest), ou le moment de la journée de façon linéaire (comme si la pollution augmentait du matin au soir ou inversement). En guise dexemple, la figure 11.1, tirée de Gelb et Apparicio (2020), illustre bien ces variations temporelles pour deux polluants (le dioxyde dazote et lozone). Figure 11.1: Patron journalier du dioxyde dazote et de lozone à Paris 11.1.1 Non linéarité fonctionnelle Il existe de nombreuses façons dintroduire des relations non linéaires dans un modèle. La première et la plus simple à mettre en oeuvre est de transformer la variable indépendante à laide dune fonction inverse, exponentielle, logarithmique ou autre. Prenons un premier exemple avec une variable Y que nous tentons de prédire avec une variable X, présenté à la figure 11.2. Si nous ajustons une droite de régression à ces données (en bleu), nous constatons que laugmentation de X est associée à une augmentation de Y. Cependant, la droite de régression est très éloignée des données et ne capte quune petite partie de la relation. Une lecture attentive permet de constater que leffet de X sur Y augmente de plus en plus rapidement à mesure que X augmente. Cette forme est caractéristique dune relation exponentielle. Nous pouvons donc transformer la variable X avec la fonction exponentielle afin dobtenir un meilleur ajustement (en rouge). Figure 11.2: Relation non linéaire exponentielle La figure 11.3 illustre trois autres situations avec les fonctions logarithmique, logistique inverse et racine carrée. Cette approche peut donner des résultats intéressants si vous disposez dune bonne justification théorique sur la forme attendue de la relation entre X et Y. Figure 11.3: Autres relations non linéaires Il existe également des cas de figure dans lesquels aucune fonction ne donne de résultats pertinents, tel quillustré à la figure 11.4. Nous constatons facilement quaucune des fonctions proposées nest capable de bien capter la relation entre les deux variables. Puisque cette relation est complexe, il convient alors dutiliser une autre stratégie pour la modéliser. Figure 11.4: Relation non linéaire plus complexe 11.1.2 Non linéarité avec des polynomiales Nous avons vu, dans le chapitre sur la régression simple (section 7.5.1.1), quil est possible dutiliser des polynomiales pour ajuster des relations non linéaires. Pour rappel, il sagit simplement dajouter à un modèle la variable X à différents exposants (\\(X+X^2+\\dots+X^k\\)). Chaque exposant supplémentaire (chaque ordre supplémentaire) permet au modèle dajuster une relation plus complexe. Rien de tel quun graphique pour illustrer le tout (figure 11.5). Figure 11.5: Visualisation de plusieurs polynomiales Lenjeu est de sélectionner le bon nombre de degrés de la polynomiale pour le modèle. Chaque degré supplémentaire constitue une nouvelle variable dans le modèle, et donc un paramètre supplémentaire. Un trop faible nombre de degrés produit des courbes trop simplistes, alors quun nombre trop élevé conduit à un surajustement (overfitting en anglais) du modèle. La figure 11.6 illustre ces deux situations. Figure 11.6: Sur et sous-ajustement dune polynomiale Un des problèmes inhérents à lapproche des polynomiales est la difficulté dinterprétation. En effet, les coefficients ne sont pas directement interprétables et seule une figure représentant les prédictions du modèle permet davoir une idée de leffet de la variable X sur la variable Y. 11.1.3 Non linéarité par segments Un compromis intéressant offrant une interprétation simple et une relation potentiellement complexe consiste à découper la variable X en segments, puis dajuster un coefficient pour chacun de ces segments. Nous obtenons ainsi une ligne brisée et des coefficients faciles à interpréter (figure 11.7). Nous ne présentons pas dexemple dapplication dans R, mais sachez que le package segmented permets dajuster ce type de modèle. Figure 11.7: Régression par segment Lenjeu est alors de déterminer le nombre de points et la localisation de points de rupture. Linconvénient majeur de cette approche est quen réalité, peu de phénomènes sont marqués par des ruptures très nettes. À la figure 11.7, nous avons divisé la variable X en trois segments (\\(k_1\\), \\(k_2\\) et \\(k_3\\)), définis respectivement avec les intervalles suivants : [0,00-0,22], [0,22-0,41] et [0,41-1,00]. Concrètement, cela revient à diviser la variable X en trois nouvelles variables \\(X_{k1}\\), \\(X_{k2}\\), et \\(X_{k3}\\). La valeur de \\(X_{ik}\\) est égale à \\(x_i\\) si \\(x_i\\) se trouve dans lintervalle propre à k, et à 0 autrement. Ici, nous obtenons trois coefficients : le premier est positif, une augmentation de X sur le premier segment est associée à une augmentation de Y; le second est négatif, une augmentation de X sur le second segment est associée à une diminution de Y; le troisième est aussi négatif, une augmentation de X sur le troisième segment est associée à une diminution de Y, mais moins forte que pour le second segment. 11.1.4 Non linéarité avec des splines La dernière approche, et certainement la plus flexible, est dutiliser ce que lon appelle une spline pour capter des relations non linéaires. Une spline est une fonction créant des variables supplémentaires à partir dune variable X et dune fonction de base. Ces variables supplémentaires, appelées bases (basis en anglais), sont ajoutées au modèle; la sommation de leurs valeurs multipliées par leurs coefficients permet de capter les relations non linéaires entre une variable dépendante et une variable indépendante. Le nombre de bases et leur localisation (plus souvent appelé nuds) permettent de contrôler la complexité de la fonction non linéaire. Prenons un premier exemple simple avec une fonction de base triangulaire (tent basis en anglais). Nous créons ici une spline avec sept nuds répartis équitablement sur lintervalle de valeurs de la variable X. Les sept bases qui en résultent sont présentées à la figure 11.8. Dans cette figure, chaque sommet dun triangle correspond à un nud et chaque triangle correspond à une base. Figure 11.8: Bases de la spline triangulaire En ajoutant ces bases dans notre modèle de régression, nous pouvons ajuster un coefficient pour chacune et le représenter en multipliant ces bases par les coefficients obtenus avec une simple régression linéaire (figure 11.9). Figure 11.9: Spline triangulaire multipliée par ces coefficients Nous remarquons ainsi que les bases correspondant à des valeurs plus fortes de Y ont reçu des coefficients plus élevés. Pour reconstituer la fonction non linéaire, il suffit dadditionner ces bases multipliées par leurs coefficients, soit la ligne bleue à la figure 11.10. Figure 11.10: Spline triangulaire La fonction de base triangulaire est intéressante pour présenter la logique qui sous-tend les splines, mais elle est rarement utilisée en pratique. On lui préfère généralement dautre formes donnant des résultats plus lisses comme les B-spline quadratiques, B-spline cubiques, M-spline, Duchon spline, etc. Figure 11.11: Comparaison de différentes bases Les approches que nous venons de décrire sont regroupées sous lappellation de modèles additifs. Dans les prochaines sous-sections, nous nous concentrons davantage sur les splines du fait de leur plus grande flexibilité. References "],["sect112.html", "11.2 Spline de régression et spline de lissage", " 11.2 Spline de régression et spline de lissage Dans les exemples précédents, nous avons vu que la construction dune spline nécessite deffectuer deux choix importants : le nombre de nuds et leur localisation. Un trop grand nombre de nuds conduit à un surajustement du modèle alors quun trop faible nombre de nuds conduit à un sous-ajustement. Lorsque ces choix sont effectués par lutilisateur et que les bases sont ajoutées manuellement dans le modèle tel que décrit précédemment, nous parlons alors de splines de régression (Regression Spline en anglais). Une approche a été proposée pour faciliter le choix du nombre de nuds, il sagit de splines de lissage (smoothing spline en anglais). Lidée derrière cette approche est dintroduire dans le modèle une pénalisation associée avec le nombre de nuds (ou degré de liberté) de la spline, dans un souci de parcimonie : chaque noeud supplémentaire doit suffisamment contribuer au modèle pour être conservé. Il nest pas nécessaire ici de rentrer dans le détail mathématique de cette pénalisation qui est un peu complexe. Retenez simplement quelle dépend dun paramètre appelé \\(\\lambda\\) : plus \\(\\lambda\\) tend vers 0, plus la pénalisation est faible et plus la spline de lissage devient une simple spline de régression; à linverse, plus elle est forte, plus la pénalité est importante, au point que la spline peut se résumer à une simple ligne droite. Cela est illustré à la figure 11.12 comprenant trois splines avec 20 nuds et des valeurs \\(\\lambda\\) différentes contrôlant la force de la pénalité. Bien évidemment, nous constatons quavec la spline de régression (non pénalisée), 20 nuds conduisent à un fort surajustement du modèle. En revanche, les splines de lissage (pénalisées) permettent de corriger ce problème de surajustement. Toutefois, une valeur trop importante de \\(\\lambda\\) conduit à un sous-ajustement du modèle (ici \\(\\lambda = 3\\) et \\(\\lambda = 100\\), lignes verte et bleue). Figure 11.12: Pénalisation des splines Avec les splines de lissage, lenjeu est de sélectionner une valeur optimale de \\(\\lambda\\). Le plus souvent, les packages R estiment eux-mêmes ce paramètre à partir des données utilisées dans le modèle. Toutefois, gardez en mémoire que vous pouvez modifier ce paramètre. Mentionnons également que les splines de lissage peuvent être reparamétrées dans un modèle pour être intégrées comme des effets aléatoires. Dans ce cas-ci, \\(\\lambda\\) est remplacé par un simple paramètre de variance directement estimé dans le modèle (Wood 2004). References "],["sect113.html", "11.3 Interprétation dune spline", " 11.3 Interprétation dune spline Linterprétation dune spline se fait à laide de graphiques. En effet, puisquelle est composée dun ensemble de coefficients appliqués à des bases, il est difficile dinterpréter directement ces derniers. Nous préférons alors représenter la fonction obtenue à laide dun graphique, illustrant son effet marginal. Ce graphique est construit en trois étapes : Créer un jeu de données fictif dans lequel lensemble des variables indépendantes sont fixées à leurs moyennes respectives, sauf la variable pour laquelle nous souhaitons représenter la spline. Pour cette dernière, un ensemble de valeurs allant de son minimum à son maximum est utilisé; Utiliser le modèle pour prédire les valeurs attendues de la variable dépendante pour chacune des observations fictives ainsi créées; Afficher les prédictions obtenues dans un graphique. Notez ici quun graphique des effets marginaux se base sur les prédictions du modèle. Si un modèle est mal ajusté, les prédictions ne seront pas fiables et il sera inutile dinterpréter la spline obtenue. Il est aussi possible, dans le cas des splines de lissage, dinterpréter les estimated degrees of freedom (EDF) qui constituent une approximation du nombre de noeuds de la spline. Sils ne nous renseignent pas sur la forme de la spline, ils nous indiquent son niveau de complexité. Une spline avec un EDF de 1 est en réalité un simple terme linéaire. Plus lEDF augmente, plus la spline est complexe. "],["sect114.html", "11.4 Multicolinéarité non linéaire", " 11.4 Multicolinéarité non linéaire Lorsque des splines sont ajoutées dans un modèle, il est nécessaire de vérifier si ces dernières ne posent pas un problème de multicolinéarité. Cependant, le VIF ne peut plus être utilisé du fait de la non-linéarité des relations modélisées. Il est alors nécessaire dutiliser une autre mesure : la concurvité (concurvity) permettant de mesurer sur une échelle allant de 0 à 1 à quel point deux splines ont en réalité capturé le même effet et se substituent lune à lautre. Une valeur de 0 indique une absence totale de concurvité alors quune valeur de 1 indique que deux splines sont rigoureusement identiques (modèle non identifiable). "],["sect115.html", "11.5 Splines avancées", " 11.5 Splines avancées Jusquici, nous avons seulement présenté le cas le plus simple pour lequel une spline est construite à partir dune seule variable dépendante continue, mais les splines peuvent être utilisées dans de nombreux autres contextes et ont une incroyable flexibilité. Nous détaillons ici trois exemples fréquents : les splines cycliques, les splines variant par groupe et les splines multivariées. Pour une description complète des effets non linéaires possibles avec mgcv, nhésitez pas à consulter sa documentation. Tableau 11.1: Exemples de splines avancées Type Code Description spline cyclique s(x, bs = 'cc') Une spline cyclique doit être utilisée si le 0 de la variable X correspond également à sa valeur maximum. Un bon exemple est le temps dans une journée car 24 h est équivalent à 0 h spline variant par groupe s(x, by = x2) Une spline variant par groupe permet dajuster une spline à une variable X1 différente pour chaque groupe identifié par une variable qualitative X2 spline bivariée s(x1,x2) Une spline bivariée est utilisée pour modéliser linteraction non linéaire de deux variables X1 et X2 sexprimant dans la même unité (typiquement des coordonnées géographiques carthésienne) spline dinteraction complète te(x1,x2) Une spline dinteraction permet de modéliser linteraction non linéaire de deux variables continues pouvant sexprimer dans des unités différentes, elle combine les effets spécifique de chacune de des deux variables et leur interaction spline dinteraction partielle s(x1) + s(x2) + ti(x1,x2) Une spline dinteraction partielle permet de distinguer les effets non linéaires individuels de deux variables de leur interaction non linéaire 11.5.1 Splines cycliques Une spline cyclique est une extension dune spline classique dont les bases aux extrémités sont spécifiées de telle sorte que la valeur au départ de la spline soit la même que celle à la fin de la spline. Cela permet à la spline de former une boucle, ce qui est particulièrement intéressant pour des variables dont le 0 et la valeur maximale correspondent en réalité à la même valeur. Lexemple le plus parlant est certainement le cas dune variable représentant la mesure dun angle en degrés. Les valeurs de 0 et 360 sont identiques et les valeurs 350 et 10 sont toutes les deux à une distance de 10 degrés de 0. Un autre exemple possible serait de considérer lheure comme une variable continue; dans ce cas, 24 h et 0 h signifient la même chose. Prenons un exemple concret. Nous souhaitons modéliser la concentration de dioxyde dazote (NO2) à Paris, mesurée par un ensemble de stations fixes. Nous pourrions nous attendre à ce que le NO2 suive chaque jour un certain patron. Concrètement, à proximité daxes routiers majeurs, nous nous attendons à observer des pics suivant les flux pendulaires. À la figure 11.13, nous retrouvons bien les deux pics attendus correspondant aux heures de pointe du matin et du soir. Aussi, tel quindiqué par la ligne rouge, la valeur prédite par la spline est la même à 24 h et à 0 h. Figure 11.13: Spline cyclique pour modéliser la concentration de dioxyde dazote 11.5.2 Splines par groupe Tel quabordé dans les chapitres précédents, il arrive régulièrement que les observations appartiennent à différents groupes. Dans ce cas de figure, nous pouvons être amené à vérifier si la relation décrite par une spline est identique pour chacun des groupes dobservations. Il sagit alors dajuster une spline différente par groupe. Dans lexemple précédent, chaque valeur de NO2 a été mesurée par une station fixe de mesure spécifique. Compte tenu du fait que lenvironnement autour de chaque station est particulier, nous pourrions sattendre à ce que les valeurs de NO2 ne présentent pas exactement les mêmes patrons journaliers pour chaque station. À la figure 11.14, il est possible de constater que le NO2 suit globalement le même patron temporel pour lensemble des stations à lexception de trois dentres-elles. Il sagit en réalité de stations situées dans des secteurs ruraux de la région parisienne, et donc moins impactées par le trafic routier. Figure 11.14: Spline cyclique variant par groupe 11.5.3 Splines multivariées et splines dinteraction Jusquici, nous navons considéré que des splines ne sappliquant quà une seule variable indépendante; cependant, il est possible de construire des splines multivariées sajustant simultanément sur plusieurs variables indépendantes. Lobjectif est alors de modéliser les potentielles interactions non linéaires entre les variables indépendantes combinées dans une même spline. Prenons un exemple concret, dans la section sur les modèles GLM, nous avons modélisé la couverture des aires de diffusion (AD) à Montréal par des îlots de chaleur. Parmi les variables indépendantes, nous avons notamment utilisé la distance au centre-ville ainsi que la part de la surface végétalisée des AD. Nous pourrions formuler lhypothèse que ces deux variables influencent conjointement et de façon non linéaire la proportion de la surface dîlot de chaleur dans chaque AD. Pour représenter une spline sur plusieurs dimensions, nous utilisons alors une carte de chaleur dont la couleur représente la valeur de la variable dépendante prédite en fonction des deux variables indépendantes. Il est important de distinguer la spline dinteraction et la spline multivariée. La première est utilisée lorsque les variables indépendantes introduites dans la spline ne sont pas exprimées sur la même échelle et névoluent pas conjointement. Lexemple donné ci-dessus avec les variables de végétation et de distance au centre-ville est un exemple de spline dinteraction, la première variable étant exprimée en pourcentage et lautre en mètres. De plus, ces deux variables ne sont pas conjointes, mais bien distinctes lune de lautre. Un cas typique où une spline multivariée serait à privilégier est le cas de lajout des coordonnées spatiales dans le modèle. Lemplacement des AD est mesuré par deux variables (coordonnées spatiales x et y) toutes les deux exprimées en mètres évoluant conjointement, au sens où les coordonnées x ninteragissent pas avec les coordonnées y, mais forment à elles deux un espace propre. Au-delà de la problématique de léchelle des données, il est important de retenir que les splines dinteraction tendent à être davantage pénalisées que les splines multivariées. La spline dinteraction représentée à la figure 11.15 indique que les AD avec la plus grande proportion de leur surface couverte par des îlots de chaleur sont situées à moins de 25 kilomètres du centre-ville, au-delà de cette distance, cette proportion chute en bas de 0,1, soit 10 % de la surface de lAD. En revanche, à proximité du centre-ville (moins dun kilomètre), même les AD disposant dun fort pourcentage de surface végétalisée sont tout de même marquées par un fort pourcentage de surface couverte par des îlots de chaleur. Les splines bivariées sont fréquemment utilisées pour capturer un potentiel patron spatial dans les données. En effet, si nous disposons des coordonnées spatiales de chaque observation (x,y), il est possible dajuster une spline bivariée sur ces coordonnées, contrôlant ainsi leffet de lespace. Figure 11.15: Spline dinteraction bivariée Il ny a pas de limite théorique au nombre de variables qui peuvent être ajoutées dans une spline dinteraction ou multivariée. Notez cependant que plus le nombre de dimensions augmente, plus la fonction à estimer est complexe et plus le volume de données nécessaire est grand et doit couvrir densément lensemble de lespace déchantillonnage multidimensionnel. "],["sect116.html", "11.6 Mise en oeuvre dans R", " 11.6 Mise en oeuvre dans R Il est possible dajuster des splines de régression dans nimporte quel package permettant dajuster des coefficients pour un modèle de régression. Il suffit de construire les bases des splines en amont à laide du package splines2 et de les ajouter directement dans léquation de régression. En revanche, il est nécessaire dutiliser des packages spécialisés pour ajuster des splines de lissage. Parmi ceux-ci, mgcv est probablement le plus populaire du fait de sa (très) grande flexibilité, suivi des packages gamlss, gam et VGAM. Nous comparons ici les deux approches, puis nous tentons daméliorer le modèle que nous avons ajusté pour prédire le pourcentage de surface couverte par des îlots de chaleur dans les aires de diffusion de Montréal, dans une perspective déquité environnementale. Pour rappel, la variable dépendante est exprimée en pourcentage et nous utilisons une distribution bêta pour la modéliser. library(mgcv) # Chargement des données dataset &lt;- read.csv(&quot;data/gam/data_chaleur.csv&quot;,fileEncoding = &quot;utf8&quot;) # Ajustement du modèle de base refmodel &lt;- gam(hot ~ A65Pct + A014Pct + PopFRPct + PopMVPct + poly(prt_veg, degree = 2) + Arrond, data = dataset, family = betar(link = &quot;logit&quot;)) Dans notre première analyse de ces données, nous avons ajusté une polynomiale dordre 2 pour représenter un potentiel effet non linéaire de la végétation sur les îlots de chaleur. Nous remplaçons à présent ce terme par une spline de régression en sélectionnant quatre nuds. library(splines2) # Création des bases de la spline basis &lt;- bSpline(x = dataset$prt_veg, df =4, intercept = FALSE) # Ajouter les bases au DataFrame basisdf &lt;- as.data.frame(basis) names(basisdf) &lt;- paste(&#39;spline&#39;,1:ncol(basisdf),sep=&#39;&#39;) dataset &lt;- cbind(dataset, basisdf) # Ajuster le modèle model0 &lt;- gam(hot ~ A65Pct + A014Pct + PopFRPct + PopMVPct + spline1 + spline2 + spline3 + spline4 + Arrond, data = dataset, family = betar(link = &quot;logit&quot;)) Nous pouvons à présent ajuster une spline de lissage et laisser mgcv déterminer son niveau de complexité. # Ajustement du modèle avec une spline simple model1 &lt;- gam(hot ~ A65Pct + A014Pct + PopFRPct + PopMVPct + s(prt_veg) + Arrond, data = dataset, family = betar(link = &quot;logit&quot;)) Notez ici que la syntaxe à employer est très simple, il suffit de spécifier s(prt_veg) pour indiquer à la fonction gam que vous souhaitez ajuster une spline pour la variable prt_veg. Nous pouvons à présent comparer lajustement des deux modèles en utilisant la mesure de lAIC. # Comparaison des AIC AIC(refmodel, model0, model1) ## df AIC ## refmodel 40.00000 -6399.784 ## model0 42.00000 -6419.630 ## model1 44.61065 -6417.562 Nous constatons que la valeur de lAIC du second modèle est plus réduite, indiquant un meilleur ajustement du modèle avec une spline de régression. Notons cependant que la différence avec la spline de lissage est anecdotique (deux points de lAIC) et que nous connaissions a priori le bon nombre de nuds à utiliser. Pour des relations plus complexes, les splines de lissage ont tendance à nettement mieux performer. Voyons à présent comment représenter ces trois termes non linéaires. # Création d&#39;un DataFrame de prédiction dans lequel seule # la variable prt_veg varie. dfpred &lt;- data.frame( prt_veg = seq(min(dataset$prt_veg), max(dataset$prt_veg), 0.5), A65Pct = mean(dataset$A65Pct), A014Pct = mean(dataset$A014Pct), PopFRPct = mean(dataset$PopFRPct), PopMVPct = mean(dataset$PopMVPct), Arrond = &quot;Verdun&quot; ) # Recréation des bases de la spline de régression # pour les nouvelles observations nvl_bases &lt;- data.frame(predict(basis,newx = dfpred$prt_veg)) names(nvl_bases) &lt;- paste(&#39;spline&#39;,1:ncol(basisdf),sep=&#39;&#39;) dfpred &lt;- cbind(dfpred, nvl_bases) # Définition de la fonction inv.logit, soit l&#39;inverse de la fonction # de lien du modèle pour retrouver les prédictions dans l&#39;échelle # originales des données inv.logit &lt;- function(x){exp(x)/(1+exp(x))} # Utilisation des deux modèles pour effectuer les prédictions predref &lt;- predict(refmodel, newdata = dfpred, type = &#39;link&#39;, se.fit = T) predmod0 &lt;- predict(model0, newdata = dfpred, type = &#39;link&#39;, se.fit = T) predmod1 &lt;- predict(model1, newdata = dfpred, type = &#39;link&#39;, se.fit = T) # Calcul de la valeur prédite et construction des intervalles de confiance dfpred$polypred &lt;- inv.logit(predref$fit) dfpred$poly025 &lt;- inv.logit(predref$fit - 1.96 * predref$se.fit) dfpred$poly975 &lt;- inv.logit(predref$fit + 1.96 * predref$se.fit) dfpred$regsplinepred &lt;- inv.logit(predmod0$fit) dfpred$regspline025 &lt;- inv.logit(predmod0$fit - 1.96 * predmod0$se.fit) dfpred$regspline975 &lt;- inv.logit(predmod0$fit + 1.96 * predmod0$se.fit) dfpred$splinepred &lt;- inv.logit(predmod1$fit) dfpred$spline025 &lt;- inv.logit(predmod1$fit - 1.96 * predmod1$se.fit) dfpred$spline975 &lt;- inv.logit(predmod1$fit + 1.96 * predmod1$se.fit) # Créer un graphique pour afficher les résultats ggplot(dfpred) + geom_ribbon(aes(x = prt_veg, ymin = poly025, ymax = poly975), alpha = 0.4, color = &#39;grey&#39;) + geom_ribbon(aes(x = prt_veg, ymin = spline025, ymax = spline975), alpha = 0.4, color = &#39;grey&#39;) + geom_ribbon(aes(x = prt_veg, ymin = regspline025, ymax = regspline975), alpha = 0.4, color = &#39;grey&#39;) + geom_line(aes(y = polypred, x = prt_veg, color = &#39;polynomiale&#39;), size = 1) + geom_line(aes(y = regsplinepred, x = prt_veg, color = &#39;spline de régression&#39;), size = 1)+ geom_line(aes(y = splinepred, x = prt_veg, color = &#39;spline de lissage&#39;), size = 1) Figure 11.16: Comparaison dune spline et dune polynomiale Nous constatons que les trois termes renvoient des prédictions très similaires et quune légère différence nest observable que pour les secteurs avec les plus hauts niveaux de végétation (supérieurs à 75 %). Jusquici, nous utilisons larrondissement dans lequel est comprise chaque aire de diffusion comme une variable nominale afin de capturer la dimension spatiale du jeu de données. Puisque nous avons abordé la notion de splines bivariées, il serait certainement plus efficace den construire une à partir des coordonnées géographiques (x,y) des centroïdes des aires de diffusion. En effet, il est plus probable que la distribution des îlots de chaleur suive un patron spatial continu sur le territoire plutôt que les délimitations arbitraires des arrondissements. # Ajustement du modèle avec une spline bivariée pour l&#39;espace model2 &lt;- gam(hot ~ A65Pct + A014Pct + PopFRPct + PopMVPct + s(prt_veg) + s(X,Y), data = dataset, family = betar(link = &quot;logit&quot;)) Notez ici que lexpression s(X,Y) permet de créer une spline bivariée à partir des coordonnées (x,y), soit deux colonnes présentes dans le jeu de données. Ces coordonnées sont exprimées toutes deux en mètres et ninteragissent pas ensemble au sens strict, nous devons donc ajuster une spline bivariée. Si vous avez besoin dajuster une spline dinteraction (notamment quand les variables sont dans des unités différentes), il est nécessaire dutiliser une autre syntaxe te(X,Y) ou t2(X,Y) faisant appel à une structure mathématique légèrement différente, soit des tensor product smooths. Puisque notre modèle intègre deux splines, nous devons nous assurer que nous navons pas de problème de concurvité, ce que nous pouvons faire avec la fonction concurvity du package mgcv. values &lt;- concurvity(model2, full = FALSE) # Worst, estimation pessimiste de la concurvité round(values$worst,3) ## para s(prt_veg) s(X,Y) ## para 1 0.000 0.000 ## s(prt_veg) 0 1.000 0.458 ## s(X,Y) 0 0.458 1.000 # Observed, estimation optimiste de la concurvité round(values$observed,3) ## para s(prt_veg) s(X,Y) ## para 1 0.000 0.000 ## s(prt_veg) 0 1.000 0.154 ## s(X,Y) 0 0.403 1.000 # Estimate, estimation entre deux de la concurvité round(values$estimate,3) ## para s(prt_veg) s(X,Y) ## para 1 0.000 0.000 ## s(prt_veg) 0 1.000 0.142 ## s(X,Y) 0 0.358 1.000 Nous pouvons ainsi constater des niveaux de concurvité tout à fait acceptables dans notre modèle. Des valeurs supérieures à 0,8 devraient être considérées comme alarmantes, surtout si elles sont reportées pour observed et estimate. Voyons désormais, le résumé dun modèle GAM tel que présenté dans R. summary(model2) ## ## Family: Beta regression(15.469) ## Link function: logit ## ## Formula: ## hot ~ A65Pct + A014Pct + PopFRPct + PopMVPct + s(prt_veg) + s(X, ## Y) ## ## Parametric coefficients: ## Estimate Std. Error z value Pr(&gt;|z|) ## (Intercept) -0.6050031 0.0645191 -9.377 &lt; 2e-16 *** ## A65Pct 0.0027671 0.0014072 1.966 0.0493 * ## A014Pct -0.0019040 0.0027674 -0.688 0.4914 ## PopFRPct 0.0095992 0.0014323 6.702 2.06e-11 *** ## PopMVPct 0.0010113 0.0008159 1.239 0.2152 ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Approximate significance of smooth terms: ## edf Ref.df Chi.sq p-value ## s(prt_veg) 6.38 7.565 6731 &lt;2e-16 *** ## s(X,Y) 27.10 28.764 1349 &lt;2e-16 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## R-sq.(adj) = 0.891 Deviance explained = 90.8% ## -REML = -3234.3 Scale est. = 1 n = 3157 La première partie du résumé comprend les résultats pour les effets fixes et linéaires du modèle. Ils sinterprètent comme pour ceux dun GLM classique. La seconde partie présente les résultats pour les termes non linéaires. La valeur de p permet de déterminer si la spline a ou non un effet différent de 0. Une valeur non significative indique que la spline ne contribue pas au modèle. Les colonnes edf et Ref.df indiquent la complexité de la spline et peuvent être considérées comme une approximation du nombre de nuds. Dans notre cas, la spline spatiale (s(X,Y)) est environ 5 fois plus complexe que la spline ajustée pour la végétation (s(prt_veg)). Cela nest pas surprenant puisque la dimension spatiale (spline bivariée) du phénomène est certainement plus complexe que leffet de la végétation. Notez ici que des valeurs edf et Ref.df proches de 1 signaleraient que leffet dun prédicteur est essentiellement linéaire et quil nest pas nécessaire de recourir à une spline pour cette variable. La dernière partie du résumé comprend deux indicateurs de qualité dajustement, soit le R2 ajusté et la part de la déviance expliquée. AIC(refmodel, model1, model2) ## df AIC ## refmodel 40.00000 -6399.784 ## model1 44.61065 -6417.562 ## model2 40.06053 -6596.884 Nous pouvons constater que le fait dintroduire la spline spatiale dans le modèle contribue à réduire encore la valeur de lAIC, et donc à améliorer le modèle. À ce stade, nous pourrions tenter de forcer la spline à être plus complexe en augmentant le nombre de nuds. # Augmentation de la complexité de la spline spatiale model3 &lt;- gam(hot ~ A65Pct + A014Pct + PopFRPct + PopMVPct + s(prt_veg) + s(X,Y,k = 40), data = dataset, family = betar(link = &quot;logit&quot;)) AIC(refmodel, model1, model2, model3) ## df AIC ## refmodel 40.00000 -6399.784 ## model1 44.61065 -6417.562 ## model2 40.06053 -6596.884 ## model3 48.28633 -6639.955 Cela a pour effet daméliorer de nouveau le modèle. Pour vérifier si laugmentation du nombre nuds est judicieuse, il est possible de représenter le résultat des deux splines précédentes. Pour ce faire, nous proposons de calculer les valeurs prédites de la spline pour chaque localisation dans notre terrain détude, en le découpant préalablement en pixels de 100 de côté. Pour cette prédiction, nous maintenons toutes les autres variables à leur moyenne respective afin dévaluer uniquement leffet de la spline spatiale. library(viridis) library(metR) # pour placer des étiquettes sur les isolignes # Création d&#39;un DataFrame fictif pour les prédictions dfpred &lt;- expand.grid( prt_veg =mean(dataset$prt_veg), A65Pct = mean(dataset$A65Pct), A014Pct = mean(dataset$A014Pct), PopFRPct = mean(dataset$PopFRPct), PopMVPct = mean(dataset$PopMVPct), X = seq(min(dataset$X),max(dataset$X),100), Y = seq(min(dataset$Y),max(dataset$Y),100) ) dfpred$predicted1 &lt;- predict(model2, newdata = dfpred, type = &#39;response&#39;) dfpred$predicted2 &lt;- predict(model3, newdata = dfpred, type = &#39;response&#39;) # Centrage des prédictions dfpred$predicted1 &lt;- dfpred$predicted1 - mean(dfpred$predicted1) dfpred$predicted2 &lt;- dfpred$predicted2 - mean(dfpred$predicted2) # Représentation des splines plot1 &lt;- ggplot(dfpred) + geom_raster(aes(x = X, y = Y, fill = predicted1)) + geom_point(aes(x = X, y = Y), size = 0.2, alpha = 0.4, color = &#39;black&#39;, data = dataset)+ geom_contour(aes(x = X, y = Y, z = predicted1),binwidth = 0.1, color = &#39;white&#39;, linetype = &#39;dashed&#39;) + geom_text_contour(aes(x = X, y = Y, z = predicted1), color = &#39;white&#39;, binwidth = 0.1)+ scale_fill_viridis() + coord_cartesian() + theme(axis.title= element_blank(), axis.text = element_blank(), axis.ticks = element_blank() ) + labs(subtitle = &#39;spline de base&#39;, fill = &quot;prédictions&quot;) plot2 &lt;- ggplot(dfpred) + geom_raster(aes(x = X, y = Y, fill = predicted2)) + geom_point(aes(x = X, y = Y), size = 0.2, alpha = 0.4, color = &#39;black&#39;, data = dataset)+ geom_contour(aes(x = X, y = Y, z = predicted2), binwidth = 0.1, color = &#39;white&#39;, linetype = &#39;dashed&#39;) + geom_text_contour(aes(x = X, y = Y, z = predicted2), color = &#39;white&#39;, binwidth = 0.1)+ scale_fill_viridis() + coord_cartesian()+ theme(axis.title= element_blank(), axis.text = element_blank(), axis.ticks = element_blank() ) + labs(subtitle = &#39;spline plus complexe&#39;, fill = &quot;prédictions&quot;) ggarrange(plot1, plot2, nrow = 1, ncol = 2, common.legend = TRUE, legend = &#39;bottom&#39;) Figure 11.17: Comparaison de deux splines spatiales Or, il savère que les deux splines spatiales sont très similaires (figures 11.17). Par conséquent, il est vraisemblablement plus pertinent de conserver la plus simple des deux. Notez que le Mont-Royal, compris dans le cercle central avec une isoligne à 0, est caractérisé par des valeurs plus faibles dîlots de chaleur, alors que les quartiers centraux situés un peu plus au nord sont au contraire marqués par des pourcentages dîlots de chaleur supérieurs de 20 points de pourcentage en moyenne. "],["sect117.html", "11.7 GAMM", " 11.7 GAMM Bien entendu, il est possible de combiner les modèles généralisés additifs (GAM) avec les modèles à effet mixtes (GLMM) abordés dans les sections précédentes. Ces modèles généralisés additifs à effets mixtes (GAMM) peuvent facilement être mis en uvre avec mgcv. 11.7.0.1 GAMM et interceptes aléatoires Pour définir des constantes aléatoires, il suffit dutiliser la notation s(var, bs = 're') avec var une variable nominale. Reprenons lexemple précédent, mais avec cette fois-ci les arrondissements comme un intercepte aléatoire. dataset$Arrond &lt;- as.factor(dataset$Arrond) model4 &lt;- gam(hot ~ A65Pct + A014Pct + PopFRPct + PopMVPct + s(prt_veg) + s(Arrond, bs = &quot;re&quot;), data = dataset, family = betar(link = &quot;logit&quot;)) Lenjeu est ensuite dextraire la variance propre à cet effet aléatoire ainsi que les valeurs des interceptes pour chaque arrondissement. gam.vcomp(model4) ## ## Standard deviations and 0.95 confidence intervals: ## ## std.dev lower upper ## s(prt_veg) 0.007047166 0.003785275 0.01311993 ## s(Arrond) 0.393539474 0.302707198 0.51162747 ## ## Rank: 2/2 Nous constatons donc que lécart-type de leffet aléatoire des arrondissements est de 0,39, ce qui signifie que les effets de chaque arrondissement seront compris à 95 % entre -1,17 et 1,17 (1.17 = 3*0.39) sur léchelle du prédicteur linéaire. En effet, rappelons que les effets aléatoires sont modélisés comme des distributions normales et que 95 % de la densité dune distribution normale se situe entre -3 et +3 écarts-types. Pour extraire les interceptes spécifiques de chaque arrondissement, nous pouvons utiliser la fonction get_random du package itsadug. library(itsadug) values &lt;- get_random(model4)[[1]] df &lt;- data.frame( ri = as.numeric(values), arrond = names(values) ) ggplot(df) + geom_point(aes(x = ri, y = reorder(arrond, ri))) + geom_vline(xintercept = 0, color = &quot;red&quot;) + labs(y = &quot;Arrondissement&quot;, x = &quot;intercepte aléatoire&quot;) Figure 11.18: Constantes aléatoires pour les arrondissements Nous constatons ainsi, à la figure 11.18, que pour une partie des arrondissements, la densité dîlot de chaleur est systématiquement supérieure à la moyenne régionale représentée ici par la ligne rouge (0 = effet moyen pour tous les arrondissements). Il convient alors daméliorer ce graphique en ajoutant le niveau dincertitude associé à chaque intercepte. Pour ce faire, nous utilisons la fonction extract_random_effects du package mixedup. Notez que ce package nest actuellement pas disponible sur CRAN et doit être téléchargé sur github avec la commande suivante : remotes::install_github(&#39;m-clark/mixedup&#39;) Avec la version 4.0.1 de R, nous avons rencontré des difficultés pour installer mixedup. Nous avons donc simplement récupéré le code source de la fonction et lavons enregistré dans un fichier de code séparé que nous appelons ici. source(&quot;code_complementaire/gam_functions.R&quot;) Nous pouvons ensuite procéder à lextraction des effets aléatoires et les représenter à nouveau (figure 11.19). df_re &lt;- extract_random_effects.gam(model4, re = &quot;Arrond&quot;) ggplot(df_re) + geom_errorbarh(aes(xmin = lower_2.5, xmax = upper_97.5, y = reorder(group, value))) + geom_point(aes(x = value, y = reorder(group, value))) + geom_vline(xintercept = 0, color = &quot;red&quot;) + labs(y = &quot;Arrondissement&quot;, x = &quot;Intercepte aléatoire&quot;) Figure 11.19: Constantes aléatoires pour les arrondissements avec intervalle de confiance Cela permet de distinguer quels écarts sont significativement différents de 0 au seuil de 95 %. À titre de rappel, pour être significatif à ce seuil, un intervalle représenté par une ligne noire horizontale ne doit pas intersecter la ligne rouge verticale. Puisque nous utilisons ici la distribution bêta et une fonction de lien logistique, nous devons utiliser des prédictions pour simplifier linterprétation des coefficients. Nous fixons ici toutes les variables à leur moyenne respective, sauf larrondissement, et calculons les prédictions dans léchelle originale (0 à 1). dfpred &lt;- data.frame( A65Pct = mean(dataset$A65Pct), A014Pct = mean(dataset$A014Pct), PopFRPct = mean(dataset$PopFRPct), PopMVPct = mean(dataset$PopMVPct), prt_veg = mean(dataset$prt_veg), Arrond = as.character(unique(dataset$Arrond)) ) # Calculer les prédictions pour le prédicteur linéaire dfpred$preds &lt;- predict(model4, newdata = dfpred, type = &quot;link&quot;) # Calculer l&#39;intervalle de confiance en utilisant les valeurs # extraites avec extract_random_effects dfpred &lt;- dfpred[order(dfpred$Arrond),] df_re &lt;- df_re[order(df_re$group),] dfpred$lower &lt;- dfpred$preds - 1.96*df_re$se dfpred$upper &lt;- dfpred$preds + 1.96*df_re$se # Il nous reste juste à reconvertir le tout dans l&#39;unité d&#39;origine # en utilisant l&#39;inverse de la fonction logistique inv.logit &lt;- function(x){exp(x)/(1+exp(x))} dfpred$lower &lt;- inv.logit(dfpred$lower) dfpred$upper &lt;- inv.logit(dfpred$upper) dfpred$preds &lt;- inv.logit(dfpred$preds) ggplot(dfpred) + geom_errorbarh(aes(xmin = lower, xmax = upper, y = reorder(Arrond, preds))) + geom_point(aes(x = preds, y = reorder(Arrond, preds))) + geom_vline(xintercept = mean(dfpred$preds), color = &quot;red&quot;) + labs(y = &quot;Arrondissement&quot;, x = &quot;intercepte aléatoire&quot;) Figure 11.20: Prédictions pour les différents arrondissements pour une AD fictive moyenne Nous constatons ainsi, à la figure 11.20, que pour une hypothétique aire de diffusion moyenne, la différence de densité dîlot de chaleur peut être de 0,32 (32 % de la surface de lAD) entre les arrondissements Verdun et Dollard-des-Ormeaux. 11.7.0.2 GAMM et coefficients aléatoires En plus des interceptes aléatoires, il est aussi possible de définir des coefficients aléatoires. Reprenons notre exemple et tentons de faire varier leffet de la variable PopFRPct en fonction de larrondissement. model5 &lt;- gam(hot ~ A65Pct + A014Pct + PopFRPct + PopMVPct + s(prt_veg) + s(Arrond, bs = &quot;re&quot;) + s(PopFRPct, Arrond, bs = &quot;re&quot;), data = dataset, family = betar(link = &quot;logit&quot;)) Notez ici une distinction importante! Le modèle nassume aucune corrélation entre les coefficients aléatoires pour la variable PopFRPct et pour les constantes aléatoires. Il est présumé que ces deux effets proviennent de deux distributions normales distinctes. En dautres termes, le modèle ne dispose pas des paramètres nécessaires pour vérifier si les arrondissements avec les constantes les plus fortes (avec des densités supérieures dîlot de chaleur) sont aussi des arrondissements dans lesquels leffet de la variable PopFRPct est plus prononcé (et vice-versa). Pour plus dinformations sur cette distinction, référez-vous à la section 9.2.3. AIC(model4, model5) ## df AIC ## model4 41.54635 -6421.791 ## model5 56.84734 -6466.726 Ce dernier modèle présente une valeur de lAIC plus faible et serait donc ainsi mieux ajusté que notre modèle avec seulement un intercepte aléatoire. Nous pouvons donc extraire les coefficients aléatoires et les représenter à la figure 11.21. df_re &lt;- extract_random_effects.gam(model5) df_re &lt;- subset(df_re, df_re$effect == &#39;PopFRPct&#39;) ggplot(df_re) + geom_errorbarh(aes(xmin = lower_2.5, xmax = upper_97.5, y = reorder(group, value))) + geom_point(aes(x = value, y = reorder(group, value))) + geom_vline(xintercept = 0, color = &quot;red&quot;) + labs(y = &quot;Arrondissement&quot;, x = &quot;coefficient aléatoire&quot;) Figure 11.21: Pentes et constantes aléatoires pour les arrondissements Nous constatons notamment que seuls trois arrondissements ont des coefficients aléatoires significativement différents de 0. Ainsi, pour les arrondissements Anjou et Plateau-Mont-Royal, les coefficients aléatoires sont respectivement de -0,013 et -0,015, et viennent donc se retrancher à la valeur moyenne régionale de 0,0154 qui atteint alors presque 0. Du point de vue de linterprétation, nous pouvons en conclure que le groupe des personnes à faible revenu ne subit pas de surexposition aux îlots de chaleur à léchelle des AD dans ces arrondissements. En revanche, dans larrondissement Mercier-Hochelaga-Maisonneuve, la situation est à linverse plus systématiquement en défaveur des populations à faible revenu, avec une taille deffet près de deux fois supérieure à la moyenne régionale. En effet, leffet moyen régional (coefficient fixe) est de 0,0154, auquel vient sajouter leffet spécifique (coefficient aléatoire) de Mercier-Hochelaga-Maisonneuve, soit 0,011, pour un effet total de 0,0264 Des effets aléatoires plus complexes dans les GAMM Il est possible de spécifier des GAMM avec des effets aléatoires plus complexes autorisant, par exemple, des corrélations entre les différents effets / niveaux. Il faut pour cela utiliser la fonction gamm de mgcv ou la fonction gamm4 du package gamm4. La première offre plus de flexibilité, mais la seconde est plus facile à utiliser et doit être privilégiée quand un modèle comporte un très grand nombre de groupes dans un effet aléatoire, ou lorsque la distribution du modèle nest pas gaussienne. La fonction gamm permet dajuster des modèles non gaussiens, mais elle utilise une approche appelée PQL (Penalized Quasi-Likelihood en anglais) connue pour être moins stable et moins précise. Cependant, dans lexemple de cette section, nous utilisons un modèle GAMM avec une distribution bêta, ce qui nest actuellement pas supporté par les fonctions gamm et gamm4. Pour un modèle GAMM plus complexe utilisant une distribution bêta, il est nécessaire dutiliser le package gamlss, mais ce dernier utilise aussi une approche de type PQL. Nous montrons tout de même ici comment ajouter un modèle qui inclut une corrélation entre les deux effets aléatoires de lexemple précédent. Notez ici que le terme re apparaissant dans la formule permet de spécifier un effet aléatoire en utilisant la syntaxe du package nlme. Plus spécifiquement, gamlss fait un pont avec nlme et utilise son algorithme dajustement au sein de ces propres routines. De même, le terme pb permet de spécifier une spline de lissage dans le même esprit que mgcv. Il est également possible dutiliser le terme ga faisant le lien avec mgcv et de profiter de sa flexibilité dans gamlss. library(gamlss) library(gamlss.add) model6 &lt;- gamlss(hot ~ pb(prt_veg) + re(fixed = ~ A65Pct + A014Pct + PopFRPct + PopMVPct, random = ~(1 + PopFRPct)|Arrond), data = dataset, family = BE(mu.link = &quot;logit&quot;)) Nous pouvons ensuite accéder à la partie du modèle qui nous intéresse, soit celle concernant les effets aléatoires. randomPart &lt;- model6$mu.coefSmo[[2]] print(randomPart) ## Linear mixed-effects model fit by maximum likelihood ## Data: Data ## Log-likelihood: -2964.494 ## Fixed: fix.formula ## (Intercept) A65Pct A014Pct PopFRPct PopMVPct ## -0.060862832 -0.001945204 -0.010139278 0.017259606 -0.002599745 ## ## Random effects: ## Formula: ~(1 + PopFRPct) | Arrond ## Structure: General positive-definite, Log-Cholesky parametrization ## StdDev Corr ## (Intercept) 0.47298363 (Intr) ## PopFRPct 0.01078909 -0.646 ## Residual 0.99888012 ## ## Variance function: ## Structure: fixed weights ## Formula: ~W.var ## Number of Observations: 3157 ## Number of Groups: 33 À lecture de la partie du résumé consacrée aux résultats pour les effets aléatoires, nous constatons que la corrélation entre les interceptes aléatoires et les coefficients aléatoires est de -0,65. Cela signifie que pour les arrondissements avec des interceptes élevés (plus grande proportion dîlots de chaleur), leffet de la variable PopFRPct tend à être plus faible. Autrement dit, dans les arrondissements avec beaucoup dîlots de chaleur, les personnes à faible revenu ont tendance à être moins exposées, tel quillustré à la figure 11.22. df &lt;- ranef(randomPart) df$arrond &lt;- rownames(df) names(df) &lt;- c(&#39;Intercept&#39;, &#39;PopFRPct&#39;, &#39;Arrondissement&#39;) ggplot(df) + geom_hline(yintercept = 0, color = &quot;red&quot;) + geom_vline(xintercept = 0, color = &quot;red&quot;) + geom_point(aes(x = Intercept, y = PopFRPct)) Figure 11.22: Relation entre les effets aléatoires des arrondissements et la variable population à faible revenu "],["sect118.html", "11.8 Quiz de révision du chapitre", " 11.8 Quiz de révision du chapitre Que signifie lacronyme GAM? Relisez lintroduction du chapitre 11 au besoin. Gaussian Asymetric Model Generalized Additive Model Gaussian Asynchronus Model Generalized Asymetric Model Quel est lintérêt dun modèle GAM comparativement à un modèle GLM? Relisez au besoin la section 11.1. la possibilité dajuster nimporte quelle distribution dans le modèle la possibilité de tenir compte de structures de corrélation entre les observations lajout de termes non-linéaires pour les prédicteurs la transformation de la variable Y pour quelle se rapproche dune distribution normale Une spline ajustée sur une variable X dans un GAM est construite comme : Relisez au besoin la section 11.1.4 un ensemble de coefficients ajustés à différentes sections de la variable X identifiées par des points de ruptures la somme dun ensemble de polynomiales de X multipliées par des coefficients ajustés par le modèle la somme dun ensemble de fonctions de base appliquées à X et multipliées par des coefficients ajustés par le modèle Le degré de complexité dune spline est contrôlé par : Relisez au besoin la section 11.1.4. le nombre de noeuds de la spline le nombre de variables X sur lesquelles la spline est ajustée le type de fonction de base de la spline la distribution du modèle Le nombre de noeuds dune spline peut être : Relisez au besoin la section 11.3. défini manuellement, nous parlons alors de spline de régression déterminé par une approche automatique appelée pénalisation de la vraisemblance, nous parlons alors de spline de lissage déterminé automatiquement en re-paramétrisant la spline comme un effet aléatoire, nous parlons alors de spline de lissage déterminé de façon itérative en ajoutant un noeud à chaque fois et en comparant le R2 de Nagelkerke Une spline bivariée est un autre nom pour une spline dinteraction. Relisez au besoin la section 11.5 Vrai Faux Une spline peut être ajustée sur plus que deux variables X simultanément. Relisez au besoin la section 11.5. Vrai Faux Pour interpréter les résultats dune spline, il est possible de : Relisez au besoin la section 11.4. observer le nombre de degrés de liberté (estimated degree of freedom) de cette dernière pour se faire une idée de son degré de complexité représenter graphiquement les fonctions de base utilisées par la spline représenter les prédictions du modèle toutes choses égales par ailleurs afin dobtenir les effets marginaux des termes non linéaires extraire les coefficients de la spline et les interpréter de façon classique Verifier Votre score "],["chap12.html", "Chapitre 12 Méthodes factorielles", " Chapitre 12 Méthodes factorielles Dans le cadre de ce chapitre, nous présentons les trois méthodes factorielles les plus utilisées en sciences sociales : lanalyse en composantes principales (ACP, section 12.2), lanalyse factorielle des correspondances (AFC, section 12.3) et lanalyse factorielle des correspondances multiples (ACM, section 12.4). Ces méthodes, qui permettent dexplorer et de synthétiser linformation de différents tableaux de données, relèvent de la statistique exploratoire multidimensionnelle. Dans ce chapitre, nous utilisons les packages suivants : Pour créer des graphiques : ggplot2, le seul, lunique! ggpubr pour combiner des graphiques. Pour les analyses factorielles : FactoMineR pour réaliser une ACP, une AFC et une ACM. factoextra pour réaliser des graphiques à partir des résultats dune analyse factorielle. explor pour les résultats dune ACP, dune AFC ou dune ACM avec une interface Web interactive. Autres packages : geocmeans pour un jeu de données utilisé pour calculer une ACP. ggplot2, ggpubr, stringr et corrplot pour réaliser des graphiques personnalisés sur les résultats dune analyse factorielle. tmap et RColorBrewer pour cartographier les coordonnées factorielles. Hmisc pour lobtention dune matrice de corrélation. Réduction de données et identification de variables latentes Les méthodes factorielles sont souvent dénommées des méthodes de réduction de données, en raison de leur objectif principal : résumer linformation dun tableau en quelques nouvelles variables synthétiques (figure 12.1). Ainsi, elles permettent de réduire linformation dun tableau volumineux  comprenant par exemple 1000 observations et 100 variables  en p nouvelles variables (par exemple cinq avec toujours 1000 observations) résumant X % de linformation contenue dans le tableau initial. Formulée plus mathématiquement, Lebart et al. (1995, 13) en donnent une formulation plus mathématique : ils signalent quavec les méthodes factorielles, « on cherche à réduire les dimensions du tableau de données en représentant les associations entre individus et entre variables dans des espaces de faibles dimensions ». Figure 12.1: Principe de base des analyses factorielles Ces nouvelles variables synthétiques peuvent être considérées comme des variables latentes puisquelles ne sont pas directement observées; elles sont plutôt produites par la méthode factorielle utilisée afin de résumer les relations/associations entre plusieurs variables mesurées initialement. References "],["sect121.html", "12.1 Aperçu des méthodes factorielles", " 12.1 Aperçu des méthodes factorielles 12.1.1 Méthodes factorielles et types de données En analyse factorielle, la nature même des données du tableau à traiter détermine la méthode à employer : lanalyse en composantes principales (ACP) est adaptée aux tableaux avec des variables continues (idéalement normalement distribuées), lanalyse factorielle des correspondances (AFC) sapplique à des tableaux de contingence tandis que lanalyse des correspondances multiples (ACM) permet de résumer des tableaux avec des données qualitatives (issues dun sondage par exemple) (tableau 12.1). Sachez toutefois quil existe dautres méthodes factorielles qui ne sont pas abordées dans ce chapitre, notamment : lanalyse factorielle de données mixtes (AFDM) permettant dexplorer des tableaux avec à la fois des variables continues et des variables qualitatives et lanalyse factorielle multiple hiérarchique (AFMH) permettant de traiter des tableaux avec une structure hiérarchique. Pour sinitier à ces deux autres méthodes factorielles plus récentes, consultez notamment lexcellent ouvrage de Jérôme Pagès (2013). Tableau 12.1: Trois principales méthodes factorielles Méthode factorielle Abr. Type de données Type de distance Analyse en composantes principales ACP Variables continues Distance euclidienne Analyse factorielle des correspondances AFC Tableau de contingence Distance du khi-deux Analyse factorielle des correspondances multiples ACM Variables qualitatives Distance du khi-deux 12.1.2 Bref historique des méthodes factorielles Il existe une longue tradition de lutilisation des méthodes factorielles dans le monde universitaire francophone puisque plusieurs dentre elles ont été proposées par des statisticiens et des statisticiennes francophones à partir des années 1960. Lanalyse en composantes principales (ACP) a été proposée dès les années 1930 par le statisticien américain Harold Hotelling (1933). En revanche, lanalyse des correspondances (AFC) et son extension, lanalyse des correspondances multiples (ACM), ont été proposées par le statisticien français Jean-Paul Benzécri (1973), tandis que lanalyse factorielle de données mixtes (AFDM) a été proposée par Brigitte Escofier et Jérôme Pagès (Escofier 1979; Pagès 2002). Ainsi, plusieurs ouvrages de statistique sur les méthodes factorielles, désormais classiques, ont été publiés en français (Benzécri 1973; Escofier et Pagès 1998; Lebart, Morineau et Piron 1995; Pagès 2013). Ils méritent grandement dêtre consultés, notamment pour mieux comprendre les formulations mathématiques (matricielles et géométriques) de ces méthodes. À cela sajoutent plusieurs ouvrages visant à « vulgariser ces méthodes » en sciences sociales; cest notamment le cas de lexcellent ouvrage de Léna Sanders (1989) en géographie. References "],["sect122.html", "12.2 Analyses en composantes principales (ACP)", " 12.2 Analyses en composantes principales (ACP) Demblée, notez quil existe deux types danalyse en composantes principales (ACP) (Principal Component Analysis, PCA en anglais) : lACP non normée dans laquelle les variables quantitatives du tableau sont uniquement centrées (moyenne = 0). lACP normée dans laquelle les variables quantitatives du tableau sont préalablement centrées réduites (moyenne = 0 et variance = 1; section 2.5.5.2). Puisque les variables dun tableau sont souvent exprimées dans des unités de mesure différentes ou avec des ordres de grandeur différents (intervalles et écarts-types bien différents), lutilisation de lACP normée est bien plus courante. Elle est dailleurs loption par défaut dans les fonctions R permettant de calculer une ACP. Par conséquent, nous détaillons dans cette section uniquement lACP normée. Autrement dit, le recours à une ACP non normée est plus rare et sapplique uniquement à la situation suivante : toutes les variables du tableau sont mesurées dans la même unité (par exemple, en pourcentage); il pourrait être ainsi judicieux de conserver leurs variances respectives. 12.2.1 Recherche dune simplification LACP permet dexplorer et de résumer un tableau constitué uniquement de variables quantitatives (figure 12.2), et ce, de trois façons : 1) en montrant les ressemblances entre les individus (observations), 2) en révélant les liaisons entre les variables quantitatives et 3) en résumant lensemble des variables du tableau par des variables synthétiques nommées composantes principales. Figure 12.2: Tableau pour une ACP Ressemblance entre les individus. Concrètement, deux individus se ressemblent si leurs valeurs respectives pour les p variables du tableau sont similaires. Cette proximité/ressemblance est évaluée à partir de la distance euclidienne (équation (12.1)). La notion de distance fait lobjet dune section à part entière (section 13.2) que vous pouvez consulter dès à présent si elle ne vous est pas familière. \\[\\begin{equation} d^2(a,b) = \\sum_{j=1}^p(x_{aj}-x_{bj})^2 \\tag{12.1} \\end{equation}\\] Prenons un exemple fictif avec trois individus (i, j et k) ayant des valeurs pour trois variables préalablement centrées réduites (V1 à V3) (tableau 12.2). La proximité entre les paires de points est évaluée comme suit : \\[d^2(i,j)=(-\\mbox{1,15}-\\mbox{0,49})^2+(-\\mbox{1,15}-\\mbox{0,58})^2+(\\mbox{0,83}+\\mbox{1,11})^2=\\mbox{9,44}\\] \\[d^2(i,k)=(-\\mbox{1,15}+\\mbox{0,66})^2+(-\\mbox{1,15}-\\mbox{0,58})^2+(\\mbox{0,83}-\\mbox{0,28})^2=\\mbox{5,98}\\] \\[d^2(j,k)= (\\mbox{0,49}+\\mbox{0,66})^2+(\\mbox{0,58}-\\mbox{0,58})^2+(-\\mbox{1,11}-\\mbox{0,28})^2=\\mbox{1,97}\\] Nous pouvons en conclure que i est plus proche de k que de j, mais aussi que la paire de points les plus proches est (i,k). En dautres termes, les deux observations i et k sont les plus similaires du jeu de données selon la distance euclidienne. Tableau 12.2: Données fictives Variables centrées réduites Individu V1 V2 V3 i -1,15 -1,15 0,83 j 0,49 0,58 -1,11 k 0,66 0,58 0,28 Liaisons entre les variables. Dans une ACP normée, les liaisons entre les variables deux à deux sont évaluées avec le coefficient de corrélation (section 4.3.1), soit la moyenne du produit des deux variables centrées réduites (équation (12.2)). Notez que dans une ACP non normée, plus rarement utilisée, les liaisons sont évaluées avec la covariance puisque les variables sont uniquement centrées (équation (12.3)). \\[\\begin{equation} r_{xy} = \\frac{\\sum_{i=1}^n (x_{i}-\\bar{x})(y_{i}-\\bar{y})}{n\\sqrt{\\sum_{i=1}^n(x_i - \\bar{x})^2(y_i - \\bar{y})^2}}=\\sum_{i=1}^n\\frac{Zx_iZy_i}{n} \\tag{12.2} \\end{equation}\\] \\[\\begin{equation} cov(x,y) = \\frac{\\sum_{i=1}^n (x_{i}-\\bar{x})(y_{i}-\\bar{y})}{n} \\tag{12.3} \\end{equation}\\] Composantes principales. Au chapitre 4, nous avons abordé deux méthodes pour identifier des relations linéaires entre des variables continues normalement distribuées : la corrélation de Pearson (section 4.3), quil est possible dillustrer graphiquement à partir dun nuage de points; la régression linéaire simple (section 4.4), permettant de résumer la relation linéaire entre deux variables avec une droite de régression de type \\(Y=a+bX\\). Brièvement, plus deux variables sont corrélées (positivement ou négativement), plus le nuage de points quelles forment est allongé et plus les points sont proches de la droite de régression (figure 12.3, partie a). À linverse, plus la liaison entre les deux variables normalement distribuées est faible, plus le nuage prend la forme dun cercle et plus les points du nuage sont éloignés de la droite de régression (figure 12.3, partie b). Puisquen ACP normée, les variables sont centrées réduites, le centre de gravité du nuage de points est (x=0, y=0) et il est toujours traversé par la droite de régression. Finalement, nous avons vu que la méthode des moindres carrés ordinaires (MCO) permet de déterminer cette droite en minimisant les distances entre les valeurs observées et celles projetées orthogonalement sur cette droite (valeurs prédites). Dans le cas de deux variables uniquement, laxe factoriel principal/la composante principale est donc la droite qui résume le mieux la liaison entre les deux variables (en rouge). Laxe 2 représente la seconde plus importante composante (axe, dimension) et il est orthogonal (perpendiculaire) au premier axe (en bleu). Figure 12.3: Corrélation, allongement du nuage de points et axes factoriels Imaginez maintenant trois variables pour lesquelles vous désirez identifier un axe, une droite qui résume le mieux les liaisons entre elles. Visuellement, vous passez dun nuage de points en deux dimensions (2D) à un nuage en dimensions (3D). Si les corrélations entre les trois variables sont très faibles, alors le nuage prend la forme dun ballon de soccer (football en Europe). Par contre, plus ces liaisons sont fortes, plus la forme est allongée comme un ballon de rugby et plus les points sont proches de laxe traversant le ballon. Ajouter une autre variable revient alors à ajouter une quatrième dimension quil est impossible de visualiser, même pour les plus fervents adaptes de science-fiction. Pourtant, le problème reste le même : identifier, dans un plan en p dimensions (variables), les axes factoriels  les composantes principales  qui concourent le plus à résumer les liaisons entre les variables continues préalablement centrées réduites, et ce, en utilisation la méthode des moindres carrés ordinaires. Les termes composantes principales et axes factoriels sont des synonymes employés pour référer aux nouvelles variables synthétiques produites par lACP et résumant linformation du tableau intitial. 12.2.2 Aides à linterprétation Pour illustrer les aides à linterprétation de lACP, nous utilisons un jeu de données spatiales tiré dun article sur lagglomération lyonnaise en France (Gelb et Apparicio 2021b). Ce jeu de données comprend dix variables, dont quatre environnementales (EN) et six socioéconomiques (SE), pour les îlots regroupés pour linformation statistique (IRIS) de lagglomération lyonnaise (tableau 12.3 et figure 12.4). Sur ces dix variables, nous calculons une ACP normée. Tableau 12.3: Statistiques descriptives pour le jeu de données utilisé pour lACP Nom Intitulé Type Moy. E.-T. Min. Max. Lden Bruit routier (Lden dB(A)) EN 55,6 4,9 33,9 71,7 NO2 Dioxyde dazote (ug/m3) EN 28,7 7,9 12,0 60,2 PM25 Particules fines (PM\\(_{2,5}\\)) EN 16,8 2,1 11,3 21,9 VegHautPrt Canopée (%) EN 18,7 10,1 1,7 53,8 Pct0_14 Moins de 15 ans (%) SE 18,5 5,7 0,0 54,0 Pct_65 65 ans et plus (%) SE 16,2 5,9 0,0 45,1 Pct_Img Immigrants (%) SE 14,5 9,1 0,0 59,8 TxChom1564 Taux de chômage SE 14,8 8,1 0,0 98,8 Pct_brevet Personnes à faible scolarité (%) SE 23,5 12,6 0,0 100,0 NivVieMed Médiane du niveau de vie (Euros) SE 21 804,5 4 922,5 11 324,0 38 707,0 Figure 12.4: Cartographie des dix variables utilisées pour lACP Trois étapes pour bien analyser une ACP et comprendre la signification des axes factoriels : Interprétation des résultats des valeurs propres pour identifier le nombre daxes (de composantes principales) à retenir. Lenjeu est de garder un nombre daxes limité qui résume le mieux le tableau initial (réduction des données). Analyse des résultats pour les variables (coordonnées factorielles, cosinus carrés et contributions sur les axes retenus). Analyse des résultats pour les individus (coordonnées factorielles, cosinus carrés et contributions sur les axes retenus). Les deux dernières étapes permettent de comprendre la signification des axes retenus et de les qualifier. Cette étape dinterprétation est essentielle en sciences sociales. En effet, nous avons vu dans lintroduction du chapitre que les méthodes factorielles permettent de résumer linformation dun tableau en quelques nouvelles variables synthétiques, souvent considérées comme des variables latentes dans le jeu de données. Il convient alors de bien comprendre ces variables synthétiques (latentes), si nous souhaitons les utiliser dans une autre analyse subséquente (par exemple, les introduire dans une régression). 12.2.2.1 Résultats de lACP pour les valeurs propres À titre de rappel, une ACP normée est réalisée sur des variables préalablement centrées réduites (équation (12.4)), ce qui signifie que pour chaque variable : Nous soustrayons à chaque valeur la moyenne de la variable correspondante (centrage); la moyenne est donc égale à 0. Nous divisons cette différence par lécart-type de la variable correspondante (réduction); la variance est égale à 1. \\[\\begin{equation} z= \\frac{x_i-\\mu}{\\sigma} \\tag{12.4} \\end{equation}\\] Par conséquent, la variance totale (ou inertie totale) dun tableau sur lequel est calculée une ACP normée est égale au nombre de variables quil comprend. Puisque nous lappliquons ici à dix variables, la variance totale du tableau à réduire  cest-à-dire à résumer en K nouvelles variables synthétiques, composantes principales, axes factoriels  est donc égale à 10. Trois mesures reportées au tableau 12.4 permettent danalyser les valeurs propres : \\(\\mbox{VP}_k\\), la valeur propre (eigenvalue en anglais) de laxe k, cest-à-dire la quantité de variance du tableau initial résumé par laxe. \\(\\mbox{VP}_k / \\mbox{P}\\) avec P étant le nombre de variables que comprend le tableau initial. Cette mesure représente ainsi le pourcentage de la variance totale du tableau résumé par laxe k, autrement dit la quantité dinformations du tableau initial résumée par laxe, la composante principale k. Cela nous permet ainsi dévaluer le pouvoir explicatif de laxe. Le pourcentage cumulé pour les axes. Tableau 12.4: Résultats de lACP pour les valeurs propres Composante Valeur propre Pourcentage Pourc. cumulé 1 3,543 35,425 35,425 2 2,760 27,596 63,021 3 1,042 10,422 73,443 4 0,751 7,511 80,954 5 0,606 6,059 87,013 6 0,388 3,880 90,893 7 0,379 3,788 94,681 8 0,244 2,441 97,122 9 0,217 2,167 99,289 10 0,071 0,711 100,000 Avant danalyser en détail le tableau 12.4, notez que la somme des valeurs propres de toutes les composantes de lACP est toujours égale au nombre de variables du tableau initial. Aussi, la quantité de variance expliquée (les valeurs propres) décroît de la composante 1 à la composante K. Combien daxes dune ACP faut-il retenir? Pour répondre à cette question, deux approches sont possibles : Approche statistique (avec le critère de Kaiser (1960)). Nous retenons uniquement les composantes qui présentent une valeur propre supérieure à 1. Rappelez-vous quen ACP normée, les variables sont préalablement centrées réduites, et donc que leur variance respective est égale à 1. Par conséquent, une composante ayant une valeur propre inférieure à 1 a un pouvoir explicatif inférieur à celui dune variable. À la lecture du tableau, nous retenons les trois premières composantes si nous appliquons ce critère. Approche empirique basée sur la lecture des pourcentages et des pourcentages cumulés. Nous pouvons retenir uniquement les deux premières composantes. En effet, ces deux premiers facteurs résument près des deux tiers de la variance totale du tableau (63,02 %). Cela démontre bien que lACP, comme les autres méthodes factorielles, est bien une méthode de réduction de données puisque nous résumons dix variables avec deux nouvelles variables synthétiques (axes, composantes principales). Pour faciliter le choix du nombre daxes, il est fortement conseillé de construire des histogrammes à partir des valeurs propres, des pourcentages et des pourcentages cumulés (figure 12.5). Or, à la lecture de ces graphiques, nous constatons que la variance expliquée chute drastiquement après les deux premières composantes. Par conséquent, nous pouvons retenir uniquement les deux premiers axes. Lecture du diagramme des valeurs propres Plus les variables incluses dans lACP sont corrélées entre elles, plus lACP est intéressante : plus les valeurs propres des premiers axes sont fortes et plus il y a des sauts importants dans le diagramme des valeurs propres. À linverse, lorsque les variables incluses dans lACP sont peu corrélées entre elles, il ny a pas de sauts importants dans lhistogramme, autrement dit les valeurs propres sont uniformément décroissantes. Figure 12.5: Graphiques personnalisés pour les valeurs propres pour lACP 12.2.2.2 Résultats de lACP pour les variables Pour qualifier les axes, quatre mesures sont disponibles pour les variables : Les coordonnées factorielles des variables sont simplement les coefficients de corrélation de Pearson des variables sur laxe k et varient ainsi de -1 à 1 (relire au besoin la section 4.3). Pour qualifier un axe, il convient alors de repérer les variables les plus corrélées positivement et négativement sur laxe, autrement dit, de repérer les variables situées aux extrémités laxe. Les cosinus carrés des variables (Cos2) (appelés aussi les qualités de représentation des variables sur un axe) permettent de repérer le ou les axes qui concourent le plus à donner un sens à la variable. Ils sont en fait les coordonnées des variables mises au carré. La somme des cosinus carrés dune variable sur tous les axes de lACP est donc égale à 1 (sommation en ligne). La qualité de représentation dune variable sur les n premiers axes est simplement la somme des cosinus carrés dune variable sur les axes retenus. Par exemple, pour la variable Lden, la qualité de représentation de la variable sur le premier axe est égale : \\(\\mbox{0,42}^2=\\mbox{0,17}\\). Pour cette même variable, la qualité de la Lden sur les trois premiers axes est égale à : \\(\\mbox{0,17}+\\mbox{0,32}+\\mbox{0,26}=\\mbox{0,75}\\). Les contributions des variables permettent de repérer celles qui participent le plus à la formation dun axe. Elles sobtiennent en divisant les cosinus carrés par la valeur propre de laxe multiplié par 100. La somme des contributions des variables pour un axe donné est donc égale à 100 (sommation en colonne). Par exemple, pour la variable Lden, la contribution sur le premier axe est égale : \\(\\mbox{0,174} / \\mbox{3,543} \\times \\mbox{100}= \\mbox{4,920 }%\\). Les résultats de lACP pour les variables sont présentés au tableau 12.5. Tableau 12.5: Résultats de lACP pour les variables Coordonnées Cosinus carrés Contributions Variable 1 2 3 1 2 3 Qualité 1 2 3 Lden 0,42 0,57 0,51 0,17 0,32 0,26 0,75 4,92 11,64 24,80 NO2 0,15 0,93 0,19 0,02 0,86 0,04 0,92 0,66 31,07 3,54 PM25 0,19 0,92 0,03 0,04 0,84 0,00 0,87 1,01 30,36 0,12 VegHautPrt -0,40 -0,42 0,40 0,16 0,18 0,16 0,50 4,63 6,35 15,46 Pct0_14 0,55 -0,53 0,08 0,30 0,28 0,01 0,59 8,61 10,28 0,55 Pct_65 -0,41 -0,27 0,72 0,17 0,07 0,51 0,75 4,73 2,66 49,26 Pct_Img 0,87 -0,09 0,11 0,76 0,01 0,01 0,78 21,56 0,29 1,08 TxChom1564 0,77 -0,09 -0,07 0,60 0,01 0,00 0,61 16,89 0,27 0,45 Pct_brevet 0,73 -0,43 0,22 0,53 0,19 0,05 0,77 14,94 6,81 4,61 NivVieMed -0,88 0,09 0,04 0,78 0,01 0,00 0,79 22,06 0,28 0,14 Analyse de la première composante principale (valeur propre de 3,54, 35,43 %) À la lecture des contributions, il est clair que quatre variables contribuent grandement à la formation de laxe 1 : NivVieMed (22,06 %), Pct_Img (21,56 %), TxChom1564 (16,89 %) et Pct_brevet (14,94 %). Il convient alors danalyser en détail leurs coordonnées factorielles et leurs cosinus carrés. À la lecture des coordonnées factorielles, nous constatons que trois variables socioéconomiques sont fortement corrélées positivement avec laxe 1, soit le pourcentage dimmigrants (0,87), le taux de chômage (0,77) et le pourcentage de personnes avec une faible scolarité (0,73). À lautre extrémité, la médiane du niveau de vie (en Euros) est négativement corrélée avec laxe 1. Comment interpréter ce résultat? Premièrement, cela signifie que plus la valeur de laxe 1 est positive et élevée, plus celles des trois variables (Pct_Img,TxChom1564 et Pct_brevet) sont aussi élevées (corrélations positives) et plus la valeur de NivVieMed est faible (corrélation négative). Inversement, plus la valeur de laxe 1 est négative et faible, les valeurs de Pct_Img, TxChom1564 et Pct_brevet sont faibles et plus celle de NivVieMed est forte. Deuxièmement, cela signifie que les trois variables (Pct_Img,TxChom1564 et Pct_brevet) sont fortement corrélées positivement entre elles puisquelles se situent sur la même extrémité de laxe et quelles sont toutes trois négativement corrélées avec la variable NivVieMed. Cela peut être rapidement confirmé avec la matrice de corrélation entre les dix variables (tableau 12.6). À la lecture des cosinus carrés de laxe 1, nous constatons que plus des trois quarts de la dispersion/de linformation des variables NivVieMed (0,78) et Pct_Img (0,76) est concentrée sur laxe 1. Tableau 12.6: Matrice de corrélation de Pearson entre les variables utilisées pour lACP Variable A B C D E F G H I J A. Lden 0,62 0,49 -0,23 0,04 -0,09 0,28 0,19 0,14 -0,26 B. NO2 0,62 0,90 -0,28 -0,34 -0,21 0,07 0,04 -0,25 -0,04 C. PM25 0,49 0,90 -0,39 -0,34 -0,26 0,12 0,07 -0,25 -0,10 D. VegHautPrt -0,23 -0,28 -0,39 0,04 0,32 -0,22 -0,18 -0,14 0,32 E. Pct0_14 0,04 -0,34 -0,34 0,04 -0,12 0,46 0,36 0,54 -0,45 F. Pct_65 -0,09 -0,21 -0,26 0,32 -0,12 -0,24 -0,30 0,00 0,32 G. Pct_Img 0,28 0,07 0,12 -0,22 0,46 -0,24 0,66 0,64 -0,73 H. TxChom1564 0,19 0,04 0,07 -0,18 0,36 -0,30 0,66 0,47 -0,62 I. Pct_brevet 0,14 -0,25 -0,25 -0,14 0,54 0,00 0,64 0,47 -0,67 J. NivVieMed -0,26 -0,04 -0,10 0,32 -0,45 0,32 -0,73 -0,62 -0,67 Analyse de la deuxième composante principale (valeur propre de 2,76, 27,60 %) À la lecture des contributions, trois variables environnementales contribuent à la formation de laxe 2 : principalement, celles sur la pollution de lair (NO2 = 31,07 % et PM25 = 30,36 %) et secondairement, celle sur le bruit routier (Lden = 11,64 %). À la lecture des coordonnées factorielles, ces trois variables sont fortement corrélées positivement avec laxe 2 : NO2 (0,93), PM25 (0,92) et Lden (0,57). À lautre extrémité de laxe, la variable Pct0_14 est négativement, mais pas fortement, corrélée (-0,53). La lecture de la matrice de corrélation au tableau 12.6 confirme que ces trois variables environnementales sont fortement corrélées positivement entre elles (par exemple, un coefficient de corrélation de Pearson de 0,90 entre NO2 et PM25). À la lecture des cosinus carrés de laxe 2, nous constatons que près de 90 % de la dispersion/de linformation des variables NO2 (0,86) et PM25 (0,84) est concentrée sur laxe 2. Analyse de la troisième composante principale (valeur propre de 1,042, 10,42 %) Le pourcentage de personnes âgées (Pct_65) contribue principalement à la formation de laxe 3 avec lequel il est corrélé positivement (contribution de 49,26 % et coordonnée factorielle de 0,72). Sen suit la variable Lden, qui joue un rôle beaucoup moins important (contribution de 24,80 % et coordonnée factorielle de 0,51). Lien entre la valeur propre dun axe et le nombre de variables contribuant à sa formation Vous auvez compris que plus la valeur propre dun axe est forte, plus il y a potentiellement de variables qui concourent à sa formation. Cela explique que pour la troisième composante, qui a une faible valeur propre (1,042), seule une variable contribue significativement à sa formation. Analyse de la qualité de représentation des variables sur les premiers axes de lACP À titre de rappel, la qualité est simplement la somme des cosinus carrés dune variable sur les axes retenus. Si nous retenons trois axes, les six variables qui sont le mieux résumées  et qui ont donc le plus dinfluence sur les résultats de lACP  sont : NO2 (0,92), PM25 (0,87), NivVieMed (0,79), Pct_Img (0,78), Pct_brevet (0,77) et Lden (0,75). Qualification, dénomination daxes factoriels Lanalyse des coordonnées, des contributions et des cosinus carrés doit vous permettre de formuler un intitulé pour chacun des axes retenus. Nous vous proposons les intitulés suivants : Niveau de défavorisation socioéconomique (axe 1). Plus la valeur de laxe est élevé, plus le niveau de défavorisation de lentité spatiale (IRIS) est élevé. Qualité environnementale (axe 2). Plus la valeur de laxe est forte, plus les niveaux de pollution atmosphérique (dioxyde dazote et particules fines) et de bruit (Lden) sont élevés. Recours à des graphiques pour analyser les résultats de lACP pour des variables Plus le nombre de variables utilisées pour calculer lACP est important, plus lanalyse des coordonnées factorielles, des cosinus carrés et des contributions reportés dans un tableau devient fastidieuse. Puisque lACP a été calculée sur dix variables, lanalyse des valeurs du tableau 12.5 a été assez facile et rapide. Imaginez maintenant que nous réalisons une ACP sur une centaine de variables, la taille du tableau des résultats pour les variables sera considérable Par conséquent, il est recommandé de construire plusieurs graphiques qui facilitent lanalyse des résultats pour les variables. Par exemple, à la figure 12.6, nous avons construit des graphiques avec les coordonnées factorielles sur les trois premiers axes de lACP. En un coup dil, il est facile de repérer les variables les plus corrélées positivement ou négativement avec chacun dentre eux. Aussi, il est fréquent de construire un nuage de points avec les coordonnées des variables sur les deux premiers axes factoriels, soit un graphique communément appelé nuage de points des variables sur le premier plan factoriel sur lequel est représenté le cercle des corrélations (figure 12.7). Bien entendu, cet exercice peut être fait avec dautres axes factoriels (les axes 3 et 4 par exemple). Figure 12.6: Coordonnées factorielles des variables Figure 12.7: Premier plan factoriel de lACP pour les variables 12.2.2.3 Résultats de lACP pour les individus Comme pour les variables, nous retrouvons les mêmes mesures pour les individus : les coordonnées factorielles, les cosinus carrés et les contributions. Les coordonnées factorielles des individus sont les projections orthogonales des observations sur laxe. Puisquen ACP normée, les variables utilisées pour lACP sont centrées réduites, la moyenne des coordonnées factorielles des individus pour un axe est toujours égale à zéro. En revanche, contrairement aux coordonnées factorielles pour les variables, les coordonnées pour les individus ne varient pas de -1 à 1! Les cosinus carrés quantifient à quel point chaque axe représente chaque individu. Enfin, les contributions quantifient lapport de chaque individu à la formation dun axe. Si le jeu de données comprend peu dobservations, il est toujours possible de créer un nuage de points des individus sur le premier plan factoriel sur lequel vous pouvez ajouter les étiquettes permettant didentifier les observations (figure 12.8). Ce graphique est rapidement illisible lorsque le nombre dobservations est important. Il peut rester utile si certaines des observations du jeu de données doivent faire lobjet dune analyse spécifique. Figure 12.8: Premier plan factoriel pour les individus Lorsque les observations sont des unités spatiales, il est très intéressant de cartographier les coordonnées factorielles des individus (figure 12.8). À la lecture de la carte choroplèthe de gauche (axe 1), nous pouvons constater que le niveau de défavorisation socioéconomique est élevé dans lest (IRIS en vert), et inversement, très faible à louest de lagglomération (IRIS en rouge). À la lecture de la carte de droite (axe 2), sans surprise, la partie centrale de lagglomération est caractérisée par des niveaux de pollution atmosphérique et de bruit routier bien plus élevés quen périphérie. Figure 12.9: Cartographie des coordonnées factorielles des individus Nous abordons ici plusieurs autres éléments intéressants de lACP. Ajout de variables ou dindividus supplémentaires Premièrement, il est possible dajouter des variables continues ou des individus supplémentaires qui nont pas été pris en compte dans le calcul de lACP (figure 12.10). Concernant les variables continues supplémentaires, il sagit simplement de calculer leurs corrélations avec les axes retenus de lACP. Concernant les individus, il sagit de les projeter sur les axes factoriels. Pour plus dinformations sur le sujet, consultez les excellents ouvrages de Ludovic Lebart, Alain Morineau et Marie Piron (1995, 4245) ou encore de Jérôme Pagès (2013, 2224). Figure 12.10: Variables et individus supplémentaires pour lACP Pondération des individus et des variables Deuxièmement, il est possible de pondérer à la fois les individus et, plus rarement, les variables lors du calcul de lACP. Analyse en composantes principales non paramétrique Troisièmement, il est possible de calculer une ACP sur des variables préalablement transformées en rang (section 2.5.5.2). Cela peut être justifié lorsque les variables sont très anormalement distribuées en raison de valeurs extrêmes. Les coordonnées factorielles pour les variables sont alors le coefficient de Spearman (section 4.3.3) et non de Pearson. Aussi, les variables sont centrées non pas sur leurs moyennes respectives, mais sur leurs médianes. Pour plus dinformations sur cette approche, consultez de nouveau Lebart et al. (1995, 5152). Analyse en composantes principales robuste Finalement, dautres méthodes plus avancées quune ACP non paramétrique peuvent être utilisées afin dobtenir des composantes principales qui ne sont pas influencées par des valeurs extrêmes : les ACP robustes (Rivest et Plante 1988; Hubert, Rousseeuw et Vanden Branden 2005) qui peuvent être mises en uvre, entre autres avec le package roscpca. 12.2.3 Mise en uvre dans R Plusieurs packages permettent de calculer une ACP dans R, notamment psych (fonction principal), ade4 (fonction dudi.pca) et FactoMineR (fonction PCA). Ce dernier est certainement le plus abouti. De plus, il permet également de calculer une analyse des correspondances (AFC), une analyse des correspondances multiples (ACM) et une analyse factorielle de données mixtes (AFDM). Nous utilisons donc FactoMineR pour mettre en uvre les trois types de méthodes factorielles abordées dans ce chapitre (ACP, AFC et ACM). Pour lACP, nous exploitons un jeu de données issu du package geocmeans quil faut préalablement charger à laide des lignes de code suivantes. library(geocmeans) data(LyonIris) Data &lt;- LyonIris@data[c(&quot;CODE_IRIS&quot;,&quot;Lden&quot;,&quot;NO2&quot;,&quot;PM25&quot;,&quot;VegHautPrt&quot;, &quot;Pct0_14&quot;,&quot;Pct_65&quot;,&quot;Pct_Img&quot;, &quot;TxChom1564&quot;,&quot;Pct_brevet&quot;,&quot;NivVieMed&quot;)] 12.2.3.1 Calcul et exploration dune ACP avec FactoMineR Pour calculer lACP, il suffit dutiliser la fonction PCA de FactoMineR, puis la fonction summary(MonACP) qui renvoie les résultats de lACP pour : Les valeurs propres (section Eigenvalues) pour les composantes principales (Dim.1 à Dim.n) avec leur variance expliquée brute (Variance) en pourcentage (% of var.) et en pourcentage cumulé (Cumulative % of var.). Les dix premières observations (section Individuals) avec les coordonnées factorielles (Dim.1 à Dim.n), les contributions (ctr) et les cosinus carrés (cos2). Pour accéder aux résultats pour toutes les observations, utilisez les fonctions res.acp$ind ou encore res.acp$ind$coord (uniquement les coordonnées factorielles), res.acp$ind$contrib (uniquement les contributions) et res.acp$ind$cos2 (uniquement les cosinus carrés). Les variables (section Variables) avec les coordonnées factorielles (Dim.1 à Dim.n), les contributions (ctr) et les cosinus carrés (cos2). library(FactoMineR) # Version classique avec FactoMineR # Construction d&#39;une ACP sur les colonnes 2 à 11 du DataFrame Data res.acp &lt;- PCA(Data[,2:11], scale.unit=TRUE, graph=F) # Affichage des résultats de la fonction PCA print(res.acp) ## **Results for the Principal Component Analysis (PCA)** ## The analysis was performed on 506 individuals, described by 10 variables ## *The results are available in the following objects: ## ## name description ## 1 &quot;$eig&quot; &quot;eigenvalues&quot; ## 2 &quot;$var&quot; &quot;results for the variables&quot; ## 3 &quot;$var$coord&quot; &quot;coord. for the variables&quot; ## 4 &quot;$var$cor&quot; &quot;correlations variables - dimensions&quot; ## 5 &quot;$var$cos2&quot; &quot;cos2 for the variables&quot; ## 6 &quot;$var$contrib&quot; &quot;contributions of the variables&quot; ## 7 &quot;$ind&quot; &quot;results for the individuals&quot; ## 8 &quot;$ind$coord&quot; &quot;coord. for the individuals&quot; ## 9 &quot;$ind$cos2&quot; &quot;cos2 for the individuals&quot; ## 10 &quot;$ind$contrib&quot; &quot;contributions of the individuals&quot; ## 11 &quot;$call&quot; &quot;summary statistics&quot; ## 12 &quot;$call$centre&quot; &quot;mean of the variables&quot; ## 13 &quot;$call$ecart.type&quot; &quot;standard error of the variables&quot; ## 14 &quot;$call$row.w&quot; &quot;weights for the individuals&quot; ## 15 &quot;$call$col.w&quot; &quot;weights for the variables&quot; # Résumé des résultats (valeurs propres, individus, variables) summary(res.acp) ## ## Call: ## PCA(X = Data[, 2:11], scale.unit = TRUE, graph = F) ## ## ## Eigenvalues ## Dim.1 Dim.2 Dim.3 Dim.4 Dim.5 Dim.6 Dim.7 ## Variance 3.543 2.760 1.042 0.751 0.606 0.388 0.379 ## % of var. 35.425 27.596 10.422 7.511 6.059 3.880 3.788 ## Cumulative % of var. 35.425 63.021 73.443 80.954 87.013 90.893 94.681 ## Dim.8 Dim.9 Dim.10 ## Variance 0.244 0.217 0.071 ## % of var. 2.441 2.167 0.711 ## Cumulative % of var. 97.122 99.289 100.000 ## ## Individuals (the 10 first) ## Dist Dim.1 ctr cos2 Dim.2 ctr cos2 Dim.3 ## 1 | 3.054 | 1.315 0.096 0.185 | -2.515 0.453 0.678 | 0.221 ## 2 | 1.882 | 0.193 0.002 0.011 | -1.744 0.218 0.859 | 0.082 ## 3 | 2.820 | 2.338 0.305 0.687 | -0.860 0.053 0.093 | -0.765 ## 4 | 2.816 | -0.740 0.031 0.069 | 2.265 0.367 0.647 | 1.293 ## 5 | 3.210 | -2.208 0.272 0.473 | -1.597 0.183 0.248 | 1.471 ## 6 | 3.016 | 2.287 0.292 0.575 | -1.515 0.164 0.252 | 0.390 ## 7 | 3.022 | -1.540 0.132 0.260 | -1.803 0.233 0.356 | 0.465 ## 8 | 3.122 | -1.536 0.132 0.242 | -2.038 0.298 0.426 | -0.120 ## 9 | 4.743 | -3.930 0.862 0.687 | -1.806 0.234 0.145 | 0.993 ## 10 | 3.055 | 2.713 0.411 0.789 | 0.368 0.010 0.014 | -0.391 ## ctr cos2 ## 1 0.009 0.005 | ## 2 0.001 0.002 | ## 3 0.111 0.074 | ## 4 0.317 0.211 | ## 5 0.411 0.210 | ## 6 0.029 0.017 | ## 7 0.041 0.024 | ## 8 0.003 0.001 | ## 9 0.187 0.044 | ## 10 0.029 0.016 | ## ## Variables ## Dim.1 ctr cos2 Dim.2 ctr cos2 Dim.3 ctr cos2 ## Lden | 0.417 4.920 0.174 | 0.567 11.640 0.321 | 0.508 24.799 0.258 ## NO2 | 0.153 0.657 0.023 | 0.926 31.068 0.857 | 0.192 3.540 0.037 ## PM25 | 0.189 1.007 0.036 | 0.915 30.355 0.838 | 0.035 0.117 0.001 ## VegHautPrt | -0.405 4.630 0.164 | -0.419 6.353 0.175 | 0.401 15.459 0.161 ## Pct0_14 | 0.552 8.605 0.305 | -0.533 10.281 0.284 | 0.076 0.553 0.006 ## Pct_65 | -0.409 4.730 0.168 | -0.271 2.658 0.073 | 0.716 49.258 0.513 ## Pct_Img | 0.874 21.559 0.764 | -0.089 0.288 0.008 | 0.106 1.077 0.011 ## TxChom1564 | 0.774 16.893 0.598 | -0.086 0.267 0.007 | -0.068 0.450 0.005 ## Pct_brevet | 0.727 14.936 0.529 | -0.434 6.813 0.188 | 0.219 4.612 0.048 ## NivVieMed | -0.884 22.062 0.782 | 0.088 0.278 0.008 | 0.038 0.136 0.001 ## ## Lden | ## NO2 | ## PM25 | ## VegHautPrt | ## Pct0_14 | ## Pct_65 | ## Pct_Img | ## TxChom1564 | ## Pct_brevet | ## NivVieMed | Avec les fonctions de base barplot et plot, il est possible de construire rapidement des graphiques pour explorer les résultats de lACP pour les valeurs propres, les variables et les individus. # Graphiques pour les valeurs propres barplot(res.acp$eig[,1], main=&quot;Valeurs propres&quot;, names.arg=1:nrow(res.acp$eig)) barplot(res.acp$eig[,2], main=&quot;Variance expliquée (%)&quot;, names.arg=1:nrow(res.acp$eig)) barplot(res.acp$eig[,3], main=&quot;Variance expliquée cumulée (%)&quot;, names.arg=1:nrow(res.acp$eig)) # Nuage du points du premier plan factoriel pour les variables et les individus plot(res.acp, graph.type = &quot;classic&quot;, choix=&quot;var&quot;, axes = 1:2, title = &quot;Premier plan factoriel (variables)&quot;) plot(res.acp, graph.type = &quot;classic&quot;, choix=&quot;ind&quot;, axes = 1:2, title = &quot;Premier plan factoriel (individus)&quot;) Nous avons vu, dans un encadré ci-dessus, quil est possible dajouter des variables et des individus supplémentaires dans une ACP, ce que permet la fonction PCA de FactoMineR avec les paramètres ind.sup et quanti.sup. Aussi, pour ajouter des pondérations aux individus ou aux variables, utilisez les paramètres row.w et col.w. Pour plus dinformations sur ces paramètres, consulter laide de la fonction en tapant ?PCA dans la console de RStudio. 12.2.3.2 Exploration graphique des résultats de lACP avec factoextra Visuellement, vous avez pu constater que les graphiques ci-dessus (pour les valeurs propres et pour le premier plan factoriel pour les variables et les individus), réalisés avec les fonctions de base barplot et plot, sont peu attrayants. Avec le package factoextra, quelques lignes de code suffissent pour construire des graphiques bien plus esthétiques. Premièrement, la syntaxe ci-dessous renvoie deux graphiques pour analyser les résultats des valeurs propres (figure 12.11). library(factoextra) library(ggplot2) library(ggpubr) # Graphiques pour les variables propres avec factoextra G1 &lt;- fviz_screeplot(res.acp, choice =&quot;eigenvalue&quot;, addlabels = TRUE, x=&quot;Composantes&quot;, y=&quot;Valeur propre&quot;, title=&quot;&quot;) G2 &lt;- fviz_screeplot(res.acp, choice =&quot;variance&quot;, addlabels = TRUE, x=&quot;Composantes&quot;, y=&quot;Pourcentage de la variance expliquée&quot;, title=&quot;&quot;) ggarrange(G1, G2) Figure 12.11: Graphiques pour les valeurs propres de lACP avec factoextra Deuxièmement, la syntaxe ci-dessous renvoie trois graphiques pour analyser les contributions de chaque variable aux deux premiers axes de lACP (figures 12.12 et 12.13) et la qualité de représentation des variables sur les trois premiers axes (figure 12.14), cest-à-dire la somme des cosinus carrés sur les trois axes retenus. # Contributions des variables aux deux premières composantes avec factoextra fviz_contrib(res.acp, choice = &quot;var&quot;, axes = 1, top = 10, title = &quot;Contributions des variables à la première composante&quot;) fviz_contrib(res.acp, choice = &quot;var&quot;, axes = 2, top = 10, title = &quot;Contributions des variables à la première composante&quot;) fviz_cos2(res.acp, choice = &quot;var&quot;, axes = 1:3)+ labs(x=&quot;&quot;, y=&quot;Somme des cosinus carrés sur les 3 axes retenus&quot;, title =&quot;Qualité de représentation des variables sur les axes retenus de l&#39;ACP&quot;) Figure 12.12: Contributions des variables à la première composante avec factoextra Figure 12.13: Contributions des variables à la deuxième composante avec factoextra Figure 12.14: Qualité des variables sur les trois premières composantes avec factoextra Troisièmement, le code ci-dessous renvoie un nuage de points pour le premier plan factoriel de lACP (axes 1 et 2) pour les variables (figure 12.15) et les individus (figure 12.16). # Premier plan factoriel pour les variables avec factoextra fviz_pca_var(res.acp, col.var=&quot;contrib&quot;, title = &quot;Premier plan factoriel pour les variables&quot;)+ scale_color_gradient2(low=&quot;#313695&quot;, mid=&quot;#ffffbf&quot;, high=&quot;#a50026&quot;, midpoint=mean(res.acp$var$contrib[,1])) # Premier plan factoriel pour les individus avec factoextra fviz_pca_ind(res.acp, label=&quot;none&quot;, title=&quot;ACP. Individus&quot;) fviz_pca_ind(res.acp, col.ind=&quot;cos2&quot;, title=&quot;ACP. Individus&quot;) + scale_color_gradient2(low=&quot;blue&quot;, mid=&quot;white&quot;, high=&quot;red&quot;, midpoint=0.50) Figure 12.15: Premier plan factoriel de lACP pour les variables avec factoextra Figure 12.16: Premier plan factoriel de lACP pour les individus avec factoextra 12.2.3.3 Personnalisation des graphiques avec les résultats de lACP Avec un peu plus de lignes de code et lutilisation dautres packages (ggplot2, ggpubr, stringr, corrplot), vous pouvez aussi construire des graphiques personnalisés. Premièrement, la syntaxe ci-dessous permet de réaliser trois graphiques pour analyser les valeurs propres (figure 12.17). Notez que, dun coup dil, nous pouvons identifier les composantes principales avec une valeur propre égale ou supérieure à 1. library(ggplot2) library(ggpubr) library(stringr) library(corrplot) # Calcul de l&#39;ACP res.acp &lt;- PCA(Data[,2:11], ncp=5, scale.unit=TRUE, graph=F) print(res.acp) # Construction d&#39;un DataFrame pour les valeurs propres dfACPvp &lt;- data.frame(res.acp$eig) names(dfACPvp) &lt;- c(&quot;VP&quot;,&quot;VP_pct&quot;,&quot;VP_cumupct&quot;) dfACPvp$Composante &lt;- factor(1:nrow(dfACPvp), levels=rev(1:nrow(dfACPvp))) couleursAxes &lt;- c(&quot;steelblue&quot;,&quot;skyblue2&quot;) vpsup1 &lt;- round(sum(subset(dfACPvp, VP &gt;= 1)$VP),2) vpsup1cumul &lt;- round(sum(subset(dfACPvp, VP &gt;= 1)$VP_pct),2) plotVP1 &lt;- ggplot(dfACPvp,aes(x=VP, y=Composante,fill=VP&lt;1))+ geom_bar(stat=&quot;identity&quot;, width = .6, alpha=.8, color=&quot;black&quot;)+ geom_vline(xintercept=1, linetype=&quot;dashed&quot;, color = &quot;azure4&quot;, size=1)+ scale_fill_manual(name=&quot;Valeur\\npropre&quot;,values=couleursAxes,labels = c(&quot;&gt;= 1&quot;,&quot;&lt; 1&quot;))+ labs(x=&quot;Valeur propre&quot;, y=&quot;Composante principale&quot;) plotVP2 &lt;- ggplot(dfACPvp, aes(x=VP_pct, y=Composante,fill=VP&lt;1))+ geom_bar(stat=&quot;identity&quot;, width = .6, alpha=.8, color=&quot;black&quot;)+ scale_fill_manual(name=&quot;Valeur\\npropre&quot;,values=couleursAxes,labels = c(&quot;&gt;= 1&quot;,&quot;&lt; 1&quot;))+ theme(legend.position=&quot;none&quot;)+ labs(x=&quot;Pourcentage de la variance expliquée&quot;, y=&quot;&quot;) plotVP3 &lt;- ggplot(dfACPvp, aes(x=VP_cumupct, y=Composante,fill=VP&lt;1, group=1))+ geom_bar(stat=&quot;identity&quot;, width = .6, alpha=.8, color=&quot;black&quot;)+ scale_fill_manual(name=&quot;Valeur\\npropre&quot;,values=couleursAxes,labels = c(&quot;&gt;= 1&quot;,&quot;&lt; 1&quot;))+ geom_line(colour=&quot;brown&quot;, linetype=&quot;solid&quot;, size=.8) + geom_point(size=3, shape=21, color=&quot;brown&quot;, fill=&quot;brown&quot;)+ theme(legend.position=&quot;none&quot;)+ labs(x=&quot;Pourcentage cumulé de la variance expliquée&quot;, y=&quot;&quot;) text1 &lt;- paste0(&quot;Somme des valeurs propres supérieures à 1 : &quot;, vpsup1, &quot;.\\nPourcentage cumulé des valeurs propres supérieures à 1 : &quot;, vpsup1cumul, &quot;%.&quot;) annotate_figure(ggarrange(plotVP1, plotVP2, plotVP3, ncol=2, nrow=2), text_grob(&quot;Analyse des valeurs propres&quot;, color = &quot;black&quot;, face = &quot;bold&quot;, size = 12), bottom = text_grob(text1, color = &quot;black&quot;, hjust = 1, x = 1, size = 10)) Figure 12.17: Graphiques personnalisés pour les valeurs propres Deuxièmement, la syntaxe ci-dessous permet de : Construire un DataFrame avec les résultats des variables. Construire des histogrammes avec les coordonnées des variables sur les axes factoriels (figure 12.18). Notez que les coordonnées négatives sont indiquées avec des barres bleues et celles positives, avec des barres de couleur saumon. Un graphique avec les contributions des variables sur les axes retenus (figure 12.19). Un graphique avec les cosinus carrés des variables sur les axes retenus (figure 12.20). Un histogramme avec la qualité des variables sur les axes retenus (figure 12.21), soit la sommation de leurs cosinus carrés sur les axes retenus. # Analyse des résultats de L&#39;ACP pour les variables library(corrplot) library(stringr) library(ggplot2) library(ggpubr) # Indiquer le nombre d&#39;axes à conserver suite à l&#39;analyse des valeurs propres nComp &lt;- 3 # Variance expliquée par les axes retenus vppct &lt;- round(dfACPvp[1:nComp,&quot;VP_pct&quot;],1) # Dataframe des résultats pour les variables CoordsVar &lt;- res.acp$var$coord[, 1:nComp] Cos2Var &lt;- res.acp$var$cos2[, 1:nComp] CtrVar &lt;- res.acp$var$contrib[, 1:nComp] dfACPVars &lt;- data.frame(Variable = row.names(res.acp$var$coord[, 1:nComp]), Coord = CoordsVar, Cos2 = Cos2Var, Qualite = rowSums(Cos2Var), Ctr = CtrVar) row.names(dfACPVars) &lt;- NULL names(dfACPVars) &lt;- str_replace(names(dfACPVars), &quot;.Dim.&quot;, &quot;Comp&quot;) dfACPVars # Histogrammes pour les coordonnées couleursCoords &lt;- c(&quot;lightsalmon&quot;,&quot;steelblue&quot;) plotCoordF1 &lt;- ggplot(dfACPVars, aes(y = reorder(Variable, CoordComp1), x = CoordComp1, fill=CoordComp1&lt;0))+ geom_bar(stat=&quot;identity&quot;, width = .6, alpha=.8, color=&quot;black&quot;)+ geom_vline(xintercept=0, color = &quot;black&quot;, size=1)+ scale_fill_manual(name=&quot;Coordonnée&quot;,values=couleursCoords, labels = c(&quot;Positive&quot;,&quot;Négative&quot;))+ labs(x=paste0(&quot;Axe 1 (&quot;, vppct[1],&quot;%)&quot;), y=&quot;Variable&quot;)+ theme(legend.position=&quot;none&quot;) plotCoordF2 &lt;- ggplot(dfACPVars, aes(y = reorder(Variable, CoordComp2), x = CoordComp2, fill=CoordComp2&lt;0))+ geom_bar(stat=&quot;identity&quot;, width = .6, alpha=.8, color=&quot;black&quot;)+ geom_vline(xintercept=0, color = &quot;black&quot;, size=1)+ scale_fill_manual(name=&quot;Coordonnée&quot;,values=couleursCoords, labels = c(&quot;Positive&quot;,&quot;Négative&quot;))+ labs(x=paste0(&quot;Axe 2 (&quot;, vppct[2],&quot;%)&quot;), y=&quot;Variable&quot;)+ theme(legend.position=&quot;none&quot;) plotCoordF3 &lt;- ggplot(dfACPVars, aes(y = reorder(Variable, CoordComp3), x = CoordComp3, fill=CoordComp3&lt;0))+ geom_bar(stat=&quot;identity&quot;, width = .6, alpha=.8, color=&quot;black&quot;)+ geom_vline(xintercept=0, color = &quot;black&quot;, size=1)+ scale_fill_manual(name=&quot;Coordonnée&quot;, values=couleursCoords, labels = c(&quot;Positive&quot;,&quot;Négative&quot;))+ labs(x=paste0(&quot;Axe 3 (&quot;, vppct[3],&quot;%)&quot;), y=&quot;Variable&quot;) annotate_figure(ggarrange(plotCoordF1, plotCoordF2, plotCoordF3, nrow=nComp), text_grob(&quot;Coordonnées des variables sur les axes factoriels&quot;, color = &quot;black&quot;, face = &quot;bold&quot;, size = 12)) # Contributions des variables à la formation des axes corrplot(CtrVar, is.corr=FALSE, method =&quot;square&quot;, addCoef.col = 1, cl.pos = FALSE) # La qualité des variables sur les composantes retenues : cosinus carrés corrplot(Cos2Var, is.corr=FALSE, method =&quot;square&quot;, addCoef.col = 1, cl.pos = FALSE) ggplot(dfACPVars)+ geom_bar(aes(y=reorder(Variable, Qualite), x=Qualite), stat=&quot;identity&quot;, width = .6, alpha=.8, fill=&quot;steelblue&quot;)+ labs(x=&quot;&quot;, y=&quot;Somme des cosinus carrés sur les axes retenus&quot;, title =&quot;Qualité de représentation des variables sur les axes retenus de l&#39;ACP&quot;, subtitle = paste0(&quot;Variance expliquée par les &quot;, nComp, &quot; composantes : &quot;, sum(vppct), &quot;%&quot;)) Figure 12.18: Histogrammes personnalisés avec les coordonnées factorielles pour les variables Figure 12.19: Graphiques personnalisés avec les contributions des variables Figure 12.20: Graphiques personnalisés avec les cosinus carrés des variables Figure 12.21: Graphique personnalisé avec la qualité des variables sur les axes retenus de lACP Troisièmement, lorsque les observations sont des unités spatiales, il convient de cartographier les coordonnées factorielles des individus. Dans le jeu de données utilisé, les observations sont des polygones délimitant les îlots regroupés pour linformation statistique (IRIS) pour lagglomération de Lyon (France). Nous utilisons les packages tmap et RColorBrewer pour réaliser des cartes choroplèthes avec les coordonnées des deux premières composantes (figure 12.22). library(&quot;tmap&quot;) library(&quot;RColorBrewer&quot;) # Analyse des résultats de l&#39;ACP pour les individus # Dataframe des résultats pour les individus CoordsInd &lt;- res.acp$ind$coord[, 1:nComp] Cos2Ind &lt;- res.acp$ind$cos2[, 1:nComp] CtrInd &lt;- res.acp$ind$contrib[, 1:nComp] dfACPInd &lt;- data.frame(Coord = CoordsInd, Cos2 = Cos2Ind, Ctr = CtrInd) names(dfACPInd) &lt;- str_replace(names(dfACPInd), &quot;.Dim.&quot;, &quot;Comp&quot;) # Fusion du tableau original avec les résultats de l&#39;ACP pour les individus CartoACP &lt;- cbind(LyonIris, dfACPInd) # Cartographie des coordonnées factorielles pour les individus pour les # deux premières composantes Carte1 &lt;- tm_shape(CartoACP) + tm_polygons(col = &quot;CoordComp1&quot;, style = &quot;cont&quot;, midpoint = 0, title = &#39;Coordonnées&#39;)+ tm_layout(main.title = paste0(&quot;Axe 1 (&quot;, vppct[1],&quot;%)&quot;), attr.outside = TRUE, frame = FALSE, main.title.size = 1) Carte2 &lt;- tm_shape(CartoACP) + tm_polygons(col = &quot;CoordComp2&quot;, style = &quot;cont&quot;, midpoint = 0, title = &#39;Coordonnées&#39;)+ tm_layout(main.title = paste0(&quot;Axe 2 (&quot;, vppct[2],&quot;%)&quot;), attr.outside = TRUE, frame = FALSE, main.title.size = 1) tmap_arrange(Carte1, Carte2) Figure 12.22: Cartographie des coordonnées factorielles des individus Exploration interactive des résultats dune ACP avec le package explor. Vous avez compris quil ne suffit pas de calculer une ACP, il faut retenir les n premiers axes de lACP qui nous semblent les plus pertinents, puis les interpréter à la lecture des coordonnées factorielles, des cosinus carrés et des contributions des variables et des individus sur les axes. Il faut donc bien explorer les résultats à laide de tableaux et de graphiques! Cela explique que nous avons mobilisé de nombreux graphiques dans les deux sections précédentes (12.2.3.2 et 12.2.3.3). Lexploration des données dune ACP peut aussi être réalisée avec des graphiques interactifs. Or, un superbe package dénommé explor (https://juba.github.io/explor/), reposant sur Shiny (https://shiny.rstudio.com/), permet dexplorer de manière interactive les résultats de plusieurs méthodes factorielles calculés avec FactorMinerR. Pour cela, il vous suffit de lancer les deux lignes de code suivantes : library(explor) explor(res.acp) Finalement, explor permet également dexplorer les résultats dune analyse des correspondances (AFC) et dune analyse des correspondances multiples (ACM). References "],["sect123.html", "12.3 Analyse factorielle des correspondances (AFC)", " 12.3 Analyse factorielle des correspondances (AFC) Pour bien comprendre lAFC, il est essentiel de bien maîtriser les notions de tableau de contingence (marges du tableau, fréquences observées et théoriques, pourcentages en ligne et en colonne, contributions au khi-deux) et de distance du khi-deux. Si ce nest pas le cas, il est conseillé de (re)lire le chapitre 5. Dans le chapitre 5, nous avons vu comment construire un tableau de contingence (figure 12.23) à partir de deux variables qualitatives comprenant plusieurs modalités, puis comment vérifier sil y a dépendance entre les deux variables qualitatives avec le test du khi-deux. Or, sil y a bien dépendance, il est peut-être judicieux de résumer linformation que contient le tableau de contingence en quelques nouvelles variables synthétiques, objectif auquel répond lanalyse factorielle des correspondances (AFC). Figure 12.23: Tableau de contingence pour une AFC À titre de rappel (section 12.1.2), lAFC a été développée par le statisticien français Jean-Paul Benzécri (1973). Cela explique quelle est souvent enseignée et utilisée en sciences sociales dans les universités francophones, mais plus rarement dans les universités anglophones. Pourtant, les applications de lAFC sont nombreuses dans différentes disciplines des sciences sociales comme illustrées avec les exemples suivants : En géographie, les modalités de la première variable du tableau de contingence sont souvent des entités spatiales (régions, municipalités, quartiers, etc.) croisées avec les modalités dune autre variable qualitative (catégories socioprofessionnelles, modes de transport, tranches de revenu des ménages ou des individus, etc.). En économie régionale, nous pourrions vouloir explorer un tableau de contingence croisant des entités spatiales (par exemple, MRC au Québec, départements en France) et les effectifs demplois pour différents secteurs dactivité. En sciences politiques, le recours à lAFC peut être intéressant pour explorer les résultats dune élection. Les deux variables qualitatives pourraient être les circonscriptions électorales et les partis politiques. Le croisement des lignes et des colonnes du tableau de contingence représenterait le nombre de votes obtenus par un parti politique j dans la circonscription électorale i. Appliquer une AFC sur un tel tableau de contingence permettrait de révéler les ressemblances entre les différents partis politiques et celles entre les circonscriptions électorales. ::: {.bloc_attention data-latex=\"\"} Application dune ACP sur un tableau de contingence transformé en un tableau avec les pourcentages en ligne : un bien mauvais calcul Il pourrait être tentant de transformer le tableau de contingence initial (tableau 12.7) en un tableau avec les pourcentages en ligne (tableau 12.8) afin de lui appliquer une analyse en composantes principales. Une telle démarche a deux inconvénients majeurs : chacune des modalités de la première variable qualitative (I) aurait alors le même poids; chacune des modalités de la deuxième variable (J) aurait aussi le même poids. Or, à la lecture des marges en ligne et en colonne au tableau 12.7, il est clair que les modalités j1 et i1 comprennent bien plus dindividus que les autres modalités respectives. Si nous reprenons le dernier exemple applicatif, cela signifierait que le même poids est accordé à chaque parti puisque les variables sont centrées réduites en ACP (moyenne = 0 et variance = 1). Autrement dit, les grands partis traditionnels seraient ainsi sur le pied dégalité que les autres partis. Aussi, chaque circonscription électorale aurait le même poids bien que certaines comprennent bien plus délecteurs et délectrices que dautres. Tableau 12.7: Exemple de tableau de contingence pour lAFC j1 j2 j3 j4 j5 Marge (ligne) i1 357 060 22 010 276 625 65 000 29 415 750 110 i2 427 530 26 400 295 860 69 410 30 645 849 845 i3 147 500 6 545 34 545 4 415 1 040 194 045 i4 128 520 6 405 42 925 6 565 2 670 187 085 Marge (colonne) 1 060 610 61 360 649 955 145 390 63 770 1 981 085 Tableau 12.8: Exemple dun tableau de contingence transformé (pourcentage en ligne) pour lACP V1 V2 V3 V4 V5 i1 47,6 2,9 36,9 8,7 3,9 i2 50,3 3,1 34,8 8,2 3,6 i3 76,0 3,4 17,8 2,3 0,5 i4 68,7 3,4 22,9 3,5 1,4 ::: 12.3.1 Recherche dune simplification basée sur la distance du khi-deux Sur le plan mathématique et des objectifs visés, lAFC est similaire à lACP puisquelle permet dexplorer un tableau de trois façons : 1) en montrant les ressemblances entre un ensemble dindividus (I), 2) en révélant les liaisons entre les variables (J) et 3) en résumant le tout avec des variables synthétiques. Toutefois, avec lAFC, les ensembles I et J sont les modalités de deux variables qualitatives (dont le croisement forme un tableau de contingence) et elle est basée sur la distance du khi-deux (et non sur la distance euclidienne comme en ACP). Ainsi, avec la distance du khi-deux, la proximité (ressemblance) entre deux lignes (i et l) et deux colonnes (j et k) est mesurée comme suit : \\[\\begin{equation} d_{\\chi_{il}^2} = \\sum_j \\frac{1}{f_{.j}}(\\frac{f_{ij}}{f_{i.}}-\\frac{f_{lj}}{f_{l.}})^2 \\tag{12.5} \\end{equation}\\] \\[\\begin{equation} d_{\\chi_{jk}^2} = \\sum_i \\frac{1}{f_{i.}}(\\frac{f_{ij}}{f_{.j}}-\\frac{f_{ik}}{f_{.k}})^2 \\tag{12.6} \\end{equation}\\] Prenons un exemple fictif pour calculer ces deux distances. Le tableau 12.9 comprend trois modalités en ligne (I) et trois autres en colonne (J). Le total des effectifs de ce tableau de contingence est égal à 1 665. À partir des données brutes, il est facile de construire deux tableaux : le profil des lignes et le profil des colonnes (tableau 12.10), cest-à-dire les proportions en ligne et en colonne. Tableau 12.9: Données brutes du tableau de contingence j1 j2 j3 Total (ligne) i1 360 65 275 700 i2 420 70 290 780 i3 145 5 35 185 Total (colonne) 925 140 600 1 665 Tableau 12.10: Profils des lignes et des colonnes j1 j2 j3 Total Profil des lignes i1 0,514 0,093 0,393 1 i2 0,538 0,090 0,372 1 i3 0,784 0,027 0,189 1 Profils des colonnes i1 0,389 0,464 0,458 i2 0,454 0,500 0,483 i3 0,157 0,036 0,058 Total 1,000 1,000 1,000 En divisant les valeurs du tableau 12.9 par le grand total (1 665), nous obtenons tous les termes utilisés dans les équations (12.5) et (12.6) au tableau 12.11 : Les fréquences relatives dénommées \\(f_{ij}\\). La marge \\(fi.\\) est égale à la somme des fréquences relatives en ligne. La marge \\(f.j\\) est égale à la somme des fréquences relatives en colonne. La somme de toutes les fréquences relatives est donc égale à 1, soit \\(\\sum{f_{i.}}\\) ou \\(\\sum{f_{.j}}\\). Tableau 12.11: Données relatives du tableau de contingence (fij) j1 j2 j3 Total (fi.) i1 0,216 0,039 0,165 0,420 i2 0,252 0,042 0,174 0,468 i3 0,087 0,003 0,021 0,111 Total (f.j) 0,556 0,084 0,360 1,000 Il est possible de calculer les distances entre les différentes modalités de I en appliquant léquation (12.5); par exemple, la distance entre les observations i1 et i2 est égale à : \\[d_{(i1,i2)}=\\frac{\\mbox{1}}{\\mbox{0,556}}(\\mbox{0,216}-\\mbox{0,252})^2+\\frac{\\mbox{1}}{\\mbox{0,084}}(\\mbox{0,039}-\\mbox{0,042})^2+ \\frac{\\mbox{1}}{\\mbox{0,360}}(\\mbox{0,165}-\\mbox{0,174})^2=\\mbox{0,003}\\] Avec léquation (12.6), la distance entre les modalités j1 et j2 de J est égale à : \\[d_{(j1,j2)}=\\frac{\\mbox{1}}{\\mbox{0,420}}(\\mbox{0,216}-\\mbox{0,039})^2+ \\frac{\\mbox{1}}{\\mbox{0,468}}(\\mbox{0,252}-\\mbox{0,042})^2 + \\frac{\\mbox{1}}{\\mbox{0,111}}(\\mbox{0,087}-\\mbox{0,003})^2=\\mbox{0,233}\\] À la lecture du tableau 12.12, les modalités les plus semblables sont i1 et i2 (0,003) pour I et j1 et j3 (0,058) pour J. Tableau 12.12: Distances du khi-deux entre les modalités I et les modalités J Ind. i1 i2 i3 Col. j1 j2 j3 i1 0,000 0,003 0,103 j1 0,000 0,233 0,058 i2 0,003 0,000 0,132 j2 0,233 0,000 0,078 i3 0,103 0,132 0,000 j3 0,058 0,078 0,000 Finalement, lapproche pour déterminer les axes factoriels de lAFC est similaire à celle de lACP : les axes factoriels sont les droites orthogonales qui minimisent les distances aux points du profil des lignes, excepté que la métrique pour mesurer ces distances est celle du khi-deux (et non celle la distance euclidienne comme pour lACP). Pour plus détails sur le calcul de ces axes (notamment les formulations matricielles), consultez notamment Benzécri (1973), Escofier et Pagès (1998) et Lebart et al. (1995). 12.3.2 Aides à linterprétation Pour illustrer les aides à linterprétation de lAFC, nous utilisons un jeu de données spatiales extrait du profil du recensement de 2016 de Statistique Canada pour les secteurs de recensement de lîle de Montréal. La liste des modalités des variables quil comprend est reportée au tableau 12.13. LAFC est calculée sur un tableau de contingence croisant les secteurs de recensement (lignes) et les modalités dune variable relative au mode de transport utilisé pour les déplacements domicile-travail (colonnes). Ces modalités sont cartographiées à la figure 12.24. Tableau 12.13: Jeu de données utilisé pour lanalyse factorielle des correspondances Nom Intitulé Somme Modalités de la variable utilisée dans lAFC (mode de transport) VehCond Véhicule motorisé (conducteur·trice) 427 560 VehPass Véhicule motorisé (passager·ère) 26 490 TranspC Transport en commun 295 800 Apied À pied 69 330 Velo Bicyclette 30 615 AutreMoyen Autre moyen 7 750 Modalités de la variable supplémentaire (durée du trajet) T15min Moins de 15 minutes 130 435 T1529min 15 à 29 minutes 287 500 T3044min 30 à 44 minutes 244 425 T4559min 45 à 59 minutes 107 065 T60plus 60 minutes et plus 88 050 Figure 12.24: Cartographie des modalités de la variable mode de transport utilisée pour lAFC 12.3.2.1 Résultats de lAFC pour les valeurs propres Avant de calculer lAFC, il convient de vérifier sil y a bien une dépendance entre les modalités des deux variables qualitatives. En effet, si les deux variables sont indépendantes, il nest pas nécessaire de résumer le tableau de contingence avec une AFC. Pour ce faire, nous utilisons le test du khi-deux largement décrit à la section 5.2. Les résultats de ce test signalent quil existe des associations entre les modalités des deux variables (\\(\\chi\\) = 203 971, p &lt; 0,001, tableau 12.14). Nous pouvons donc appliquer une AFC sur ce tableau de contingence. Tableau 12.14: Résultats du test du khi-deux sur le tableau de contingence Mesure Valeur Modalités I (secteurs de recensement) 521,00 Modalités J (variable mode de transport) 6,00 Somme des données brutes (\\(n_{ij}\\)) 857 545,00 Khi-deux (\\(\\chi^2\\)) 207 129,27 Degrés de liberté, soit \\((c-1)\\times(l-1)\\) 2 600,00 Valeur de p 0,00 Coefficient Phi au carré (\\(\\phi^2=\\chi^2 / n_{ij})\\) 0,24 Nous avons vu quen ACP normée (section 12.2.2.1), la somme des valeurs propres est égale au nombre de variables puisquelles sont centrées réduites. Par contre, en AFC, cette somme est égale à linertie totale du tableau de contingence, cest-à-dire à la valeur du khi-deux divisée par le nombre total des effectifs bruts (soit le coefficient phi au carré, \\(\\phi^2\\)) (section 5.2). Le tableau 12.15 permet de vérifier que la somme des valeurs propres est bien égale au coefficient phi au carré : \\[\\mbox{0,156}+\\mbox{0,046}+\\mbox{0,031}+\\mbox{0,004}+\\mbox{0,004} = \\mbox{0,24}\\] \\[\\phi^2 = \\chi^2 / n_{ij}=\\mbox{203 971}/ \\mbox{849 795} = \\mbox{0,24}\\] Tableau 12.15: Résultats de lAFC pour les valeurs propres Axe factoriel Valeur propre Pourcentage Pourc. cumulé 1 0,156 64,590 64,590 2 0,046 19,250 83,840 3 0,031 12,995 96,835 4 0,004 1,683 98,518 5 0,004 1,482 100,000 Combien daxes dune AFC faut-il retenir? Approche statistique. Mike Bendixen (1995), cité dans lexcellent site STHDA, propose deux critères pour sélectionner les premiers axes dune AFC : \\(c_1= 1 / (l-1) \\times 100\\) et \\(c_2= 1 / (c-1) \\times 100\\) avec l et c étant respectivement les nombres de modalités en ligne et en colonne. Autrement dit, lorsque les données sont distribuées aléatoirement, la valeur propre en pourcentage devrait être égale à \\(c_1\\) et celle de laxe factoriel moyen à \\(c_2\\). Par conséquent, nous pourrions retenir uniquement les axes dont les valeurs propres en pourcentage excèdent : \\(c_1 = \\mbox{1}/(\\mbox{521}-\\mbox{1})\\times \\mbox{100}=\\mbox{0,19 }%\\) et \\(c_2=\\mbox{1}/(\\mbox{6}-\\mbox{1})\\times \\mbox{100}=\\mbox{20 }%\\). En appliquant ces deux critères, seul le premier axe factoriel qui résume 65,6 % mérite dêtre retenu. Approche empirique basée sur la lecture des pourcentages et des pourcentages cumulés. Nous retenons uniquement les deux premières composantes qui résument 85 % de la variance totale. Pour faciliter le choix du nombre daxes avec cette approche empirique, il est fortement conseillé de construire un histogramme à partir des valeurs propres, soit brutes, soit en pourcentage, soit en pourcentage cumulé (figure 12.25). Figure 12.25: Histogramme des valeurs propres de lAFC 12.3.2.2 Résultats de lAFC pour les variables et les individus Comme pour lACP, nous retrouvons les trois mêmes mesures pour les variables et les individus : 1) les coordonnées factorielles, 2) les contributions et 3) les cosinus carrés. Compréhension des axes factoriels de lAFC : une étape essentielle, incontournable Comme en ACP, lanalyse des trois mesures (coordonnées, contributions et cosinus carrés) pour les variables et les individus doit vous permettre de comprendre la signification des axes factoriels retenus de lAFC. Cette étape dinterprétation est essentielle afin de qualifier les variables latentes (axes factoriels, variables synthétiques) produites par lAFC. Les coordonnées factorielles sont simplement les projections des points-lignes et des points-colonnes sur les axes de lAFC. Tant pour les lignes que pour les colonnes, ces coordonnées bénéficient de deux propriétés intéressantes. Premièrement, pour chaque axe factoriel k, la somme du produit des marges des variables (\\(f.j\\), colonnes) ou des individus (\\(fi.\\), lignes) avec leurs coordonnées respectives (\\(C^k_j\\) et \\(C^k_i\\)) est égale à 0 (équation (12.7)). Deuxièmement, pour chaque axe factoriel k, la somme des produits entre les marges (en ligne et en colonne) et les coordonnées au carré (en ligne et en colonne) est égale à la valeur propre de laxe (équation (12.8)). \\[\\begin{equation} \\sum{f.j (C^k_j)}= 0 \\text{ et} \\sum{fi. (C^k_i)}= 0 \\tag{12.7} \\end{equation}\\] \\[\\begin{equation} \\sum{fi. (C^k_i)^2}= \\mu_k \\text{ et} \\sum{f.j (C^k_j)^2}= \\mu_k \\tag{12.8} \\end{equation}\\] En guise dexemple, le tableau 12.16 permet de vérifier les deux propriétés des coordonnées pour les variables. Les sommes de \\({f.j (C^k_j)}\\) pour les axes 1 et 2 sont bien égales à 0; et les sommes de \\({f.j (C^k_j)^2}\\) pour les axes 1 et 2 sont bien égales aux valeurs propres de ces deux axes, soit 0,156 et 0,046 (comparez ces valeurs avec celles reportées au tableau 12.15 plus haut). Tableau 12.16: Vérification des deux propriétés des coordonnées factorielles pour les variables Coord. f.j x Coord. f.j x Coord2 Modalité f.j 1 2 1 2 1 2 VehCond 0,499 -0,329 0,077 -0,164 0,038 0,054 0,003 VehPass 0,031 -0,255 0,081 -0,008 0,003 0,002 0,000 TranspC 0,345 0,208 -0,229 0,072 -0,079 0,015 0,018 Apied 0,081 0,813 0,545 0,066 0,044 0,053 0,024 Velo 0,036 0,938 -0,187 0,033 -0,007 0,031 0,001 AutreMoyen 0,009 0,142 0,078 0,001 0,001 0,000 0,000 Somme 1,000 0,000 0,000 0,156 0,046 Contrairement à lACP, les coordonnées factorielles pour les variables en AFC ne sont pas les coefficients de corrélation de Pearson des variables sur les axes! Les contributions des colonnes ou des lignes en AFC permettent des repérer celles qui contribuent le plus à la formation des axes factoriels (de manière analogue à lACP). Pour un axe donné, leur sommation est égale à 100 %. Elles sobtiennent en multipliant la coordonnée au carré avec la marge et en divisant le tout par la valeur propre de laxe (équations (12.9) et (12.10)). \\[\\begin{equation} \\mbox{Ctr}_j^k =\\frac{f.j(C^k_j)^2}{\\mu_{k}}\\times 100 \\tag{12.9} \\end{equation}\\] \\[\\begin{equation} \\mbox{Ctr}_i^k =\\frac{fi.(C^k_i)^2}{\\mu_{k}}\\times 100 \\tag{12.10} \\end{equation}\\] Les cosinus carrés (Cos2) (appelés aussi les qualités de représentation sur un axe) permettent de repérer le ou les axes qui concourent le plus à donner un sens aux colonnes (variables) et aux lignes (individus), de manière analogue à lACP. Pour une variable ou un individu, la sommation des Cos2 pour tous les axes de lAFC est aussi égale à 1. Interprétation des résultats pour les colonnes (variables) Maintenant, analysons ces trois statistiques pour les variables pour les deux premiers axes de lAFC (tableau 12.17 et figure 12.26). Pour laxe 1, résumant 65 % de la variance, trois modalités concourent à sa formation : VehCond (34,69 %), Apied (34,25 %) et Velo (20,13 %). À la lecture des coordonnées factorielles sur cet axe, les modes de transport relatifs aux véhicules motorisés (VehCond = -0,33 et VehPass = -0,25) sopposent clairement aux modes actifs (Apied = 0,81 et Velo = 0,94), constat quil est possible de confirmer visuellement avec la figure 12.26. La modalité VehCond a dailleurs la plus forte valeur de Cos2 sur cet axe (0,92), ce qui signale, sans lombre dun doute, que laxe 1 est celui qui donne le plus de sens à cette modalité. Puisque laxe 2 résume une partie beaucoup plus limitée de la variance du tableau (19,25 %), il nest pas étonnant quun nombre plus limité de modalités concourent à sa formation : seules les contributions de la modalité Apied (51,68 %) et secondairement de VehPass (38,81 %) sont importantes. Leurs coordonnées factorielles sopposent dailleurs sur cet axe (respectivement 0,81 et 0,21). Tableau 12.17: Résultats de lAFC pour les variables Coordonnées Cosinus carrés Contributions (%) Modalité 1 2 1 2 1 2 VehCond -0,33 0,08 0,92 0,05 34,69 6,33 VehPass -0,25 0,08 0,34 0,03 1,28 0,44 TranspC 0,21 -0,23 0,39 0,47 9,53 38,81 Apied 0,81 0,54 0,67 0,30 34,25 51,61 Velo 0,94 -0,19 0,56 0,02 20,13 2,69 AutreMoyen 0,14 0,08 0,05 0,01 0,12 0,12 Figure 12.26: Premier plan factoriel de lAFC pour les variables Interprétation des résultats pour les individus Premier plan factoriel pour les variables et les individus Lorsque le jeu de données comprend à la fois peu de modalités en ligne et en colonne, il est judicieux de les représenter simultanément sur le premier plan factoriel (axes 1 et 2). Pour ce faire, vous pouvez utiliser la fonction fviz_ca_biplot du package factoextra. Étant donné que notre jeu de données comprend 521 secteurs de recensement, nous proposons ici de cartographier les coordonnées factorielles des individus pour les deux premiers axes de lAFC (figure 12.27). Pour laxe 1, les secteurs de recensement à lest et louest de lîle de Montréal présentent les coordonnées les plus fortement négatives (en rouge); dans ces zones, lusage des véhicules motorisés pour des déplacements domicile-travail est certainement surreprésenté, comparativement aux modes actifs. À linverse, dans les secteurs de recensement du centre de lîle présentant de fortes valeurs positives (en rouge), le recours aux modes de transports actifs (marche et vélo) est bien plus important, toutes proportions gardées. Quant à la cartographie des coordonnées pour laxe 2, elle permet surtout de repérer quelques secteurs de recensement autour du centre-ville (très fortes valeurs positives en vert foncé) où les déplacements domicile-travail à pied sont plus fréquents, toutes proportions gardées. En résumé, suite à lanalyse des coordonnées factorielles des variables et des individus, nous pouvons conclure que le premier axe est certainement le plus intéressant puisquil permet dopposer lusage des modes de transports motorisés versus les modes de transports actifs pour les déplacements domicile-travail sur lîle de Montréal. Cette nouvelle variable synthétique (variable latente) pourrait ainsi être introduite dans des analyses subséquentes (par exemple, dans un modèle de régression). Cela démontre quau même titre que lACP, lAFC est une méthode de réduction de données puisque nous sommes passés dun tableau comprenant 512 secteurs de recensement et six modalités à un tableau comprenant une seule variable synthétique (axe 1). Figure 12.27: Cartographie de coordonnées factorielles des individus pour lAFC Ajout de modalités supplémentaires dans une analyse des correspondances (AFC) Comme pour lACP, il est possible dajouter des variables et des individus supplémentaires une fois lAFC calculée. En guise dillustration, nous avons ajouté à lAFC précédemment analysée des modalités relatives à la durée des temps de déplacements : moins de 15 minutes, 15 à 29, 30 à 44, 45 à 59, 60 minutes et plus. Sans surprise, sur le premier plan factoriel à la figure 12.27, cette dernière modalité, représentant les trajets les plus longs, est la plus proche des modalités relatives à lusage des véhicules motorisés (VehCond et VehPass). Figure 12.28: Ajout de modalités supplémentaires sur le premier plan factoriel de lAFC 12.3.3 Mise en uvre dans R 12.3.3.1 Calcul dune AFC avec FactoMineR Plusieurs packages permettent de calculer une AFC dans R, notamment ca (fonction ca), MASS (fonction corresp), ade4 (fonction dudi.coa) et FactoMineR (fonction CA). De nouveau, nous utilisons FactoMineR couplé au package factoextra pour réaliser rapidement des graphiques avec les résultats pour les variables et les coordonnées. Pour calculer lAFC, il suffit dutiliser la fonction CA de FactoMineR, puis la fonction summary(res.afc), qui renvoie les résultats de lAFC pour : Les valeurs propres (section Eigenvalues) pour les axes factoriels (Dim.1 à Dim.n) avec leur variance expliquée brute (Variance), en pourcentage (% of var.) et en pourcentage cumulé (Cumulative % of var.). Les dix premières observations (section Rows) avec les coordonnées factorielles (Dim.1 à Dim.n), les contributions (ctr) et les cosinus carrés (cos2). Pour accéder aux résultats pour toutes les observations, utilisez les fonctions res.afc$row ou encore res.afc$row$coord (uniquement les coordonnées factorielles), res.afc$row$contrib (uniquement les contributions) et res.afc$row$cos2 (uniquement les cosinus carrés). Les colonnes (section Columns) avec les coordonnées factorielles (Dim.1 à Dim.n), les contributions (ctr) et les cosinus carrés (cos2). # Chargement des packages library(FactoMineR) library(factoextra) # Chargement des données load(&quot;data/analysesfactorielles/DonneesAFC.Rdata&quot;) # Avant de calculer l&#39;AFC, il convient de vérifier si les deux variables # qualitatives sont dépendantes avec le test du khi-deux khideux &lt;- chisq.test(dfDonneesAFC[,1:6]) print(khideux) ## ## Pearson&#39;s Chi-squared test ## ## data: dfDonneesAFC[, 1:6] ## X-squared = 207129, df = 2600, p-value &lt; 2.2e-16 if(khideux$p.value &lt;=0.05){ cat(&quot;La valeur de p &lt; 0,05. Les variables sont dépendantes. Calculer l&#39;AFC.&quot;) }else { cat(&quot;La valeur de p &gt; 0,05. Les variables sont indépendantes. Inutile de calculer l&#39;AFC&quot;) } ## La valeur de p &lt; 0,05. Les variables sont dépendantes. Calculer l&#39;AFC. # Calcul de l&#39;analyse des correspondances sur les six premières variables res.afc &lt;- CA(dfDonneesAFC[,1:6], graph=F) # Affichage des résultats de la fonction CA print(res.afc) ## **Results of the Correspondence Analysis (CA)** ## The row variable has 521 categories; the column variable has 6 categories ## The chi square of independence between the two variables is equal to 207129.3 (p-value = 0 ). ## *The results are available in the following objects: ## ## name description ## 1 &quot;$eig&quot; &quot;eigenvalues&quot; ## 2 &quot;$col&quot; &quot;results for the columns&quot; ## 3 &quot;$col$coord&quot; &quot;coord. for the columns&quot; ## 4 &quot;$col$cos2&quot; &quot;cos2 for the columns&quot; ## 5 &quot;$col$contrib&quot; &quot;contributions of the columns&quot; ## 6 &quot;$row&quot; &quot;results for the rows&quot; ## 7 &quot;$row$coord&quot; &quot;coord. for the rows&quot; ## 8 &quot;$row$cos2&quot; &quot;cos2 for the rows&quot; ## 9 &quot;$row$contrib&quot; &quot;contributions of the rows&quot; ## 10 &quot;$call&quot; &quot;summary called parameters&quot; ## 11 &quot;$call$marge.col&quot; &quot;weights of the columns&quot; ## 12 &quot;$call$marge.row&quot; &quot;weights of the rows&quot; # Visualisation des marges en colonne round(res.afc$call$marge.col,4) ## VehCond VehPass TranspC Apied Velo AutreMoyen ## 0.4986 0.0309 0.3449 0.0808 0.0357 0.0090 # Visualisation des marges en ligne. Étant donnée que nous avons 521 individus, # la ligne ci-dessous est en commentaire # round(res.afc$call$marge.row,4) # Sommaire des résultats de l&#39;AFC # Remarquez que la première ligne de ce sommaire est le résultat du khi-deux summary(res.afc) ## ## Call: ## CA(X = dfDonneesAFC[, 1:6], graph = F) ## ## The chi square of independence between the two variables is equal to 207129.3 (p-value = 0 ). ## ## Eigenvalues ## Dim.1 Dim.2 Dim.3 Dim.4 Dim.5 ## Variance 0.156 0.046 0.031 0.004 0.004 ## % of var. 64.590 19.250 12.995 1.683 1.482 ## Cumulative % of var. 64.590 83.840 96.835 98.518 100.000 ## ## Rows (the 10 first) ## Iner*1000 Dim.1 ctr cos2 Dim.2 ctr cos2 Dim.3 ## 1 | 0.155 | -0.304 0.095 0.961 | -0.023 0.002 0.006 | 0.048 ## 2 | 0.123 | -0.232 0.067 0.850 | 0.028 0.003 0.012 | -0.021 ## 3 | 0.268 | -0.246 0.127 0.737 | -0.002 0.000 0.000 | -0.046 ## 4 | 0.102 | -0.168 0.034 0.513 | -0.111 0.049 0.222 | -0.117 ## 5 | 0.118 | -0.251 0.067 0.883 | 0.004 0.000 0.000 | -0.007 ## 6 | 0.120 | -0.130 0.024 0.313 | -0.103 0.051 0.196 | -0.144 ## 7 | 0.124 | -0.029 0.002 0.022 | -0.158 0.167 0.626 | -0.079 ## 8 | 0.073 | -0.157 0.028 0.598 | -0.090 0.031 0.195 | -0.006 ## 9 | 0.014 | -0.060 0.005 0.506 | -0.033 0.005 0.150 | -0.018 ## 10 | 0.040 | 0.004 0.000 0.000 | -0.204 0.073 0.838 | 0.053 ## ctr cos2 ## 1 0.012 0.024 | ## 2 0.003 0.007 | ## 3 0.022 0.026 | ## 4 0.080 0.246 | ## 5 0.000 0.001 | ## 6 0.146 0.380 | ## 7 0.061 0.155 | ## 8 0.000 0.001 | ## 9 0.002 0.048 | ## 10 0.007 0.056 | ## ## Columns ## Iner*1000 Dim.1 ctr cos2 Dim.2 ctr cos2 Dim.3 ## VehCond | 58.559 | -0.329 34.687 0.924 | 0.077 6.331 0.050 | 0.051 ## VehPass | 5.923 | -0.255 1.283 0.338 | 0.081 0.440 0.035 | 0.001 ## TranspC | 38.261 | 0.208 9.534 0.389 | -0.229 38.812 0.472 | -0.124 ## Apied | 79.193 | 0.813 34.252 0.675 | 0.545 51.610 0.303 | -0.147 ## Velo | 55.633 | 0.938 20.126 0.564 | -0.187 2.688 0.022 | 0.802 ## AutreMoyen | 3.969 | 0.142 0.117 0.046 | 0.078 0.119 0.014 | 0.070 ## ctr cos2 ## VehCond 4.141 0.022 | ## VehPass 0.000 0.000 | ## TranspC 16.995 0.139 | ## Apied 5.543 0.022 | ## Velo 73.180 0.413 | ## AutreMoyen 0.140 0.011 | 12.3.3.2 Exploration graphique des résultats de lAFC avec factoextra Comme pour lACP, factoextra dispose de plusieurs fonctions très intéressantes pour construire rapidement des graphiques avec les résultats de lAFC. Premièrement, la syntaxe ci-dessous (avec la fonction fviz_screeplot) renvoie deux graphiques pour analyser les résultats des valeurs propres de lAFC (figure 12.29). library(factoextra) library(ggplot2) library(ggpubr) # Nombre de modalités en ligne et en colonne ModalitesLig &lt;- nrow(dfDonneesAFC) ModalitesCol &lt;- ncol(dfDonneesAFC[,1:6]) # Critère statistique du profil moyen critere2 &lt;- round(1/(ModalitesCol-1)*100,2) texte &lt;- paste0(&quot;Critère pour le profil moyen : &quot;, as.character(critere2), &quot; %&quot;) # Graphique avec les valeurs propres G1 &lt;- fviz_screeplot(res.afc, choice=&quot;eigenvalue&quot;, ylab=&quot;Valeurs propres&quot;, xlab=&quot;Axes factoriels&quot;, main=&quot;Valeurs propres&quot;) G2 &lt;- fviz_screeplot(res.afc, choice=&quot;variance&quot;, addlabels = TRUE, ylim = c(0, 70), ylab=&quot;Variance expliquée (%)&quot;, xlab=&quot;Axes factoriels&quot;, main=&quot;Valeurs propres (%)&quot;)+ geom_hline(yintercept = c2, linetype = 1, color = &quot;red&quot;, size=1)+ annotate(geom=&quot;text&quot;, x = ModalitesCol-.5, y= critere2+3, label=texte, color=&quot;red&quot;, hjust = 1, size = 4) ggarrange(G1, G2) Figure 12.29: Graphiques pour les valeurs propres de lAFC avec factoextra Avec les fonctions fviz_contrib et fviz_cos2, il est très facile de réaliser des histogrammes pour les contributions et les cosinus carrés pour les variables (colonnes) ou les individus (lignes), et ce, avec le paramètre choice = c(\"row\", \"col\") (figure 12.30). library(factoextra) library(ggplot2) library(ggpubr) VP1pct &lt;- round(res.afc$eig[1,2],2) VP2pct &lt;- round(res.afc$eig[2,2],2) G1 &lt;- fviz_contrib (res.afc, choice = &quot;col&quot;, axes = 1, title=&quot;Axe 1&quot;) G2 &lt;- fviz_contrib (res.afc, choice = &quot;col&quot;, axes = 2, title=&quot;Axe 2&quot;) ggarrange(G1, G2, ncol = 2, nrow = 1) Figure 12.30: Contributions des variables avec factoextra Quant aux fonctions fviz_ca_col et fviz_ca_row, elles permettent rapidement de construire le premier plan factoriel pour les colonnes (variables) et les lignes (individus) (figure 12.31). Aussi, la fonction fviz_ca_biplot permet de construire un plan factoriel, mais avec les lignes et les colonnes simultanément. G3 &lt;- fviz_ca_col(res.afc, repel = TRUE, geom= c(&quot;text&quot;,&quot;point&quot;), col.col = &quot;steelblue&quot;, title = &quot;Mode de transport&quot;, xlab=paste0(&quot;Axe 1 (&quot;, VP1pct, &quot; %)&quot;), ylab=paste0(&quot;Axe 2 (&quot;, VP2pct, &quot; %)&quot;)) G4 &lt;- fviz_ca_row(res.afc, repel = TRUE, geom= c(&quot;point&quot;), col.row = &quot;steelblue&quot;, title = &quot;Secteurs de recensement&quot;, xlab=paste0(&quot;Axe 1 (&quot;, VP1pct, &quot; %)&quot;), ylab=paste0(&quot;Axe 2 (&quot;, VP2pct, &quot; %)&quot;)) ggarrange(G3, G4, ncol = 2, nrow = 1) Figure 12.31: Premier plan factoriel de lAFC pour les variables et les individus avec factoextra La syntaxe ci-dessous permet dajouter des modalités supplémentaires dans lAFC et de constuire le graphique du premier plan factoriel (figure 12.32). # Les colonnes 7 à 11 sont mises comme des variables supplémentaires dans l&#39;AFC res.afc2 &lt;- CA(dfDonneesAFC, col.sup = 7:11, graph = FALSE) VP1pct &lt;- round(res.afc2$eig[1,2],2) VP2pct &lt;- round(res.afc2$eig[2,2],2) fviz_ca_col(res.afc2, repel = TRUE, geom= c(&quot;text&quot;,&quot;point&quot;), col.col = &quot;steelblue&quot;, title = &quot;&quot;, xlab=paste0(&quot;Axe 1 (&quot;, VP1pct, &quot; %)&quot;), ylab=paste0(&quot;Axe 2 (&quot;, VP2pct, &quot; %)&quot;)) Figure 12.32: Ajout de modalités supplémentaires sur le premier plan factoriel lAFC avec factoextra Finalement, la syntaxe ci-dessous permet de cartographier les coordonnées factorielles des individus de lAFC avec le package tmap (figure 12.33). library(tmap) library(stringr) dfAFCInd &lt;- data.frame(Coord = res.afc$row$coord, Cos2 = res.afc$row$cos2, Ctr = res.afc$row$contrib) names(dfAFCInd) &lt;- str_replace(names(dfAFCInd), &quot;.Dim.&quot;, &quot;Comp&quot;) CartoAFC &lt;- cbind(sfDonneesAFC, dfAFCInd) VP1pct &lt;- tofr(round(res.afc$eig[1,2],2)) VP2pct &lt;- tofr(round(res.afc$eig[2,2],2)) Carte1 &lt;- tm_shape(CartoAFC) + tm_fill(col = &quot;CoordComp1&quot;, style = &quot;cont&quot;, midpoint = 0, title = &#39;Coordonnées&#39;)+ tm_layout(title = paste0(&quot;Axe 1 (&quot;, VP1pct,&quot;%)&quot;), attr.outside = TRUE, frame = FALSE) Carte2 &lt;- tm_shape(CartoAFC) + tm_fill(col = &quot;CoordComp2&quot;, style = &quot;cont&quot;, midpoint = 0, title = &#39;Coordonnées&#39;)+ tm_layout(title = paste0(&quot;Axe 2 (&quot;, VP2pct,&quot;%)&quot;), attr.outside = TRUE, frame = FALSE) tmap_arrange(Carte1, Carte2, nrow = 1) Figure 12.33: Cartographie de coordonnées factorielles des individus pour lAFC References "],["sect124.html", "12.4 Analyse de correspondances multiples (ACM)", " 12.4 Analyse de correspondances multiples (ACM) Lanalyse des correspondances multiples (ACM) est particulièrement adaptée à lexploration de données issues dune enquête par sondage, puisquelle permet de résumer/synthétiser linformation dun tableau comprenant uniquement des variables qualitatives (figure 12.34). Figure 12.34: Tableau pour une ACM Par exemple, une enquête sur la mobilité dune population donnée pourrait comprendre plusieurs variables qualitatives dont celles reportées au tableau 12.18. Tableau 12.18: Exemple de variables qualitatives issues dune enquête Modalités des variables Codage Sexe Homme 1 Femme 2 Groupe dâge Moins de 20 ans 1 20 à 39 ans 2 40 à 59 ans 3 60 ans et plus 4 Mode de transport Automobile 1 Transport en commun 2 Marche 3 Vélo 4 Pour analyser de telles données, il suffit de transformer le tableau condensé (de données brutes) en un tableau disjonctif complet dans lequel chaque modalité des variables qualitatives devient une variable binaire prenant les valeurs de 0 ou 1 (tableaux 12.19 et 12.20). Notez que la somme de chaque ligne est alors égale au nombre de variables qualitatives. Tableau 12.19: Tableau condensé (données brutes) Sexe Groupe dâge Mode de transport Ind. 1 1 1 2 Ind. 2 1 2 3 Ind. 3 2 3 1 Ind. 4 1 2 1 Ind. 5 2 4 2 Ind. 6 1 4 4 Tableau 12.20: Tableau disjonctif complet Sexe Groupe dâge Mode de transport Individu Homme Femme Moins de 20 ans 20 à 39 ans 40 à 59 ans 60 ans et plus Auto. T.C. Marche Vélo Ind. 1 1 0 1 0 0 0 0 1 0 0 Ind. 2 1 0 0 1 0 0 0 0 1 0 Ind. 3 0 1 0 0 1 0 1 0 0 0 Ind. 4 1 0 0 1 0 0 1 0 0 0 Ind. 5 0 1 0 0 0 1 0 1 0 0 Ind. 6 1 0 0 0 0 1 0 0 0 1 ACM versus AFC Nous avons vu que lAFC permet danalyser un tableau de contingence avec deux variables qualitatives. En ACM, les colonnes sont les différentes modalités des variables qualitatives et les lignes sont les observations (par exemple, les individus ayant répondu à une enquête par sondage). En résumé, lanalyse des correspondances multiples (ACM) est simplement une analyse des correspondances (AFC) appliquée sur un tableau disjonctif complet. LACM permet ainsi de révéler les ressemblances entre les différentes modalités des variables qualitatives et les ressemblances entre les différents individus. Par conséquent, elle produit également des variables synthétiques (axes factoriels) résumant linformation contenue dans le tableau initial. Lévaluation de ces ressemblances et la détermination des axes factoriels sont aussi basées sur la distance du khi-deux. 12.4.1 Aides à linterprétation Puisque lACM est une extension de lAFC, nous retrouvons les mêmes aides à linterprétation : les valeurs propres pour les axes, les coordonnées factorielles, les contributions et les cosinus carrés pour les variables et les individus. Pour présenter lACM, nous utilisons des données ouvertes de la Ville de Montréal et, plus particulièrement, celles dun sondage auprès de la population de lîle de Montréal sur lagriculture urbaine. Pour ce faire, nous avons conservé uniquement les personnes pratiquant lagriculture urbaine (n = 352). Les variables qualitatives extraites pour lACM sont reportées au tableau 12.21 avec la description des questions, leurs modalités respectives avec les effectifs bruts et en pourcentage. Au final, lACM est calculée de la manière suivante : Neuf variables qualitatives relatives à la pratique de lagriculture urbaine sont retenues (q3, q4, q5, q8, q9, q10, q11, q12 et q13). Quatre variables relatives au profil socioéconomique des personnes répondantes sont introduites comme variables supplémentaires (q15, q16, q17 et q21). Chaque ligne est pondérée avec la variable pond. Lobjectif de cette ACM est double : Montrer les ressemblances entre les différentes modalités relatives à la pratique de lagriculture urbaine. Lanalyse des axes factoriels devrait nous permettre didentifier différents profils des personnes pratiquant lagriculture urbaine. Projeter les modalités des variables socioéconomiques afin de vérifier si elles sont ou non associées aux axes factoriels, cest-à-dire aux différents profils révélés par les axes. Lanalyse du sondage sur lagriculture urbaine réalisée ici est purement exploratoire : elle vise uniquement à démontrer que lACM est un outil particulièrement intéressant pour analyser les données dun sondage. Par contre, cette analyse na aucune prétention scientifique puisque nous ne sommes pas des spécialistes de lagriculture urbaine. Dans ce champ de recherche très fertile quest lagriculture urbaine (surement pas la meilleure blague du livre), vous pourrez consulter plusieurs études montréalaises (McClintock 2018; Audate, Cloutier et Lebel 2021; Bhatt et Farah 2016). Tableau 12.21: Variables qualitatives extraites du sondage sur lagriculture urbaine de la Ville de Montréal Modalité N % Q3. Depuis combien de temps cultivez-vous des fruits, des fines herbes ou des légumes? Q3. Moins de 1 an 35 9,9 Q3. De 1 à 4 ans 101 28,7 Q3. De 5 à 9 ans 66 18,8 Q3. 10 ans ou plus 150 42,6 Q4. Selon vous, quelle proportion des fruits, des fines herbes et des légumes que vous consommez durant lété provient de votre propre production? Q4. Moins de 10% 192 54,5 Q4. 10 à 25% 70 19,9 Q4. 26 à 50% 47 13,4 Q4. Plus de 50% 43 12,2 Q5. Utilisez-vous du compost provenant de vos déchets verts ou alimentaires pour faire pousser des fruits, des fines herbes ou des légumes? Q5. Oui 90 25,6 Q5. Non 262 74,4 Q8. Récupérez-vous leau de pluie pour irriguer vos cultures de fruits, de fines herbes ou des légumes ou encore votre jardin? Q8. Oui 72 20,5 Q8. Non 280 79,5 Q9. Combien de sortes de fruits, de fines herbes ou de légumes cultivez-vous? Q9. Moins de 5 sortes 170 48,3 Q9. 5 à 9 sortes 124 35,2 Q9. 10 à 14 sortes 42 11,9 Q9. 15 sortes ou plus 16 4,5 Q10. Cultivez-vous suffisamment de fruits, de fines herbes ou de légumes pour partager avec dautres personnes? Q10. Oui 143 40,6 Q10. Non 209 59,4 Q11. Échangez-vous vos semis ou vos récoltes de fruits, de fines herbes ou de légumes avec dautres personnes? Q11. Oui 90 25,6 Q11. Non 262 74,4 Q12. Selon vous, lagriculture urbaine contribue-t-elle à améliorer les rapports entre les gens? Q12. Oui 283 80,4 Q12. Non 46 13,1 Q12. NSP/NRP 23 6,5 Q13. Saviez-vous que la Ville de Montréal encourage et soutient lagriculture urbaine sur lîle de Montréal? Q13. Oui 203 57,7 Q13. Non 149 42,3 Q15. À quel groupe dâge appartenez-vous? Q15. 18 à 34 ans 54 15,3 Q15. 35 à 49 ans 110 31,2 Q15. 50 à 64 ans 101 28,7 Q15. 65 ans et plus 87 24,7 Q16. Quelle est votre occupation principale? Q16. Travail temps plein 177 50,3 Q16. Travail. temps partiel 26 7,4 Q16. Étudiant 14 4,0 Q16. Retraité 101 28,7 Q16. Sans emploi 10 2,8 Q16. À la maison 24 6,8 Q17. Quel est le plus haut niveau de scolarité que vous avez complété? Q17. Aucun certificat ou dipl. 25 7,1 Q17. Dipl. secondaires 80 22,7 Q17. Dipl. collégiales 75 21,3 Q17. Études universitaires 172 48,9 Q21. Êtes-vous propriétaire ou locataire de votre résidence ? Q21. Propriétaire 250 71,0 Q22. Locataire 102 29,0 12.4.1.1 Résultats de lACM pour les valeurs propres Les résultats pour les valeurs propres sont reportés au tableau 12.22 et à la figure 12.35. En ACM, linertie totale du tableau des variables qualitatives est égale au nombre moyen de modalités par variable moins un, soit \\(\\frac{K}{J}-1\\) avec K et J étant respectivement les nombres de modalités et de variables. Aussi, le nombre daxes produits par lACM est égal à \\(K - J\\). Pour notre tableau, linertie est donc égale à \\(\\mbox{25} / \\mbox{9} = \\mbox{1,77}\\) avec \\(\\mbox{25}-\\mbox{9} = \\mbox{16}\\) axes. Le nombre daxes à retenir est souvent plus difficile à déterminer puisque, tel que signalé judicieusement par Jérôme Pagès (2002, 53) : « en pratique, comparée à lACP, lACM conduit, dans lensemble à : des pourcentages dinertie plus petits; une décroissance de ces pourcentages plus douce ». Lhistogramme des valeurs propres (figure 12.35) révèle plusieurs sauts importants dans les valeurs propres qui pourraient justifier le choix du nombre daxes factoriels, soit aux axes 1, 2, 3 et 6. Pour lexercice, nous retenons les trois premiers axes qui résument 30 % de linertie du tableau initial. Tableau 12.22: Résultats de lACM pour les valeurs propres Axe factoriel Valeur propre Pourcentage Pourc. cumulé 1 0,248 13,940 13,940 2 0,156 8,792 22,732 3 0,135 7,620 30,352 4 0,127 7,161 37,513 5 0,126 7,065 44,579 6 0,123 6,916 51,494 7 0,114 6,385 57,879 8 0,107 6,003 63,882 9 0,101 5,671 69,553 10 0,095 5,327 74,880 11 0,093 5,234 80,115 12 0,086 4,822 84,937 13 0,077 4,340 89,277 14 0,071 4,011 93,288 15 0,064 3,619 96,906 16 0,055 3,094 100,000 Figure 12.35: Graphiques pour les valeurs propres pour lACM 12.4.1.2 Résultats de lACM pour les modalités des variables À titre de rappel, comme pour lACP et lAFC, nous retrouvons les trois mêmes mesures pour les variables et les individus (coordonnées factorielles, contributions et cosinus carrés). Plus les variables qualitatives du jeu données comprennent de modalités, plus la taille du tableau des résultats des modalités est importante et plus il est fastidieux de lanalyser. Il est donc recommandé de construire des histogrammes avec les coordonnées factorielles et les contributions des modalités, mais aussi un nuage de points avec les coordonnées des modalités des variables qualitatives sur le premier, voire le deuxième plan factoriel. Compréhension des axes factoriels de lACM : une étape essentielle, incontournable Comme en ACP et en AFC, lanalyse des trois mesures (coordonnées, contributions et cosinus carrés) pour les variables et les individus doit vous permettre de comprendre la signification des axes factoriels retenus de lACM. Prenez le temps de bien réaliser cette étape dinterprétation souvent plus fastidieuse quen ACP et ACM, en raison du nombre élevé de modalités. Cette étape est en effet essentielle afin de qualifier les variables latentes (axes factoriels, variables synthétiques) produites par lACM. Les résultats pour les variables sont reportés 1) au tableau 12.23, 2) aux figures 12.36, 12.37 et 12.39 pour les coordonnées et les contributions et à la figure 12.38 pour le premier plan factoriel. Interprétation des résultats de laxe 1 pour les variables Sept modalités concourent le plus à la formation de laxe 1 résumant 13,9 % de la variance : Q9. 10 à 14 sortes (10,35 %), Q10. Oui (9,99 %), Q9. Moins de 5 sortes (9,71 %), Q5. Oui (9,19 %), Q11. Oui (8,20 %), Q4. Moins de 10% (7,87 %) et Q10. Non (7,10 %). Aussi, les modalités suivantes sont aux deux extrémités de cet axe : Coordonnées négatives : Q12. Non (-0,84), Q3. Moins de 1 an (-0,73), Q9. Moins de 5 sortes (-0,67), Q4. Moins de 10% (-0,56), Q10. Non (-0,521). Cela signifie que lorsque les coordonnées des individus sont fortement négatives sur cet axe, les personnes pratiquant lagriculture urbaine : ne pensent pas que lagriculture urbaine contribue à améliorer les rapports entre les gens (Q12); cultivent des fruits, des fines herbes ou de légumes depuis moins dun an (Q3); cultivent moins de cinq sortes de fruits, de fines herbes ou de légumes (Q9); moins de 10 % de la proportion des fruits, des fines herbes et des légumes consommés durant lété provient de leur propre production (Q4); ne cultivent pas suffisamment pour partager avec dautres personnes (Q10). Coordonnées positives : Q9. 15 sortes ou plus (1,36), Q9. 10 à 14 sortes (1,28), Q5. Oui (0,95) et Q11. Oui (0,85). Cela signifie que lorsque les coordonnées des individus sont fortement positives sur cet axe, les personnes pratiquant lagriculture urbaine : cultivent plus de dix sortes de fruits, de fines herbes ou de légumes (Q9); utilisent du compost provenant de leurs déchets verts ou de leurs déchets alimentaires pour faire pousser des fruits, des fines herbes ou de légumes (Q5); échangent leurs semis ou leurs récoltes de fruits, de fines herbes ou des légumes avec dautres personnes (Q11). En résumé, laxe 1 oppose clairement les néophytes en agriculture versus les personnes expérimentées cultivant des fruits et de légumes variés avec leur propre compost et échangeant leurs semis ou leurs récoltes. Tableau 12.23: Résultats de lACM pour les modalités des variables Coordonnées Cosinus carrés Contributions (%) Modalité 1 2 3 1 2 3 1 2 3 Q3. Moins de 1 an -0,73 0,68 0,63 2,70 3,68 3,64 0,07 0,06 0,05 Q3. De 1 à 4 ans -0,29 -0,79 0,39 1,26 15,30 4,30 0,04 0,33 0,08 Q3. De 5 à 9 ans 0,12 0,38 -1,11 0,12 2,02 19,43 0,00 0,04 0,29 Q3. 10 ans ou plus 0,45 0,35 0,02 3,19 3,01 0,02 0,11 0,07 0,00 Q4. Moins de 10% -0,56 0,03 0,07 7,87 0,04 0,22 0,40 0,00 0,01 Q4. 10 à 25% 0,74 -0,76 -0,11 4,92 8,22 0,19 0,14 0,14 0,00 Q4. 26 à 50% 0,78 0,64 0,15 3,82 4,18 0,28 0,10 0,07 0,00 Q4. Plus de 50% 0,53 0,40 -0,37 1,31 1,17 1,19 0,03 0,02 0,02 Q5. Oui 0,95 0,56 -0,13 9,19 5,01 0,29 0,27 0,09 0,00 Q5. Non -0,28 -0,16 0,04 2,70 1,47 0,09 0,27 0,09 0,00 Q8. Oui 0,55 0,37 1,21 2,58 1,86 23,31 0,07 0,03 0,35 Q8. Non -0,13 -0,09 -0,29 0,62 0,45 5,60 0,07 0,03 0,35 Q9. Moins de 5 sortes -0,67 0,01 0,47 9,71 0,00 8,83 0,42 0,00 0,21 Q9. 5 à 9 sortes 0,24 0,11 -0,79 0,89 0,30 17,31 0,03 0,01 0,32 Q9. 10 à 14 sortes 1,28 -0,97 0,07 10,35 9,42 0,06 0,27 0,15 0,00 Q9. 15 sortes ou plus 1,36 2,15 0,65 3,62 14,42 1,50 0,08 0,21 0,02 Q10. Oui 0,73 -0,15 0,07 9,99 0,63 0,18 0,38 0,02 0,00 Q10. Non -0,52 0,10 -0,05 7,10 0,45 0,13 0,38 0,02 0,00 Q11. Oui 0,85 -0,83 0,32 8,20 12,45 2,11 0,25 0,23 0,03 Q11. Non -0,29 0,28 -0,11 2,79 4,24 0,72 0,25 0,23 0,03 Q12. Oui 0,16 0,02 0,01 0,97 0,02 0,01 0,11 0,00 0,00 Q12. Non -0,84 -0,38 0,09 4,12 1,32 0,08 0,11 0,02 0,00 Q12. NSP/NRP -0,36 0,56 -0,31 0,36 1,39 0,48 0,01 0,02 0,01 Q13. Oui 0,17 0,31 0,31 0,70 3,91 4,37 0,04 0,13 0,12 Q13. Non -0,22 -0,40 -0,40 0,91 5,05 5,66 0,04 0,13 0,12 Figure 12.36: Graphiques pour les résultats des modalités de laxe 1 de lACM Interprétation des résultats de laxe 2 pour les variables Quatre modalités concourent le plus à la formation de laxe 2 résumant 8,8 % de la variance : Q3. De 1 à 4 ans (15,30 %), Q9. 15 sortes ou plus (14,42 %), Q11. Oui (12,45 %) et Q9. 10 à 14 sortes (9,42 %). Les modalités suivantes sont présentes aux deux extrémités de laxe 2 : Coordonnées négatives : Q9. 10 à 14 sortes (-0,97), Q11. Oui (-0,83), Q3. De 1 à 4 ans (-0,79), Q4. 10 à 25% (-0,76). Cela signifie que lorsque les coordonnées des individus sont fortement négatives sur cet axe, les personnes pratiquant lagriculture urbaine : cultivent de 10 à 14 sortes de fruits, de fines herbes ou de légumes (Q9); échangent leurs semis ou leurs récoltes de fruits, de fines herbes ou de légumes avec dautres personnes (Q11); cultivent des fruits, des fines herbes ou des légumes depuis 1 à 4 ans (Q3); de 10 à 25 % de la proportion des fruits, des fines herbes et des légumes consommés durant lété provient de leur propre production (Q4). Coordonnées positives : seule la modalité Q9. 15 sortes ou plus (2,15) présente une forte coordonnée positive. En résumé, laxe 2 permet surtout didentifier des personnes pratiquant lagriculture urbaine depuis quelques années (de 1 à 4 ans), mais cultivant déjà de nombreuses sortes de fruits et légumes et partageant aussi leurs semis ou récoltes. Figure 12.37: Graphiques pour les résultats des modalités de laxe 2 de lACM Figure 12.38: Premier plan factoriel de lACM pour les modalités Interprétation des résultats de laxe 3 pour les variables Trois modalités concourent le plus à la formation de laxe 3 résumant 7,6 % de la variance : Q8. Oui (23,31), Q3. De 5 à 9 ans (19,43) et Q9. 5 à 9 sortes (17,31). Les modalités suivantes sont présentes aux deux extrémités de laxe 3 : Coordonnées négatives : Q3. De 5 à 9 ans (-1,11), Q9. 5 à 9 sortes (-0,79). Coordonnées positives : seule la modalité Q8. Oui présente une coordonnée fortement positive (1,21). Par conséquent, cet axe semble plus complexe à analyser et surtout moins intéressant que les deux premiers. Figure 12.39: Graphiques pour les résultats des modalités de laxe 3 de lACM Analyse des variables supplémentaires dans lACM Il est ensuite possible de projeter les modalités supplémentaires sur les axes de lACM retenus (tableau 12.24 et figure 12.40). Les faibles valeurs des coordonnées factorielles des modalités supplémentaires sur les deux axes semblent indiquer que le profil socioéconomique des personnes pratiquant lagriculture urbaine ne semble pas (ou peu) relié aux profils identifiés par les axes factoriels. Tableau 12.24: Résultats de lACM pour les modalités des variables supplémentaires Coordonnées Cosinus carrés Modalité 1 2 1 2 Q15. 18 à 34 ans -0,09 -0,27 0,00 0,04 Q15. 35 à 49 ans -0,06 -0,01 0,00 0,00 Q15. 50 à 64 ans 0,14 0,25 0,01 0,02 Q15. 65 ans et plus 0,11 0,25 0,00 0,01 Q16. Travail temps plein -0,10 -0,06 0,01 0,01 Q16. Travail. temps partiel 0,36 -0,15 0,01 0,00 Q16. Étudiant -0,14 -0,11 0,00 0,00 Q16. Retraité 0,17 0,25 0,01 0,02 Q16. Sans emploi 0,44 -0,14 0,01 0,00 Q16. À la maison -0,06 0,18 0,00 0,00 Q17. Aucun certificat ou dipl. 0,28 0,16 0,00 0,00 Q17. Dipl. secondaires -0,09 0,01 0,00 0,00 Q17. Dipl. collégiales 0,01 0,19 0,00 0,01 Q17. Études universitaires 0,00 -0,10 0,00 0,01 Q21. Propriétaire 0,03 0,02 0,00 0,00 Q22. Locataire -0,06 -0,03 0,00 0,00 Figure 12.40: Premier plan factoriel de lACM avec toutes les modalités incluant celles supplémentaires Visualisation de variables qualitatives ordinales sur un plan factoriel Lorsque les variables qualitatives sont ordinales et non nominales, il peut être intéressant de relier les différentes modalités avec une ligne. Cela permet de comprendre en un coup dil la trajectoire que suivent les modalités sur les deux axes factoriels. En guise dexemple, nous réalisons cet exercice pour les variables Q3 et Q9 (figure 12.41). Figure 12.41: Trajectoires des variables ordinales sur le premier plan factoriel de lACM 12.4.1.3 Résultats de lACM pour les individus Comme toute méthode factorielle, les coordonnées factorielles, les cosinus carrés et les contributions sont aussi disponibles pour les individus en ACM. Nous proposons ici simplement de réaliser le premier plan factoriel pour les individus en attribuant un dégradé de couleurs avec les cosinus carrés (figure 12.42). Il est aussi possible dattribuer des couleurs aux différentes modalités dune variable. Par exemple, sur le premier plan factoriel, nous avons utilisé la variable Q12. Selon vous, lagriculture urbaine contribue-t-elle à améliorer les rapports entre les gens?. Cela permet de repérer visuellement que les personnes ayant répondu négativement à cette question ont surtout des coordonnées négatives sur laxe 1. Figure 12.42: Premier plan factoriel de lACM pour les individus Figure 12.43: Premier plan factoriel de lACM pour les individus avec coloration dune variable 12.4.2 Mise en uvre dans R 12.4.2.1 Calcul dune ACM avec FactoMineR Plusieurs packages permettent de calculer une ACM dans R, notamment ExPosition (fonction epMCA), ade4 (fonction dudi.mca) et FactoMineR (fonction MCA). De nouveau, nous utilisons FactoMineR couplé au package factoextra pour réaliser rapidement des graphiques. Pour calculer lACM, il suffit dutiliser la fonction MCA de FactoMineR, puis la fonction summary(res.acm) qui renvoie les résultats de lACM pour : Les valeurs propres (section Eigenvalues) pour les axes factoriels (Dim.1 à Dim.n) avec leur variance expliquée brute (Variance), en pourcentage (% of var.) et en pourcentage cumulé (Cumulative % of var.). Les dix premières observations (section Individuals) avec les coordonnées factorielles (Dim.1 à Dim.n), les contributions (ctr) et les cosinus carrés (cos2). Pour accéder aux résultats pour toutes les observations, utilisez les fonctions res.acm$ind ou encore res.acm$ind$coord (uniquement les coordonnées factorielles), res.acm$ind$contrib (uniquement les contributions) et res.acm$ind$cos2 (uniquement les cosinus carrés). Les dix premières modalités des variables (section Categories) avec les coordonnées factorielles (Dim.1 à Dim.n), les contributions (ctr) et les cosinus carrés (cos2). La syntaxe ci-dessous permet, dans un premier temps, de calculer lACM, puis de créer un DataFrame pour les résultats des valeurs propres. library(FactoMineR) # Calcul de l&#39;AFC res.acm &lt;- MCA(dfACM, # Nom du DataFrame ncp = 3, # Nombre d&#39;axes retenus quali.sup=10:13, # Variables supplémentaires graph = FALSE, row.w = dfenquete$pond) # Variables pour la pondération des lignes # Affichage des résultats print(res.acm) ## **Results of the Multiple Correspondence Analysis (MCA)** ## The analysis was performed on 352 individuals, described by 13 variables ## *The results are available in the following objects: ## ## name description ## 1 &quot;$eig&quot; &quot;eigenvalues&quot; ## 2 &quot;$var&quot; &quot;results for the variables&quot; ## 3 &quot;$var$coord&quot; &quot;coord. of the categories&quot; ## 4 &quot;$var$cos2&quot; &quot;cos2 for the categories&quot; ## 5 &quot;$var$contrib&quot; &quot;contributions of the categories&quot; ## 6 &quot;$var$v.test&quot; &quot;v-test for the categories&quot; ## 7 &quot;$ind&quot; &quot;results for the individuals&quot; ## 8 &quot;$ind$coord&quot; &quot;coord. for the individuals&quot; ## 9 &quot;$ind$cos2&quot; &quot;cos2 for the individuals&quot; ## 10 &quot;$ind$contrib&quot; &quot;contributions of the individuals&quot; ## 11 &quot;$quali.sup&quot; &quot;results for the supplementary categorical variables&quot; ## 12 &quot;$quali.sup$coord&quot; &quot;coord. for the supplementary categories&quot; ## 13 &quot;$quali.sup$cos2&quot; &quot;cos2 for the supplementary categories&quot; ## 14 &quot;$quali.sup$v.test&quot; &quot;v-test for the supplementary categories&quot; ## 15 &quot;$call&quot; &quot;intermediate results&quot; ## 16 &quot;$call$marge.col&quot; &quot;weights of columns&quot; ## 17 &quot;$call$marge.li&quot; &quot;weights of rows&quot; summary(res.acm) ## ## Call: ## MCA(X = dfACM, ncp = 3, quali.sup = 10:13, graph = FALSE, row.w = dfenquete$pond) ## ## ## Eigenvalues ## Dim.1 Dim.2 Dim.3 Dim.4 Dim.5 Dim.6 Dim.7 ## Variance 0.248 0.156 0.135 0.127 0.126 0.123 0.114 ## % of var. 13.940 8.792 7.620 7.161 7.065 6.916 6.385 ## Cumulative % of var. 13.940 22.732 30.352 37.513 44.579 51.494 57.879 ## Dim.8 Dim.9 Dim.10 Dim.11 Dim.12 Dim.13 Dim.14 ## Variance 0.107 0.101 0.095 0.093 0.086 0.077 0.071 ## % of var. 6.003 5.671 5.327 5.234 4.822 4.340 4.011 ## Cumulative % of var. 63.882 69.553 74.880 80.115 84.937 89.277 93.288 ## Dim.15 Dim.16 ## Variance 0.064 0.055 ## % of var. 3.619 3.094 ## Cumulative % of var. 96.906 100.000 ## ## Individuals (the 10 first) ## Dim.1 ctr cos2 Dim.2 ctr cos2 ## 4 | 0.261 0.063 0.052 | 0.327 0.155 0.081 | ## 10 | -0.533 0.688 0.278 | 0.050 0.010 0.002 | ## 11 | 0.135 0.020 0.014 | -0.120 0.025 0.011 | ## 15 | 0.020 0.000 0.000 | 0.271 0.073 0.061 | ## 17 | -0.133 0.014 0.012 | -0.264 0.088 0.049 | ## 18 | 0.196 0.024 0.018 | 0.279 0.078 0.037 | ## 19 | -0.193 0.041 0.014 | -0.063 0.007 0.002 | ## 21 | 0.845 0.731 0.369 | -0.337 0.184 0.059 | ## 23 | -0.253 0.155 0.058 | -0.020 0.002 0.000 | ## 26 | 0.802 0.552 0.170 | 0.460 0.288 0.056 | ## Dim.3 ctr cos2 ## 4 0.251 0.105 0.048 | ## 10 -0.413 0.757 0.167 | ## 11 -0.354 0.252 0.097 | ## 15 -0.503 0.291 0.209 | ## 17 0.835 1.019 0.486 | ## 18 0.104 0.012 0.005 | ## 19 0.159 0.051 0.010 | ## 21 -0.390 0.285 0.079 | ## 23 -0.375 0.624 0.128 | ## 26 0.098 0.015 0.003 | ## ## Categories (the 10 first) ## Dim.1 ctr cos2 v.test Dim.2 ctr ## Q3. Moins de 1 an | -0.731 2.704 0.068 -4.940 | 0.677 3.681 ## Q3. De 1 à 4 ans | -0.286 1.259 0.043 -3.921 | -0.791 15.299 ## Q3. De 5 à 9 ans | 0.119 0.122 0.003 1.102 | 0.385 2.023 ## Q3. 10 ans ou plus | 0.450 3.189 0.110 6.271 | 0.347 3.006 ## Q4. Moins de 10% | -0.562 7.874 0.395 -11.913 | 0.033 0.044 ## Q4. 10 à 25% | 0.745 4.918 0.137 7.006 | -0.765 8.220 ## Q4. 26 à 50% | 0.775 3.815 0.099 5.966 | 0.644 4.176 ## Q4. Plus de 50% | 0.527 1.310 0.033 3.424 | 0.395 1.167 ## Q5. Oui | 0.950 9.194 0.265 9.760 | 0.557 5.008 ## Q5. Non | -0.279 2.701 0.265 -9.760 | -0.164 1.471 ## cos2 v.test Dim.3 ctr cos2 v.test ## Q3. Moins de 1 an 0.058 4.578 | 0.627 3.636 0.050 4.236 | ## Q3. De 1 à 4 ans 0.328 -10.855 | 0.390 4.304 0.080 5.360 | ## Q3. De 5 à 9 ans 0.035 3.556 | -1.110 19.427 0.293 -10.261 | ## Q3. 10 ans ou plus 0.065 4.835 | 0.023 0.016 0.000 0.327 | ## Q4. Moins de 10% 0.001 0.704 | 0.070 0.221 0.006 1.477 | ## Q4. 10 à 25% 0.144 -7.194 | -0.109 0.191 0.003 -1.021 | ## Q4. 26 à 50% 0.068 4.957 | 0.154 0.276 0.004 1.187 | ## Q4. Plus de 50% 0.018 2.566 | -0.372 1.195 0.016 -2.417 | ## Q5. Oui 0.091 5.720 | -0.126 0.294 0.005 -1.290 | ## Q5. Non 0.091 -5.720 | 0.037 0.086 0.005 1.290 | ## ## Categorical variables (eta2) ## Dim.1 Dim.2 Dim.3 ## q3 | 0.162 0.338 0.334 | ## q4 | 0.400 0.191 0.023 | ## q5 | 0.265 0.091 0.005 | ## q8 | 0.071 0.032 0.352 | ## q9 | 0.548 0.340 0.338 | ## q10 | 0.381 0.015 0.004 | ## q11 | 0.245 0.235 0.034 | ## q12 | 0.121 0.038 0.007 | ## q13 | 0.036 0.126 0.122 | ## ## Supplementary categories (the 10 first) ## Dim.1 cos2 v.test Dim.2 cos2 v.test ## Q15. 18 à 34 ans | -0.091 0.004 -1.221 | -0.271 0.037 -3.630 | ## Q15. 35 à 49 ans | -0.060 0.001 -0.731 | -0.014 0.000 -0.175 | ## Q15. 50 à 64 ans | 0.140 0.006 1.419 | 0.251 0.018 2.543 | ## Q15. 65 ans et plus | 0.107 0.002 0.874 | 0.248 0.011 2.020 | ## Q16. Travail temps plein | -0.096 0.012 -2.084 | -0.065 0.005 -1.404 | ## Q16. Travail. temps partiel | 0.364 0.010 1.875 | -0.147 0.002 -0.757 | ## Q16. Étudiant | -0.139 0.002 -0.774 | -0.111 0.001 -0.617 | ## Q16. Retraité | 0.166 0.006 1.521 | 0.254 0.015 2.331 | ## Q16. Sans emploi | 0.440 0.006 1.433 | -0.142 0.001 -0.464 | ## Q16. À la maison | -0.056 0.000 -0.279 | 0.175 0.002 0.878 | ## Dim.3 cos2 v.test ## Q15. 18 à 34 ans 0.092 0.004 1.232 | ## Q15. 35 à 49 ans -0.112 0.005 -1.360 | ## Q15. 50 à 64 ans -0.002 0.000 -0.020 | ## Q15. 65 ans et plus 0.015 0.000 0.122 | ## Q16. Travail temps plein -0.025 0.001 -0.540 | ## Q16. Travail. temps partiel 0.291 0.006 1.497 | ## Q16. Étudiant -0.088 0.001 -0.488 | ## Q16. Retraité 0.031 0.000 0.284 | ## Q16. Sans emploi -0.495 0.007 -1.611 | ## Q16. À la maison 0.144 0.001 0.720 | ## ## Supplementary categorical variables (eta2) ## Dim.1 Dim.2 Dim.3 ## q15 | 0.010 0.048 0.007 | ## q16 | 0.027 0.020 0.015 | ## q17 | 0.006 0.014 0.014 | ## q21 | 0.002 0.001 0.007 | # Construction d&#39;un DataFrame pour les valeurs propres dfACMvp &lt;- data.frame(res.acm$eig) names(dfACMvp) &lt;- c(&quot;VP&quot;,&quot;VP_pct&quot;,&quot;VP_pctCumul&quot;) dfACMvp$Axe &lt;- factor(1:nrow(dfACMvp), levels=rev(1:nrow(dfACMvp))) dfACMvp &lt;- dfACMvp[,c(4,1:3)] 12.4.2.2 Exploration graphique des résultats de lACM pour les valeurs propres Pour créer un histogramme des valeurs propres de lACM, vous pouvez utiliser la fonction fviz_screeplot de factoextra. library(factoextra) library(ggplot2) fviz_screeplot(res.acm, addlabels = TRUE, x=&quot;Composantes&quot;, y=&quot;Valeur propre&quot;, title=&quot;&quot;) Figure 12.44: Graphique pour les valeurs propres de lACM avec factoextra Avec un peu plus de lignes de code, il est relativement facile dexploiter le DataFrame des valeurs propres créé précédemment (dfACMvp) pour construire des graphiques plus personnalisés. library(factoextra) library(ggplot2) couleursAxes &lt;- c(&quot;steelblue&quot;,&quot;skyblue2&quot;) g1 &lt;- ggplot(dfACMvp,aes(x=VP, y=Axe))+ geom_bar(stat=&quot;identity&quot;, width = .6, alpha=.8, color=&quot;black&quot;, fill=&quot;skyblue2&quot;)+ labs(x=&quot;Valeur propre&quot;, y=&quot;Axe factoriel&quot;) g2 &lt;- ggplot(dfACMvp, aes(x=VP_pct, y=Axe))+ geom_bar(stat=&quot;identity&quot;, width = .6, alpha=.8, color=&quot;black&quot;, fill=&quot;skyblue2&quot;)+ theme(legend.position=&quot;none&quot;)+ labs(x=&quot;Variance expliquée (%)&quot;, y=&quot;Axe factoriel&quot;) g3 &lt;- ggplot(dfACMvp, aes(x=VP_pctCumul, y=Axe, group=1))+ geom_bar(stat=&quot;identity&quot;, width = .6, alpha=.8, color=&quot;black&quot;, fill=&quot;skyblue2&quot;)+ geom_line(colour=&quot;brown&quot;, linetype=&quot;solid&quot;, size=.8) + geom_point(size=3, shape=21, color=&quot;brown&quot;, fill=&quot;brown&quot;)+ theme(legend.position=&quot;none&quot;)+ labs(x=&quot;Variance expliquée (% cumulé)&quot;, y=&quot;Axe factoriel&quot;) ggarrange(g2, g3, nrow = 2) Figure 12.45: Graphiques pour les valeurs propres de lACM avec factoextra La syntaxe ci-dessous permet de construire un tableau avec les coordonnées factorielles, les cosinus carrés et les contributions pour les modalités des variables qualitatives. library(stringr) nAxes &lt;- 3 dfmodalites &lt;- data.frame(Modalite =rownames(res.acm$var$coord), Coord = round(res.acm$var$coord[, 1:nAxes],3), Cos2 = round(res.acm$var$cos2[, 1:nAxes],3), ctr = round(res.acm$var$contrib[, 1:nAxes],3)) rownames(dfmodalites) &lt;- 1:nrow(dfmodalites) names(dfmodalites) &lt;- str_replace(names(dfmodalites), &quot;.Dim.&quot;, &quot;F&quot;) 12.4.2.3 Exploration graphique des résultats de lACM pour les modalités Avant dexplorer graphiquement les résultats pour les modalités, il est judicieux de construire un DataFrame avec les coordonnées factorielles, les contributions et les cosinus carrés des modalités (voir la syntaxe ci-dessous). library(kableExtra) library(stringr) nAxes &lt;- 3 dfmodalites &lt;- data.frame(Modalite =rownames(res.acm$var$coord), Coord = round(res.acm$var$coord[, 1:nAxes],2), ctr = round(res.acm$var$contrib[, 1:nAxes],2), Cos2 = round(res.acm$var$cos2[, 1:nAxes],2)) rownames(dfmodalites) &lt;- 1:nrow(dfmodalites) names(dfmodalites) &lt;- str_replace(names(dfmodalites), &quot;.Dim.&quot;, &quot;F&quot;) Plusieurs fonctions très faciles à utiliser de factoextra permettent de construire rapidement des graphiques : fviz_mca_var pour un nuage de points dun plan factoriel, fviz_cos2 et fviz_contrib (en utilisant le paramètre choice=var.cat) pour des histogrammes avec les cosinus carrés et les contributions des modalités. Nhésitez pas à consulter laide de ces fonctions ou encore cette section du site de STHDA. Il est aussi possible de créer vos propres graphiques avec ggplot2 en utilisant le DataFrame créé précédemment avec les modalités. Par exemple, la syntaxe ci-dessous renvoie deux histogrammes pour laxe 1 : lun avec les coordonnées, lautre avec les contributions. Dans la syntaxe, repérez le terme CoordF1. Dupliquez la syntaxe et changez ce terme pour CoordF2 et CoordF3 pour réaliser les graphiques des axes 2 et 3. # Histogrammes pour les coordonnées des modalités couleursCoords &lt;- c(&quot;lightsalmon&quot;,&quot;steelblue&quot;) plotCoordF1 &lt;- ggplot(dfmodalites, aes(y = reorder(Modalite, CoordF1), x = CoordF1, fill=CoordF1&lt;0))+ geom_bar(stat=&quot;identity&quot;, width = .6, alpha=.8, color=&quot;black&quot;)+ geom_vline(xintercept=0, color = &quot;black&quot;, size=1)+ scale_fill_manual(name=&quot;Coordonnée&quot;,values=couleursCoords, labels = c(&quot;Positive&quot;,&quot;Négative&quot;))+ labs(x=&quot;Coordonnées sur l&#39;axe 1&quot;, y=&quot;Modalité&quot;)+ theme(legend.position=&quot;none&quot;, axis.text.y = element_text(size = 7)) plotCtrF1 &lt;- ggplot(dfmodalites, aes(y = reorder(Modalite, ctrF1), x = ctrF1))+ geom_bar(stat=&quot;identity&quot;, width = .6, alpha=.8, color=&quot;black&quot;, fill=&quot;steelblue&quot;)+ labs(x=&quot;Contributions sur l&#39;axe 1&quot;, y=&quot;Modalité&quot;)+ theme(legend.position=&quot;none&quot;, axis.text.y = element_text(size = 7)) ggarrange(plotCoordF1, plotCtrF1, ncol = 1, nrow = 2) Figure 12.46: Exemple de graphiques pour les résultats des modalités La syntaxe suivante permet de construire le premier plan factoriel pour les modalités avec la fonction fviz_mca_var de factoextra (figure 12.47). res.acm2 &lt;- MCA(dfACM[1:9], ncp = 3, graph = FALSE, row.w = dfenquete$pond) fviz_mca_var(res.acm2, repel = TRUE, choice=&quot;var.cat&quot;, axes = c(1, 2), # col.var = &quot;black&quot;, title=&quot;&quot;, xlab=&quot;Axe 1&quot;, ylab=&quot;Axe 2&quot;, ggtheme = theme_minimal ()) Figure 12.47: Premier plan factoriel de lACM pour les modalités La syntaxe suivante permet de construire le premier plan factoriel pour les modalités supplémentaires avec la fonction fviz_mca_var de factoextra (figure 12.48). fviz_mca_var(res.acm, repel = TRUE, choice=&quot;var.cat&quot;, axes = c(1, 2), col.var = &quot;gray23&quot;, col.quali.sup = &quot;darkred&quot;, labelsize = 3, title=&quot;&quot;, xlab=&quot;Axe 1&quot;, ylab=&quot;Axe 2&quot;, ggtheme = theme_minimal ()) Figure 12.48: Premier plan factoriel de lACM pour les modalités supplémentaires Finalement, la syntaxe ci-dessous renvoie un graphique avec la trajectoire de la variable Q3 (figure 12.49). library(ggpubr) Q3 &lt;- dfmodalites[1:4, 1:3] ggplot(Q3, aes(x=CoordF1, y=CoordF2, label=Modalite))+ xlim(-1, .75)+ylim(-1, 1)+ labs(title = &quot;Q3. Depuis combien de temps cultivez-vous \\n des fruits, des fines herbes ou des légumes?&quot;, x=&quot;Axe 1&quot;, y=&quot;Axe 2&quot;)+ geom_label(nudge_x=0, nudge_y=0.07) + geom_line( color=&quot;black&quot;, size=.2)+ geom_point(shape=21, color=&quot;black&quot;, fill=&quot;steelblue&quot;, size=4) Figure 12.49: Trajectoires des variables ordinales sur le premier plan factoriel de lACM 12.4.2.4 Exploration graphique des résultats de lACM pour les individus Dautres fonctions de factoextra produisent rapidement des graphiques pour les individus : fviz_cos2 et fviz_contrib (en utilisant le paramètre choice=ind) pour construire des histogrammes pour les cosinus carrés et les contributions des individus. fviz_mca_ind pour un nuage de points dun plan factoriel (axes 1 et 2 habituellement). La syntaxe ci-dessous produit le premier axe factoriel pour les individus (figure 12.50). fviz_mca_ind(res.acm, col.ind = &quot;cos2&quot;, gradient.cols = c(&quot;#00AFBB&quot;, &quot;#E7B800&quot;, &quot;#FC4E07&quot;), repel = TRUE, xlab=&quot;Axe 1&quot;, ylab=&quot;Axe 2&quot;, title=&quot;&quot;, ggtheme = theme_minimal()) Figure 12.50: Premier plan factoriel de lACM pour les individus avec factoextra La syntaxe ci-dessous produit aussi le premier plan factoriel pour les individus, mais en attribuant une couleur différente aux modalités de la variable q12 (figure 12.51). fviz_mca_ind (res.acm, label = &quot;none&quot;, habillage = &quot;q12&quot;, # colorer par groupes xlab=&quot;Axe 1&quot;, ylab=&quot;Axe 2&quot;, title=&quot;&quot;, palette = c (&quot;darkred&quot;, &quot;steelblue&quot;, &quot;gray23&quot;), ggtheme = theme_minimal ()) Figure 12.51: Premier plan factoriel de lACM pour les individus avec coloration dune variable avec factoextra References "],["sect125.html", "12.5 Quiz de révision du chapitre", " 12.5 Quiz de révision du chapitre Des variables latentes ne sont pas directement observées, mais plutôt produites par la méthode factorielle afin de résumer les relations/associations entre plusieurs variables mesurées initialement. Relisez au besoin lintroduction du chapitre 12. Vrai Faux Quels sont les métriques utilisées pour les trois principales méthodes factorielle? Relisez au besoin la section 12.1.1. ACP (distance euclidienne), AFC (distance du khi-deux), ACM (distance du khi-deux) ACP (distance du khi-deux), AFC (distance du khi-deux), ACM (distance euclidienne) ACP (distance euclidienne), AFC (distance euclidienne), ACM (distance du khi-deux) En ACP normée, la somme des valeurs propres (inertie totale) est égale au : Relisez au besoin le début de la section 12.2.2.1. nombre de variables quantitatives du tableau initial nombre dobservations moins le nombre de variables En ACP normée, la coordonnée factorielle dune variable sur un axe est : Relisez au besoin la section 12.2.2.2. le covariance de la variable avec la composante principale (axe factoriel) le coefficient de corrélation de la variable avec la composante principale (axe factoriel) la variance de la variable Quelles affirmations sont exactes pour toutes les méthodes factorielles? Relisez au besoin chacune des sections intitulées aides à linterprétation pour les trois méthodes factorielle. La somme des cosinus carrés en ligne est toujours égale à 1 La somme des valeurs propres est toujours égale à linertie totale du tableau La somme des contributions en colonne pour un axe est égale à 100 % Les coordonnées factorielles sont toujours le coefficient de corrélation de la variable avec laxe Lanalyse des correspondances multiples (ACM) est simplement une analyse des correspondances (AFC) sur un tableau disjonctif complet? Relisez au besoin la section 12.4. Vrai Faux Dans une ACM, les variables du tableau disjonctif complet sont : Relisez au besoin la section 12.4. les fréquences des modalités des variables qualitatives les modalités des variables qualitatives transformées en variables binaires Quels sont les étapes essentielles pour bien interpréter une analyse factorielle (ACP, AFC ou ACM)? Relisez le deuxième encadré à la section 12.2.1. Interprétation des résultats des valeurs propres pour identifier le nombre daxes à retenir Analyse des résultats pour les variables (coordonnées, cosinus carrés et contributions) Analyse des résultats pour les individus (coordonnées, cosinus carrés et contributions) Dénommer, qualifier chacun des axes suite à lanalyse des résultats pour les variables et les individus Verifier Votre score "],["chap13.html", "Chapitre 13 Méthodes de classification non supervisée", " Chapitre 13 Méthodes de classification non supervisée Dans le cadre de ce chapitre, nous présentons les méthodes les plus utilisées en sciences sociales pour explorer la présence de groupes homogènes au sein dun jeu de données, soit les méthodes de classification non supervisée. Le qualificatif non supervisé signifie que ces classes/groupes ne sont pas connus a priori et doivent être identifiés à partir des données. Autrement dit, nous cherchons à regrouper les observations partageant des caractéristiques similaires sur la base de plusieurs variables. Ces méthodes descriptives et exploratoires multivariées peuvent être vues comme une façon de réduire le nombre dobservations dun jeu de données à un ensemble dobservations synthétiques, représentant le mieux possible la population à létude. Dans ce chapitre, nous utilisons les packages suivants : Pour créer des graphiques : ggplot2 le seul, lunique! ggpubr pour combiner des graphiques et réaliser des diagrammes. Outils généraux pour faciliter les classifications : clusterCrit pour calculer des indicateurs de qualité de classification. NbClust pour trouver le bon nombre de groupe dans une classification. cluster pour appliquer la méthode GAP. proxy pour calculer plusieurs types de distances. Gmedian pour calculer le k-médianes. geocmeans pour explorer les résultats de classifications floues. Pourquoi recourir à des méthodes de classification non supervisée en sciences sociales? Les méthodes de classification sont très utilisées en sciences sociales. Elles visent à identifier des groupes cohérents au sein dun ensemble dobservations sur la base de plusieurs variables (figure 13.1). Ces groupes peuvent ensuite être analysés et nous renseigner sur les caractéristiques communes partagées par les individus qui les composent. Figure 13.1: Principe de base des méthodes de classification non supervisée Un exemple classique est lidentification de profils dindividus ayant répondu à un sondage, en fonction de plusieurs caractéristiques (par exemple, lâge, le sexe, la situation de famille, le revenu, etc.). En identifiant ces groupes homogènes, il est ensuite possible dexplorer les associations entre ces profils et dautres variables. Un second exemple serait de regrouper les secteurs dune ville selon leurs caractéristiques environnementales (végétation, niveau de bruit, pollution atmosphérique, etc.) et socioéconomiques (revenu médian des ménages, pourcentage dimmigrants, pourcentage de personnes à faible scolarité, taux de chômage, etc.). "],["sect131.html", "13.1 Méthodes de classification : un aperçu", " 13.1 Méthodes de classification : un aperçu Il existe une multitude de méthodes de classification généralement regroupées dans plusieurs familles imbriquées à partir de deux distinctions importantes. La première distinction vise à séparer les méthodes supervisées des non supervisées. Pour les premières, les catégories/groupes/classes des observations sont connues à lavance. Lenjeu nest pas de trouver les catégories puisquelles sont connues, mais de déterminer des règles ou un modèle permettant dattribuer des observations à ces catégories. Parmi les méthodes de classification supervisée, les plus connues sont les forêts darbres décisionnels, les réseaux de neurones artificiels ou encore lanalyse factorielle discriminante. Nous nabordons pas ces méthodes dans ce chapitre dédié uniquement aux méthodes de classification non supervisée. Pour ces dernières, les catégories ne sont pas connues à lavance et lenjeu est de faire ressortir les structures des groupes propres aux données. Ainsi, les méthodes de classification non supervisée « relèvent de la statistique exploratoire multidimensionnelle et permettent de classifier automatiquement les observations sans connaissance a priori sur la nature des classes présentes dans le jeu de données; les plus connues sont sans conteste les algorithmes de classification ascendante hiérarchique (CAH) et du k-means (k-moyennes) » (Gelb et Apparicio 2021b, 1). Notez également quà la frontière entre ces deux familles, se situent les méthodes de classification semi-supervisée. Il sagit de cas spécifiques où des informations partielles sont connues sur les groupes à détecter : seulement le groupe final de certaines observations est connu, certaines observations sont supposées appartenir à un même groupe même sil est indéfini en lui-même (Bair 2013). La seconde distinction vise à séparer les méthodes strictes des floues. Les premières ont pour objectif dassigner chaque observation à une et une seule catégorie, alors que les secondes décrivent le degré dappartenance de chaque observation à chaque catégorie. Autrement dit, « dans une classification stricte, chaque observation appartient à une seule classe. Mathématiquement parlant, lappartenance à une classe donnée est binaire (0 ou 1) tandis que dans une classification floue, chaque observation a une probabilité dappartenance variant de 0 à 1 à chacune des classes » (Gelb et Apparicio 2021b, 1). Bien entendu, pour chaque observation, la somme des degrés dappartenance à chacune des classes est égale à 1 (figure 13.2). En termes de données, cela signifie que pour les méthodes strictes, le groupe dappartenance dune observation est contenu dans une seule variable nominale (une colonne dun DataFrame). Pour les méthodes floues, il est nécessaire de disposer dautant de variables continues (plusieurs colonnes numériques dun DataFrame), soit une par groupe, dans lesquelles est enregistré le degré dappartenance de chaque observation à chacun des groupes. Parmi les méthodes de classification supervisée floue, notez que nous avons déjà abordé la régression logistique multinomiale dans le chapitre sur les GLM (section 8.2.4). Figure 13.2: Classifications stricte et floue En résumé, le croisement de ces deux distinctions permet ainsi de différencier les méthodes supervisées strictes, supervisées floues, non supervisées strictes et non supervisées floues (figure 13.3), auxquelles sajoutent les méthodes semi-supervisées discutées brièvement. Figure 13.3: Synthèse des principales méthodes de classification (Gelb et Apparicio 2021) Dans ce chapitre, nous décrivons les trois méthodes de classification non supervisée les plus utilisées et faciles à mettre en uvre : la classification ascendante hiérarchique, les nuées dynamiques strictes (k-means et k-medians) et nuées dynamiques floues (c-means et c-medians). References "],["sect132.html", "13.2 Notions essentielles en classification", " 13.2 Notions essentielles en classification Avant de décrire différentes méthodes de classification non supervisées, il convient de définir deux notions centrales, soit la distance et linertie. 13.2.1 Distance La distance en analyse de données est définie comme une fonction (d) permettant de déterminer à quel point deux observations sont semblables ou différentes lune de lautre. Elle doit respecter les conditions suivantes : la non-négativité : la distance minimale entre deux objets est égale à 0; \\(d(x,y) \\geq 0\\). le principe didentité des indiscernables : la distance entre deux objets \\(x\\) et \\(y\\) est égale à 0, si \\(x = y\\); \\(d(x,y)=0\\text{ si et seulement si }x=y\\). la symétrie : la distance entre \\(x\\) et \\(y\\) est la même quentre \\(y\\) et \\(x\\); \\(d(x,y) = d(y,x)\\). le triangle dinégalité : passer dun point \\(x\\) à un point \\(z\\) est toujours plus court ou égal que de passer par \\(y\\) entre \\(x\\) et \\(z\\); \\(d(x,z)\\leq d(x,y)+d(y,z)\\). Il existe un grand nombre de types de distance qui peuvent être utilisés pour déterminer le degré de similarité entre les observations. Nous présentons ici les six types les plus fréquemment utilisés en sciences sociales, mais retenez quil en existe bien dautres. 13.2.1.1 Distance euclidienne Il sagit vraisemblablement de la distance la plus couramment utilisée, soit la longueur de la ligne droite la plus courte entre les deux objets considérés. Pour la représenter, admettons que nous nous intéressons à trois classes détudiants et détudiantes A, B et C pour lesquelles nous avons calculé la moyenne de leurs notes dans les cours de méthodes quantitatives et qualitatives. Ces deux variables sont mesurées dans la même unité et varient de 0 à 100. Le nuage de points à la figure 13.4 illustre cette situation avec des données fictives. Figure 13.4: Situation de base pour le calcul de distance Les distances euclidiennes entre les classes B et C et les classes C et A sont représentées par les lignes noires à la figure 13.5. Nous pouvons constater que la distance entre les classes C et B est plus petite que celle entre les classes A et C, ce qui signale que les deux premières se ressemblent davantage. Figure 13.5: Représentation de la distance euclidienne La formule de la distance euclidienne (équation (13.1)) est simplement la racine carrée de la somme des écarts au carré pour chacune des variables décrivant les observations a et b. \\[\\begin{equation} d(a,b) = \\sqrt{\\sum{}^v_{i=1}(a_i-b_i)^2} \\tag{13.1} \\end{equation}\\] avec v le nombre de variables décrivant les observations a et b. Nous pouvons facilement calculer la distance euclidienne pour notre jeu de données : \\(d(A,B)=\\sqrt{(\\mbox{85}-\\mbox{80})^2+(\\mbox{80}-\\mbox{77})^2} = \\mbox{5,83}\\) \\(d(B,C)=\\sqrt{(\\mbox{80}-\\mbox{83})^2+(\\mbox{79}-\\mbox{77})^2} = \\mbox{3,60}\\) Distance et unité de mesure Il est très important de garder à lesprit que la distance entre deux observations dépend directement des unités de mesure utilisées. Cela est très souvent problématique, car il est rare que toutes les variables utilisées pour décrire des observations soient mesurées dans la même unité. Ainsi, une variable dont les valeurs numériques sont plus grandes risque de déséquilibrer les calculs de distance. À titre dexemple, une variable mesurée en mètres plutôt quen kilomètres produit des distances euclidiennes 1000 fois plus grandes. Il est donc nécessaire de standardiser les variables utilisées avant de calculer des distances. Cette opération permet de transformer les variables originales vers une échelle commune. Plusieurs types de transformations peuvent être utilisés tels que décrits à la section 2.5.5.2 : Le centrage et la réduction qui consistent à soustraire de chaque valeur sa moyenne, puis à la diviser par son écart-type. La nouvelle variable obtenue sexprime alors en écart-type (appelé aussi score-z). La formule de la transformation est \\(f(x) = \\frac{x - \\bar{x}}{\\sigma_x}\\), avec \\(\\bar{x}\\) la moyenne de \\(x\\) et \\(\\sigma_x\\) lécart-type de \\(x\\). La transformation sur une mise à léchelle de 0 à 1 qui permet de modifier létendue dune variable afin que sa valeur maximale soit de 1 et sa valeur minimale soit de 0. La formule de cette transformation est \\(f(x) = \\frac{x-min(x)}{max(x)-min(x)}\\). La transformation en rang qui consiste à remplacer les valeurs dune variable par leur rang. La valeur la plus faible est remplacée par 1, et la plus forte par n (nombre dobservations). Notez que cette transformation modifie la distribution de la variable originale contrairement aux deux transformations précédentes. Cette propriété peut être désirable si les écarts absolus entre les valeurs ont peu dimportance, si la variable na pas été mesurée avec précision ou encore si des valeurs extrêmes sont présentes. La transformation en percentile qui consiste à remplacer les valeurs dune variable par leur percentile correspondant. Elle peut être vue comme une standardisation de la transformation en rang, car elle ne dépend pas du nombre dobservations. La figure 13.6 montre leffet de ces transformations sur lhistogramme dune variable. Figure 13.6: Effets de différentes transformations sur la distribution dune variable 13.2.1.2 Distance de Manhattan Cette seconde distance est également couramment utilisée. Elle doit son nom au réseau de rue de lîle de Manhattan qui suit un plan quadrillé. La distance de Manhattan correspond à la somme des écarts absolus entre les valeurs des différentes variables décrivant les observations (équation (13.2)). La figure 13.7 illustre que la distance Manhattan (lignes noires) représente les deux côtés opposés de lhypoténuse dun triangle rectangle; lhypoténuse représentant quant à elle la distance euclidienne. \\[\\begin{equation} d(a,b) = \\sum{}^v_{i=1}(|a_i-b_i|) \\tag{13.2} \\end{equation}\\] Figure 13.7: Représentation de la distance de Manhattan La distance de Manhattan doit être privilégiée à la distance euclidienne lorsque les données considérées ont un très grand nombre de dimensions (variables). En effet, lorsque le nombre de variables est important (supérieur à 30), la distance euclidienne tend à être grande pour toutes les paires dobservations et à moins bien discriminer les observations proches et lointaines les unes des autres. Du fait de sa nature additive, la distance de Manhattan est moins sujette à ce problème (Aggarwal, Hinneburg et Keim 2001). Calculons la distance de Manhattan pour nos deux paires dobservations : \\(d(A,B)=|85-80|+|80-77| = 8\\) \\(d(B,C)=|80-83|+|79-77| = 5\\) 13.2.1.3 Distance du khi-deux La distance du khi-deux est basée sur le test du khi-deux (chapitre 5) et est généralement utilisée pour calculer la distance entre deux histogrammes, deux images ou deux ensembles de mots. Plus précisément, elle permet de mesure la distance entre deux observations A et B, pour lesquelles nous disposons dun ensemble de variables étant toutes des variables de comptage. Prenons un exemple concret en générant trois histogrammes A, B et C sur lintervalle [0,50] à partir des distributions normale, log-normale et Gamma, puis comptons le nombre de valeurs de chaque unité (1, 2, 3, 4, etc.). Ces histogrammes sont représentés à la figure 13.8. Figure 13.8: Trois histogrammes pour illustrer le calcul de la distance du khi-deux Nous pouvons calculer les distances du khi-deux entre les paires dhistogrammes (tableau 13.1). Nous constatons ainsi que les histogrammes B et C sont les plus semblables. Tableau 13.1: Distance du khi-deux entre trois histogrammes Histogrammes Distance du khi-deux A-B 284,8375 A-C 376,7862 B-C 219,5133 La formule de cette distance est la suivante : \\[\\begin{equation} d_{\\chi^2}(a,b) = \\frac{1}{2}\\sum^n_{i=1}\\frac{(a_i-b_i)^2}{(a_i+b_i)} \\tag{13.3} \\end{equation}\\] avec \\(a_i\\) et \\(b_i\\) les comptages pour les histogrammes. Notez que si \\(a_i\\) et \\(b_i\\) valent tous les deux 0, il faut retirer ces valeurs avant le calcul, car cela provoquerait une division par 0. À première vue, cette distance peut paraître moins utile que les deux précédentes. Pourtant, de nombreuses données sont collectées comme des histogrammes. Un premier exemple serait des images que nous pouvons représenter sous forme de trois histogrammes, un pour chaque canal de couleur (rouge, vert et bleu). Un second exemple serait des données sonores, souvent synthétisées sous forme dhistogrammes des fréquences sonores enregistrées (octaves ou tiers doctaves). Un dernier exemple pourrait être le nombre daccidents de la route enregistré à diverses intersections dune ville chaque heure. Dans ce contexte, un histogramme serait formé par lintersection avec les heures de la journée comme limites des bandes et le nombre daccidents comme hauteur des bandes. 13.2.1.4 Distance de Mahalanobis Proposée dans les années 1930 par le statisticien indien Prasanta Chandra Mahalanobis (1936), cette distance se base sur la matrice de covariance des variables analysées. Plus spécifiquement, elle est utilisée pour calculer la distance entre un point et une distribution normale multivariée. Elle permet notamment de tenir compte du fait que certaines variables sont corrélées et ainsi déviter de surestimer les distances entre des observations dans des jeux de données comprenant des variables corrélées entre elles. La formule permettant de calculer cette distance est la suivante : \\[\\begin{equation} d(a,b) = \\sqrt{(a-b)^TS^{-1}(a-b)} \\tag{13.4} \\end{equation}\\] avec S étant la matrice de covariance. 13.2.1.5 Distance de Hamming Cette distance est utilisée quand les écarts entre les variables de deux observations sont uniquement binaires. Un bon exemple serait un jeu de données ne comprenant que des variables qualitatives pouvant avoir une valeur identique pour deux observations (distance = 0) ou différente (distance = 1). La distance de Hamming est la simple addition de ces écarts. Prenons un exemple très simple en prenant trois maisons pour lesquelles nous connaissons cinq caractéristiques 13.2). Tableau 13.2: Exemple de données pour la distance de Hamming couleur jardin garage cheminée sous-sol blanc non oui oui non blanc non non oui non rouge oui oui non oui Nous pouvons utiliser la distance de Hamming pour estimer le niveau de dissimilarité entre ces différentes maisons et lorganiser dans une matrice de distances. À la lecture du tableau 13.3), les maisons 2 et 3 sont les plus dissimilaires (distance de Hamming = 5), et les maisons 1 et 2 les plus similaires (distance de Hamming = 1). Tableau 13.3: Distance de Hamming entre les maisons maison 1 maison 2 maison 3 maison 1 0 1 4 maison 2 1 0 5 maison 3 4 5 0 13.2.1.6 Distance de Gower La distance de Gower (1971) peut être utilisée pour mesurer la distance entre deux observations lorsque les données sont à la fois qualitatives et quantitatives. Cette distance est comprise dans un intervalle de 0 à 1, 0 signifiant que les deux observations sont identiques et 1, que les observations sont radicalement différentes. Elle se calcule de la façon suivante : \\[\\begin{equation} \\begin{aligned} &amp;d(a,b) = 1-\\frac{1}{p}\\sum^p_{j=1}s_{12j}\\\\ &amp;\\left\\{\\begin{array}{c} s_{xyj} = 1 \\text{ si } x_j = y_j \\text{, 0 autrement pour une variable qualitative} \\\\ s_{xyj} = 1 - \\frac{|x_j-y_j|}{max(j)-min(j)} \\text{ pour une variable quantitative} \\end{array}\\right. \\end{aligned} \\tag{13.5} \\end{equation}\\] avec p le nombre de variables, x et y deux observations et j une variable. Autrement dit, si la valeur dune variable qualitative diffère entre deux observations, la distance entre ces deux observations augmente de \\(1/p\\). Pour une variable quantitative, la distance augmente selon la différence absolue entre les valeurs de la variable divisée par létendue totale de la variable, le tout à nouveau divisé par p. Si cette mesure semble intéressante puisquelle permet de combiner des variables quantitatives et qualitatives, elle souffre de deux limites importantes : Elle ne prend pas en compte le fait que certaines modalités des variables qualitatives sont moins fréquentes ni que certaines combinaisons sont également moins fréquentes. Les variables qualitatives tendent à affecter bien plus la distance que les variables quantitatives. En effet, pour obtenir un écart de 1 sur une variable quantitative, il faut que les deux valeurs soient respectivement le maximum et le minimum de cette variable. Dautres distances pour des données mixtes Il existe bien dautres distances qui peuvent être utilisées dans le cas de données mixtes. Le package kmed en implémente cinq (auxquelles sajoute la distance de Gower) dans sa fonction distmix : les distances de Wishart, de Podani, dHuang, dHarikumar et dAhmad. Ces différentes distances ont toutes leurs avantages et leurs défauts respectifs; pour plus dinformation, référez-vous à la documentation de la fonction distmix. 13.2.1.7 Distance du Phi2 La distance du \\(\\Phi^2\\) (Phi2) est une variante de la distance du \\(\\chi^2\\). Il sagit donc dune distance à utiliser lorsque les données à analyser sont uniquement qualitatives. Elle calcule la distance entre deux observations en additionnant les différences entre les valeurs de chaque variable (1 si différentes, 0 si identiques, pour chaque variable), divisées respectivement par la fréquence totale doccurrences de chaque modalité dans le jeu de données. En dautres termes, cette distance tient compte du fait que certaines valeurs pour des variables qualitatives peuvent être observées plus fréquemment que dautres et quune distance plus grande devrait être obtenue entre deux observations si lune des deux présente des modalités rares comparativement au reste du jeu de données. Elle peut être calculée de la façon suivante : \\[\\begin{equation} d_{\\Phi^2}(i,j) = \\frac{1}{Q}\\sum_k\\frac{(\\delta_{ik} - \\delta_{jk})^2}{f_k} \\tag{13.6} \\end{equation}\\] avec i et j deux observations, k une modalité dune variable qualitative, Q le nombre total de modalités des variables qualitatives, \\(\\delta_{ik} = 1\\) si lobservation i a la modalité k, 0 sinon et \\(f_k\\) la fréquence de la modalité k dans le jeu de données. La distance du \\(\\Phi^2\\) est très utile pour analyser les résultats de questionnaires. 13.2.2 Inertie Une notion importante à saisir dans le cadre des méthodes de classification non supervisée est celui celle linertie dun jeu de données. Elle est proche de la notion de variance qui a été présentée dans le chapitre sur la statistique univariée (section 2.5.3). Linertie est une quantité permettant de décrire la dispersion des observations dun jeu de données. Cette mesure dépend à la fois des données (nombres dobservations et de variables, échelle des variables) et de la mesure de distance retenue entre deux observations. Plus spécifiquement, linertie correspond à la somme des distances entre chaque observation et le centre du jeu de données. \\[\\begin{equation} inertie= \\sum{}^n_{i=1} d(c,x_i) \\tag{13.7} \\end{equation}\\] avec c le centre du jeu de données, n le nombre dobservations, x une observation et d la fonction calculant la distance entre deux observations. Lenjeu est de définir c dans un contexte où la distance euclidienne est utilisée. Il sagit simplement dune observation fictive dont les coordonnées sont les moyennes des différentes variables du jeu de données. Dans le cas dautres distances, il peut sagir de lobservation minimisant la distance à toutes les autres observations. Pour bien visualiser la notion dinertie, prenons une fois encore le jeu de données IRIS comme exemple. Admettons que nous ne nous intéressons quà deux variables de ce jeu de données : sepal.Length et sepal.Width. Nous pouvons représenter linertie totale du jeu de données à la figure 13.9. Figure 13.9: Représentation de linertie du jeu de données IRIS Chaque ligne bleue représente la contribution de chaque point à linertie totale du jeu de données. Pour chaque iris, nous connaissons son espèce (Setosa, Versicolor ou Virginica). Nous pouvons donc attribuer chaque point de ce jeu de données à un groupe (une espèce dans notre cas). Il devient alors possible de calculer linertie de chacun des sous-groupes de notre jeu de données. Pour cela, nous devons calculer le centre de chaque groupe (généralement les moyennes des variables des observations au sein dun groupe) et ensuite calculer linertie entre chaque observation et le centre de son groupe. Nous représentons cette situation à la figure 13.10. Figure 13.10: Représentation de linertie par groupe pour le jeu de données IRIS Cette inertie propre aux groupes est toujours inférieure ou égale à linertie totale du jeu de données. Il sagit en réalité de linertie que la structure de groupe nest pas en mesure dexpliquer. En utilisant ces concepts, il est possible de calculer la part de linertie totale expliquée par les groupes (équation (13.8)) : \\[\\begin{equation} \\text{inertie expliquée} = 1-\\frac{\\text{inertie totale}}{\\text{inertie restante}} \\tag{13.8} \\end{equation}\\] Cette valeur nous renseigne sur la capacité dune classification à bien réduire linertie totale dun jeu de données. Elle est comprise entre 0 et 1. Si linertie expliquée est à 0, cest que la classification nexplique absolument aucune part de linertie totale. Si linertie expliquée est à 1, la classification utilisée explique lintégralité de linertie, ce qui en pratique nest atteignable que si le nombre de groupes de la classification est égal au nombre dobservations. En dautres termes, chaque observation est attribuée à un groupe dont elle est la seule représentante. Un telle situation na aucun intérêt puisque lobjectif dune classification est bien de réduire la complexité dun jeu de données en regroupant les observations. References "],["sect133.html", "13.3 Classification ascendante hiérarchique", " 13.3 Classification ascendante hiérarchique La classification ascendante hiérarchique (CAH) est un algorithme de classification non supervisée dont lobjectif est de créer un arbre de classification des observations. Cet arbre est ensuite utilisé pour déterminer le nombre de groupes à former et à quel groupe appartient chaque observation. 13.3.1 Fonctionnement de lalgorithme La classification ascendante hiérarchique est un algorithme permettant de regrouper les observations dun jeu de données de façon itérative. À chaque itération, deux observations similaires sont agrégées en un groupe représenté par le point central entre les deux observations. Le processus est ensuite répété en considérant le nouveau point comme une observation jusquà ce que toutes les observations soient fusionnées en un seul groupe. Ces regroupements successifs créent un arbre de classification appelé dendrogramme. La racine de cet arbre est le groupe unique fusionnant toutes les observations, et ses branches correspondent aux différentes agrégrations effectuées jusquaux observations individuelles. Cet arbre peut être vu comme une hiérarchie de classification. Chaque niveau de larbre est un regroupement de plus en plus généraliste au fur et à mesure que nous nous approchons de sa racine. Pour appliquer cette méthode, il est nécessaire de sélectionner une fonction de distance pour mesurer la dissimilarité ou la ressemblance entre deux observations. Lalgorithme fonctionne avec nimporte quelle fonction de distance, ce qui permet de lappliquer aussi bien à des données qualitatives que quantitatives. En effet, lopération de regroupement des observations se base sur une matrice de distance, soit un tableau de taille n x n indiquant pour chaque paire dobservations leur degré de dissimilarité. La figure 13.11 illustre cette transformation en appliquant la distance du \\(\\Phi^2\\) à un jeu de données comprenant cinq observations et 5 variables qualitatives. Figure 13.11: Du tableau de données à la matrice de distance En plus de la fonction de distance, il est également nécessaire de sélectionner un critère dagrégation, soit la règle permettant de décider à chaque itération quelles observations doivent être regroupées. Les méthodes les plus courantes sont : Le critère de Ward (1963) : cette méthode consiste à agréger à chaque itération les deux observations permettant de minimiser la variance (ou linertie) intra-groupe, ce qui revient à maximiser linertie inter-groupe (autrement dit, à rendre les groupes les plus homogènes possible et les plus dissemblables entre eux). Ainsi, lenjeu est de fusionner les deux observations permettant davoir les groupes les plus dissimilaires possible après fusion. Le lien complet : à chaque itération, les deux groupes dobservations associés sont ceux pour lesquels la distance maximale entre les observations les composant est la plus petite parmi tous les groupes. Le lien simple : à chaque itération, les deux groupes dobservations associés sont ceux pour lesquels la distance minimum entre les observations les composant est la plus petite parmi tous les groupes. La plus utilisée est de loin la méthode de Ward. La méthode du lien complet produit généralement des résultats similaires. En revanche, la méthode du lien simple peut produire des groupes non sphériques (non centrés sur leur moyenne) plus difficle à interpréter. Prenons un instant pour visualiser cet algorithme (figure 13.12). Cette animation a été réalisée par David Sheehan et est également accessible sur son blog. Elle présente bien le processus dagglomération de la classification ascendante hiérarchique et la construction progressive du dendrogramme. Figure 13.12: Principe de fonctionnement de la classification ascendante hiérarchique (auteur : David Sheehan) 13.3.2 Choisir le bon nombre de groupes Une fois que lalgorithme a été appliqué aux données et le dendrogramme obtenu, il faut encore choisir le nombre optimal de groupes pour la classification finale. Chaque embranchement du dendrogramme constitue une classification possible, allant de la plus complexe (chaque observation appartient à un groupe formé delle seule) à la plus simple (toutes les observations appartiennent au même groupe). Si le nombre de groupes nest pas connu à lavance et quaucune forte justification théorique nexiste, il est possible dutiliser plusieurs techniques pour déterminer un nombre de groupes judicieux à partir des données. Nous en présentons ici trois, mais il convient de ne pas sen tenir uniquement à ses critères arbitraires. Il est important dexplorer les résultats de la classification obtenue pour plusieurs valeurs de k candidates et de tenir compte de la qualité des informations quelles fournissent. Au final, il est pertinent de retenir la classification dont les résultats offrent linterprétation la plus claire avec un nombre de groupes réduit (principe de parcimonie). 13.3.2.1 Méthode du coude Cette première approche est la plus simple à mettre en oeuvre. Il sagit simplement de produire plusieurs classifications à partir du dendrogramme avec différentes valeurs de k (nombre de groupes) et de calculer à chaque fois la part de linertie expliquée. Chaque groupe supplémentaire ne peut quaméliorer linertie expliquée, car pour rappel, si \\(k=n\\), alors nous expliquons 100 % de linertie totale. Lobjectif est de déterminer à quel moment lajout dun groupe supplémentaire ne contribue que de façon marginale à améliorer linertie expliquée. Si nous représentons les valeurs dinertie expliquée pour les différentes valeurs de k dans un graphique, une rupture (un coude) indiquerait le point au-delà duquel les groupes supplémentaires ne captent finalement que du bruit et non plus de linformation. Si nous reprenons lexemple du jeu de données IRIS, nous pouvons créer ce graphique avec k allant de 2 à 8 (figure 13.13). Un premier coude très net est observable pour \\(k = 3\\) et un second plus faible, mais tout de même marqué pour \\(k = 4\\). Figure 13.13: Méthode du coude Inertie expliquée et centre de groupe Pour calculer linertie expliquée, il est nécessaire de pouvoir déterminer pour le centre de gravité (ou centroïde) chaque groupe. Lorsque la distance euclidienne est utilisée, il sagit simplement de calculer pour chaque groupe la valeur moyenne des différentes colonnes des observations. Cependant, lorsque dautres distances sont utilisées, il peut être plus difficile de déterminer le centre dun groupe. Avec la distance de Manhattan, il est par exemple recommandé dutiliser la médiane des colonnes plutôt que la moyenne. Pour la distance de Hamming, la moyenne peut aussi être utilisée, car elle représente pour cette distance la fréquence doccurrence des différentes modalités des variables qualitatives. Pour dautres distances plus complexes, il est préférable de définir le centre dun groupe comme le point de ce groupe minimisant les distances à tous les autres points du groupe. Il sagit du médoïde du groupe. 13.3.2.2 Indicateur de silhouette Si un coude net ne sobserve pas pour la méthode précédente, il est possible dutiliser lindicateur de silhouette. Il permet de mesurer pour une classification à quel point une observation est similaire à celles dans son propre groupe (cohésion) comparativement aux observations des autres groupes. Elle se calcule de la façon suivante : \\[\\begin{equation} \\begin{aligned} s(i) &amp;= \\frac{b(i)-a(i)}{\\max \\{a(i), b(i)\\}} \\\\ a(i) &amp;= \\frac{1}{|C_i|-1}\\sum_{j \\in C_i,i \\neq j}d(i,j) \\\\ b(i) &amp;= min_{i \\neq j}\\frac{1}{|C_j|}\\sum_{j \\in C_j}d(i,j) \\end{aligned} \\tag{13.9} \\end{equation}\\] avec \\(s(i)\\) la valeur de lindice de silhouette pour lobservation i, \\(a(i)\\) la distance moyenne entre lobservation i et son groupe \\(C_i\\) et \\(b(i)\\) la distance minimale entre lobservation i et le centre de chaque autre groupe \\(C_j\\). La valeur totale de lindice est simplement la moyenne des valeurs moyennes des indices de silhouette au sein de chaque groupe. Une valeur plus élevée indique une meilleure classification. Il est nécessaire de déterminer le centre des groupes pour calculer cet indicateur ce qui peut être un exercice difficile quand une distance autre que la distance euclidienne est utilisée. Référez-vous à la note de la section précédente pour plus dinformations. Lindice de silhouette semble indiquer que seulement trois groupes serait un choix optimal, soit la valeur la plus haute (figure 13.14). Figure 13.14: Méthode de lindice de silhouette 13.3.2.3 Méthode GAP Cette méthode, proposée par Tibshirani, Walther et Hastie (2001), consiste à comparer linertie intra-groupe (inexpliquée) avec linertie observée pour un jeu de données généré aléatoirement (distribution uniforme des valeurs entre le minimum et le maximum de chaque variable) pour différentes valeurs successives de k. Une fois ces calculs effectués, lobjectif est de trouver la valeur de k telle que la valeur de GAP à k + 1 nest pas plus grande quun écart type pour GAP à k + 1. La statistique GAP est calculée ainsi : \\[\\begin{equation} \\begin{aligned} GAP(k) = \\frac{1}{\\text{nsim}} \\sum^{\\text{nsim}}_{\\text{sim} = 1} log(W_{ksim}) - log(W_k) \\end{aligned} \\tag{13.10} \\end{equation}\\] avec \\(W_k\\) linertie non expliquée (intra-groupe), \\(W_{ksim}\\) linertie non expliquée (intra-groupe) obtenue pour un jeu de données simulé et k le nombre de groupes. Lidée est quune bonne classification doit produire des résultats plus structurés que ce que nous pourrions attendre du hasard. Chaque groupe supplémentaire permet de réduire linertie, mais lorsque lajout dun groupe ne permet pas un gain significatif comparativement au hasard, alors lajout de ce groupe ne se justifie pas. À nouveau, il est possible de visualiser la situation avec un simple graphique (figure 13.15). Selon cette méthode, il faudrait sélectionner quatre groupes, car il sagit de la première valeur de k validant le critère de cette méthode. La seconde valeur retenue par cette méthode est 6. Figure 13.15: Méthode GAP 13.3.3 Limites de la classification ascendante hiérarchique Bien que très flexible (choix de la fonction de distance et du critère dagrégation), la CAH fait face à un enjeu majeur : la vitesse dexécution et la consommation de mémoire lorsque des grands jeux de données sont utilisés. En effet, il est nécessaire de calculer à chaque étape une matrice de distance entre les groupes. Si un jeu de données comprend 1000 observations, cette matrice comprend donc 1000 x 1000 cases, soit un million de distances. Même en divisant ce nombre par deux (les éléments de la matrice sont symétriques, donc \\(d(ij) = d(ji)\\)), ce nombre augmente avec le carré du nombre dobservations. Pour de grands jeux de données, la CAH peut donc échouer à cause des limites de lordinateur utilisé. Il existe des versions plus performantes de lalgorithme réduisant cette limite, mais il convient de la garder en mémoire. Quand un très grand jeu de données doit être analysé, les méthodes des nuées dynamiques sont une solution à considérer. 13.3.4 Mise en oeuvre dans R Nous proposons ici un exemple issu dun article portant sur les parcs urbains de Montréal (Apparicio et al. 2010), dont lobjectif était notamment de classifier ces parcs en fonction de leur superficie et des équipements quils comprennent, et ce, en utilisant la classification ascendante hiérarchique. Nous proposons ici de reproduire létape de classification effectuée dans cet article. La base de données comporte 653 parcs pour lesquels la présence de 18 équipements est codée comme un ensemble de variables binaires (0 signifiant absence et 1 présence). Nous disposons également de la taille de ces parcs, recodée en cinq catégories : moins dun hectare, de 1 à 5 hectares, de 5 à 10 hectares, de 10 à 20 hectares et 20 hectares et plus. Le tableau 13.4 indique le nombre déquipements recensés dans les parcs. Tableau 13.4: Équipements recensés dans les différents parcs de Montréal Équipements N Équipements pour les 0 à 4 ans Aire de jeux 601 Pataugeoire 161 Jeux deau 28 Terrains de sport Baseball 188 Soccer (football) 169 Basketball 144 Tennis 125 Football 36 Volleyball 24 Athlétisme 20 Équipements dhiver Patinoire extérieure 241 Glissade 30 Piste de ski de fond 14 Piste de raquette 9 Équipements spécialisés Parc de planches à roulettes 18 Patins à roues alignées 8 Autres équipements Piscine intérieure 92 Chemin de randonnée 15 Puisque notre jeu de données ne comporte que des variables qualitatives, nous utilisons la distance du \\(\\Phi^2\\) pour construire notre matrice de distance entre les parcs. Notons que, dans larticle original, la distance euclidienne au carrée avait été utilisée, alors nous nobtiendrons probablement pas les mêmes résultats, car la distance du \\(\\Phi^2\\) tient compte des fréquences doccurrence des modalités des variables qualitatives. 13.3.4.1 Calcul de la matrice de distance La première étape consiste donc à charger notre jeu de données et à calculer la matrice de distance. # chargement du jeu de données et sélection des colonnes pour l&#39;analyse parcs &lt;- read.csv(&quot;data/classification/Parcs.txt&quot;, header = TRUE, stringsAsFactors = FALSE) X &lt;- parcs[c(5:22, 27)] Pour calculer la distance du \\(\\Phi^2\\), nous utilisons la fonction dist du package proxy avec le paramètre method = \"Phi-squared\". Elle requiert que lensemble des variables catégorielles soient converties en variables binaires. Pour cela, nous pouvons utiliser la fonction dummy_cols du package fastDummies. library(fastDummies) library(proxy) X &lt;- dummy_cols(X,select_columns = &quot;HaTypo&quot;,remove_selected_columns = TRUE) parc_distances &lt;- dist(as.matrix(X), method = &quot;Phi-squared&quot;) 13.3.4.2 Application de lalgorithme de classification ascendante hiérarchique Une fois la matrice obtenue, il ne reste plus quà appliquer la fonction hclust disponible de base dans R pour obtenir le dendrogramme. Comme dans larticle, nous utilisons le critère dagrégation de Ward pour la création des groupes. dendogramme_parcs &lt;- hclust(parc_distances, method = &quot;ward.D&quot;) Puisque nous nutilisons pas la distance euclidienne, nous optons ici pour lindice de silhouette pour déterminer le nombre adéquat de groupes à former. Nous testons toutes les valeurs comprises entre 2 et 10. library(cluster) ks &lt;- 2:10 # Calcul des indices de silhouette pour les différentes valeurs de k values &lt;- sapply(ks, function(k){ # découpage du dendrogramme groupes &lt;- cutree(dendogramme_parcs, k = k) # calcul des valeurs de silhouette sil &lt;- silhouette(groupes, dist = parc_distances) # extraction de l&#39;indice global (moyenne des moyennes) idx &lt;- mean(summary(sil)$clus.avg.widths) return(idx) }) # Création d&#39;un graphique avec les résultats df &lt;- data.frame(k = ks, silhouette = values) ggplot(df) + geom_line(aes(x = k, y = silhouette)) + geom_point(aes(x = k, y = silhouette), color = &quot;red&quot;) + labs(x = &quot;nombre de groupes&quot;, y=&quot;indice global de silhouette&quot;) Figure 13.16: Valeur de lindice de silhouette pour différents nombres de groupes Si nous écartons demblée les résultats pour k = 2 et k = 3 (trop peu de groupes pour linterprétation), nous constatons que la solution optimale selon ce critère est k = 5. Dans larticle original, la solution k = 6 avait été retenue en examinant le dendrogramme. Comparons les résultats pour k = 5 et k = 6. resk5 &lt;- cutree(dendogramme_parcs, k = 5) resk6 &lt;- cutree(dendogramme_parcs, k = 6) sil5 &lt;- silhouette(resk5, dist = parc_distances) sil6 &lt;- silhouette(resk6, dist = parc_distances) # résumé pour l&#39;indice de silhouette pour k = 5 summary(sil5) ## Silhouette of 693 units in 5 clusters from silhouette.default(x = resk5, dist = parc_distances) : ## Cluster sizes and average silhouette widths: ## 116 212 246 84 35 ## 0.07029553 1.00000000 -0.11827930 -0.19969707 1.00000000 ## Individual silhouette widths: ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## -0.62041 -0.08502 0.09814 0.30200 1.00000 1.00000 # résumé pour l&#39;indice de silhouette pour k = 6 summary(sil6) ## Silhouette of 693 units in 6 clusters from silhouette.default(x = resk6, dist = parc_distances) : ## Cluster sizes and average silhouette widths: ## 116 212 197 49 84 35 ## 0.05906553 1.00000000 -0.10289391 0.07935325 -0.19969707 1.00000000 ## Individual silhouette widths: ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## -0.62041 -0.06414 0.10998 0.31846 1.00000 1.00000 Nous constatons que le groupe supplémentaire vient séparer le groupe trois comprenant 246 parcs dans la solution avec k = 5. Ce dernier ne comprend plus que 197 parcs pour la solution k = 6 et le nouveau groupe en compte 49. Ce nouveau groupe à un indice de silhouette moyen relativement faible (0,079), et le fait de découper le groupe trois améliore très peu sa propre valeur (passant de -0,12 à -0,10). Nous retenons cependant ici la solution avec k = 6 afin de tenter de reproduire les résultats de larticle. 13.3.4.3 Interprétation des résultats La dernière étape consiste à identifier les groupes obtenus et leur attribuer un intitulé en fonction de leurs caractéristiques. Dans notre cas, la classification ne comporte que des variables binaires, nous pouvons donc calculer le pourcentage de valeurs à 1 (présence dun équipement) dans chacun des groupes. # calcul du nombre de fois où chaque modalité est observée dans un groupe X$groupe &lt;- resk6 df_groupes &lt;- X %&gt;% group_by(groupe) %&gt;% summarise_all(.funs = sum) # calcul du nombre d&#39;observations par groupe nb_gp &lt;- table(resk6) groupe_ratios &lt;- round(100 * as.matrix(df_groupes)[,2:ncol(df_groupes)] / as.vector(nb_gp),1) groupe_ratios &lt;- as.data.frame(t(groupe_ratios)) names(groupe_ratios) &lt;- paste0(&quot;groupe &quot;, 1:ncol(groupe_ratios)) # calcul du nombre moyen d&#39;équipements par catégorie par parc equip_class &lt;- list( c(&quot;AIRE_JEUX&quot;, &quot;JEUX_EAU&quot;, &quot;PATAUGEOIRE&quot;), c(&quot;ATHLETISME&quot;, &quot;BASEBALL_S&quot;, &quot;BASKETBALL&quot;, &quot;FOOTBALL&quot;, &quot;SOCCER&quot;, &quot;TENNIS&quot;, &quot;VOLLEY_BALL&quot;), c(&quot;TOBBOGAN_G&quot;, &quot;PATINOIRE_E&quot;, &quot;RAQUETTES&quot;, &quot;SKI_FOND&quot;), c(&quot;PATIN_ROUE&quot;, &quot;ROULI_ROUL&quot;), c(&quot;PISC_EXT&quot;, &quot;RANDONNEE&quot;) ) class_compte &lt;- data.frame(sapply(equip_class, function(equip){ rowSums(X[equip]) })) names(class_compte) &lt;- c(&quot;enfants&quot;, &quot;terrain_sport&quot;, &quot;hiver&quot;, &quot;specialise&quot;, &quot;autre&quot;) class_compte$groupe &lt;- resk6 df_class_equip &lt;- class_compte %&gt;% group_by(groupe) %&gt;% summarise_all(mean) df_class_equip &lt;- t(df_class_equip[2:ncol(df_class_equip)]) colnames(df_class_equip) &lt;- paste0(&quot;groupe &quot;, 1:ncol(df_class_equip)) # comptage du nombre moyen total d&#39;équipements df_equip_tot &lt;- data.frame( nb = rowSums(X[1:18]), groupe = resk6 ) df_equip_tot_mean &lt;- df_equip_tot %&gt;% group_by(groupe) %&gt;% summarize_all(mean) # mise dans l&#39;ordre de la première partie du tableau all_types &lt;- do.call(c,equip_class) idxs &lt;- match(all_types,row.names(groupe_ratios[1:length(all_types),])) groupe_ratios &lt;- rbind(groupe_ratios[idxs,], groupe_ratios[(length(all_types)+1):nrow(groupe_ratios),]) # combinaison des deux tableaux groupe_ratios &lt;- rbind(groupe_ratios, df_class_equip, df_equip_tot_mean$nb, as.integer(nb_gp)) Il est ensuite possible dafficher le tableau obtenu pour linterpréter. Les résultats sont ici rapportés au tableau 13.5. Tableau 13.5: Caractéristiques des groupes obtenus lors de la CAH groupe 1 groupe 2 groupe 3 groupe 4 groupe 5 groupe 6 Équipements pour les 0 à 4 ans (%) Aire de jeux 69,8 100 83,2 71,4 88,1 100 Jeux deau 7,8 0 2,5 18,4 6,0 0 Pataugeoire 36,2 0 47,2 2,0 29,8 0 Terrains de sport (%) Athlétisme 12,1 0 2,0 2,0 1,2 0 Baseball 62,1 0 50,8 0,0 19,0 0 Basketball 37,9 0 36,0 16,3 21,4 0 Football américain 15,5 0 7,1 8,2 0,0 0 Soccer (football) 52,6 0 29,9 87,8 7,1 0 Tennis 38,8 0 32,5 8,2 14,3 0 Volleyball 7,8 0 4,6 12,2 0,0 0 Équipements dhiver (%) Glissade 19,8 0 3,0 2,0 0,0 0 Patinoire 58,6 0 59,4 34,7 46,4 0 Piste de ski de fond 7,8 0 0,0 0,0 0,0 0 Raquettes 12,1 0 0,0 0,0 0,0 0 Équipements spécialisés (%) Parc de planches à roulettes 6,0 0 0,5 0,0 0,0 0 Patins à roues alignées 8,6 0 4,1 0,0 0,0 0 Autres équipements (%) Piscine extérieure 27,6 0 27,4 4,1 4,8 0 Chemin de randonnée 12,9 0 0,0 0,0 0,0 0 Superficie (%) Moins dun hectare 0,0 100 0,0 0,0 100,0 0 1 à 5 hectares 5,2 0 98,5 100,0 0,0 100 5 à 10 hectares 61,2 0 0,0 0,0 0,0 0 10 à 20 hectares 17,2 0 1,0 0,0 0,0 0 20 hectares et plus 16,4 0 0,5 0,0 0,0 0 Nombre moyen déquipement du type Équipements pour les 0 à 4 ans 1,1 1 1,3 0,9 1,2 1 Terrains de sport 2,3 0 1,6 1,3 0,6 0 Équipements dhiver 1,0 0 0,6 0,4 0,5 0 Équipements spécialisés 0,1 0 0,0 0,0 0,0 0 Autres équipements 0,4 0 0,3 0,0 0,0 0 Tous les équipements 4,9 1 3,9 2,7 2,4 1 Nombre dobservations par groupe 116,0 212 197,0 49,0 84,0 35 Le premier groupe correspond à de grands parcs (superficie généralement comprise entre 5 et plus de 20 hectares), il comporte 116 observations. Ces grands parcs sont en moyenne équipés de deux terrains de sport et dun équipement dhiver. Il sagit vraisemblablement des grands parcs identifiés dans larticle original, dans lesquels se retrouvent également les parcs à vocation métropolitaine. Le second groupe (212 parcs) correspond à de très petits parcs (moins dun hectare) comportant uniquement une aire de jeu. Le troisième groupe (197 parcs) correspond à de petits parcs (entre 1 et 5 hectares), souvent équipés dune piscine extérieure (27,4 % des cas), et en moyenne de deux terrains de sports (essentiellement des terrains de tennis et de soccer). Ces parcs comprennent en moyenne plus de 4 équipements et doivent donc correspondre à la classe D dans larticle original (Petit parc (1 à 5 ha) avec en moyenne six équipements, dont une patinoire et une piscine). Le quatrième groupe (49 parcs) comprend de petits parcs (entre 1 et 5 hectares) qui ressemblent aux parcs du groupe 2 mais tendent à disposer en plus dun terrain de sport (baseball ou basketball). Le quatrième groupe (84 parcs) correspond à de petits parcs, il est caractérisé par une présence plus marquée de pataugeoires (39 %). Le cinquième groupe (35 parcs) est très similaire au second groupe (uniquement une aire de jeux), excepté sont les parcs qui sy trouvent sont de taille supérieure (de 1 à 5 hectares). Considérant les différences minimes entre certains des groupes que nous avons obtenus, il est clair que retenir seulement trois ou cinq groupes serait préférable. Notez également limportance du choix de la distance, car nous obtenons des résultats sensiblement différents de ceux de larticle original en ayant opté pour la distance du \\(\\Phi^2\\) plutôt que la distance euclidienne au carré. 13.3.4.4 Utilisation de la matrice de distance eucidienne au carré Pour obtenir des résultats plus proches de ceux de larticle original, nous pouvons reprendre notre analyse et utiliser cette fois-ci une distance euclidienne au carré. X$groupe &lt;- NULL # calcule de la matrice de distance parc_distances_euc &lt;- dist(as.matrix(X), method = &quot;Euclidean&quot;)**2 # Application de la CAH dendogramme_parcs_euc &lt;- hclust(parc_distances_euc, method = &quot;ward.D&quot;) # calcul de l&#39;indice de silhouette ks &lt;- 2:10 values &lt;- sapply(ks, function(k){ # découpage du dendrogramme groupes &lt;- cutree(dendogramme_parcs_euc, k = k) # calcul des valeurs de silhouette sil &lt;- silhouette(groupes, dist = parc_distances_euc) # extraction de l&#39;indice global (moyenne des moyennes) idx &lt;- mean(summary(sil)$clus.avg.widths) return(idx) }) # création d&#39;un graphique avec les résultats df &lt;- data.frame( k = ks, silhouette = values ) ggplot(df) + geom_line(aes(x = k, y = silhouette)) + geom_point(aes(x = k, y = silhouette), color = &quot;red&quot;) + labs(x = &quot;nombre de groupes&quot;, y=&quot;indice global de silhouette&quot;) Figure 13.17: Valeur de lindice de silhouette pour différents nombres de groupes (distance euclidienne au carré) Nous constatons cette fois-ci, que quatre groupes serait probablement le meilleur choix et quau-delà de ce nombre, lindice global de silhouette ne fait que diminuer. Tentons cependant de reproduire les résultats de larticle avec k = 6. resk6 &lt;- cutree(dendogramme_parcs_euc, k = 6) # calcul du nombre de fois ou chaque modalité est observée dans un groupe X$groupe &lt;- resk6 df_groupes &lt;- X %&gt;% group_by(groupe) %&gt;% summarise_all(.funs = sum) # calcul du nombre d&#39;observations par groupe nb_gp &lt;- table(resk6) groupe_ratios &lt;- round(100 * as.matrix(df_groupes)[,2:ncol(df_groupes)] / as.vector(nb_gp),1) groupe_ratios &lt;- as.data.frame(t(groupe_ratios)) names(groupe_ratios) &lt;- paste0(&quot;groupe &quot;, 1:ncol(groupe_ratios)) # calcul du nombre moyen d&#39;équipements par catégorie par parc equip_class &lt;- list( c(&quot;AIRE_JEUX&quot;, &quot;JEUX_EAU&quot;, &quot;PATAUGEOIRE&quot;), c(&quot;ATHLETISME&quot;, &quot;BASEBALL_S&quot;, &quot;BASKETBALL&quot;, &quot;FOOTBALL&quot;, &quot;SOCCER&quot;, &quot;TENNIS&quot;, &quot;VOLLEY_BALL&quot;), c(&quot;TOBBOGAN_G&quot;, &quot;PATINOIRE_E&quot;, &quot;RAQUETTES&quot;, &quot;SKI_FOND&quot;), c(&quot;PATIN_ROUE&quot;, &quot;ROULI_ROUL&quot;), c(&quot;PISC_EXT&quot;, &quot;RANDONNEE&quot;) ) class_compte &lt;- data.frame(sapply(equip_class, function(equip){ rowSums(X[equip]) })) names(class_compte) &lt;- c(&quot;enfants&quot;, &quot;terrain_sport&quot;, &quot;hiver&quot;, &quot;specialise&quot;, &quot;autre&quot;) class_compte$groupe &lt;- resk6 df_class_equip &lt;- class_compte %&gt;% group_by(groupe) %&gt;% summarise_all(mean) df_class_equip &lt;- t(df_class_equip[2:ncol(df_class_equip)]) colnames(df_class_equip) &lt;- paste0(&quot;groupe &quot;, 1:ncol(df_class_equip)) # comptage du nombre moyen d&#39;équipements df_equip_tot &lt;- data.frame( nb = rowSums(X[1:18]), groupe = resk6 ) df_equip_tot_mean &lt;- df_equip_tot %&gt;% group_by(groupe) %&gt;% summarize_all(mean) # mise dans l&#39;ordre de la première partie du tableau all_types &lt;- do.call(c,equip_class) idxs &lt;- match(all_types,row.names(groupe_ratios[1:length(all_types),])) groupe_ratios &lt;- rbind(groupe_ratios[idxs,], groupe_ratios[(length(all_types)+1):nrow(groupe_ratios),]) # combinaison des deux tableaux groupe_ratios &lt;- rbind(groupe_ratios, df_class_equip, df_equip_tot_mean$nb, as.integer(nb_gp)) Recréons le tableau final des résultats au tableau 13.6. Si vous comparez ce tableau avec celui de larticle original, vous verrez que notre groupe 3 correspond exactement à la classe A et que notre groupe 5 correspond exactement à la classe F. Pour les autres groupes, nous pouvons observer de légères variations, ce qui correspond vraisemblablement à des divergences dimplémentation des algorithmes entre le logiciel utilisé pour larticle (SAS) et R. Tableau 13.6: Caractéristiques des groupes obtenus lors de la CAH (distance euclidienne au carré) groupe 1 groupe 2 groupe 3 groupe 4 groupe 5 groupe 6 Équipements pour les 0 à 4 ans (%) Aire de jeux 79,6 74,2 96,6 100,0 20,0 79,3 Jeux deau 11,1 3,0 1,7 5,1 0,0 5,9 Pataugeoire 59,3 42,4 8,4 61,0 0,0 19,7 Terrains de sport (%) Athlétisme 13,0 15,2 0,3 0,0 0,0 1,0 Baseball 88,9 63,6 5,4 89,8 6,7 13,8 Basketball 83,3 30,3 6,1 35,6 0,0 18,2 Football 31,5 12,1 0,0 10,2 0,0 2,5 Soccer (football) 75,9 57,6 2,0 27,1 0,0 33,5 Tennis 90,7 19,7 4,1 35,6 0,0 14,8 Volleyball 20,4 3,0 0,0 1,7 0,0 4,9 Équipements dhiver (%) Glissade 14,8 16,7 0,0 1,7 33,3 2,5 Patinoire 87,0 57,6 13,2 86,4 26,7 30,5 Piste de ski de fond 1,9 1,5 0,0 0,0 46,7 0,0 Raquettes 0,0 1,5 0,0 0,0 86,7 0,0 Équipements spécialisés (%) Parc de planches à roulettes 0,0 0,0 0,0 1,7 46,7 0,0 Patins à roues alignées 16,7 7,6 0,0 5,1 0,0 0,5 Autres équipements (%) Piscine extérieure 75,9 16,7 1,4 11,9 6,7 13,8 Chemin de andonnée 1,9 0,0 0,0 0,0 93,3 0,0 Superficie (%) Moins dun hectare 0,0 0,0 100,0 0,0 0,0 0,0 1 à 5 hectares 42,6 1,5 0,0 98,3 0,0 99,5 5 à 10 hectares 46,3 69,7 0,0 0,0 0,0 0,0 10 à 20 hectares 1,9 27,3 0,0 0,0 13,3 0,5 20 hectares et plus 9,3 1,5 0,0 1,7 86,7 0,0 Nombre moyen déquipement du type Équipements pour les 0 à 4 ans 1,5 1,2 1,1 1,7 0,2 1,0 Terrains de sport 4,0 2,0 0,2 2,0 0,1 0,9 Équipements dhiver 1,0 0,8 0,1 0,9 1,9 0,3 Équipements spécialisés 0,2 0,1 0,0 0,1 0,5 0,0 Autres équipements 0,8 0,2 0,0 0,1 1,0 0,1 Tous les équipements 7,5 4,2 1,4 4,7 3,7 2,4 Nombre dobservations par groupe 54,0 66,0 296,0 59,0 15,0 203,0 References "],["sect134.html", "13.4 Nuées dynamiques", " 13.4 Nuées dynamiques Les méthodes des nuées dynamiques regroupent plusieurs algorithmes, tous plus ou moins liés avec lalgorithme le plus connu : k-means, originalement proposé par James MacQueen (1967). Nous présentons également ici plusieurs variantes du k-means, soit le k-medians, le k-medioids, le c-means et le c-medians. 13.4.1 K-means 13.4.1.1 Fonctionnement de lalgorithme Nous commençons ici par détailler le fonctionnement de cet algorithme afin de mieux le cerner. Demblée, cet algorithme nécessite que certains éléments soient définis davance : Une matrice de données X comportant n lignes (nombre dobservations) et p colonnes (nombre de variables). Chaque variable de cette matrice doit être quantitative et continue et de préférence dans une échelle standardisée (par exemple des variables centrées réduites). Le nombre de groupes à identifier k doit être choisi par lutilisateur ou lutilisatrice. La distance d à utiliser entre les observations. Le fonctionnement classique du k-means est le suivant : Définir k centres de groupes de façon aléatoire. Déterminer pour chaque observation le centre de son groupe le plus proche en utilisant la fonction de distance. Pour chacun des groupes ainsi formés, recalculer le centre du groupe en calculant le centroïde (moyennes le plus souvent) des observations appartenant à ce groupe. Répéter lopération 2 avec les nouveaux centres. Calculer linertie expliquée par la nouvelle classification. Comparer cette inertie expliquée avec celle obtenue lors de litération précédente. Si la variation entre les deux valeurs est supérieure à une certaine limite, reprendre à létape 2, sinon, lalgorithme prend fin. Ainsi, lalgorithme k-means part dune première classification obtenue aléatoirement et la raffine jusquau point où lamélioration de la classification devient négligeable. Du fait de ce point de départ aléatoire, cet algorithme est dit heuristique, car deux exécutions risquent de ne pas donner exactement le même résultat. Par conséquent, en relaçant lalgorithme, vous pourriez obtenir des résultats légèrement différents, avec par exemple des groupes similaires, mais obtenus dans un autre ordre, le groupe 1 étant devenu le groupe 3 et vice-versa. Il est aussi possible dobtenir des résultats radicalement différents dune tentative à lautre, ce qui signifie que les groupes formés sont très instables et ne sont pas représentatifs de la population étudiée. Réplicabilité des résultats dans R Lorsquune méthode heuristique ou faisant appel au hasard est utilisée dans R, il est nécessaire de sassurer que les résultats sont reproductibles. Cela permet notamment de relancer le même code et de réobtenir exactement les mêmes résultats : lidée étant de figer le hasard. Ultimement, un programme informatique est incapable de générer un résultat véritablement aléatoire, car il ne fait que suivre une suite dopérations prédéterminées. Pour générer des résultats qui ressemblent au hasard, des algorithmes ont été proposés, partant dune configuration initiale et appliquant une série dopérations complexes permettant de générer des nombres semblant se distribuer aléatoirement. Si nous connaissons le point de départ de la suite dopérations et que nous réappliquons ces dernières, alors nous sommes certains dobtenir le même résultat. Il est possible, dans R, de définir un état initial de hasard à laide de la fonction set.seed. Avec ce point de départ défini, nous sommes certains dobtenir les mêmes résultats en relançant les mêmes opérations. Prenons un exemple concret en sélectionnant aléatoire 3 chiffres dans un vecteur allant de 1 à 10. vec &lt;- 1:10 # prenons un premier échantillon sample(vec, size = 3) ## [1] 4 9 3 # et un second échantillon sample(vec, size = 3) ## [1] 6 10 8 Nous obtenons bien deux échantillons différents. Recommençons en utilisant la fonction set.seed pour obtenir cette fois-ci des résultats identiques. vec &lt;- 1:10 # prenons un premier échantillon set.seed(123) sample(vec, size = 3) ## [1] 3 10 2 # et un second échantillon set.seed(123) sample(vec, size = 3) ## [1] 3 10 2 # prenons un troisème échantillon set.seed(4568997) sample(vec, size = 3) ## [1] 5 6 7 # et un quatrième échantillon set.seed(4568997) sample(vec, size = 3) ## [1] 5 6 7 Vous constatez que nous utilisons cette fonction plusieurs fois au cours de cette section. Elle nous permet de nous assurer que les résultats obtenus ne changent pas entre le moment où nous écrivons le livre et le moment où nous le formatons. Sinon, le texte pourrait ne plus être en phase avec les images ou les tableaux. Pour mieux comprendre le fonctionnement du k-means, nous proposons ici une visualisation de ses différentes itérations. Figure 13.18: Classifications stricte et floue Nous pouvons constater que, pour ce jeu de données relativement simple, lalgorithme converge très rapidement et que sa solution varie peu au-delà de la troisième itération. Si vous utilisez la version HTLM du livre, la figure 13.18 devrait être animée et illustrer pourquoi le k-means est aussi appelé algorithme de nuées dynamiques. Centre de groupe et k-means À nouveau, puisque chaque itération du k-means nécessite de recalculer les centres des groupes formés, des problèmes peuvent être rencontrés avec certains types de distance. Cest pourquoi il est recommandé dutiliser la distance euclidienne avec le k-means original. Si des distances plus complexes doivent être utilisées, il est préférable dutiliser la classification ascendante hiérarchique. 13.4.1.2 Choix du nombre optimal de groupes Comme pour la CAH, le principal enjeu avec le k-means est de déterminer le nombre idéal de groupes pour effectuer la classification. Si ce nombre nest pas connu à lavance et quaucune forte justification théorique nexiste, il est possible dutiliser les mêmes techniques que pour la CAH, soit la méthode du coude, lindicateur de silhouette ou la méthode GAP. 13.4.2 K-médianes Le k-medians est une variante du k-means. Contrairement au k-means privilégiant la distance euclidienne, le k-medians est à utiliser en priorité avec une distance de Manhattan. En effet, le centre dun groupe nest pas déterminé comme la moyenne des variables des observations appartenant à ce groupe (k-means), mais comme la médiane pour chaque variable (k-medians). En dehors de ces deux spécificités, il reprend le fonctionnement décrit plus haut pour le k-means. Il est particulièrement pertinent de lutiliser quand un jeu de données comprend un très grand nombre de colonnes, car dans ce contexte, la distance euclidienne peine à représenter les différences entre les observations. De plus, lutilisation de la médiane le rend moins sensible aux valeurs extrêmes. 13.4.3 K-médoïds Le k-médoïds est également une variante du k-means. Le k-means crée des groupes en cherchant les centres de ces groupes dans lespace multidimensionnel des données. Ces centres de groupes peuvent très bien ne pas correspondre à un point du jeu de données, au même titre que la moyenne dune variable ne coïncide que rarement avec une observation réelle de cette variable. Pour le k-médoïds, les groupes sont formés en cherchant les centres de ces groupes parmi les observations du jeu de données. Ainsi, chaque groupe est centré sur une observation réelle, la plus similaire à lensemble des observations du groupe. Lalgorithme effectue les opérations suivantes : Sélectionner aléatoirement k observations du jeu de données, elles constituent les centres des groupes initiaux. Attribuer chaque observation au centre du groupe le plus proche. Tant que la nouvelle solution est plus efficace, effectuer les opérations suivantes : pour chaque centre m et pour chaque observation o, considérer linversion de m et o si cette permutation est meilleure que les précédentes, la conserver en mémoire effectuer la meilleure permutation retenue si elle améliore la classification, sinon lalgorithme prend fin. Le k-médoïds est moins utilisé que le k-means, mais il est plus performant quand des distances autres que la distance euclidienne sont utilisées ou encore que des valeurs aberrantes/extrêmes sont présentes dans les données. 13.4.4 Mise en oeuvre dans R Pour cet exemple, nous proposons dutiliser le jeu de données spatiales LyonIris du package geocmeans. Ce jeu de données spatiales pour lagglomération lyonnaise (France) comprend dix variables, dont quatre environnementales (EN) et six socioéconomiques (SE), pour les îlots regroupés pour linformation statistique (IRIS) de lagglomération lyonnaise (tableau 13.7 et figure 12.4). Nous proposons de réaliser une analyse similaire à celle de larticle de Gelb et Apparicio (2021b), soit de classer les IRIS de Lyon selon ces caractéristiques pour déterminer si certains groupes dIRIS combinent des situations désavantageuses sur les plans sociaux et environnementaux, dans une perspective déquité environnementale. Tableau 13.7: Statistiques descriptives du jeu de données LyonIris Nom Intitulé Type Moy. E.-T. Min. Max. Lden Bruit routier (Lden dB(A)) EN 55,6 4,9 33,9 71,7 NO2 Dioxyde dazote (ug/m3) EN 28,7 7,9 12,0 60,2 PM25 Particules fines (PM\\(_{2,5}\\)) EN 16,8 2,1 11,3 21,9 VegHautPrt Canopée (%) EN 18,7 10,1 1,7 53,8 Pct0_14 Moins de 15 ans (%) SE 18,5 5,7 0,0 54,0 Pct_65 65 ans et plus (%) SE 16,2 5,9 0,0 45,1 Pct_Img Immigrants (%) SE 14,5 9,1 0,0 59,8 TxChom1564 Taux de chômage SE 14,8 8,1 0,0 98,8 Pct_brevet Personnes à faible scolarité (%) SE 23,5 12,6 0,0 100,0 NivVieMed Médiane du niveau de vie (Euros) SE 21 804,5 4 922,5 11 324,0 38 707,0 13.4.4.1 Préparation des données La première étape consiste donc à charger les données et à les préparer pour lanalyse. Toutes les variables que nous utilisons sont des variables continues. Cependant, elles ne sont pas exprimées dans la même échelle, nous proposons donc de les standardiser ici en les centrant (moyenne = 0) et en les réduisant (écart-type = 1). Cette opération peut être effectuée simplement dans R en utilisant la fonction scale. # Chargement des données library(geocmeans) data(LyonIris) # NB : LyonIris est un objet spatial, il faut donc extraire uniquement son DataFrame X &lt;- LyonIris@data[c(&quot;Lden&quot;,&quot;NO2&quot;,&quot;PM25&quot;,&quot;VegHautPrt&quot;,&quot;Pct0_14&quot;,&quot;Pct_65&quot;,&quot;Pct_Img&quot;, &quot;TxChom1564&quot;,&quot;Pct_brevet&quot;,&quot;NivVieMed&quot;)] # Centrage et réduction de chaque colonne du DataFrame for (col in names(X)){ X[[col]] &lt;- scale(X[[col]], center = TRUE, scale = TRUE) } 13.4.4.2 Choix du nombre de groupes optimal La seconde étape consiste à déterminer le nombre de groupes optimal. Pour cela, nous comparons les résultats des trois méthodes proposées : la méthode du coude, lindice de silhouette et la méthode GAP. Pour chaque méthode, nous testons les nombres de groupes de 2 à 10. 13.4.4.2.1 Méthode du coude Commençons par appliquer la méthode du coude. Nous calculons donc linertie expliquée par la classification pour différentes valeurs de k (nombre de groupes) avant de construire la figure 13.19. ks &lt;- 2:10 ## ---- Méthode du coude ---- ## inertie_exps &lt;- sapply(ks, function(k){ # calcul du kmeans avec k resultat &lt;- kmeans(X, centers = k) # calcul de l&#39;inertie expliquée (1 - inertie intragroupe / inertie totale) inertie_exp &lt;- 1-(sum(resultat$withinss) / resultat$totss) return(inertie_exp) }) df &lt;- data.frame( k = ks, inertie_exp = inertie_exps ) ggplot(df) + geom_line(aes(x = k, y = inertie_exp)) + geom_point(aes(x = k, y = inertie_exp), color = &quot;red&quot;) + labs(x = &quot;nombre de groupes&quot;, y = &quot;inertie expliquée (%)&quot;) Figure 13.19: Inertie expliquée pour différents nombres de groupes pour le k-means Dans larticle original, quatre groupes avaient été retenus. Nous pouvons constater ici quun coude fort se situe à k = 3 et quau-delà de cette limite, lajout dun groupe supplémentaire contribue à expliquer une plus petite partie de linertie supplémentaire comparativement au précédent. 13.4.4.2.2 Indice de silhouette Poursuivons avec lindice de silhouette calculé de nouveau avec des valeurs de k allant de 2 à 10. Notez que nous devons au préalable créer une matrice de distances entre les observations du jeu de données pour construire notre indice de silhouette. Puisque nous utilisons lalgorithme k-means, nous utilisons la distance euclidienne. ks &lt;- 2:10 # calcul d&#39;une matrice de distance euclidienne entre les observations dist_mat &lt;- dist(X, method = &quot;euclidean&quot;) ## ---- indice de silhouette ---- ## values &lt;- sapply(ks, function(k){ resultat &lt;- kmeans(X,centers = k) groupes &lt;- resultat$cluster # calcul des valeurs de silhouette sil &lt;- silhouette(groupes, dist = dist_mat) # extraction de l&#39;indice global (moyenne des moyennes) idx &lt;- mean(summary(sil)$clus.avg.widths) return(idx) }) df &lt;- data.frame( k = ks, silhouette = values ) ggplot(df) + geom_line(aes(x = k, y = silhouette)) + geom_point(aes(x = k, y = silhouette), color = &quot;red&quot;) + labs(x = &quot;nombre de groupes&quot;, y = &quot;Indice de silhouette&quot;) Figure 13.20: Indice de silhouette pour différents nombres de groupes pour le k-means À nouveau, la figure 13.20 indique que le nombre de groupes optimal est trois selon lindice de silhouette. 13.4.4.2.3 Méthode GAP Pour appliquer la méthode GAP, nous proposons dutiliser la fonction clusGap du package NbClust. Pour lutiliser, il est nécessaire de définir une fonction renvoyant pour le nombre de groupes k et le jeu de données x une liste comprenant un vecteur attribuant chaque observation à chaque groupe. Il est possible de considérer ce type de fonction comme un « adaptateur ». library(NbClust) # définition de la fonction adaptateur adaptor &lt;- function(x,k){ clust &lt;- kmeans(x,k) return(list( &quot;cluster&quot; = clust$cluster )) } # calcul de la méthode GAP vals &lt;- clusGap(X, adaptor, K.max = 10, verbose = FALSE) tab &lt;- data.frame(vals$Tab) tab$k &lt;- 1:nrow(tab) # détermination des valeurs de k retenues par la méthode (1ere et 2e) is_valid &lt;- sapply(2:nrow(tab), function(i){ tab[i-1,&quot;gap&quot;] &gt;= (tab[i,&quot;gap&quot;] - tab[i,&quot;SE.sim&quot;]) }) valids &lt;- subset(tab,is_valid)[1,] valids2 &lt;- subset(tab,is_valid)[2,] # réalisation du graphique ggplot(tab) + geom_line(aes(x = k, y = gap)) + geom_segment(x = valids$k, xend = valids$k, y = min(tab$gap), yend = valids$gap, linetype = &quot;dashed&quot;) + geom_segment(x = valids2$k, xend = valids2$k, y = min(tab$gap), yend = valids2$gap, linetype = &quot;dashed&quot;) + geom_point(aes(x = k, y = gap), color = &#39;red&#39;) + scale_x_continuous(breaks = 1:10) + labs(x = &quot;nombre de groupes&quot;, y = &quot;GAP&quot;) Figure 13.21: Méthode GAP pour différents nombres de groupes pour le k-means La figure 13.21 indique également que le nombre de groupes à retenir est trois. Nous retenons cependant quatre groupes pour pouvoir plus facilement comparer nos résultats avec ceux de larticle original. 13.4.4.3 Application lalgorithme du k-means Maintenant que nous avons choisi le nombre de groupes à former, nous pouvons simplement appliquer la fonction kmeans présente de base dans R. set.seed(145) resultats &lt;- kmeans(X, centers = 4) 13.4.4.4 Interprétation des résultats Une fois les groupes obtenus, létape la plus importante est de parvenir à interpréter ces groupes. Pour cela, il est nécessaire de les explorer en profondeur au travers des variables utilisées pour les constituer. Dans notre cas, le jeu de données LyonIris est spatialisé, nous pouvons donc commencer par cartographier les groupes. library(tmap) LyonIris$groupes &lt;- paste(&quot;groupe&quot;, resultats$cluster, sep = &quot; &quot;) tm_shape(LyonIris) + tm_polygons(col = &quot;groupes&quot;, palette = c(&quot;#EFBE89&quot;, &quot;#4A6A9F&quot;, &quot;#7DB47C&quot;, &quot;#FAF29C&quot;),lty = 1, lwd = 0.1) Figure 13.22: Cartographie des groupes obtenus avec la méthode du k-means Il est ainsi possible de constater que le groupe 3 forme un ensemble assez compact dIRIS au centre de Lyon. Le groupe 4 correspond quant à lui à des IRIS situés en périphérie plutôt éloignée, essentiellement à louest. Le groupe 1 correspond à une périphérie proche du groupe 2 et apparaît comme un ensemble denclaves dispersées. Pour distinguer rapidement les profils des différents groupes, il est possible dutiliser un graphique en radar. La construction dun tel graphique peut être un peu fastidieuse dans R, cependant le package geocmeans propose une fonction assez pratique : spiderPlots. library(geocmeans) # création d&#39;une matrice d&#39;appartenance binaire des groupes matrice_gp &lt;- fastDummies::dummy_cols(resultats$cluster, remove_selected_columns = TRUE) # réalisation du graphique par(mfrow=c(3,2), mai = c(0.1,0.1,0.1,0.1)) plots &lt;- spiderPlots(X, matrice_gp, chartcolors = c(&quot;#EFBE89&quot;, &quot;#4A6A9F&quot;, &quot;#7DB47C&quot;, &quot;#FAF29C&quot;)) Figure 13.23: Graphiques en radar pour les groupes issus du k-means Il est ainsi possible de constater, à la figure 13.23, que le groupe 3 est caractérisé par un niveau de vie élevé, mais par des niveaux de concentration de pollution atmosphérique plus élevés également. Le groupe 4 en revanche est caractérisé par un important couvert végétal, un niveau de vie médian élevé et une plus forte proportion de personnes de plus de 65 ans. Le groupe 1 est quant à lui marqué par des niveaux sonores plus élevés. Enfin, le groupe 2 se caractérise par une plus grande proportion de population ayant obtenu comme diplôme le plus élevé le brevet des collèges, dimmigrants, de jeunes de moins de 15 ans et un taux de chômage plus élevé. Notez que ces graphiques nous permettent rapidement de nous faire une idée des caractéristiques des groupes, mais uniquement sur une échelle relative. En effet, ils ne nous indiquent à aucun moment la taille des écarts entre les groupes. Pour cela, il est nécessaire de réaliser des graphiques en violon pour chaque variable. Pour ce type de graphique, il est préférable dutiliser les données originales non transformées pour pouvoir mieux appréhender si les différences entre les groupes sont importantes ou négligeables. X2 &lt;- LyonIris@data[c(&quot;Lden&quot;,&quot;NO2&quot;,&quot;PM25&quot;,&quot;VegHautPrt&quot;,&quot;Pct0_14&quot;,&quot;Pct_65&quot;,&quot;Pct_Img&quot;, &quot;TxChom1564&quot;,&quot;Pct_brevet&quot;,&quot;NivVieMed&quot;)] plots &lt;- violinPlots(X2, as.character(resultats$cluster)) ggarrange(plotlist = plots, ncol = 2, nrow = 5) Figure 13.24: Graphiques en violon pour les groupes issus du k-means Il est également recommandé de calculer des statistiques descriptives par groupe et de les rapporter dans un tableau. # obtention d&#39;un tableau par groupe tableaux &lt;- summarizeClusters(X2, matrice_gp, dec = 1, silent = TRUE) # concaténation des tableaux tableau_tot &lt;- do.call(rbind, tableaux) Tableau 13.8: Descriptions des quatre groupes obtenus Lden NO2 PM25 VegHautPrt Pct014 Pct65 PctImg TxChom1564 Pctbrevet NivVieMed groupe 1 Q5 53,8 25,1 15,6 6,6 12,3 10,0 8,1 7,5 17,5 15 845,4 Q10 54,4 26,4 15,9 8,0 13,9 11,4 9,2 9,8 18,2 16 988,2 Q25 56,3 29,3 17,0 10,9 16,3 13,6 11,6 11,5 20,8 18 454,0 Q50 58,9 32,3 18,2 15,1 18,2 16,6 15,9 13,6 24,1 19 559,0 Q75 62,5 36,4 18,7 22,0 20,5 19,5 18,6 16,9 30,0 21 509,0 Q90 64,5 39,2 19,0 30,0 22,3 22,3 21,0 19,6 32,8 23 523,8 Q95 66,4 40,3 19,2 33,7 24,5 24,6 22,7 21,8 37,1 24 461,4 Mean 59,6 32,7 17,8 17,2 18,2 16,7 15,7 14,1 25,5 19 948,0 Std 4,2 5,2 1,2 8,5 4,0 4,7 6,5 4,3 7,6 2 637,2 groupe 2 Q5 50,8 19,3 13,9 6,1 18,4 6,6 17,7 16,5 30,7 12 350,5 Q10 52,0 20,0 14,2 7,7 19,8 8,7 20,1 16,8 32,8 12 747,0 Q25 53,9 23,0 15,2 11,2 22,8 10,6 23,6 19,7 36,2 13 546,0 Q50 56,4 25,0 16,2 14,5 25,2 13,6 28,0 24,5 39,9 15 340,0 Q75 58,4 29,2 17,0 18,0 27,8 16,9 33,2 32,3 45,9 16 330,5 Q90 62,9 33,2 18,3 23,5 31,3 20,0 38,1 35,6 50,0 18 140,0 Q95 64,3 37,2 18,8 27,1 32,6 20,8 40,3 38,0 55,2 19 009,0 Mean 56,8 26,3 16,2 15,4 25,4 13,8 28,5 26,6 42,0 15 401,4 Std 4,1 6,3 1,5 6,8 6,2 4,8 8,0 10,5 11,3 2 340,4 groupe 3 Q5 50,2 28,3 17,0 5,0 6,9 5,2 5,8 7,7 6,7 19 036,4 Q10 51,1 29,5 17,5 6,6 9,5 7,2 6,6 8,5 7,7 19 509,9 Q25 53,2 31,3 18,6 9,1 11,4 9,4 7,9 11,0 9,5 21 632,8 Q50 55,2 35,4 19,3 12,6 14,1 12,4 11,0 12,9 12,0 23 342,0 Q75 58,0 39,6 19,8 16,0 16,0 15,7 13,1 15,0 14,8 25 932,2 Q90 60,0 42,9 20,1 19,9 18,0 18,7 16,3 17,8 16,6 28 810,1 Q95 61,1 44,4 20,3 27,0 19,2 20,6 17,6 19,1 18,4 31 835,2 Mean 55,6 35,8 19,0 13,6 13,8 12,6 11,1 13,1 12,1 23 999,7 Std 3,7 5,6 1,0 6,8 4,2 4,7 4,6 4,4 4,0 3 870,3 groupe 4 Q5 44,9 14,7 12,7 8,1 13,0 12,7 3,9 6,7 10,8 19 391,2 Q10 46,6 15,7 13,0 11,6 14,9 13,5 4,4 7,0 12,4 20 257,0 Q25 50,3 19,0 13,8 16,5 17,1 16,1 6,0 8,0 15,7 21 963,0 Q50 52,6 22,0 14,7 24,8 18,9 19,3 8,1 9,8 20,0 24 090,0 Q75 54,8 25,1 15,5 32,3 20,8 22,7 10,9 12,0 25,4 26 667,0 Q90 57,4 27,5 16,2 41,1 22,3 27,4 14,4 14,7 30,5 29 891,0 Q95 58,9 28,7 16,7 43,4 22,7 29,6 17,4 16,4 32,9 31 872,7 Mean 52,3 21,8 14,7 25,5 18,6 20,1 8,8 10,4 21,1 24 761,6 Std 4,3 4,4 1,2 11,0 3,1 5,6 4,2 3,4 7,6 4 008,7 Les constats que nous avons faits précédemment sont confirmés par la figure 13.24 et le tableau 13.8. Nous retrouvons ici les groupes originaux décrits dans larticle de Gelb et Apparicio (2021b) : Groupe 1 : les espaces interstitiels, formant une périphérie proche du centre et relativement hétérogène sur les variables étudiées, mais caractérisée par des niveaux de bruit importants. Groupe 2 : les banlieues jeunes et défavorisées, avec des niveaux dexposition aux pollutions atmosphérique et sonore relativement élevés comparativement à lensemble de la région. Groupe 3 : les quartiers centraux aisés, mais marqués par les plus hauts niveaux de pollution atmosphérique. Groupe 4 : les communes rurales, aisées et vieillissantes. Interprétation interactive Si, comme dans notre exemple, vos données comportent une dimension spatiale, le package geocmeans propose une fonction intéressante appelée sp_clust_explorer démarrant une application permettant dexplorer les résultats de votre classification. Le seul enjeu est de créer un objet de la classe FCMres. Voici un court exemple : # création d&#39;une matrice binaire d&#39;appartenance kmeans_mat &lt;- dummy_cols(resultats$cluster, remove_selected_columns = TRUE) # extraction des centres de notre classification centres &lt;- resultats$centers # création de l&#39;objet FCMres kmeansres &lt;- FCMres(list( &quot;Centers&quot; = centres, &quot;Belongings&quot; = kmeans_mat, &quot;Data&quot; = X2, &quot;m&quot; = 1, &quot;algo&quot; = &quot;kmeans&quot; )) # démarrage de l&#39;application shiny sp_clust_explorer(object = kmeansres, spatial = LyonIris) 13.4.4.5 K-médianes et K-médoides Nous présentons simplement ici comment effectuer la même analyse en utilisant les variantes du k-means, soit le k-medians et le k-mediods. Il existe relativement peu dimplémentation du k-medians dans R, nous optons donc ici pour la fonction kGmedian du package Gmedian. Pour le k-mediods, nous avons retenu la fonction pam du package cluster. library(Gmedian) k_median_res &lt;- kGmedian(X, 4) library(cluster) k_mediods_res &lt;- pam(X,4) Juste pour le plaisir des yeux, nous pouvons cartographier les trois classifications obtenues en nous assurant au préalable de faire coïncider les groupes les plus similaires de nos trois classifications. matrice_gp_kmeans &lt;- dummy_cols(resultats$cluster, remove_selected_columns = TRUE) matrice_gp_kmedians &lt;- dummy_cols(as.vector(k_median_res$cluster), remove_selected_columns = TRUE) matrice_gp_kmedioids &lt;- dummy_cols(k_mediods_res$cluster, remove_selected_columns = TRUE) # Appariement des groupes du k-medians avec ceux du kmeans matrice_gp_kmedians &lt;- geocmeans::groups_matching(as.matrix(matrice_gp_kmeans), as.matrix(matrice_gp_kmedians)) # Appariement des groupes du k-medioids avec ceux du kmeans matrice_gp_kmedioids &lt;- geocmeans::groups_matching(as.matrix(matrice_gp_kmeans), as.matrix(matrice_gp_kmedioids)) # ajouts des colonnes nécessaires à LyonIris colnames(matrice_gp_kmeans) &lt;- paste0(&quot;groupe_&quot;, 1:4) colnames(matrice_gp_kmedians) &lt;- paste0(&quot;groupe_&quot;, 1:4) colnames(matrice_gp_kmedioids) &lt;- paste0(&quot;groupe_&quot;, 1:4) LyonIris$kmeans &lt;- colnames(matrice_gp_kmeans)[max.col(matrice_gp_kmeans)] LyonIris$kmedians &lt;- colnames(matrice_gp_kmedians)[max.col(matrice_gp_kmedians)] LyonIris$kmedioids &lt;- colnames(matrice_gp_kmedioids)[max.col(matrice_gp_kmedioids)] # construction de la figure couleurs &lt;- c(&quot;#EFBE89&quot;, &quot;#4A6A9F&quot;, &quot;#7DB47C&quot;, &quot;#FAF29C&quot;) map1 &lt;- tm_shape(LyonIris) + tm_polygons(col = &quot;kmeans&quot;,palette = couleurs,lty = 1, lwd = 0.1) map2 &lt;- tm_shape(LyonIris) + tm_polygons(col = &quot;kmedians&quot;,palette = couleurs,lty = 1, lwd = 0.1) map3 &lt;- tm_shape(LyonIris) + tm_polygons(col = &quot;kmedioids&quot;,palette = couleurs,lty = 1, lwd = 0.1) tmap_arrange(map1, map2, map3, ncol = 2, nrow = 2) Figure 13.25: Comparaison géographique des résultats obtenus pour le k-means, le k-medians et le k-medoids Les trois cartes sont très similaires (figure 13.25), ce qui signifie que les trois algorithmes tendent à attribuer les observations aux mêmes groupes. Cependant, nous observons des différences, notamment au nord avec des observations alternant entre les groupes 2 et 3 selon la méthode employée. Cela peut notamment signifier que ces observations sont « indécises », quil est difficile de les attribuer définitivement à une catégorie en particulier. Pour prendre en compte cette forme dincertitude, il est possible dopter pour des méthodes de classification en logique floue. 13.4.5 Extensions en logique floue : c-means, c-medoids Comme nous lavons mentionné en introduction de cette section, les méthodes de classification floues ont pour objectif dévaluer le degré dappartenance de chaque observation à chaque groupe plutôt que dattribuer chaque observation à un seul groupe. Il est ainsi possible de repérer des observations incertaines, à cheval entre plusieurs groupes. Nous présentons ici deux algorithmes appartenant à cette famille : le c-means et le c-medoids. Il sagit dans les deux cas dextensions des k-means et k-medoids vus précédemment. Pour ces deux méthodes, comme pour le k-means, le nombre de groupes k doit être spécifié. Elles comprennent cependant un paramètre supplémentaire : m, appelé paramètre de floutage qui contrôle à quel point le résultat obtenu sera flou ou strict. Une valeur de 1 produit une classification stricte (chaque observation appartient à un seul groupe) et une valeur plus grande conduit à des classifications de plus en plus floues, jusquà ce que chaque observation appartienne à un degré identique à chacun des groupes. Il est recommandé de sélectionner m en même temps que k, car ces deux valeurs influencent simultanément la qualité de la classification. La meilleure approche consiste à tester un ensemble de combinaisons de m et de k et à comparer les valeurs obtenues pour différents indicateurs de qualité de classification floue. Parmi ces indicateurs, il est notamment recommandé dutiliser le pourcentage de linertie expliquée, lindice de silhouette pour classification floue, lindice de Xie et Beni (1991), et de Fukuyama et Sugeno (Fukuyama 1989). 13.4.5.1 Mise en oeuvre du c-means dans R Le package fclust comprend un très grand nombre de méthodes pour effectuer des classifications floues, nous lutilisons donc en priorité ici en combinaison avec des fonctions dinterprétation du package geocmeans. 13.4.5.1.1 Préparation des données Comme pour le k-means, cette méthode nécessite de disposer dun jeu de données ne comprenant que des variables quantitatives dans la même échelle. Nous commençons donc à nouveau par standardiser nos données. Pour varier les plaisirs, nous optons cette fois-ci pour une transformation des variables dans une échelle allant de 0 à 100. library(fclust) data(LyonIris) # NB : LyonIris est un objet spatial, il faut donc extraire uniquement son DataFrame X &lt;- LyonIris@data[c(&quot;Lden&quot;,&quot;NO2&quot;,&quot;PM25&quot;,&quot;VegHautPrt&quot;,&quot;Pct0_14&quot;,&quot;Pct_65&quot;,&quot;Pct_Img&quot;, &quot;TxChom1564&quot;,&quot;Pct_brevet&quot;,&quot;NivVieMed&quot;)] # changement d&#39;échelle des données (0 à 100) to_0_100 &lt;- function(x){ return((x-min(x)) / (max(x) - min(x)) * 100) } for (col in names(X)){ X[[col]] &lt;- to_0_100(X[[col]]) } 13.4.5.1.2 Sélection de k et de m La seconde étape consiste à sélectionner les valeurs optimales pour k et m. Nous testons ici toutes les valeurs de k de 2 à 7, et les valeurs de m de 1,5 à 2,5 (avec des écarts de 0,1). library(e1071) set.seed(123) ms &lt;- seq(1.5,2.5,by = 0.1) ks &lt;- 2:7 # calcul de toutes les combinaisons combinaisons &lt;- expand.grid(ms,ks) eval_indices &lt;- c(&quot;Explained.inertia&quot;, &quot;Silhouette.index&quot;, &quot;FukuyamaSugeno.index&quot;) values &lt;- apply(combinaisons, MARGIN = 1, FUN = function(row){ m &lt;- row[[1]] k &lt;- row[[2]] resultats &lt;- FKM(X, k, m) idx &lt;- geocmeans::calcqualityIndexes(as.matrix(X), as.matrix(resultats$U), m = m, indices = eval_indices) return(c(k,m,unlist(idx))) }) df_scores &lt;- data.frame(t(values)) names(df_scores) &lt;- c(&quot;k&quot;, &quot;m&quot;, &quot;inertie&quot;, &quot;silhouette&quot;, &quot;FukuyamaSugeno&quot;) # changer l&#39;échelle de l&#39;indice pour un graphique plus joli df_scores$FukuyamaSugeno &lt;- round(df_scores$FukuyamaSugeno/10000,2) # création de trois figures pour représenter les trois indicateurs library(viridis) plot1 &lt;- ggplot(df_scores) + geom_raster(aes(x = k, y = m, fill = inertie)) + scale_fill_viridis() + scale_x_continuous(breaks = c(2,3,4,5,6,7)) + coord_fixed(ratio=4) + guides(fill = guide_colourbar(barwidth = 5, barheight = 0.5)) + labs(fill = &quot;Inertie expliquée&quot;) + theme(legend.position = &quot;bottom&quot;, legend.box = &quot;horizontal&quot;, legend.title = element_text( size=9), legend.text=element_text(size=8)) plot2 &lt;- ggplot(df_scores) + geom_raster(aes(x = k, y = m, fill = silhouette)) + scale_fill_viridis() + scale_x_continuous(breaks = c(2,3,4,5,6,7)) + coord_fixed(ratio=4) + guides(fill = guide_colourbar(barwidth = 5, barheight = 0.5)) + labs(fill = &quot;Indice de silhouette&quot;) + theme(legend.position = &quot;bottom&quot;, legend.box = &quot;horizontal&quot;, legend.title = element_text( size=9), legend.text=element_text(size=8)) plot3 &lt;- ggplot(df_scores) + geom_raster(aes(x = k, y = m, fill = FukuyamaSugeno)) + scale_fill_viridis() + scale_x_continuous(breaks = c(2,3,4,5,6,7)) + coord_fixed(ratio=4) + guides(fill = guide_colourbar(barwidth = 5, barheight = 0.5)) + labs(fill = &quot;Indice de Fukuyama et Sugeno&quot;) + theme(legend.position = &quot;bottom&quot;, legend.box = &quot;horizontal&quot;, legend.title = element_text( size=9), legend.text=element_text(size=8)) ggarrange(plot1, plot2, plot3, ncol = 2, nrow = 2) Figure 13.26: Sélection des paramètres k et m pour lalgorithme c-means Les trois graphiques à la figure 13.26 semblent indiquer des solutions différentes. Sans surprise, augmenter le niveau de flou (m) réduit linertie expliquée, alors quaugmenter le nombre de groupes (k) augmente linertie expliquée. Lindice de silhouette indique assez clairement que trois groupes serait le meilleur choix, suivi par deux ou quatre groupes, si m est inférieur à 1,8. Cependant, ne retenir que trois groupes ne permet dexpliquer que 30% de linertie. Afin de nous rapprocher des résultats de larticle original (Gelb et Apparicio 2021b), nous retenons m = 1,5 et k = 4. 13.4.5.1.3 Application lalgorithme c-means Avec k et m définis, il ne reste plus quà appliquer lalgorithme à nos observations. set.seed(123) cmeans_resultats &lt;- FKM(X, 4, 1.5) Lobjet obtenu cmeans_resultats contient les résultats de la classification. Plus spécifiquement, cmeans_resultats$U est la matrice dappartenance, soit une matrice de taille n x k, dont chaque case \\(U_{ij}\\) indique la probabilité pour lobservation i dappartenir au groupe j. cmeans_resultats$H contient le centre des groupes, et cmeans_resultats$Clus, le groupe auquel chaque observation à le plus de chances dappartenir. Pour comparer plus facilement nos résultats avec ceux du k-means, nous pouvons changer lordre des groupes obtenus pour les faire coïncider avec les groupes les plus similaires obtenus avec la méthode k-means. # changeons l&#39;ordre des groupes U &lt;- cmeans_resultats$U U2 &lt;- geocmeans::groups_matching(as.matrix(matrice_gp_kmeans), as.matrix(U)) # mais aussi du centre des classes idx &lt;- as.integer(gsub(&quot;Clus &quot;,&quot;&quot;,colnames(U2), fixed = TRUE)) H2 &lt;- cmeans_resultats$H[idx,] # et recalcul du groupe le plus probable Clus2 &lt;- data.frame( &quot;Cluster&quot; = (1:4)[max.col(U2,ties.method=&quot;first&quot;)], &quot;Membership degree&quot; = apply(U2, MARGIN = 1, max) ) colnames(U2) &lt;- paste(&quot;Clus&quot;,1:4, sep = &quot; &quot;) rownames(H2) &lt;- paste(&quot;Clus&quot;,1:4, sep = &quot; &quot;) cmeans_resultats$U &lt;- U2 cmeans_resultats$H &lt;- H2 cmeans_resultats$Clus &lt;- Clus2 13.4.5.1.4 Interprétation des résultats Globalement, les approches pour interpréter les résultats issus dune classification obtenue par c-means sont les mêmes que pour une classification obtenue par k-means. Commençons donc par créer plusieurs cartes des probabilités dappartenir aux différents groupes. maps &lt;- mapClusters(LyonIris, cmeans_resultats$U) ggarrange(plotlist = maps$ProbaMaps, ncol = 2, nrow = 2, legend = &quot;none&quot;) Figure 13.27: Cartographie des probabilités dappartenir aux quatre groupes identifiés par lalgorithme c-means Sur les cartes de la figure 13.27, lintensité de bleu correspond à la probabilité pour chaque IRIS dappartenir aux différents groupes. Nous retrouvons les principales structures spatiales que nous avons identifiées avec le k-means; cependant, nous pouvons à présent constater que le groupe 1 est bien plus incertain que les autres. Nous pouvons une fois encore générer un graphique en radar pour comparer les profils des quatre groupes. par(mfrow=c(3,2), mai = c(0.1,0.1,0.1,0.1)) spiderPlots(X, cmeans_resultats$U, chartcolors = c(&quot;#EFBE89&quot;, &quot;#4A6A9F&quot;, &quot;#7DB47C&quot;, &quot;#FAF29C&quot;)) Figure 13.28: Graphique en radar pour les résultats du c-means Sans surprise, nous retrouvons essentiellement les profils que nous avons obtenus avec le k-means dans la figure 13.28. Pour compléter la lecture des résultats, il est nécessaire de se pencher sur le tableau des statistiques descriptives des différents groupes. Une fois encore, nous proposons dutiliser la fonction summarizeClusters du package geocmeans. Notez que cette fonction calcule les statistiques descriptives pondérées en fonction de lappartenance des observations aux groupes. Ainsi, une observation ayant une faible chance dappartenir à un groupe ne contribue que faiblement aux statistiques descriptives de ce groupe. df &lt;- LyonIris@data[c(&quot;Lden&quot;,&quot;NO2&quot;,&quot;PM25&quot;,&quot;VegHautPrt&quot;,&quot;Pct0_14&quot;,&quot;Pct_65&quot;,&quot;Pct_Img&quot;, &quot;TxChom1564&quot;,&quot;Pct_brevet&quot;,&quot;NivVieMed&quot;)] tableaux &lt;- summarizeClusters(data = df, belongmatrix = cmeans_resultats$U, weighted = TRUE, dec = 1) tableau_tot &lt;- do.call(rbind, tableaux) Tableau 13.9: Description des groupes avec la méthode c-means Lden NO2 PM25 VegHautPrt Pct014 Pct65 PctImg TxChom1564 Pctbrevet NivVieMed groupe 1 Q5 48,7 16,1 13,6 6,3 12,4 9,9 4,5 6,7 11,1 16 274,1 Q10 50,6 18,8 13,9 7,6 14,3 11,4 5,9 7,7 13,9 17 857,3 Q25 52,4 21,0 14,7 11,5 16,9 14,2 8,0 9,3 18,5 19 608,0 Q50 54,7 25,0 15,6 15,8 19,0 17,7 11,3 12,0 24,0 21 955,8 Q75 57,5 28,6 16,8 22,3 21,3 21,2 15,7 15,2 29,9 24 068,0 Q90 60,7 33,3 18,5 29,7 23,3 24,4 20,3 18,5 34,7 26 134,7 Q95 63,1 37,7 19,0 34,6 25,5 27,6 23,6 22,3 39,1 29 013,0 Mean 55,1 25,4 15,8 17,5 18,9 17,9 12,4 13,0 24,7 21 951,6 Std 4,4 6,3 1,7 8,6 4,5 5,7 6,8 6,8 10,3 3 744,1 groupe 2 Q5 51,0 19,7 14,1 6,4 14,1 7,7 8,9 10,1 17,1 12 426,6 Q10 52,3 21,5 14,6 7,9 16,7 8,8 13,4 13,1 22,4 12 973,6 Q25 54,6 23,3 15,8 10,9 20,3 11,1 19,7 16,8 30,7 14 108,1 Q50 57,1 26,9 16,6 14,5 23,6 13,9 25,8 22,0 37,8 16 010,0 Q75 59,5 32,0 17,8 19,0 27,1 17,4 32,1 30,1 44,4 18 568,9 Q90 63,5 37,4 18,8 25,5 30,1 20,7 38,0 33,9 49,0 21 028,3 Q95 65,2 39,6 19,2 30,8 32,2 23,5 40,6 37,7 52,4 23 774,4 Mean 57,3 28,1 16,7 15,8 23,4 14,4 25,5 23,0 36,9 16 658,7 Std 4,4 6,6 1,6 7,6 6,3 5,1 9,7 9,3 12,3 3 611,9 groupe 3 Q5 50,6 27,6 16,4 6,3 8,7 7,1 6,1 7,7 7,6 17 130,3 Q10 52,2 28,9 17,2 7,7 10,4 8,6 7,1 8,6 8,7 18 454,2 Q25 53,9 30,9 18,4 10,2 12,6 10,8 9,1 11,1 11,0 19 805,4 Q50 56,5 35,0 18,9 13,4 15,2 14,1 12,3 13,1 14,8 22 308,8 Q75 59,4 38,7 19,6 17,5 17,9 17,5 15,9 15,5 21,5 24 515,7 Q90 62,8 41,0 20,0 24,8 20,4 20,5 19,0 18,4 27,9 27 620,4 Q95 64,4 44,1 20,2 30,3 21,8 23,2 21,1 20,7 32,1 29 862,2 Mean 56,8 34,9 18,7 14,8 15,3 14,2 12,8 13,7 16,9 22 595,1 Std 4,4 5,9 1,3 7,2 4,6 5,2 5,8 5,5 9,1 3 969,2 groupe 4 Q5 44,8 14,8 12,6 12,2 12,5 11,5 4,0 6,8 9,7 18 922,4 Q10 45,8 15,7 12,9 17,7 14,2 13,2 4,6 7,3 11,2 20 246,9 Q25 49,5 18,7 13,7 24,8 16,6 15,8 5,9 7,9 14,3 22 753,9 Q50 52,3 22,0 14,7 30,5 18,6 19,0 7,5 9,7 18,0 24 950,1 Q75 55,1 26,3 15,9 37,9 20,8 22,4 10,1 12,1 23,0 28 806,2 Q90 58,9 30,8 17,1 42,3 22,4 27,3 14,5 15,3 30,0 31 426,2 Q95 60,8 34,7 18,3 45,5 23,3 28,8 19,2 18,7 33,3 34 309,0 Mean 52,3 22,8 14,9 30,3 18,4 19,4 8,8 10,9 19,5 25 547,4 Std 5,1 6,3 1,7 10,0 4,1 5,9 5,5 6,2 9,2 4 603,5 13.4.5.2 Mise en oeuvre du c-medoids dans R La méthode du c-medoids dans R peut être mise en oeuvre avec la fonction FKM.med du package fclust. Le processus danalyse et de validation est identique à celui présenté ci-dessus pour le c-means. Nous ne donnons donc pas un exemple complet de la méthode. Stabilité des groupes obtenus par les méthodes de nuées dynamiques : Puisque la méthode k-means et ses variantes reposent sur une initialisation aléatoire de leur algorithme, les résultats peuvent varier en fonction de cet état de départ. Dans certains contextes, il est possible que les résultats obtenus varient significativement, ce qui signifie que les groupes obtenus ne sont pas représentatifs de la population étudiée. Une solution pour vérifier si ce problème se pose est simplement de relancer lalgorithme un grand nombre de fois (généralement 1000) et de comparer les résultats obtenus au cours de ces réplications. Cette méthode est rarement implémentée directement et requiert décrire sa propre fonction. geocmeans dispose dune fonction déjà existante, mais ne pouvant être appliquée quavec lalgorithme c-means. Nous proposons ici une implémentation pour la méthode k-means qui peut facilement être adaptée aux autres méthodes de classifications heuristiques. La démarche à suivre est la suivante : Appliquer lalgorithme une première fois pour obtenir une classification de référence à laquelle nous comparerons toutes les réplications. Effectuer 1000 itérations au cours desquelles : Une nouvelle classification est calculée. Les groupes obtenus sont comparés à ceux de la classification de référence. Lindice de Jacard est calculé entre les groupes des deux classifications. Les valeurs de lindice de Jacard sont enregistrées. Les centres des groupes sont enregistrés. Ainsi, nous obtenons 1000 valeurs de lindice de Jacard pour chaque groupe. Cet indice permet de mesurer le degré daccord entre deux variables (ici les probabilités dappartenance des observations au même groupe pour deux classifications différentes.) Une valeur moyenne en dessous de 0,5 indique quun groupe est très instable, car nous obtenons des résultats très différents lors des réplications. Une valeur entre 0,6 et 0,75 indique quun groupe semble bien exister dans les données, bien que marqué par une certaine incertitude. Une valeur au-dessus de 0,8 indique un groupe bien identifié et stable. Nous obtenons également les centres des groupes des 1000 classifications. Il est ainsi possible de représenter leurs histogrammes et de déterminer si les centres des groupes sont stables (unimodalité et faible variance) ou incertains (plusieurs modes et/ou forte variance). # X sera le jeu de données pour la classification # clust_ref sera le vecteur indiquant le groupe de chaque observation obtenu par kmeans # nsim sera le nombre de simulations à effectuer kmeans_stability &lt;- function(X, clust_ref, nsim, verbose = TRUE){ # définition de la matrice d&#39;appartenance originale k &lt;- length(unique(clust_ref)) ref_mat &lt;- dummy_cols(clust_ref, remove_selected_columns = TRUE) colnames(ref_mat) &lt;- paste0(&quot;groupe_&quot;,1:k) # lancement des itérations sim_resultats &lt;- lapply(1:nsim, function(i){ # afficher la progression si requis if(verbose){ print(paste0(&quot;iteration numeros : &quot;,i,&quot;/&quot;,nsim)) } # calculer le kmeans km_res &lt;- kmeans(X,k) sim_mat &lt;- dummy_cols(km_res$cluster, remove_selected_columns = TRUE) # ajustement de l&#39;ordre des groupes avec geocmeans sim_mat &lt;- groups_matching(as.matrix(ref_mat), as.matrix(sim_mat)) # calcul des indices de jacard jac_idx &lt;- sapply(1:k, function(j){ calc_jaccard_idx(sim_mat[,j], ref_mat[,j]) }) # recuperation des centres des groupes idx &lt;- as.integer(gsub(&quot;.data_&quot;,&quot;&quot;,colnames(sim_mat),fixed = TRUE)) centers &lt;- data.frame(km_res$centers) centers &lt;- centers[idx,] centers$groupe &lt;- 1:k return(list( &quot;jac_idx&quot; = jac_idx, &quot;centers&quot; = centers )) }) # les simulations sont finies, nous pouvons combiner les resultats all_jac_values &lt;- do.call(rbind, lapply(sim_resultats, function(x){x$jac_idx})) all_centers &lt;- do.call(rbind, lapply(sim_resultats, function(x){x$centers})) return(list( &quot;jacard_values&quot; = all_jac_values, &quot;centers&quot; = all_centers )) } Il ne nous reste plus quà utiliser notre nouvelle fonction pour déterminer si les groupes obtenus avec notre k-means sont stables. data(LyonIris) set.seed(123) # NB : LyonIris est un objet spatial, il faut donc extraire uniquement son DataFrame X &lt;- LyonIris@data[c(&quot;Lden&quot;,&quot;NO2&quot;,&quot;PM25&quot;,&quot;VegHautPrt&quot;,&quot;Pct0_14&quot;,&quot;Pct_65&quot;,&quot;Pct_Img&quot;, &quot;TxChom1564&quot;,&quot;Pct_brevet&quot;,&quot;NivVieMed&quot;)] # Centrage et réduction de chaque colonne du DataFrame for (col in names(X)){ X[[col]] &lt;- scale(X[[col]], center = TRUE, scale = TRUE) } # calcul du kmeans de référence kmeans_ref &lt;- kmeans(X, 4) # application de la fonction de stabilité stab_results &lt;- kmeans_stability(X, kmeans_ref$cluster, nsim = 1000, verbose = FALSE) Nous pouvons à présent vérifier la stabilité de nos quatre groupes. jacard_values &lt;- data.frame(stab_results$jacard_values) names(jacard_values) &lt;- paste(&quot;groupe&quot;, 1:4, sep = &quot;_&quot;) df &lt;- reshape2::melt(jacard_values) df$groupes &lt;- as.factor(df$variable) ggplot(df) + geom_histogram(aes(x = value), bins = 30) + facet_wrap(vars(groupes), ncol=2) + labs(x = &quot;&quot;, y = &quot;Indice de Jacard&quot;) Figure 13.29: Indices de Jacard obtenus sur 1000 réplications du k-means La figure 13.29 indique clairement que les groupes 1 et 2 sont très stables, car les valeurs de Jacard obtenues sont le plus souvent supérieures à 0,75. Le groupe 3 a le plus souvent des valeurs légèrement inférieures aux deux premiers groupes, mais tout de même bien supérieures à 0,5. En revanche, le groupe 4 a un grand nombre de valeurs inférieures à 0,5 indiquant une tendance du groupe à se dissoudre lors des réplications. Considérant que le dernier groupe est le plus instable, nous décidons dobserver les valeurs des centres quil obtient pour les différentes réplications. centers_groupe4 &lt;- subset(stab_results$centers, stab_results$centers$groupe == 4) centers_groupe4$groupe &lt;- NULL df &lt;- reshape2::melt(centers_groupe4) df$variable &lt;- as.factor(df$variable) ggplot(df) + geom_histogram(aes(x = value), bins = 30) + facet_wrap(vars(variable), ncol=3, scales=&quot;free&quot;) + labs(x = &quot;&quot;, y = &quot;&quot;) Figure 13.30: Distributions des valeurs des centres du groupe 4 sur 1000 itérations Les différents histogrammes de la figure 13.30 indiquent clairement que pour plusieurs variables (Lden, NO2, PM25, Pct_Img, et NivVieMed) les caractéristiques du groupe 4 varient grandement sur lensemble des réplications. Nous pouvons comparer ce graphique à celui du groupe 2 qui est bien plus stable. centers_groupe2 &lt;- subset(stab_results$centers, stab_results$centers$groupe == 2) centers_groupe2$groupe &lt;- NULL df &lt;- reshape2::melt(centers_groupe2) df$variable &lt;- as.factor(df$variable) ggplot(df) + geom_histogram(aes(x = value), bins = 30) + facet_wrap(vars(variable), ncol=3, scales=&quot;free&quot;) + labs(x = &quot;&quot;, y = &quot;&quot;) Figure 13.31: Distributions des valeurs des centres du groupe 2 sur 1000 itérations Nous pouvons constater une plus faible variance des résultats obtenus (en regardant notamment laxe horizontal) pour les centres des groupes à la figure 13.31. References "],["sect135.html", "13.5 Conclusion sur la cinquième partie", " 13.5 Conclusion sur la cinquième partie Dans le cadre de cette cinquième partie du livre, nous avons abordé les principales méthodes factorielles et les principales méthodes de classification non supervisée. Les premières sont des méthodes de réduction de données puisquelles permettent de résumer linformation dun tableau en quelques nouvelles variables synthétiques. Les secondes permettent de regrouper les observations dun tableau en plusieurs groupes homogènes. Il existe donc une complémentarité évidente entre ces deux groupes de méthodes : si le tableau initial comprend un grand nombre de variables, il est possible de lui appliquer une méthode factorielle produisant de nouvelles variables synthétiques qui sont ensuite utilisées pour calculer une méthode de classification non supervisée. Figure 13.32: Complémentarité entre les méthodes factorielles et les méthodes de classification non supervisée "],["sect136.html", "13.6 Quiz de révision du chapitre", " 13.6 Quiz de révision du chapitre quizz_classif &lt;- quizz(&quot;quizzs/classification.yml&quot;, &quot;quizz_classif&quot;) render_quizz(quizz_classif) Les méthodes de classification non supervisée sont appelées ainsi puisque : Relisez au besoin la section 13.1. le nombre de groupes générés par ces méthodes est déterminé automatiquement les groupes sont inconnus au préalable et formés automatiquement par ces méthodes lexécution de ces algorithmes ne nécessite pas de supervision aucun paramètre nest à définir pour exécuter ces méthodes En quoi se distinguent les méthodes de classifications strictes et floues? Relisez au besoin la section 13.1. les premières attribuent chaque observation à un seul groupe alors que les secondes évaluent le degré dappartenance des observations à chaque groupe les méthodes strictes produisent des classifications comportant un moins grand nombre de degrés de liberté les méthodes strictes produisent toujours les mêmes résultats, alors que les méthodes floues reposent sur un état initial aléatoire pouvant conduire à des résultats différents Quels paramètres doivent être définis pour exécuter lalgorithme c-means? Relisez au besoin la section 13.4.4. k, soit le nombre de groupes à obtenir alpha, soit le paramètre contrôlant la vitesse de convergence lambda, soit la probabilité minimale quune observation appartiennent à un groupe m, soit le paramètre controlant le niveau de flou dans une classification floue La classification ascendante hiérarchique nécessite de calculer : Relisez au besoin la section 13.3. la distance entre chaque observation et ses k plus proches voisins la distance entre lensemble des paires dobservations la probabilité pour chaque observation dappartenir à chaque groupe un dendrogramme, soit une structure hiérarchique permettant de conserver lordre dans lequel les groupes sont formés par lalgorithme Pour effectuer une classification non supervisée floue utilisant comme centres de groupes de réelles observations plutôt que des moyennes fictives, quelle méthode peut-on utiliser? Relisez au besoin la section 13.4.4. Verifier Votre score "],["annexes.html", "Chapitre 14 Annexes ", " Chapitre 14 Annexes "],["annexe1.html", "14.1 Table des valeurs critiques de khi-deux", " 14.1 Table des valeurs critiques de khi-deux La courte syntaxe R ci-dessous permet de générer le tableau 14.1 avec les valeurs critiques du khi-deux pour différents degrés de signification (valeurs de p). library(stargazer) # vecteur pour les degrés de liberté de 1 à 30, puis 40 et 50 dl &lt;- c(1:30, 40, 50, 100, 250, 500) # la fonction qchisq permet d&#39;obtenir la valeur théorique en fonction # d&#39;une valeur de p et d&#39;un nombre de degrés de liberté tableKhi2 &lt;- cbind(dl, p0.10 = round(qchisq(p=0.90, df=dl, lower.tail = TRUE),3), p0.05 = round(qchisq(p=0.95, df=dl, lower.tail = TRUE),3), p0.01 = round(qchisq(p=0.99, df=dl, lower.tail = TRUE),3), p0.001 = round(qchisq(p=0.999, df=dl, lower.tail = TRUE),3)) # Impression du tableau avec la library stargazer stargazer(tableKhi2, type=&quot;text&quot;, summary=FALSE, rownames=FALSE, align = TRUE, digits = 2, title=&quot;Distribution des valeurs critiques du Khi2&quot;) Tableau 14.1: Distribution des valeurs critiques du khi-deux dl p = 0,10 p = 0,05 p = 0,01 p = 0,001 1 2,71 3,84 6,64 10,83 2 4,61 5,99 9,21 13,82 3 6,25 7,82 11,35 16,27 4 7,78 9,49 13,28 18,47 5 9,24 11,07 15,09 20,52 6 10,64 12,59 16,81 22,46 7 12,02 14,07 18,48 24,32 8 13,36 15,51 20,09 26,12 9 14,68 16,92 21,67 27,88 10 15,99 18,31 23,21 29,59 11 17,27 19,68 24,73 31,26 12 18,55 21,03 26,22 32,91 13 19,81 22,36 27,69 34,53 14 21,06 23,68 29,14 36,12 15 22,31 25,00 30,58 37,70 16 23,54 26,30 32,00 39,25 17 24,77 27,59 33,41 40,79 18 25,99 28,87 34,80 42,31 19 27,20 30,14 36,19 43,82 20 28,41 31,41 37,57 45,31 21 29,61 32,67 38,93 46,80 22 30,81 33,92 40,29 48,27 23 32,01 35,17 41,64 49,73 24 33,20 36,42 42,98 51,18 25 34,38 37,65 44,31 52,62 26 35,56 38,88 45,64 54,05 27 36,74 40,11 46,96 55,48 28 37,92 41,34 48,28 56,89 29 39,09 42,56 49,59 58,30 30 40,26 43,77 50,89 59,70 40 51,80 55,76 63,69 73,40 50 63,17 67,50 76,15 86,66 100 118,50 124,34 135,81 149,45 250 279,05 287,88 304,94 324,83 500 540,93 553,13 576,49 603,45 "],["annexe2.html", "14.2 Table des valeurs critiques de Fisher", " 14.2 Table des valeurs critiques de Fisher La courte syntaxe R ci-dessous permet de générer les tableaux 14.2, 14.3 et 14.4 avec les valeurs critiques de F avec p = 0,05. library(stargazer) dl1 &lt;- c(1:10, 15, 20, 30, 40, 50, 60, 70, 80, 90, 100, 200, 300, 400, 500, 1000) dl2 &lt;- c(1:10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 200, 300, 500, 1000, 2000) matrice &lt;- matrix(ncol=length(dl1), nrow=length(dl2), byrow = TRUE) for(r in 1:length(dl1)){ for(c in 1:length(dl2)){ matrice[c,r] &lt;- round(qf(p=0.05, dl1[r], dl2[c], lower.tail = FALSE),2) } } tableF_p0.05 &lt;- data.frame(dl2 = dl2, matrice) names(tableF_p0.05) &lt;- c(&quot;dl2&quot;, paste0(&quot;dl1=&quot;,dl1)) stargazer(tableF_p0.05, type=&quot;text&quot;, summary=FALSE, rownames=FALSE, align = TRUE, digits = 3, title=&quot;Distribution des valeurs critiques de F avec p = 0,05&quot;) Tableau 14.2: Distribution des valeurs critiques de F avec p = 0,05 dl2 dl1=1 dl1=2 dl1=3 dl1=4 dl1=5 dl1=6 dl1=7 dl1=8 dl1=9 dl1=10 1 161,45 199,50 215,71 224,58 230,16 233,99 236,77 238,88 240,54 241,88 2 18,51 19,00 19,16 19,25 19,30 19,33 19,35 19,37 19,38 19,40 3 10,13 9,55 9,28 9,12 9,01 8,94 8,89 8,85 8,81 8,79 4 7,71 6,94 6,59 6,39 6,26 6,16 6,09 6,04 6,00 5,96 5 6,61 5,79 5,41 5,19 5,05 4,95 4,88 4,82 4,77 4,74 6 5,99 5,14 4,76 4,53 4,39 4,28 4,21 4,15 4,10 4,06 7 5,59 4,74 4,35 4,12 3,97 3,87 3,79 3,73 3,68 3,64 8 5,32 4,46 4,07 3,84 3,69 3,58 3,50 3,44 3,39 3,35 9 5,12 4,26 3,86 3,63 3,48 3,37 3,29 3,23 3,18 3,14 10 4,96 4,10 3,71 3,48 3,33 3,22 3,14 3,07 3,02 2,98 20 4,35 3,49 3,10 2,87 2,71 2,60 2,51 2,45 2,39 2,35 30 4,17 3,32 2,92 2,69 2,53 2,42 2,33 2,27 2,21 2,16 40 4,08 3,23 2,84 2,61 2,45 2,34 2,25 2,18 2,12 2,08 50 4,03 3,18 2,79 2,56 2,40 2,29 2,20 2,13 2,07 2,03 60 4,00 3,15 2,76 2,53 2,37 2,25 2,17 2,10 2,04 1,99 70 3,98 3,13 2,74 2,50 2,35 2,23 2,14 2,07 2,02 1,97 80 3,96 3,11 2,72 2,49 2,33 2,21 2,13 2,06 2,00 1,95 90 3,95 3,10 2,71 2,47 2,32 2,20 2,11 2,04 1,99 1,94 100 3,94 3,09 2,70 2,46 2,31 2,19 2,10 2,03 1,97 1,93 200 3,89 3,04 2,65 2,42 2,26 2,14 2,06 1,98 1,93 1,88 300 3,87 3,03 2,63 2,40 2,24 2,13 2,04 1,97 1,91 1,86 500 3,86 3,01 2,62 2,39 2,23 2,12 2,03 1,96 1,90 1,85 1 000 3,85 3,00 2,61 2,38 2,22 2,11 2,02 1,95 1,89 1,84 2 000 3,85 3,00 2,61 2,38 2,22 2,10 2,01 1,94 1,88 1,84 Tableau 14.3: Distribution des valeurs critiques de F avec p = 0,05 (suite) dl2 dl1=15 dl1=20 dl1=30 dl1=40 dl1=50 dl1=60 dl1=70 dl1=80 dl1=90 1 245,95 248,01 250,10 251,14 251,77 252,20 252,50 252,72 252,90 2 19,43 19,45 19,46 19,47 19,48 19,48 19,48 19,48 19,48 3 8,70 8,66 8,62 8,59 8,58 8,57 8,57 8,56 8,56 4 5,86 5,80 5,75 5,72 5,70 5,69 5,68 5,67 5,67 5 4,62 4,56 4,50 4,46 4,44 4,43 4,42 4,41 4,41 6 3,94 3,87 3,81 3,77 3,75 3,74 3,73 3,72 3,72 7 3,51 3,44 3,38 3,34 3,32 3,30 3,29 3,29 3,28 8 3,22 3,15 3,08 3,04 3,02 3,01 2,99 2,99 2,98 9 3,01 2,94 2,86 2,83 2,80 2,79 2,78 2,77 2,76 10 2,85 2,77 2,70 2,66 2,64 2,62 2,61 2,60 2,59 20 2,20 2,12 2,04 1,99 1,97 1,95 1,93 1,92 1,91 30 2,01 1,93 1,84 1,79 1,76 1,74 1,72 1,71 1,70 40 1,92 1,84 1,74 1,69 1,66 1,64 1,62 1,61 1,60 50 1,87 1,78 1,69 1,63 1,60 1,58 1,56 1,54 1,53 60 1,84 1,75 1,65 1,59 1,56 1,53 1,52 1,50 1,49 70 1,81 1,72 1,62 1,57 1,53 1,50 1,49 1,47 1,46 80 1,79 1,70 1,60 1,54 1,51 1,48 1,46 1,45 1,44 90 1,78 1,69 1,59 1,53 1,49 1,46 1,44 1,43 1,42 100 1,77 1,68 1,57 1,52 1,48 1,45 1,43 1,41 1,40 200 1,72 1,62 1,52 1,46 1,41 1,39 1,36 1,35 1,33 300 1,70 1,61 1,50 1,43 1,39 1,36 1,34 1,32 1,31 500 1,69 1,59 1,48 1,42 1,38 1,35 1,32 1,30 1,29 1 000 1,68 1,58 1,47 1,41 1,36 1,33 1,31 1,29 1,27 2 000 1,67 1,58 1,46 1,40 1,36 1,32 1,30 1,28 1,27 Tableau 14.4: Distribution des valeurs critiques de F avec p = 0,05 (suite) dl2 dl1=100 dl1=200 dl1=300 dl1=400 dl1=500 dl1=1000 1 253,04 253,68 253,89 254,00 254,06 254,19 2 19,49 19,49 19,49 19,49 19,49 19,49 3 8,55 8,54 8,54 8,53 8,53 8,53 4 5,66 5,65 5,64 5,64 5,64 5,63 5 4,41 4,39 4,38 4,38 4,37 4,37 6 3,71 3,69 3,68 3,68 3,68 3,67 7 3,27 3,25 3,24 3,24 3,24 3,23 8 2,97 2,95 2,94 2,94 2,94 2,93 9 2,76 2,73 2,72 2,72 2,72 2,71 10 2,59 2,56 2,55 2,55 2,55 2,54 20 1,91 1,88 1,86 1,86 1,86 1,85 30 1,70 1,66 1,65 1,64 1,64 1,63 40 1,59 1,55 1,54 1,53 1,53 1,52 50 1,52 1,48 1,47 1,46 1,46 1,45 60 1,48 1,44 1,42 1,41 1,41 1,40 70 1,45 1,40 1,39 1,38 1,37 1,36 80 1,43 1,38 1,36 1,35 1,35 1,34 90 1,41 1,36 1,34 1,33 1,33 1,31 100 1,39 1,34 1,32 1,31 1,31 1,30 200 1,32 1,26 1,24 1,23 1,22 1,21 300 1,30 1,23 1,21 1,20 1,19 1,17 500 1,28 1,21 1,18 1,17 1,16 1,14 1 000 1,26 1,19 1,16 1,14 1,13 1,11 2 000 1,25 1,18 1,15 1,13 1,12 1,09 "],["annexe3.html", "14.3 Table des valeurs critiques de t", " 14.3 Table des valeurs critiques de t La courte syntaxe R ci-dessous permet de générer le tableau 14.5 avec les valeurs critiques de t avec p = 0,10, 0,05, 0,01 et 0,01. library(stargazer) # vecteur pour les degrés de liberté de 1 à 30, puis 40 et 50 dl &lt;- c(1:30, 40, 50, 60, 70, 80, 90, 100, 250, 500, 1000, 2500) # la fonction qchisq permet d&#39;obtenir la valeur théorique en fonction # d&#39;une valeur de p et d&#39;un nombre de degrés de liberté tableT &lt;- cbind(dl, p0.10 = round(qt(p=1 - (0.10/2), df=dl),2), p0.05 = round(qt(p=1 - (0.05/2), df=dl),2), p0.01 = round(qt(p=1 - (0.01/2), df=dl),2), p0.001 = round(qt(p=1 - (0.001/2), df=dl),2)) # Impression du tableau avec la library stargazer stargazer(tableT, type=&quot;text&quot;, summary=FALSE, rownames=FALSE, align = TRUE, digits = 2, title=&quot;Distribution des valeurs critiques de t&quot;) Tableau 14.5: Distribution des valeurs critiques de t dl p = 0,10 p = 0,05 p = 0,01 p = 0,001 1 6,31 12,71 63,66 636,62 2 2,92 4,30 9,92 31,60 3 2,35 3,18 5,84 12,92 4 2,13 2,78 4,60 8,61 5 2,02 2,57 4,03 6,87 6 1,94 2,45 3,71 5,96 7 1,89 2,36 3,50 5,41 8 1,86 2,31 3,36 5,04 9 1,83 2,26 3,25 4,78 10 1,81 2,23 3,17 4,59 11 1,80 2,20 3,11 4,44 12 1,78 2,18 3,05 4,32 13 1,77 2,16 3,01 4,22 14 1,76 2,14 2,98 4,14 15 1,75 2,13 2,95 4,07 16 1,75 2,12 2,92 4,01 17 1,74 2,11 2,90 3,97 18 1,73 2,10 2,88 3,92 19 1,73 2,09 2,86 3,88 20 1,72 2,09 2,85 3,85 21 1,72 2,08 2,83 3,82 22 1,72 2,07 2,82 3,79 23 1,71 2,07 2,81 3,77 24 1,71 2,06 2,80 3,75 25 1,71 2,06 2,79 3,73 26 1,71 2,06 2,78 3,71 27 1,70 2,05 2,77 3,69 28 1,70 2,05 2,76 3,67 29 1,70 2,05 2,76 3,66 30 1,70 2,04 2,75 3,65 40 1,68 2,02 2,70 3,55 50 1,68 2,01 2,68 3,50 60 1,67 2,00 2,66 3,46 70 1,67 1,99 2,65 3,44 80 1,66 1,99 2,64 3,42 90 1,66 1,99 2,63 3,40 100 1,66 1,98 2,63 3,39 250 1,65 1,97 2,60 3,33 500 1,65 1,96 2,59 3,31 1 000 1,65 1,96 2,58 3,30 2 500 1,65 1,96 2,58 3,29 "]]
